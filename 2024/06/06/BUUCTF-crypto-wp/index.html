<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUUCTF crypto wp | coperlm's Blog</title><meta name="author" content="coperlm"><meta name="copyright" content="coperlm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[NewStarCTF 2023 公开赛道]Rabin’s RSA12345678910111213141516171819from Crypto.Util.number import *from secret import flagp &#x3D; getPrime(64)q &#x3D; getPrime(64)assert p % 4 &#x3D;&#x3D; 3assert q % 4 &#x3D;&#x3D; 3n &#x3D; p * qe &#x3D; 2m &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="BUUCTF crypto wp">
<meta property="og:url" content="https://coperlm.github.io/2024/06/06/BUUCTF-crypto-wp/index.html">
<meta property="og:site_name" content="coperlm&#39;s Blog">
<meta property="og:description" content="[NewStarCTF 2023 公开赛道]Rabin’s RSA12345678910111213141516171819from Crypto.Util.number import *from secret import flagp &#x3D; getPrime(64)q &#x3D; getPrime(64)assert p % 4 &#x3D;&#x3D; 3assert q % 4 &#x3D;&#x3D; 3n &#x3D; p * qe &#x3D; 2m &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://coperlm.github.io/img/(34).gif">
<meta property="article:published_time" content="2024-06-05T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-17T04:45:54.886Z">
<meta property="article:author" content="coperlm">
<meta property="article:tag" content="cryptoCTF">
<meta property="article:tag" content="常驻">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://coperlm.github.io/img/(34).gif"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "BUUCTF crypto wp",
  "url": "https://coperlm.github.io/2024/06/06/BUUCTF-crypto-wp/",
  "image": "https://coperlm.github.io/img/(34).gif",
  "datePublished": "2024-06-05T16:00:00.000Z",
  "dateModified": "2024-10-17T04:45:54.886Z",
  "author": [
    {
      "@type": "Person",
      "name": "coperlm",
      "url": "https://coperlm.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/good.gif"><link rel="canonical" href="https://coperlm.github.io/2024/06/06/BUUCTF-crypto-wp/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUUCTF crypto wp',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/nl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/(34).gif);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/niu.gif" alt="Logo"><span class="site-name">coperlm's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">BUUCTF crypto wp</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">BUUCTF crypto wp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-05T16:00:00.000Z" title="发表于 2024-06-06 00:00:00">2024-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T04:45:54.886Z" title="更新于 2024-10-17 12:45:54">2024-10-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="NewStarCTF-2023-公开赛道-Rabin’s-RSA"><a href="#NewStarCTF-2023-公开赛道-Rabin’s-RSA" class="headerlink" title="[NewStarCTF 2023 公开赛道]Rabin’s RSA"></a>[NewStarCTF 2023 公开赛道]Rabin’s RSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line">p = getPrime(64)</span><br><span class="line">q = getPrime(64)</span><br><span class="line">assert p % 4 == 3</span><br><span class="line">assert q % 4 == 3</span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line"></span><br><span class="line">e = 2</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">c = pow(m,e,n)</span><br><span class="line"></span><br><span class="line">print(&#x27;n =&#x27;, n)</span><br><span class="line">print(&#x27;c =&#x27;, c)</span><br><span class="line"></span><br><span class="line"># n = 201354090531918389422241515534761536573</span><br><span class="line"># c = 20442989381348880630046435751193745753</span><br></pre></td></tr></table></figure>
<hr>
<p>Rabin加密算法——一种基于摸平方和模平方根的非对称加密</p>
<p>特点：</p>
<ul>
<li>同一密文，可能有两个以上对应的明文</li>
<li>破解该体制等价于对大整数的分解</li>
<li>满足 $p\equiv 3\mod4$ 且 $q\equiv 3\mod4$</li>
</ul>
<p>Rabin密码体制选取 <code>e=2</code></p>
<p>加密过程：</p>
<ul>
<li>$c\equiv m^2\mod n$</li>
</ul>
<p>解密过程：</p>
<ul>
<li><p>根据费马小定理计算 $m$ 在模 $p$ 和 $q$ 时的平方根 $m_p$ 和 $m_q$：</p>
<p>$\circ$ $m_p\equiv c^{\frac{1}{4}(p+1)}\mod p$</p>
<p>$\circ$ $m_q\equiv c^{\frac{1}{4}(q+1)}\mod q$</p>
</li>
<li><p>使用拓展欧几里得算法来查找 $inv_p$ 和 $inv_q$ ：</p>
<p>$\circ$ $inv_p<em>p+inv_q</em>q=1$</p>
</li>
<li><p>根据中国剩余定理定理求四个模 $n$ 时的平方根：</p>
<p>$\circ$ $r_1\equiv (inv_p\cdot p\cdot m_q+inv_q\cdot q\cdot m_p)\mod n$</p>
<p>$\circ$ $r_2\equiv (n-r_1)\mod n$</p>
<p>$\circ$ $r_3\equiv (inv_p\cdot p\cdot m_q-inv_q\cdot q\cdot m_p)\mod n$</p>
<p>$\circ$ $r_4\equiv (n-r_3)\mod n$</p>
</li>
</ul>
<hr>
<ul>
<li>为什么 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$ 是 $m^2\equiv c\mod p$ 的解？</li>
</ul>
<p>即：已知 $m^2\equiv c\mod p$，求证 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$</p>
<p>因为 $p$ 是素数，且 $c$ 是一个模 $p$ 的二次剩余，那么有：</p>
<p>$c^{\frac{p-1}{2}}\equiv 1\mod p$ $\ (Euler’s Criterion)$</p>
<p>恒等号两侧同时乘以 $c$</p>
<p>$c^{\frac{p+1}{2}}\equiv c\mod p$</p>
<p>恒等号两侧同时开根</p>
<p>$c^{\frac{p+1}{4}}\equiv c^{\frac{1}{2}}\mod p$</p>
<p>模 $p$ 意义下的 $c^{\frac{1}{2}}$ 即为 $m$</p>
<p>故 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$</p>
<p>证毕。</p>
<ul>
<li>为什么 $inv_p<em>p+inv_q</em>q=1$</li>
</ul>
<p>根据贝祖定理，有 $x<em>p+y</em>q=gcd(p,q)=1$</p>
<p>该式对 $q$ 取模，得到 $x*p\equiv 1\mod q$ ，故 $x\equiv p^{-1}\mod q$</p>
<p>同理对 $p$ 取模，$y\equiv q^{-1}\mod p$</p>
<p>故有 $inv_p<em>p+inv_q</em>q=1$</p>
<p>证毕</p>
<hr>
<p>能够抵御低密度指数攻击的原因：</p>
<p>低密度指数攻击基于爆破 $k$ 满足 $m<em>m=c+i</em>n$</p>
<p>本题的 $n,m,c$ 数位相近，$i$ 需要枚举到 $n,m,c$ 数位量级才有可能爆破出答案</p>
<hr>
<p>由于模数 N 通常是两个大质数相乘，其<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?q=欧拉函数&amp;zhida_source=entity&amp;is_preview=1">欧拉函数</a>很大概率是偶数，故欧拉函数和加密指数不互素，那么逆元性质将不再成立，导致解密操作无法正确还原出原始明文。</p>
<p>原RSA里面要求 e 和 d 模 N 互为逆元 ，否则明文不唯一，明文不唯一的后果就是容易被攻击</p>
<p>传统RSA算法不能解决不互素的情况，无法得到所有的明文解，而二次剩余的情况可以专门被处理，所以就可以被其他算法专门研究</p>
<p>Tonelli-Shanks算法：$p,q\equiv 1\mod 4$</p>
<p>推导：设 $p=4k-3,x^2\equiv c\mod p$</p>
<p>由费马定理，$x^{4k-4}\equiv 1\mod p$</p>
<p>也即 $(c^{\frac{p-1}{4}}+1)^2\equiv 1\mod p$（存疑，这一步是怎么得到的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/631005614">https://zhuanlan.zhihu.com/p/631005614</a></p>
<h1 id="UNFIXED"><a href="#UNFIXED" class="headerlink" title="UNFIXED"></a>UNFIXED</h1><p>本题代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">n = 201354090531918389422241515534761536573</span><br><span class="line">c = 20442989381348880630046435751193745753</span><br><span class="line">p = 14450452739004884887</span><br><span class="line">q = 13934102561950901579</span><br><span class="line">e = 2</span><br><span class="line"></span><br><span class="line">inv_p = gmpy2.invert( p , q )</span><br><span class="line">inv_q = gmpy2.invert( q , p )</span><br><span class="line">mp = pow( c , (p+1)//4 , p )</span><br><span class="line">mq = pow( c , (q+1)//4 , q )</span><br><span class="line"></span><br><span class="line">a = (inv_p * p * mq + inv_q * q * mp) % n</span><br><span class="line">b = n - int(a)</span><br><span class="line">c = (inv_p * p * mq - inv_q * q * mp) % n</span><br><span class="line">d = n - int(c)</span><br><span class="line"># 因为rabin 加密有四种结果，全部列出。</span><br><span class="line">aa = [a, b, c, d]</span><br><span class="line"> </span><br><span class="line">for i in aa:</span><br><span class="line">    print(i)</span><br><span class="line">    print( long_to_bytes(i) )</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;r4b1n#4c58&#125;</code></p>
<h3 id="b01lers2020-safety-in-numbers"><a href="#b01lers2020-safety-in-numbers" class="headerlink" title="[b01lers2020]safety_in_numbers"></a>[b01lers2020]safety_in_numbers</h3><p>题目给了三个文件：enc.py<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=加密&amp;spm=1001.2101.3001.7020">加密</a>程序，flag加密结果，pubkey公钥文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import Crypto.PublicKey.RSA as RSA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def enc(msg, pubkey):</span><br><span class="line">   (n,e) = pubkey</span><br><span class="line">   m = int.from_bytes(msg, byteorder = &#x27;little&#x27;)</span><br><span class="line">   c = pow(m, e, n)</span><br><span class="line">   ctxt = (c).to_bytes(c.bit_length() // 8 + 1, byteorder = &#x27;little&#x27;)</span><br><span class="line">   return ctxt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&quot;pubkey.pem&quot;, &quot;r&quot;) as f:</span><br><span class="line">   ciph = RSA.importKey(f.read())     # chill out, Crypto.RSA takes its sweet time... (minutes)</span><br><span class="line"></span><br><span class="line">pubkey = (ciph.n, ciph.e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&quot;flag.txt&quot;, &quot;rb&quot;) as f:</span><br><span class="line">   flag = f.read()</span><br><span class="line"></span><br><span class="line">sys.stdout.buffer.write(enc(flag, pubkey))</span><br></pre></td></tr></table></figure>
<hr>
<p>通过pem文件提取公钥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Crypto.PublicKey.RSA as RSA</span><br><span class="line"></span><br><span class="line">with open(&quot;pubkey.pem&quot;, &quot;r&quot;) as f:</span><br><span class="line">   ciph = RSA.importKey(f.read())     # chill out, Crypto.RSA takes its sweet time... (minutes)</span><br><span class="line">n = ciph.n</span><br><span class="line">e = ciph.e</span><br><span class="line">print (n)</span><br><span class="line">print (e)</span><br></pre></td></tr></table></figure>
<p>n太大太大了，跑了半天都无法输出（可能超过4300位），所以直接对c开e次方即可得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import*</span><br><span class="line">from libnum import*</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">f = open(&#x27;flag.enc&#x27;,&#x27;rb&#x27;).read()</span><br><span class="line"></span><br><span class="line">e = 65537</span><br><span class="line">tmp = int.from_bytes(f, byteorder = &#x27;little&#x27;)</span><br><span class="line"></span><br><span class="line">m = iroot(tmp,e)[0]</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line">print(long_to_bytes(m)[::-1])</span><br></pre></td></tr></table></figure>
<p>其中，pem文件的最后一段是存储e的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import*</span><br><span class="line">from libnum import*</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = &#x27;AQAB&#x27;</span><br><span class="line">m = base64.b64decode(s)</span><br><span class="line">m = bytes_to_long(m)</span><br><span class="line">print(hex(m))</span><br></pre></td></tr></table></figure>
<h3 id="AFCTF2018-你听过一次一密么？"><a href="#AFCTF2018-你听过一次一密么？" class="headerlink" title="[AFCTF2018]你听过一次一密么？"></a>[AFCTF2018]你听过一次一密么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">25030206463d3d393131555f7f1d061d4052111a19544e2e5d54</span><br><span class="line">0f020606150f203f307f5c0a7f24070747130e16545000035d54</span><br><span class="line">1203075429152a7020365c167f390f1013170b1006481e13144e</span><br><span class="line">0f4610170e1e2235787f7853372c0f065752111b15454e0e0901</span><br><span class="line">081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a1855</span><br><span class="line">0909075412132e247436425332281a1c561f04071d520f0b1158</span><br><span class="line">4116111b101e2170203011113a69001b47520601155205021901</span><br><span class="line">041006064612297020375453342c17545a01451811411a470e44</span><br><span class="line">021311114a5b0335207f7c167f22001b44520c15544801125d40</span><br><span class="line">06140611460c26243c7f5c167f3d015446010053005907145d44</span><br><span class="line">0f05110d160f263f3a7f4210372c03111313090415481d49530f</span><br></pre></td></tr></table></figure>
<hr>
<p>多次一密</p>
<p>已知异或的性质，有 $C_1\oplus C_2=(M_1\oplus key)\oplus(M_2\oplus key)=M_1\oplus M_2$</p>
<p>先试用第一行和其他行异或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c = [eval(&#x27;0x&#x27;+x.strip()) for x in open(&#x27;Problem.txt&#x27;,&#x27;r&#x27;).readlines()]</span><br><span class="line">m1 = c[0]</span><br><span class="line"></span><br><span class="line">for i in range( 1 , len(c) ):</span><br><span class="line">    tmp = hex( m1^c[i] )[2:]</span><br><span class="line">    for i in range( 0 , len(tmp), 2 ):#两位一转ascll</span><br><span class="line">        p = chr(eval(&#x27;0x&#x27;+tmp[i:i+2]))</span><br><span class="line">        if p.isalpha():</span><br><span class="line">            print( p , end=&#x27;&#x27; )</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;.&#x27;, end=&#x27;&#x27; )</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....S....N.U.....A..M.N...</span><br><span class="line">...Ro..I...I....SE....P.I.</span><br><span class="line">.E..H...IN..H...........TU</span><br><span class="line">..A.H.R.....E....P......E.</span><br><span class="line">...RT...E...M....M....A.L.</span><br><span class="line">d...V..I..DNEt........K.DU</span><br><span class="line">.......I....K..I.ST...TiS.</span><br><span class="line">.....f...N.I........M.O...</span><br><span class="line">.........N.I...I.S.I..I...</span><br><span class="line">....P....N.OH...SA....Sg..</span><br></pre></td></tr></table></figure>
<p>规律：小写字母$\oplus$空格=相应的大写字母，大写字母$\oplus$空格=相应的小写字母</p>
<p>故某一 <strong>列</strong> 英文字母越多，$M_1$ 相应位置是空格的可能性越大</p>
<p>因为异或运算下，$x$ 的逆元是自身</p>
<p>故有 $M_i[j]=M_1[j]\oplus M_i[j]\oplus M_1[j]=M_1[j]\oplus M_i[j]\oplus 0x20$（$j$ 表示列）</p>
<p>只需知道某一字符串的某一位是空格，即可回复所有的密文在这一列的值</p>
<p>解密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import Crypto.Util.strxor as xo</span><br><span class="line">import libnum, codecs, numpy as np</span><br><span class="line"></span><br><span class="line">def isChr(x):</span><br><span class="line">    if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True</span><br><span class="line">    if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">def infer(index, pos):</span><br><span class="line">    if msg[index, pos] != 0:</span><br><span class="line">        return</span><br><span class="line">    msg[index, pos] = ord(&#x27; &#x27;)</span><br><span class="line">    for x in range(len(c)):</span><br><span class="line">        if x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">dat = []</span><br><span class="line"></span><br><span class="line">def getSpace():</span><br><span class="line">    for index, x in enumerate(c):</span><br><span class="line">        res = [xo.strxor(x, y) for y in c if x!=y]</span><br><span class="line">        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))</span><br><span class="line">        cnt = [f(pos) for pos in range(len(x))]</span><br><span class="line">        for pos in range(len(x)):</span><br><span class="line">            dat.append((f(pos), index, pos))</span><br><span class="line"></span><br><span class="line">c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]</span><br><span class="line"></span><br><span class="line">msg = np.zeros([len(c), len(c[0])], dtype=int)</span><br><span class="line"></span><br><span class="line">getSpace()</span><br><span class="line"></span><br><span class="line">dat = sorted(dat)[::-1]</span><br><span class="line">for w, index, pos in dat:</span><br><span class="line">    infer(index, pos)</span><br><span class="line"></span><br><span class="line">print(&#x27;\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dear Friend, T%is tim&lt; I u</span><br><span class="line">nderstood my m$stake 8nd u</span><br><span class="line">sed One time p,d encr ptio</span><br><span class="line">n scheme, I he,rd tha- it </span><br><span class="line">is the only en.ryptio7 met</span><br><span class="line">hod that is ma9hemati:ally</span><br><span class="line"> proven to be #ot cra:ked </span><br><span class="line">ever if the ke4 is ke)t se</span><br><span class="line">cure, Let Me k#ow if  ou a</span><br><span class="line">gree with me t&quot; use t1is e</span><br><span class="line">ncryption sche e alwa s...</span><br></pre></td></tr></table></figure>
<p>但是有点问题，可以选择手动修复，或者使用代码修复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def know(s,x,y):</span><br><span class="line">    msg[x,y] = ord(s)</span><br><span class="line">    for index in range(len(c)):</span><br><span class="line">        if index != x:</span><br><span class="line">            msg[index,y] = xo.strxor(c[x], c[index])[y] ^ ord(s)</span><br><span class="line">            </span><br><span class="line">know(&#x27;h&#x27;,0,14)</span><br><span class="line">know(&#x27;e&#x27;,0,21)</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dear Friend, This time I u</span><br><span class="line">nderstood my mistake and u</span><br><span class="line">sed One time pad encryptio</span><br><span class="line">n scheme, I heard that it </span><br><span class="line">is the only encryption met</span><br><span class="line">hod that is mathematically</span><br><span class="line"> proven to be not cracked </span><br><span class="line">ever if the key is kept se</span><br><span class="line">cure, Let Me know if you a</span><br><span class="line">gree with me to use this e</span><br><span class="line">ncryption scheme always...</span><br></pre></td></tr></table></figure>
<p>有了明文了，计算 $C_1\oplus M_1$ 即可得到 <code>key</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())</span><br><span class="line">print(key)</span><br></pre></td></tr></table></figure>
<p>key就是flag</p>
<p>flag:<code>flag&#123;OPT_1s_Int3rest1ng&#125;</code></p>
<hr>
<p>后记：</p>
<p>按行读取TXT中的数据：<code>c = [x for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]</code></p>
<p>去除尾部的<code>&#39;\n&#39;</code>：<code>c = [x.strip() for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]</code></p>
<p>eval的用法十分灵活，默认十进制：<code>c = [eval(&#39;0x&#39;+x.strip()) for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]</code></p>
<h3 id="NewStarCTF-2023-公开赛道-babyaes"><a href="#NewStarCTF-2023-公开赛道-babyaes" class="headerlink" title="[NewStarCTF 2023 公开赛道]babyaes"></a>[NewStarCTF 2023 公开赛道]babyaes</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import os</span><br><span class="line">from flag import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">def pad(data):</span><br><span class="line">    return data + b&quot;&quot;.join([b&#x27;\x00&#x27; for _ in range(0, 16 - len(data))])</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    flag_ = pad(flag)</span><br><span class="line">    key = os.urandom(16) * 2</span><br><span class="line">    iv = os.urandom(16)</span><br><span class="line">    print(bytes_to_long(key) ^ bytes_to_long(iv) ^ 1)</span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    enc_flag = aes.encrypt(flag_)</span><br><span class="line">    print(enc_flag)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"># 3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="line"># b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br></pre></td></tr></table></figure>
<hr>
<p>key是高位16bytes，iv是低位16bytes，所以可以很轻易的区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import os</span><br><span class="line">from gmpy2 import*</span><br><span class="line">from Crypto.Util.number import*</span><br><span class="line"></span><br><span class="line">xor = 3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="line">enc_flag = b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br><span class="line">out = long_to_bytes(xor)#先转化成16进制形式，aes和rsa不一样，操作一般都是在hex下</span><br><span class="line">key = out[:16]*2#这一部分是key的，另外一部分是iv的（别忘了最低位有个1）</span><br><span class="line">iv = long_to_bytes(bytes_to_long(key[16:])^bytes_to_long(out[16:])^1)</span><br><span class="line">aes = AES.new(key,AES.MODE_CBC,iv)#调用函数库解密</span><br><span class="line">flag = aes.decrypt(enc_flag)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;firsT_cry_Aes&#125;</code></p>
<h3 id="QCTF2018-Xman-RSA"><a href="#QCTF2018-Xman-RSA" class="headerlink" title="[QCTF2018]Xman-RSA"></a>[QCTF2018]Xman-RSA</h3><p>ciphertext:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1240198b148089290e375b999569f0d53c32d356b2e95f5acee070f016b3bef243d0b5e46d9ad7aa7dfe2f21bda920d0ac7ce7b1e48f22b2de410c6f391ce7c4347c65ffc9704ecb3068005e9f35cbbb7b27e0f7a18f4f42ae572d77aaa3ee189418d6a07bab7d93beaa365c98349d8599eb68d21313795f380f05f5b3dfdc6272635ede1f83d308c0fdb2baf444b9ee138132d0d532c3c7e60efb25b9bf9cb62dba9833aa3706344229bd6045f0877661a073b6deef2763452d0ad7ab3404ba494b93fd6dfdf4c28e4fe83a72884a99ddf15ca030ace978f2da87b79b4f504f1d15b5b96c654f6cd5179b72ed5f84d3a16a8f0d5bf6774e7fd98d27bf3c9839</span><br><span class="line">129d5d4ab3f9e8017d4e6761702467bbeb1b884b6c4f8ff397d078a8c41186a3d52977fa2307d5b6a0ad01fedfc3ba7b70f776ba3790a43444fb954e5afd64b1a3abeb6507cf70a5eb44678a886adf81cb4848a35afb4db7cd7818f566c7e6e2911f5ababdbdd2d4ff9825827e58d48d5466e021a64599b3e867840c07e29582961f81643df07f678a61a9f9027ebd34094e272dfbdc4619fa0ac60f0189af785df77e7ec784e086cf692a7bf7113a7fb8446a65efa8b431c6f72c14bcfa49c9b491fb1d87f2570059e0f13166a85bb555b40549f45f04bc5dbd09d8b858a5382be6497d88197ffb86381085756365bd757ec3cdfa8a77ba1728ec2de596c5ab</span><br></pre></td></tr></table></figure>
<p>n2&amp;n3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw==</span><br><span class="line">TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ==</span><br></pre></td></tr></table></figure>
<p>n1.encrypted:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2639c28e3609a4a8c953cca9c326e8e062756305ae8aee6efcd346458aade3ee8c2106ab9dfe5f470804f366af738aa493fd2dc26cb249a922e121287f3eddec0ed8dea89747dc57aed7cd2089d75c23a69bf601f490a64f73f6a583081ae3a7ed52238c13a95d3322065adba9053ee5b12f1de1873dbad9fbf4a50a2f58088df0fddfe2ed8ca1118c81268c8c0fd5572494276f4e48b5eb424f116e6f5e9d66da1b6b3a8f102539b690c1636e82906a46f3c5434d5b04ed7938861f8d453908970eccef07bf13f723d6fdd26a61be8b9462d0ddfbedc91886df194ea022e56c1780aa6c76b9f1c7d5ea743dc75cec3c805324e90ea577fa396a1effdafa3090</span><br><span class="line">42ff1157363d9cd10da64eb4382b6457ebb740dbef40ade9b24a174d0145adaa0115d86aa2fc2a41257f2b62486eaebb655925dac78dd8d13ab405aef5b8b8f9830094c712193500db49fb801e1368c73f88f6d8533c99c8e7259f8b9d1c926c47215ed327114f235ba8c873af7a0052aa2d32c52880db55c5615e5a1793b690c37efdd5e503f717bb8de716303e4d6c4116f62d81be852c5d36ef282a958d8c82cf3b458dcc8191dcc7b490f227d1562b1d57fbcf7bf4b78a5d90cd385fd79c8ca4688e7d62b3204aeaf9692ba4d4e44875eaa63642775846434f9ce51d138ca702d907849823b1e86896e4ea6223f93fae68b026cfe5fa5a665569a9e3948a</span><br></pre></td></tr></table></figure>
<p>encryption.encrypted:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">gqhb jbkl2 pbkhqw pt_kqpbd</span><br><span class="line">gqhb ht pbkhqw zqreahb</span><br><span class="line">pbkhqw urtd64</span><br><span class="line"></span><br><span class="line">adg ulwdt_wh_ezb(u):</span><br><span class="line">	qdwzqe pew(u.dexhad(&#x27;mdi&#x27;), 16)</span><br><span class="line">	</span><br><span class="line">adg ezb_wh_ulwdt(e):</span><br><span class="line">	u = mdi(e)[2:-1]</span><br><span class="line">	u = &#x27;0&#x27; + u pg yde(u)%2 == 1 dytd u</span><br><span class="line">	qdwzqe u.adxhad(&#x27;mdi&#x27;)</span><br><span class="line"></span><br><span class="line">adg jdw_r_kqpbd(y):</span><br><span class="line">	qreahb_tdda = zqreahb(y)</span><br><span class="line"></span><br><span class="line">	ezb = ulwdt_wh_ezb(qreahb_tdda)</span><br><span class="line">	</span><br><span class="line">	fmpyd Tqzd:</span><br><span class="line">		pg pt_kqpbd(ezb):</span><br><span class="line">			uqdrv</span><br><span class="line">		ezb+=1</span><br><span class="line">	qdwzqe ezb</span><br><span class="line"></span><br><span class="line">adg dexqlkw(t, d, e):</span><br><span class="line">	k = ulwdt_wh_ezb(t)</span><br><span class="line">	k = khf(k, d, e)</span><br><span class="line">	qdwzqe ezb_wh_ulwdt(k).dexhad(&#x27;mdi&#x27;)	</span><br><span class="line"></span><br><span class="line">adg tdkrqrwd(e):</span><br><span class="line">	k = e % 4</span><br><span class="line">	w = (k*k) % 4</span><br><span class="line">	qdwzqe w == 1</span><br><span class="line">	</span><br><span class="line">g = hkde(&#x27;gyrj.wiw&#x27;, &#x27;q&#x27;)</span><br><span class="line">gyrj = g.qdra()</span><br><span class="line">		</span><br><span class="line">btj1 = &quot;&quot;</span><br><span class="line">btj2 = &quot;&quot;</span><br><span class="line">ghq p pe qrejd(yde(gyrj)):</span><br><span class="line">	pg tdkrqrwd(p):</span><br><span class="line">		btj2 += gyrj[p]</span><br><span class="line">	dytd:</span><br><span class="line">		btj1 += gyrj[p]</span><br><span class="line"></span><br><span class="line">k1 = jdw_r_kqpbd(128)</span><br><span class="line">k2 = jdw_r_kqpbd(128)</span><br><span class="line">k3 = jdw_r_kqpbd(128)</span><br><span class="line">e1 = k1*k2</span><br><span class="line">e2 = k1*k3</span><br><span class="line">d = 0i1001</span><br><span class="line">x1 = dexqlkw(btj1, d, e1)</span><br><span class="line">x2 = dexqlkw(btj2, d, e2)</span><br><span class="line">kqpew(x1)</span><br><span class="line">kqpew(x2)</span><br><span class="line"></span><br><span class="line">d1 = 0i1001</span><br><span class="line">d2 = 0i101</span><br><span class="line">k4 = jdw_r_kqpbd(128)</span><br><span class="line">k5 = jdw_r_kqpbd(128)</span><br><span class="line">e3 = k4*k5</span><br><span class="line">x1 = ezb_wh_ulwdt(khf(e1, d1, e3)).dexhad(&#x27;mdi&#x27;)</span><br><span class="line">x2 = ezb_wh_ulwdt(khf(e1, d2, e3)).dexhad(&#x27;mdi&#x27;)</span><br><span class="line">kqpew(x1)</span><br><span class="line">kqpew(x2)</span><br><span class="line"></span><br><span class="line">kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e2)))</span><br><span class="line">kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e3)))</span><br></pre></td></tr></table></figure>
<hr>
<p>加密代码非要替换一下，直接 <a target="_blank" rel="noopener" href="https://quipqiup.com/">词频分析</a> 得到代码原文：（需要自行加入空格）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import is_prime </span><br><span class="line">from os import urandom </span><br><span class="line">import base64 </span><br><span class="line">def bytes_to_num(b): </span><br><span class="line">    return int(b.encode(&#x27;hex&#x27;), 16) </span><br><span class="line">def num_to_bytes(n): </span><br><span class="line">    b = hex(n)[2:-1] </span><br><span class="line">    b = &#x27;0&#x27; + b if len(b)%2 == 1 else b </span><br><span class="line">    return b.decode(&#x27;hex&#x27;) </span><br><span class="line">def get_a_prime(l): </span><br><span class="line">    random_seed = urandom(l) </span><br><span class="line">    </span><br><span class="line">    num = bytes_to_num(random_seed) </span><br><span class="line">    while True: </span><br><span class="line">        if is_prime(num): </span><br><span class="line">            break </span><br><span class="line">        num+=1 </span><br><span class="line">        return num </span><br><span class="line">def encrypt(s, e, n): </span><br><span class="line">    p = bytes_to_num(s) </span><br><span class="line">    p = pow(p, e, n) </span><br><span class="line">    return num_to_bytes(p).encode(&#x27;hex&#x27;) </span><br><span class="line"> </span><br><span class="line">def separate(n): </span><br><span class="line">    p = n % 4 </span><br><span class="line">    t = (p*p) % 4 </span><br><span class="line">    return t == 1 </span><br><span class="line">    </span><br><span class="line">f = open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) </span><br><span class="line">flag = f.read() </span><br><span class="line">msg1 = &quot;&quot; </span><br><span class="line">msg2 = &quot;&quot; </span><br><span class="line">for i in range(len(flag)): </span><br><span class="line">    if separate(i): </span><br><span class="line">        msg2 += flag[i] </span><br><span class="line">    else: </span><br><span class="line">        msg1 += flag[i] </span><br><span class="line"> </span><br><span class="line">p1 = get_a_prime(128) </span><br><span class="line">p2 = get_a_prime(128) </span><br><span class="line">p3 = get_a_prime(128) </span><br><span class="line"> </span><br><span class="line">n1 = p1*p2 </span><br><span class="line">n2 = p1*p3 </span><br><span class="line">e = 0x1001 </span><br><span class="line">c1 = encrypt(msg1, e, n1) </span><br><span class="line">c2 = encrypt(msg2, e, n2) </span><br><span class="line">print(c1) </span><br><span class="line">print(c2) </span><br><span class="line">e1 = 0x1001 </span><br><span class="line">e2 = 0x101 </span><br><span class="line">p4 = get_a_prime(128) </span><br><span class="line">p5 = get_a_prime(128) </span><br><span class="line">n3 = p4*p5 </span><br><span class="line">c1 = num_to_bytes(pow(n1, e1, n3)).encode(&#x27;hex&#x27;) </span><br><span class="line">c2 = num_to_bytes(pow(n1, e2, n3)).encode(&#x27;hex&#x27;) </span><br><span class="line">print(c1) </span><br><span class="line">print(c2) </span><br><span class="line">print(base64.b64encode(num_to_bytes(n2))) </span><br><span class="line">print(base64.b64encode(num_to_bytes(n3)))</span><br></pre></td></tr></table></figure>
<p>从后往前解，n2和n3是从先 <code>long_to_bytes</code>，然后 <code>base64</code> 加密，容易得到代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">from Crypto.Util.number import bytes_to_long</span><br><span class="line"></span><br><span class="line">def dec( x ):</span><br><span class="line">    return bytes_to_long(base64.b64decode(x)) </span><br><span class="line"></span><br><span class="line">n2 = dec(&#x27;PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw==&#x27;)</span><br><span class="line">n3 = dec(&#x27;TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ==&#x27;)</span><br><span class="line"></span><br><span class="line">print( n2 )</span><br><span class="line">print( n3 )</span><br></pre></td></tr></table></figure>
<p>然后通过共膜攻击，求得 <code>n1</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e1 = 0x1001</span><br><span class="line">e2 = 0x101</span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line"> </span><br><span class="line">s, s1, s2 = gmpy2.gcdext(e1, e2)</span><br><span class="line">n1 = (pow(c1, s1, n3) * pow(c2, s2, n3) % n3)</span><br><span class="line"> </span><br><span class="line">print( n1 )</span><br></pre></td></tr></table></figure>
<p>因为 <code>n1</code> 和 <code>n2</code> 有公因数，易求得 <code>p1,p2,p3</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line"> </span><br><span class="line">n1 = </span><br><span class="line">n2 = </span><br><span class="line"></span><br><span class="line">p1 = gmpy2.gcd(n1, n2)</span><br><span class="line">p2 = n1 // p1</span><br><span class="line">p3 = n2 // p2</span><br><span class="line">print( p1 , p2 , p3 )</span><br></pre></td></tr></table></figure>
<p>剩下的是常规rsa，注意flag拼接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e = 0x1001</span><br><span class="line"> </span><br><span class="line">phi1 = (p1-1)*(p2-1)</span><br><span class="line">phi2 = (p1-1)*(p3-1)</span><br><span class="line">d1 = gmpy2.invert(e, phi1)</span><br><span class="line">d2 = gmpy2.invert(e, phi2)</span><br><span class="line">m1 = pow(c1, d1, n1)</span><br><span class="line">m2 = pow(c2, d2, n2)</span><br><span class="line">flag1 = long_to_bytes(int(m1))</span><br><span class="line">flag2 = long_to_bytes(int(m2))</span><br><span class="line"> </span><br><span class="line">print(flag1)</span><br><span class="line">print(flag2)</span><br><span class="line"></span><br><span class="line">for i in range(len(flag1)):</span><br><span class="line">    print(chr(flag1[i]), end = &#x27;&#x27;)</span><br><span class="line">    try:</span><br><span class="line">        print(chr(flag2[i]), end = &#x27;&#x27;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;CRYPT0_I5_50_Interestingvim rsa.py&#125;</code></p>
<hr>
<h3 id="羊城杯-2020-RRRRRRRSA"><a href="#羊城杯-2020-RRRRRRRSA" class="headerlink" title="[羊城杯 2020]RRRRRRRSA"></a>[羊城杯 2020]RRRRRRRSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import sympy</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = &#x27;GWHT&#123;************&#125;&#x27;</span><br><span class="line">flag1 = flag[:19].encode()</span><br><span class="line">flag2 = flag[19:].encode()</span><br><span class="line">assert(len(flag) == 38)</span><br><span class="line">P1 = getPrime(1038)</span><br><span class="line">P2 = sympy.nextprime(P1)</span><br><span class="line">assert(P2 - P1 &lt; 1000)</span><br><span class="line">Q1 = getPrime(512)</span><br><span class="line">Q2 = sympy.nextprime(Q1)</span><br><span class="line">N1 = P1 * P1 * Q1</span><br><span class="line">N2 = P2 * P2 * Q2</span><br><span class="line">E1 = getPrime(1024)</span><br><span class="line">E2 = sympy.nextprime(E1)</span><br><span class="line">m1 = bytes_to_long(flag1)</span><br><span class="line">m2 = bytes_to_long(flag2)</span><br><span class="line">c1 = pow(m1, E1, N1)</span><br><span class="line">c2 = pow(m2, E2, N2)</span><br><span class="line"></span><br><span class="line">output = open(&#x27;secret&#x27;, &#x27;w&#x27;)</span><br><span class="line">output.write(&#x27;N1=&#x27; + str(N1) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;c1=&#x27; + str(c1) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;E1=&#x27; + str(E1) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;N2=&#x27; + str(N2) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;c2=&#x27; + str(c2) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;E2=&#x27; + str(E2) + &#x27;\n&#x27;)</span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N1=</span><br><span class="line">c1=</span><br><span class="line">E1=</span><br><span class="line">N2=</span><br><span class="line">c2=</span><br><span class="line">E2=</span><br></pre></td></tr></table></figure>
<hr>
<p><code>wiener attack</code> 是依靠连分数进行的攻击方式，适用于非常接近某一值（比如1）时，求一个比例关系，通过该比例关系再来反推关键信息就简单很多。这种攻击对于解密指数d很小时有很好的效果，一般的用法是通过 </p>
<p>$ed \mod \phi(N)\equiv1$ </p>
<p>得到 $ed=k*\phi(N)+1$</p>
<p>即  $\frac{e}{\phi(N)}=\frac{k}{d}+\frac{1}{\phi(N)}$</p>
<p>这种情况下 $\phi(N)≈N$，且 $\phi(N)$ 非常大</p>
<p>所以有 $\frac{e}{N}-\frac{k}{d}=\frac{1}{\phi(N)}$</p>
<p>也就是说 $\frac{k}{d}$ 与 $\frac{e}{N}$ 非常接近，而 $\frac{e}{N}$ 又是已知的</p>
<p>对 $\frac{e}{N}$ 进行连分数展开，得到的一串分数的分母很有可能就是 $d$</p>
<p>只要检验一下 $ed \mod \phi(N)$ ，看它是不是 $1$ 就知道对不对了。</p>
<p>但是这道题和普通的wiener attack 不同的是，e与N并没有近到相除约为1的地步，相差还是很大的，也就是说解密指数d也许还是很大的，这样就解不出来。</p>
<p>值得注意的是，e和N的关系不符合利用条件，但是N1和N2的关系却适合</p>
<p>对于这一道题: $\frac{N_1}{N_2}=(\frac{P_1}{P_2})^2*\frac{Q_1}{Q_2}$</p>
<p>显然我们可以知道的是 $\frac{N_1}{N_2}&lt;\frac{Q_1}{Q_2}$ </p>
<p>所以在 $\frac{Q_1}{Q_2}\in [\frac{N_1}{N_2},1]$ </p>
<p>尝试对 $\frac{N_1}{N_2}$ 进行连分数展开并求其各项渐进分数，其中某个连分数的分母可能就是 $Q_1$（依靠 $N\%Q$ 来验证）</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">N1=</span><br><span class="line">c1=</span><br><span class="line">E1=</span><br><span class="line">N2=</span><br><span class="line">c2=</span><br><span class="line">E2=</span><br><span class="line"></span><br><span class="line">def continuedFra(x, y): #不断生成连分数的项</span><br><span class="line">    cF = []</span><br><span class="line">    while y:</span><br><span class="line">        cF += [x // y]</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    return cF</span><br><span class="line">def Simplify(ctnf): #化简</span><br><span class="line">    numerator = 0</span><br><span class="line">    denominator = 1</span><br><span class="line">    for x in ctnf[::-1]: #注意这里是倒叙遍历</span><br><span class="line">        numerator, denominator = denominator, x * denominator + numerator</span><br><span class="line">    return (numerator, denominator) #把连分数分成分子和算出来的分母</span><br><span class="line">def getit(c):</span><br><span class="line">    cf=[]</span><br><span class="line">    for i in range(1,len(c)):</span><br><span class="line">        cf.append(Simplify(c[:i])) #各个阶段的连分数的分子和分母</span><br><span class="line">    return cf #得到一串连分数</span><br><span class="line"></span><br><span class="line">def wienerAttack(e, n):</span><br><span class="line">    cf=continuedFra(e,n)</span><br><span class="line">    for (Q2,Q1) in getit(cf):#遍历得到的连分数，令分子分母分别是Q2，Q1</span><br><span class="line">        if Q1 == 0:</span><br><span class="line">            continue</span><br><span class="line">        if N1%Q1==0 and Q1!=1:#满足这个条件就找到了</span><br><span class="line">            return Q1</span><br><span class="line">    print(&#x27;not find!&#x27;)</span><br><span class="line">Q1=wienerAttack(N1,N2)</span><br><span class="line"></span><br><span class="line">P1=gmpy2.iroot(N1//Q1,2)[0]</span><br><span class="line">P2=gmpy2.next_prime(P1)</span><br><span class="line">Q2=gmpy2.next_prime(Q1)</span><br><span class="line">phi1=P1*(P1-1)*(Q1-1)</span><br><span class="line">phi2=P2*(P2-1)*(Q2-1)</span><br><span class="line">d1=gmpy2.invert(E1,phi1)</span><br><span class="line">d2=gmpy2.invert(E2,phi2)</span><br><span class="line">m1=long_to_bytes(gmpy2.powmod(c1,d1,N1))</span><br><span class="line">m2=long_to_bytes(gmpy2.powmod(c2,d2,N2))</span><br><span class="line">print((m1+m2))</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;3aadab41754799f978669d53e64a3aca&#125;</code></p>
<h3 id="UTCTF2020-OTP"><a href="#UTCTF2020-OTP" class="headerlink" title="[UTCTF2020]OTP"></a>[UTCTF2020]OTP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Encoded A: 213c234c2322282057730b32492e720b35732b2124553d354c22352224237f1826283d7b0651</span><br><span class="line">Encoded B: 3b3b463829225b3632630b542623767f39674431343b353435412223243b7f162028397a103e</span><br><span class="line"></span><br><span class="line">Original A: 5448452042455354204354462043415445474f52592049532043525950544f47524150485921</span><br><span class="line">Original B: 4e4f205448452042455354204f4e452049532042494e415259204558504c4f49544154494f4e</span><br><span class="line"></span><br><span class="line">A XOR A: 7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70</span><br><span class="line">B XOR B: 7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70</span><br></pre></td></tr></table></figure>
<hr>
<p>一次一密是牢不可破的！</p>
<p>不过原文和密文都给了，就可以轻易得到flag了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = &#x27;7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70&#x27;</span><br><span class="line"> </span><br><span class="line">for i in range(0, len(c), 2):</span><br><span class="line">    print(chr(int(c[i:i+2], 16)), end = &#x27;&#x27;)</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;tw0_tim3_p4ds&#125;</code></p>
<h3 id="Dest0g3-520迎新赛-babyAES"><a href="#Dest0g3-520迎新赛-babyAES" class="headerlink" title="[Dest0g3 520迎新赛]babyAES"></a>[Dest0g3 520迎新赛]babyAES</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import os</span><br><span class="line">iv = os.urandom(16)</span><br><span class="line">key = os.urandom(16)</span><br><span class="line">my_aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()</span><br><span class="line">flag += (16 - len(flag) % 16) * b&#x27;\x00&#x27;</span><br><span class="line">c = my_aes.encrypt(flag)</span><br><span class="line">print(c)</span><br><span class="line">print(iv)</span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;</span><br><span class="line">b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;</span><br><span class="line">b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<hr>
<p>最喜欢的大水题，该给的都给了，直接解就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line"> </span><br><span class="line">c = b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;</span><br><span class="line">iv = b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;</span><br><span class="line">key = b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;</span><br><span class="line"></span><br><span class="line">my_aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">m = my_aes.decrypt(c)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4&#125;</code></p>
<h3 id="ACTF新生赛2020-crypto-des"><a href="#ACTF新生赛2020-crypto-des" class="headerlink" title="[ACTF新生赛2020]crypto-des"></a>[ACTF新生赛2020]crypto-des</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">72143238992041641000000.000000,</span><br><span class="line">77135357178006504000000000000000.000000,</span><br><span class="line">1125868345616435400000000.000000,</span><br><span class="line">67378029765916820000000.000000,</span><br><span class="line">75553486092184703000000000000.000000,</span><br><span class="line">4397611913739958700000.000000,</span><br><span class="line">76209378028621039000000000000000.000000</span><br><span class="line">To solve the key, Maybe you know some interesting data format about C language?</span><br></pre></td></tr></table></figure>
<hr>
<p>网上抄来的脚本，我也不知道为什么要这么干（感觉和密码学没关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from libnum import*</span><br><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">s = [72143238992041641000000.000000,77135357178006504000000000000000.000000,1125868345616435400000000.000000,67378029765916820000000.000000,75553486092184703000000000000.000000,4397611913739958700000.000000,76209378028621039000000000000000.000000]</span><br><span class="line">a = &#x27;&#x27;</span><br><span class="line">b = &#x27;&#x27;</span><br><span class="line">for i in s:</span><br><span class="line">    i = float(i)</span><br><span class="line">    a += struct.pack(&#x27;&lt;f&#x27;,i).hex()        #小端</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">for j in s:</span><br><span class="line">    i = float(i)</span><br><span class="line">    b += struct.pack(&#x27;&gt;f&#x27;,i).hex()        #小端</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(n2s(a))</span><br><span class="line">print(n2s(b))</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;Interestring Idea to encrypt&#x27;</span><br><span class="line">b&#x27;tpyrtpyrtpyrtpyrtpyrtpyrtpyr&#x27;</span><br></pre></td></tr></table></figure>
<p>但是我自己习惯的写法，得到的a是相同的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line">from Crypto.Util.number import long_to_bytes , bytes_to_long</span><br><span class="line"></span><br><span class="line">s = [</span><br><span class="line">    72143238992041641000000.000000,</span><br><span class="line">    77135357178006504000000000000000.000000,</span><br><span class="line">    1125868345616435400000000.000000,</span><br><span class="line">    67378029765916820000000.000000,</span><br><span class="line">    75553486092184703000000000000.000000,</span><br><span class="line">    4397611913739958700000.000000,</span><br><span class="line">    76209378028621039000000000000000.000000</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def solve( f ):</span><br><span class="line">    output = &#x27;&#x27;</span><br><span class="line">    for i in s:</span><br><span class="line">        output += str(struct.pack(f,float(i)))[2:].strip(&#x27;\&#x27;&#x27;)</span><br><span class="line">    return output</span><br><span class="line"></span><br><span class="line">a = solve(&#x27;&lt;f&#x27;)</span><br><span class="line">b = solve(&#x27;&gt;f&#x27;)</span><br><span class="line">print( a )</span><br><span class="line">print( b )</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Interestring Idea to encrypt</span><br><span class="line">etnItsergniredI ot acne tpyr</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.codeleading.com/article/82534229429/">这篇文章</a>的解法看着相对靠谱很多，但是没有详细代码，不知道是如何操作的，尝试只好一番之后未成功只好作罢</p>
<p>输出结果中，b的不一样而a一样，但是解压密码就是a的输出</p>
<p>解压密码是:<code>Interestring Idea to encrypt</code></p>
<p>得到zip文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import pyDes</span><br><span class="line">import base64</span><br><span class="line">from FLAG import flag</span><br><span class="line">deskey = &quot;********&quot;</span><br><span class="line">DES = pyDes.des(deskey)</span><br><span class="line">DES.setMode(&#x27;ECB&#x27;)</span><br><span class="line">DES.Kn = 一个矩阵</span><br><span class="line">cipher_list = base64.b64encode(DES.encrypt(flag))</span><br><span class="line">#b&#x27;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#x27;</span><br></pre></td></tr></table></figure>
<p>新生赛的题是这样的，直接解就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import pyDes</span><br><span class="line">import base64</span><br><span class="line">from Crypto.Util.number  import*</span><br><span class="line">deskey  = &quot;********&quot;</span><br><span class="line">DES = pyDes.des(deskey)</span><br><span class="line">DES.setMode(&#x27;ECB&#x27;)</span><br><span class="line">DES.Kn =</span><br><span class="line"></span><br><span class="line">k = b&#x27;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#x27;</span><br><span class="line">data = base64.b64decode(k)</span><br><span class="line">flag = DES.decrypt(data)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;breaking_DES_is_just_a_small_piece_of_cake&#125;</code></p>
<h3 id="AFCTF2018-One-Secret-Two-encryption"><a href="#AFCTF2018-One-Secret-Two-encryption" class="headerlink" title="[AFCTF2018]One Secret, Two encryption"></a>[AFCTF2018]One Secret, Two encryption</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一份秘密发送给两个人不太好吧，那我各自加密一次好啦~~~</span><br><span class="line">素数生成好慢呀</span><br><span class="line">偷个懒也……不会有问题的吧？</span><br></pre></td></tr></table></figure>
<p><code>flag_encry1</code></p>
<p><code>flag_encry2</code></p>
<p><code>public1.pub</code></p>
<p><code>public2.pub</code></p>
<hr>
<p>先用 <a target="_blank" rel="noopener" href="http://www.hiencode.com/pub_asys.html">公钥解析</a> 提取一下公钥</p>
<p>得到两组n和e</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( math.gcd(n1,n2) )</span><br></pre></td></tr></table></figure>
<p>得到两组p和q</p>
<p>也可以直接用库函数来解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import rsa</span><br><span class="line">d=int(gmpy2.invert(e,(p-1)*(q-1)))</span><br><span class="line">Rsa=rsa.PrivateKey(n,e,d,p,q)</span><br><span class="line">with open(&#x27;flag_encry1&#x27;,&#x27;rb&#x27;) as f:</span><br><span class="line">     cipher1=f.read()</span><br><span class="line">     print(rsa.decrypt(cipher1,Rsa))</span><br></pre></td></tr></table></figure>
<p>flag:<code>flag&#123;You_Know_0p3u55I&#125;</code></p>
<h3 id="watevrCTF-2019-Swedish-RSA"><a href="#watevrCTF-2019-Swedish-RSA" class="headerlink" title="[watevrCTF 2019]Swedish RSA"></a>[watevrCTF 2019]Swedish RSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">flag = bytearray(raw_input())</span><br><span class="line">flag = list(flag)</span><br><span class="line">length = len(flag)</span><br><span class="line">bits = 16</span><br><span class="line"></span><br><span class="line">## Prime for Finite Field.</span><br><span class="line">p = random_prime(2^bits-1, False, 2^(bits-1))</span><br><span class="line"></span><br><span class="line">file_out = open(&quot;downloads/polynomial_rsa.txt&quot;, &quot;w&quot;)</span><br><span class="line">file_out.write(&quot;Prime: &quot; + str(p) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">## Univariate Polynomial Ring in y over Finite Field of size p</span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line"></span><br><span class="line">## Analogous to the primes in Z</span><br><span class="line">def gen_irreducable_poly(deg):</span><br><span class="line">    while True:</span><br><span class="line">        out = R.random_element(degree=deg)</span><br><span class="line">        if out.is_irreducible():</span><br><span class="line">            return out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Polynomial &quot;primes&quot;</span><br><span class="line">P = gen_irreducable_poly(ZZ.random_element(length, 2*length))</span><br><span class="line">Q = gen_irreducable_poly(ZZ.random_element(length, 2*length))</span><br><span class="line"></span><br><span class="line">## Public exponent key</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">## Modulus</span><br><span class="line">N = P*Q</span><br><span class="line">file_out.write(&quot;Modulus: &quot; + str(N) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line"></span><br><span class="line">## Encrypt</span><br><span class="line">m = S(flag)</span><br><span class="line">c = m^e</span><br><span class="line"></span><br><span class="line">file_out.write(&quot;Ciphertext: &quot; + str(c))</span><br><span class="line">file_out.close()</span><br></pre></td></tr></table></figure>
<hr>
<p>将传统 RSA 中的 p和q 用多项式来替代</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">传统欧拉函数：对于正整数n，欧拉函数是小于等于n的数中与n互质的数的个数。</span><br><span class="line">多项式欧拉函数：对于多项式P(y)来讲，欧拉函数phi(P(y))表示所有不高于P(y)幂级的环内所有多项式中，与P(y)无（除1以外）公因式的其他多项式的个数。</span><br></pre></td></tr></table></figure>
<p>经过 <code>is_irreducible</code> 函数的判断，可以得知 $P(y)$ 是不可约多项式，所以 $\phi(P(y))=43753^{degree()}-1$</p>
<p>$degree()$ 就是多项式的最高项指数</p>
<p>信息是多项式形式的，明文的每个字符都转化成数值，作为多项式上的系数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">P=43753</span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(P))</span><br><span class="line">N=</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line">C=</span><br><span class="line">p,q = N.factor()</span><br><span class="line">p,q = p[0],q[0]</span><br><span class="line">phi=(pow(P,65)-1)*(pow(P,112)-1)</span><br><span class="line">e = 65537</span><br><span class="line">d = inverse_mod(e,phi)</span><br><span class="line">m = C^d</span><br><span class="line">print(&quot;&quot;.join([chr(c) for c in m.list()]))</span><br></pre></td></tr></table></figure>
<p>flag<code>flag&#123;RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro&#125;</code></p>
<h3 id="watevrCTF-2019-ECC-RSA"><a href="#watevrCTF-2019-ECC-RSA" class="headerlink" title="[watevrCTF 2019]ECC-RSA"></a>[watevrCTF 2019]ECC-RSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from fastecdsa.curve import P521 as Curve</span><br><span class="line">from fastecdsa.point import Point</span><br><span class="line">from Crypto.Util.number import bytes_to_long, isPrime</span><br><span class="line">from os import urandom</span><br><span class="line">from random import getrandbits</span><br><span class="line"></span><br><span class="line">def gen_rsa_primes(G):</span><br><span class="line">	urand = bytes_to_long(urandom(521//8))</span><br><span class="line">	while True:</span><br><span class="line">		s = getrandbits(521) ^ urand</span><br><span class="line"></span><br><span class="line">		Q = s*G</span><br><span class="line">		if isPrime(Q.x) and isPrime(Q.y):</span><br><span class="line">			print(&quot;ECC Private key:&quot;, hex(s))</span><br><span class="line">			print(&quot;RSA primes:&quot;, hex(Q.x), hex(Q.y))</span><br><span class="line">			print(&quot;Modulo:&quot;, hex(Q.x * Q.y))</span><br><span class="line">			return (Q.x, Q.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = int.from_bytes(input(), byteorder=&quot;big&quot;)</span><br><span class="line"></span><br><span class="line">ecc_p = Curve.p</span><br><span class="line">a = Curve.a</span><br><span class="line">b = Curve.b</span><br><span class="line"></span><br><span class="line">Gx = Curve.gx</span><br><span class="line">Gy = Curve.gy</span><br><span class="line">G = Point(Gx, Gy, curve=Curve)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = 0x10001</span><br><span class="line">p, q = gen_rsa_primes(G)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_out = open(&quot;downloads/ecc-rsa.txt&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line">file_out.write(&quot;ECC Curve Prime: &quot; + hex(ecc_p) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Curve a: &quot; + hex(a) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Curve b: &quot; + hex(b) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Gx: &quot; + hex(Gx) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Gy: &quot; + hex(Gy) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">file_out.write(&quot;e: &quot; + hex(e) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;p * q: &quot; + hex(n) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">c = pow(flag, e, n)</span><br><span class="line">file_out.write(&quot;ciphertext: &quot; + hex(c) + &quot;\n&quot;)</span><br></pre></td></tr></table></figure>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://coperlm.github.io">coperlm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://coperlm.github.io/2024/06/06/BUUCTF-crypto-wp/">https://coperlm.github.io/2024/06/06/BUUCTF-crypto-wp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://coperlm.github.io" target="_blank">coperlm's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cryptoCTF/">cryptoCTF</a><a class="post-meta__tags" href="/tags/%E5%B8%B8%E9%A9%BB/">常驻</a></div><div class="post-share"><div class="social-share" data-image="/img/(34).gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/06/03/%E6%95%B0%E8%AE%BA%E5%B0%8F%E8%8A%9D%E5%A3%AB/" title="数论小芝士"><img class="cover" src="/img/(24).gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数论小芝士</div></div><div class="info-2"><div class="info-item-1">欧拉定理：https://oi-wiki.org/math/number-theory/fermat/  123456789101112131415#[LitCTF 2023]Eulerfrom Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p*qc = pow(m,n-p-q+3,n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&quot;&quot;&quot;n = c = &quot;&quot;&quot; $phi = n-p-q+1$，故 $c=m^{phi+2} mod \ n$ ，由欧拉定理可得 $c^{phi}\equiv 1 \ mod n $ 则  $c\equiv m^{2} mod \ n $ 直接开根即可 1234import gmpy2from...</div></div></div></a><a class="pagination-related" href="/2024/08/05/Codeforces-Round-963-Div-2-%E9%A2%98%E8%A7%A3/" title="Codeforces Round 963 (Div. 2)题解"><img class="cover" src="/img/(86).gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Codeforces Round 963 (Div. 2)题解</div></div><div class="info-2"><div class="info-item-1">题目链接 本场比赛应该算是今年我打的第一场算法竞赛，也是NOIP2021结束之后难得发挥出来的比赛。ABC都是比较简单的题，D是二分+dp，比较难想 E最终还是不会，疑似是一个高级dp  A.Question Marks 观察样例就能打出来 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;signed main()&#123;    int t;cin &gt;&gt; t;    while( t -- )&#123;        string s;int n;cin &gt;&gt; n;cin &gt;&gt; s;        int a , b , c , d , e;a = b = c = d = e = 0;        for(int i = 0;i &lt; s.length();i ++)&#123;            if( s[i] == &#x27;A&#x27; ) a ++;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/05/CRYTPO-24-8%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" title="CRYTPO 24.8第一周刷题记录"><img class="cover" src="/img/(51).gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">CRYTPO 24.8第一周刷题记录</div></div><div class="info-2"><div class="info-item-1">[SWPUCTF 2021 新生赛]crypto3 123456789101112131415161718192021from gmpy2 import *from Crypto.Util.number import *flag  = &#x27;******************&#x27;p = getPrime(512)q = getPrime(512)m1 = bytes_to_long(bytes(flag.encode()))n = p*qflag1 = pow(m1,p,n)flag2 = pow(m1,q,n)print(&#x27;flag1= &#x27;+str(flag1))print(&#x27;flag2= &#x27;+str(flag2))print(&#x27;n= &#x27;+str(n))#flag1=...</div></div></div></a><a class="pagination-related" href="/2024/08/21/MoeCTF2024wp/" title="MoeCTF2024wp"><img class="cover" src="/img/(6).gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-21</div><div class="info-item-2">MoeCTF2024wp</div></div><div class="info-2"><div class="info-item-1">CRYPTO 现代密码学入门指北123456789101112131415161718from Crypto.Util.number import bytes_to_long, getPrimefrom secret import flagp = getPrime(128)q = getPrime(128)n = p*qe = 65537m = bytes_to_long(flag)c = pow(m, e, n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;p = &#123;p&#125;&quot;)print(f&quot;q = &#123;q&#125;&quot;)print(f&quot;c = &#123;c&#125;&quot;)&#x27;&#x27;&#x27;n = 40600296529065757616876034307502386207424439675894291036278463517602256790833p =...</div></div></div></a><a class="pagination-related" href="/2024/09/24/buuoj%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6wp/" title="buuoj古典密码学wp"><img class="cover" src="/img/(34).gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-24</div><div class="info-item-2">buuoj古典密码学wp</div></div><div class="info-2"><div class="info-item-1">此博客用于整理，之前做过的古典密码学题目 之前存储于本地，今天移植到博客中，后续不再在此页面更新 分级十分的混乱，之后有缘再改吧（逃  古典密码学  Linux python 很重要 Bugku 实验吧（现在没了） 南邮网络攻防训练平台（现在也没了） 密码学的三个阶段   古典密码（1949以前），复杂度不高，安全性地，具有艺术性  近代密码（1949-1975），计算机诞生，加密算法在复杂程度和安全性上得到了提升  现代密码（1976至今），美国密码学专家Diffie和Hellman在1976年提出公开密钥密码体制概念（非对称制加密），密码学有了全新的方向  古典密码学：  涉及数学问题较少 很容易被破解，但是设计原理和分析方法对理解设计分析现代密码有帮助 主要分为：替代和置换 强化python脚本编写能力，尽力讲大多数加密方法都能写出破解脚本 MD5暴力破解以及算法逆向  键盘加密  键盘布局加密  通常给出一堆无意义的字符，但是在键盘上比划一下就能拼出相应的字符 可以划归脑洞题的范围 键盘坐标加密  bye 对应的密文是 35 16...</div></div></div></a><a class="pagination-related" href="/2024/05/23/install-crypto-in-sage-of-wsl/" title="install crypto in sage of wsl"><img class="cover" src="/img/(70).gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="info-item-2">install crypto in sage of wsl</div></div><div class="info-2"><div class="info-item-1">When I input sudo -pip install pycryptodome  It output 12345678910111213141516171819202122root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper# python3 -m pip install --user pipxerror: externally-managed-environment× This environment is externally managed╰─&gt; To install Python packages system-wide, try apt install    python3-xyz, where xyz is the package you are trying to    install.        If you wish to install a non-Debian-packaged Python package,    create a virtual environment using python3 -m...</div></div></div></a><a class="pagination-related" href="/2024/09/23/%E5%85%B3%E4%BA%8E%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="关于维纳攻击的学习总结"><img class="cover" src="/img/(75).gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">关于维纳攻击的学习总结</div></div><div class="info-2"><div class="info-item-1">嘻嘻，还没开始写 参考资料：https://zhuanlan.zhihu.com/p/400818185 </div></div></div></a><a class="pagination-related" href="/2024/06/03/%E6%95%B0%E8%AE%BA%E5%B0%8F%E8%8A%9D%E5%A3%AB/" title="数论小芝士"><img class="cover" src="/img/(24).gif" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="info-item-2">数论小芝士</div></div><div class="info-2"><div class="info-item-1">欧拉定理：https://oi-wiki.org/math/number-theory/fermat/  123456789101112131415#[LitCTF 2023]Eulerfrom Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p*qc = pow(m,n-p-q+3,n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&quot;&quot;&quot;n = c = &quot;&quot;&quot; $phi = n-p-q+1$，故 $c=m^{phi+2} mod \ n$ ，由欧拉定理可得 $c^{phi}\equiv 1 \ mod n $ 则  $c\equiv m^{2} mod \ n $ 直接开根即可 1234import gmpy2from...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/nl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">coperlm</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/coperlm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/coperlm" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/coperlm@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">刚new的博客，还没完善好，图片什么的不能显示</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#NewStarCTF-2023-%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93-Rabin%E2%80%99s-RSA"><span class="toc-number">1.</span> <span class="toc-text">[NewStarCTF 2023 公开赛道]Rabin’s RSA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UNFIXED"><span class="toc-number"></span> <span class="toc-text">UNFIXED</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#b01lers2020-safety-in-numbers"><span class="toc-number">1.</span> <span class="toc-text">[b01lers2020]safety_in_numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AFCTF2018-%E4%BD%A0%E5%90%AC%E8%BF%87%E4%B8%80%E6%AC%A1%E4%B8%80%E5%AF%86%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">[AFCTF2018]你听过一次一密么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NewStarCTF-2023-%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93-babyaes"><span class="toc-number">3.</span> <span class="toc-text">[NewStarCTF 2023 公开赛道]babyaes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QCTF2018-Xman-RSA"><span class="toc-number">4.</span> <span class="toc-text">[QCTF2018]Xman-RSA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%8A%E5%9F%8E%E6%9D%AF-2020-RRRRRRRSA"><span class="toc-number">5.</span> <span class="toc-text">[羊城杯 2020]RRRRRRRSA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UTCTF2020-OTP"><span class="toc-number">6.</span> <span class="toc-text">[UTCTF2020]OTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B-babyAES"><span class="toc-number">7.</span> <span class="toc-text">[Dest0g3 520迎新赛]babyAES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020-crypto-des"><span class="toc-number">8.</span> <span class="toc-text">[ACTF新生赛2020]crypto-des</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AFCTF2018-One-Secret-Two-encryption"><span class="toc-number">9.</span> <span class="toc-text">[AFCTF2018]One Secret, Two encryption</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watevrCTF-2019-Swedish-RSA"><span class="toc-number">10.</span> <span class="toc-text">[watevrCTF 2019]Swedish RSA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watevrCTF-2019-ECC-RSA"><span class="toc-number">11.</span> <span class="toc-text">[watevrCTF 2019]ECC-RSA</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/02/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FTEE%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4/" title="关于分布式TEE的一点头脑风暴"><img src="/img/(40).gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于分布式TEE的一点头脑风暴"/></a><div class="content"><a class="title" href="/2025/07/02/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FTEE%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4/" title="关于分布式TEE的一点头脑风暴">关于分布式TEE的一点头脑风暴</a><time datetime="2025-07-02T02:43:59.000Z" title="发表于 2025-07-02 10:43:59">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/22/%E9%AB%98%E6%95%B0%E4%B8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="高数下学习笔记"><img src="/img/(57).gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高数下学习笔记"/></a><div class="content"><a class="title" href="/2025/06/22/%E9%AB%98%E6%95%B0%E4%B8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="高数下学习笔记">高数下学习笔记</a><time datetime="2025-06-22T03:32:43.000Z" title="发表于 2025-06-22 11:32:43">2025-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/%E6%95%B0%E6%8D%AE%E5%BA%932025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/" title="数据库2025期末考试重点"><img src="/img/(3).gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库2025期末考试重点"/></a><div class="content"><a class="title" href="/2025/06/17/%E6%95%B0%E6%8D%AE%E5%BA%932025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/" title="数据库2025期末考试重点">数据库2025期末考试重点</a><time datetime="2025-06-17T06:52:32.000Z" title="发表于 2025-06-17 14:52:32">2025-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/" title="操作系统2025期末考试重点"><img src="/img/(34).gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统2025期末考试重点"/></a><div class="content"><a class="title" href="/2025/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/" title="操作系统2025期末考试重点">操作系统2025期末考试重点</a><time datetime="2025-06-17T06:18:36.000Z" title="发表于 2025-06-17 14:18:36">2025-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A62025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/" title="现代密码学2025期末考试重点"><img src="/img/(31).gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现代密码学2025期末考试重点"/></a><div class="content"><a class="title" href="/2025/06/17/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A62025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/" title="现代密码学2025期末考试重点">现代密码学2025期末考试重点</a><time datetime="2025-06-17T05:58:13.000Z" title="发表于 2025-06-17 13:58:13">2025-06-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By coperlm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>