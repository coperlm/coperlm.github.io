<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024.11.13组会</title>
    <url>/2024/11/13/2024-11-13%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88deb2614f28e80f008bc2b112134b341b269ac033ff42f7078e7d01a084c3769a0cb2063eaead925b8aa04d900019bdd5dfa7fe379d5495bb9baa52c0410b4fab87e4eed009db153f2d6bac4ed1734734ea4b08fd37599b30d983f51893ce484b97d40a16035ae00c256444987677f23777d3dad6a27f8c8e8f4041b3f8c0c3efeb400621fec5ce330c321ff8950ee04ca3ae56b77f62fa41f626740356268a8a1f75fe8a69ac974e7ba020368d3918583f05d86b9c5ace613ae4e7401f53adc6712ef8b3719f68cd068d716e4ee8535b2efea5297b6cb3dcb1462bb34ff9f0cf4fc148fd6012e68138f2592527c65da13c4aba8f550a4ed071ad6341791afbdc58dd4470b71cfd6643c3a2838a57e412b5aa0e456ce83e8c0bd2bdfc720529b87c8b37b42754aa01a117b90c6ecc50ab6a3d9ce8e0c699e352722ab4366d218c4fda666075414b235e9764a0fbbc3b6a9c40007f697361b42607175cc415baad86cba56dbc3ba11fa1c760d7932a3b3fc0054b0ed450d7aa94ce3a8fa332d11002bf7d3824b992af0a085decd53e7999cc2d2e6c1930f811ae7168f9773de1ac711cf177e88b291867dea6ce7db89ad6b4b291a5d11b8f067d8ebc1efd685c49463fdcff5f48cebf3d67d0f2e1c8654ed0
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>meetings</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.10.30组会</title>
    <url>/2024/10/30/2024-10-30%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de9e961fa3e70fbc1ff6cba48e977e425d6990bac9e6f428a573d21a80577428175b2d7a167dd0c28ad1052dc69cff23ec7db1feec24acf3433122a642ede696fac1c18c6879961e8735a0f0eca93fa72cad4ad3e4d1929d16df31ab82d34972d0f3b44cdb30dd51d690bbdab84c1aff4dccbb6b17f5844d1306c5ae56c5cd20b5fba6d958ab415358cb377440debec707f13609b4fa0d179dc789b77dcfe509dfcc605d2cd9c59e5e36b22bcb5aadd720c6de42212d2ca5ed9f69d6c34654ffe4e835500e8becdac2933f38235fb1cfe1f200722819020076a43dfee15a140108941fe0750ac59d26f28987d416d3fac74180cb123bd84a8cfde43529efd7b641d4984f24d4d0420232023070393e1dbf782b66c51631447182d0189af789c6fa904c81a4dea27a5c9211e08130cd20e51766a1f3436d1439da814b72711ab1dcc452b83f4ffa994dbf2d72b160da2432c0ea12d44fa33a819f74be7d3747de8cf70e11da80de0a3b7e7de4a23a7758aee46514ec614102af43dff4a290b644509aa096f09bceea0879b28d02bdb117db990b64a8c399ad863585015aeb1e32aeb228663aeb827732027fb3bb46c6ee1a7aab47fdc614fe48cb2b4c53b1628f470ebc443a24d83b0be5ce73fbbe5cf15d40116bf3f72513c8e953354b92caee2e335dda837cca3c0bba06d89a6df8487b77666356d62288b49c460c475a1a053e84f997c0ba23a4149f6c0c06bac30b5f4182d47242d39a9a92b25dcb6cc1ba4d891aef34279e240181be0d16073de3f71e2aebe1b277794ff4bcdae4f0de06aaa3016fa73da7a1886955f814dd17d86504a5e2df60b9d21628742af7c66bd8a0504617c7b72b504bc9152d123f49d5e8f35a6acff0de3d688222cd81e1f69ad930531c00f762ab35bc336c31009eea86a79e0cb8ba3690f9bd1f6e79bb8bf2f8a15d9bb2e92953600b6d6731072515056a59f82c43dc2c37c02aa26533a3ac6058d0c350d910fa85ded6824de7001e96c116df99e222329408f4ce4b957e9727035f1d4e007639a9b01f7c925229785c8b1808ef3142b2ed283069e67cf83277968dc1d9faa764604e7a1825d558322addde72561f3118ad4ad252db319ddbd451b6313810ff3e3bb5b37ec1bdb29f6f
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>meetings</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.10.20NISA百团题目题解</title>
    <url>/2024/10/20/2024-10-20NISA%E7%99%BE%E5%9B%A2%E9%A2%98%E7%9B%AE%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[三道挺有意思的小题目，记录一下

第一题题目描述：说反话
题解：
翻转字符串即可（大雾），时间复杂度是严格线性（大大雾）
第二题题目描述：挑战者选择16/17/18张卡片和先/后手，每方每次可以掀开1/2/3张卡片；挑战者的目标是让敌手掀开最后一张卡牌
题解：
如果敌手掀开最后一张牌（即达成挑战目标），则必然最终只剩一张牌（如果剩余的牌数多于1张，则敌手可以掀开一张，这时挑战者并不会达到目标）
为了使敌手掀开最后一张牌，则只需保留一张牌，即保证挑战者掀开牌之后，剩余的牌数为4k+1即可，其中k为非负整数
在以上情况下，每一轮（指双方操作）后掀开四张卡牌即可保证挑战者一定获胜
看不懂？直接运行以下代码体验一下吧
直接使用devcpp运行以下代码即可，记得拓展名是cpp哦
#include&lt;iostream&gt;using namespace std;int n;bool check( int x )&#123;    if( x == 1 || x == 2 || x == 3 ) return 1;    cout &lt;&lt; &quot;请输入1/2/3哦，不要输入别的数字喵&quot; &lt;&lt; endl;    return 0;&#125;signed main()&#123;    INIT:;    cout &lt;&lt; &quot;请输入总牌数：(n=16/17/18)&quot;;    RST:;    cin &gt;&gt; n;    if( n != 16 &amp;&amp; n != 17 &amp;&amp; n != 18 )&#123;        cout &lt;&lt; &quot;输入的数据不合法，请重新输入&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;        goto INIT;    &#125;    if( n == 17 )&#123;        cout &lt;&lt; &quot;你长得好看，让你先手&quot; &lt;&lt; endl;        N17:;        int sum = 17 , a;        while( sum!=1 )&#123;            cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;请输入你掀开的数量：&quot;;            cin &gt;&gt; a;            if( !check(a) ) continue;            cout &lt;&lt; &quot;好的，这次我掀开的数量是：&quot; &lt;&lt; 4-a &lt;&lt; endl;            sum -= 4;            cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; sum &lt;&lt; endl;        &#125;    &#125;    else if( n == 16 )&#123;        cout &lt;&lt; &quot;我长得漂亮，让我先手&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;我掀开的数量是：&quot; &lt;&lt; 3 &lt;&lt; endl;        cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; 13 &lt;&lt; endl;        int sum = 13 , a;        while( sum!=1 )&#123;            cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;请输入你掀开的数量：&quot;;            cin &gt;&gt; a;            if( !check(a) ) continue;            cout &lt;&lt; &quot;好的，我掀开的数量是：&quot; &lt;&lt; 4-a &lt;&lt; endl;            sum -= 4;            cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; sum &lt;&lt; endl;        &#125;    &#125;    else&#123;        cout &lt;&lt; &quot;我长得漂亮，让我先手&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;我掀开的数量是：&quot; &lt;&lt; 1 &lt;&lt; endl;        cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; 17 &lt;&lt; endl;        goto N17;    &#125;    cout &lt;&lt; &quot;现在只剩下一张牌了，到你掀了，你失败了（嘻嘻）&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;再来一把？这次n是多少你说了算，但是先后手···嘿嘿······&quot; &lt;&lt; endl;    goto RST;    return 0;&#125;
结论：
17张时候，挑战者后手；16或18张时，挑战者先手
具体策略如上，此题解仅讨论必胜情况
第三题问题描述：数桥问题
题解：
其实这个时间复杂度，（在保证有解的情况下）枚举一下大概率也能出来了，除非因为没有橡皮导致图越画越乱最终看不清楚（
使用贪心思想时间复杂度为O(N*M)，其中N是点的数量，M是每个点尝试的边的数量
ai给出的贪心代码，仅供参考
#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 定义点结构struct Point &#123;    int x, y; // 点的坐标    int degree; // 点的边权（需要连接的边数）&#125;;// 定义一个方向数组，表示右、下int dx[] = &#123;1, 0&#125;; // 横向和竖向（x+1, y）表示右边，(x, y+1)表示下方int dy[] = &#123;0, 1&#125;;// 检查是否可以在(x1, y1)和(x2, y2)之间连接边bool canConnect(int x1, int y1, int x2, int y2, vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    // 确保(x2, y2)在图的范围内，且没有交叉边    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= grid.size() || y2 &gt;= grid[0].size()) return false;    if (grid[x1][y1] || grid[x2][y2]) return false;    return true;&#125;// 主函数：连接点的边，确保边不交叉void connectPoints(vector&lt;Point&gt;&amp; points, int n, int m) &#123;    // 创建一个网格表示是否有边（或点）    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));    // 遍历所有点    for (auto&amp; p : points) &#123;        int x = p.x, y = p.y, degree = p.degree;        grid[x][y] = 1; // 将该点标记为存在                // 尝试为该点连接degree条边        for (int i = 0; i &lt; degree; ++i) &#123;            for (int d = 0; d &lt; 2; ++d) &#123; // 遍历两个方向（右和下）                int nx = x + dx[d];                int ny = y + dy[d];                if (canConnect(x, y, nx, ny, grid)) &#123;                    grid[nx][ny] = 1; // 连接边并标记                    break; // 连接成功，退出当前方向的尝试                &#125;            &#125;        &#125;    &#125;&#125;int main() &#123;    int n = 5, m = 5; // 网格大小    vector&lt;Point&gt; points = &#123;        &#123;0, 0, 2&#125;, // (x, y, 边权)        &#123;2, 1, 1&#125;,        &#123;3, 4, 3&#125;,    &#125;;    connectPoints(points, n, m);    return 0;&#125;
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.9.20南洋理工密码学报告 观后总结</title>
    <url>/2024/09/20/2024-9-20%E5%8D%97%E6%B4%8B%E7%90%86%E5%B7%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%A5%E5%91%8A-%E8%A7%82%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de055a65958d0c135d9dfb3cf670e20830146cd7e756c05d5ad3c67ee1eb7e2c3e81b8182e354a5a8d8fcb20a51bb66205a40d307ce0943a4da73921a2e9a666e1804f25337b6def6e5a22369804cdd5e40503a8dca1e63c22a6a843eaa62eefa348402a7d6fe247897a502529e8619919fa448389f3a6bfc8f54441fefd6c88e4a8c1b1f73f84b8f189e7f9206a6249ca2b345289d566da5ca0626e89cf51d0b835bc2635e242ed77e37030ca4e57b869052ffe5e1deb5ee14a02ab72291faebc3061f35d5569438cc0eecdd0be7c0772ff79563875122db926928d7b583ed258a4b7a8ac28bf6694923c7c9c8ffc8210edcd6c7e101f9505591e65b73897b19a39c3514100c66e2060ef1a85ac6dd7014129b0400f88d0332a06e66c941e7fdf7651ee0573fce533207954fc9e47de7dc4befcfdff79587497c392961ed9645d735a1b2a4af4e73158b4f9e7c1d0196c5e1b31b73c4119bbdaca25effab6c31d0aa1fa8d04991ae55a33305cf98c93ca788ba2a56cce3fd64b0b1f058efbde5bc1050d3a1eaad6a61c3fa04d89092a5ecd90eeb4870620650f3d3957211714978e1f48c575c5902bade0d2673b43b68e75161c479df3947686654d7039140f183ed10518c6954b18aad7d41533bcf035d13378a8515528fb1bb0e45da004eb9699704ecdd73eccd2131d2968c1e0253e5fee99c4266a5c9a919a99710b984dda0ab4365bf4f4384c603ebf77b4d7438502be264902b4e23474aed8282e3cc780300607691f956a4ab8b607c04b455ba856c01c2cbbf06fd0f63f2f2e4d0e59d2e37bc59429f82973448d4c497101c9089704952c6971afdc650dfe0a1bcb32011d973212027c71606a666f8fcd127e6ef3b893e58bbf4a5e3c832cf8c576330a4faad195a09c871b85144f811ccf016dd3f1a71c8a922e19ccbf350092cd7d17bf4450ac321c3208427617b7466a29ed8b5e733dcd25a58c5bfaa8aac78be72d63b31649ff0fb7d851df3d8210b75d7f2671ffd4b254a494f66076cc2a689888a149cd72f2cc268190b32eb601b7f50d6c5c5071eecfc2657f1b17242dc5e969fb567bd5b42e541a3e6b6f707352e1781f993e247bc72f220093f072791b8fae3e3101f80079ff9f419da8bdc924d2b3bd451dee84f86191225f4620709241cf8d0ce9cd2c1fdb22549dc84b1c976e80693343fc473e20eae11fbd898e01fdaabb4a2a19159e6ca4303ed1cfe62f79ec8877eb26f542482f0687753989c72f666cfb5e2a216b8bcbcee278c146db647f6b9e941428b8de019efefbad2ef12df11a6bbfe9edb246a52f7d11cea6d0b98b0e61bf400c7f99788b96b147c79cccb6f14dda65666d2036fc5408ca22ae0d3fe1eb22e16944ec82b06f27b97d5ed25b7b9050004cac24c6beff0b075b50ed575f33b1faa3a19e72b1e5314cef9ebe9d0e92d0b4994310ae031ef86cec90c4b77788e9edf5b9ba55c0d494d006229379a392b221d7ecd1f99a09806b0cce8a17ff395caeba2f6cf46d62f4b73e7b8ef4f83e0fa6db8bb70bb7d06dc9b45abd76eda47f8327015ad05162d0352d928f105176900571bd07505453a92ad57ef45c5f95860ecadc1f50d5bc14af441919d9d1c36fe77c54bd2d47f6ffb81c209ca20831a561101373fbdf8cbe898b203d4daa87def53e7bf23ce1b0c927e7a9e6c56193dd14d47271b6b1fb65a1492d0cf94f7eaa86b713137f51190bae5f83b730fb682367288e870d62e57c55d98a8bcb4973bc39c4375c5854907bd361e36b11ccfac2885f2bef8b09df5b2d88e422e9b373eceb06b32df30bde61f8e4c46929096bb1b962c0f17d83e579e7df668ad62d49f3b0ed13a4053686684308e38a2c2046f4d6b72e4630d07871edb87e73164eef2e80a49bcc4152c3666f780629c4140afd715df67f17da688d6f278d95ca2657640623846aed7c7eb24117708620c0d63dd895dae9902777385d81ae7a41a7d2a80655977651ec23b5b95cac14c590299a8bc03a67a88f903668fbfb555058fe3a9ed088054d2f6291d2794cac1f22a39b69b864d564f6a1e86495d3e6bd350b9b811150e22cb47dc69ccc5e0561d8aa6cadef53722e50dd43743729ee83f5b8328b32b277b3ada26c669a511cfcf1bad8567f82bfd21a124e9b5b102768b73c646448542661953d01f1dd638e86dcd7e119d6d447358cb012534454d9e262b77b7043a58b618ea6fa2f8ab585c2cad05687ca32bf243ace756c4dc7e6a96d36c0bb649a27d46a1810d00c86e5a4a17c42e9d95f2d9702a39d44a57c35e9d5c3cc330f72d0f02247ecf9e6a093e9754e7c6d2bd19e53e31c2a98166ede6c9fba2e44374ec34ba50b481ebf6c165f66cfdf1174a062b3e091bf3e036065aaa00c495997a3883db9997f16add2a7c297e6c88e01fe48a5d2c8e845bda4f5df6614238dac9f1bff9810e0232b474024bc4a6fa186ef3c45872c273aa54d039039b70f2241d67fe88b56360b289168ed4e1c7682aa4c800492e53fa7064a291f7f1412db077b3934b7b2904dde197c2569161cc7fe33da1fba9b1831a4826451210d255346fbcce1864048c2263d31aa5ccab5177ad167b9937d2802002d03f3204bbdeeb66ec25f1ed2e073bbe3fe1970465f41e0348a4b499ab753ad664770f511d5603805c9758c9b799b14c774fee2bf4b2e5e7469ec22be2bc42278738a333a21248c81e5648c2b250cad383b3ea06609de4e426cf6c3c0a08aed01c4d22c91d98689881dcd208f5ae2722ca7c135a17a2e2c34987ce43d017ccea35beb029756fb211129bfbc46f7f1930d78e876be3491e1d80eb7d3c329d65d5a9156d15177af0e121bbaaa727a70f213ab680fa82071e9e5a857bc6b0db3c231375bd5b1a5ddb065fed739c4f610c8a6c6750d0bbdcffbc4cc29b51a29c6e27a936fd87da1a9d273e2098e50def6d588d78f9e497524520e1b460c98326b8afe64e9cbc56a5357bbc71dd775135e39cc52b659faf4a248ef8571fcd60014c4f27746e830704159ea7151dba648ea6566255132e7fb64a532b4589b8566a18ff62f162433e877aebb60c3f56d4eef7033c9ae23300a50bc3acbea87abf3cdc00e1a42338c82113831cbb1f47c67ed4e8f26388f89acbb2f597586a652b3c7c5d074572e2139a3f96a079ef42e853dc86bc9176dea40cbb2c5a9448e24d116afdc60ba96630c0372ae2f2590bc7eaa4db53a35143f1c0185860923f060a8b086596e5a1ecedf71fa12ec0247ef4bd7a11a77d01d19d06bdcc54794a594a4f1cb07f437a3a510585ef30503a379092feb3bf730428deabb607fd5a271b8a73cf53177e7c5e0c7cc30ddc3e68d9efbe3da178221079d0e6121e673f721dfb85bbf8b1e8dbd21bab97fda541352e5bb39b4cc1ca62f9d352c670c3c25e33c80bca953a497388bec6df9b021a621742c81819fd83844b84ef3976df1b2aa141a980a47c8a5e853b28c93e515d314afc2aa9af71a0972506468e7ae39cdcd92b681dab47103b62f8a4bf536c92f6fe6ca8aa23b14b6147983b682aef10ee10ff5dd0c362592c4eeb2cfe6aa8157a693f40e54e218910c6ac3b2acf365637d8125385d39c51fabe57769afae11090cf43215aa263801ec5f207b9799fe480afa66233183e6e5ca7906a8f11b312b45370e4b15299ae301e79cfb672775017dd99c44a7e39f0f5eed9723c83f78247d53ce5cd1f33faa9fb00099798bb2b2d5f2308f1421b94533750f15f34ec1ed5accbf4062e569b2b3e91a3cf512195dd13b61324503a50da6dce92f8e0f46dad5fccc578279bb80b8cfd9d80698c7a30c20090c6c92a1c2f1c817267c99aa52d6c515421653182777810f09335c111f575cd2749ea7efca7778a91b2214fefc7815c19d77fa791a973fc036e0e9c8d6aad1c5962bb1addb7bb48e70ac220b53b161713620d8be5af889ddd7f9a0cb285d756abecbd245ff623de5762822467e26d8a75b680cb820cb2cfca491f8fa4032205c471ed9d0eaa4cfd644966e9cbe312109722cdc09b35fce318f2ec5847eec43d5445ef91b1b40a4fd23d1c17bc2690ed32e9846d839c8db9805bde917d74e92c683066342f4e407dc2c51e4beb91d610066b6c6418393a177fe48f3931e91643b1f4d3b71617752da6a115d62746da7f061a110538f
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>meetings</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.9.18组会</title>
    <url>/2024/09/19/2024.9.18%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88deb19e3a2bf4efd24e816d4e33bff4379def16261ea3be9e3ce1358a249e21448bf46da3c31892d87a95ecd3a4164f2273a0243be5d8677e2d4b5697275e6fab040f4b1f32b4bb94bd3156dda8d03ced86bf4b8e111dd0984937dc69790d37f27712ac32d379ed82292f523be970fd48be48a20044112e033b542dd6be34fecaf5032c699df269954f804b8a10e136350c7b6fd21dcd839c688f53f1cfe09051c5570e9fe4a27a2dbc8f97a3fb0c8b35adec2f488fbd07c4462142db2a3c6790f2941653880829f0c0bc7ae060dcb4ee51f0561b779d6b86db8247b8f6c2f76d7763dc58178a3cd7ce7215a29a27c748e270e989bc7a1ed9cf56bc677d3ecde7756434174198b4524c8c5c9d1241050aa851960614f0c8ae7ea014a2e582f7359af00ec589136f8b733e8c1cfd6a2bbccb0e8c3d32c92ac88437c8f5c9405c81ab80ece007e1c258876c3f0c8e3974910f19dce3d6e4edccc2f7b4bb2f2f1d21ee1c7dce95dbce4bb66b25b2c6e0647a8217a2d7445075a40abbf5688798b53e451fdcc6d7e034511211985c5fbe244d1b00e3c9061b9a242d9e2246e8e9881178d1423d6e2534881f5a3773d021a2ca377e63388ac31f4441d90144c1885348885cfe0912e16a612ee61aadfaa477e9b5828ea1328667b44363110fdb14d0055dc5297d50676d2798a09e199eea0902d9d68c9be17b3009999097004ad8a0d8094efd4e6c116ff0344ebd1b8fa1cde74f95e4f909aa9b05150f0758c746cb2652008043906aee8cc4b120a1af03230a4f6da8656e128e18fcd6c264fb9371eaf72ffe7e9af8b59378d370dbc30d3d0777fc3ad96a6293dc8ed8d6d53febf5688b09f8a6911022a678d627bd6f963d379a8bf10fde1580eab351c49f5ef4672946a5a21f91b1b50760a9dd79b92ea938f687141484d4685e7e2238d3990c06ab1d9e1bc75920207e9d9b7409812f1135685076be640f73814afd46c016ebf8a6fc5c8c0b9759709fd2eb589e1c93421c14fa1ce9f9a871fb4ada01e80b7e4aea17e509fe9b1243c511edc77a0589a4d16c9ea1092a2b3f0c2085ac8b4adb8c78ac35f635b70f991824ca94287e70220485fe386110f5f1d78dac48008c2f2ab7877ba538a6fa9d300f1b835286826a42c8e4c0ccdcd864825a7697f257eb1ee9428ed50367c6a9b061cfd381e3d833d8c09b4c5df67d9b56da47e7a9406d511502f67cbcc96ea100cc5f50a4fffa2764a33241440d65fe8972ec0133fea94e9e36a832a3c87477a49b78e49cf847ba7a5b0974d3d54ec0fdabd40fd149abfde4168f54416002fd8bc4951132b464737f87c5d6ccbc638eca76806b6ba5f21bed2714b4c7b6fdec890459e56393ea9f711e3bdaecc8eaaec1b3d4ab10f579d7b82cd8e7cf6502cd656484bdcc817fe2150c29d186b173d714238283b8ac6ba1a09b472e0aa885309fbe51827c72ea92ae4f3525484fcfb572cb8e1dbdc841e6f21d88a6062a7620fd50b7a53e4f595c8a8ec879587494ef46cd5a46e9b5b1e62cbe3d82d16860c18177ab2cb078242dc59654efe08db01482999ddc3c01778ae12f06ec5ca66d4d005e328209f0a3e0530155b2d758ed8f7aadec05886bdbe9764ec10498a214493bab63f624f24358e72014d7193515d0bdaab88bebcc765f10bb7a7ce3037cc4623aa5359f824236398308e66c664d0b111744b4e75228e826f990ad57362084dcbb1474953a7e1e1ec43d149991e0364f427cd76636ffa6640a34585984267c2c12702e1994cf8685fc78239cedff388eee6a352432e188c4f04cff39c999c0e0a55681fc4ac70d3518995a07228b6e95f6b23b1bd4a263b19c175753c3ef33b5c4eb7f6747f03ff38ef538e4d9d1159ca3055f21001a8e26bea62f78b4d67e80b71c4f450e13b4812b7d709244ed66a610d25f547c5711c398247c93f82c53656606365d753d9a4ab3e9fcafd9747233a9d622481e8a925130b18e0c77f79e75cf4de1a6fc6bfebf1a1555b138c456fa411ecdffd03bc9db4a4bccaad777605e07f3c9aa767103d975783f9682b60fc4448288fcc96002c19440b593f56b6dc34064c5324a57be3cca7cf362006d64a4dad8278a18b8f17a5fd162ea68d67f1517a100a42659ded39de64422e1208819a36f6cb52f423d179ed1a095f387289bf51bf1f21d6ed16049639cbcd7f0cb057c77d4eb4276478d88c13fe7a52307ee4df9f60c98724ad7ff920925d356973b1d6bf5307b734295a1d23d85d09b6fb16d52f7a24b3934be5c620108bcd947ec0c52bf22f2d63df438a7025bbb98506a923a945e11190cfe5c3f18529738c4222e0224762a06a5b3605c79d70b5f4a024bc749609297b7fc4b2b50a12937e0537691e4adb5360d34f44173d2814d847c2186dc72e498c934b589e7ad0d23c2c2f163906f011db2a5b5bab9ead6cd748c05ef4c8230ff930300289e60bcf91e89ef661f491344df1e61795d30c97629fcfaaeda5d9c4eaa47a86f2408c2a9834a7eae66cc1206401524b4a97b282fa9ca96c9857bc2c9a1aa9829000e4f7aad9a6953989b761d682f1c977d361f20aa3bfbe8e6537b6f880fe34e90bda13214e8bbf9eadaeb4ce1dc4c15f9aa8df3a45e1d0d64973db80131d6ba9988bf2036e0a64cb6fb9d0d89c4a5b30810083aeea67bfc24cecf92e7f0366eb4d3a70f07a498a592040613d719b4c240ac77e61708c66194d9a5bb75d3ddb5c52a67e8eab737d7ce656e2e18ef41f1c6c8c360a76698746b00aed00eba347bd9215939ac7162de6b7feb2947dbb31f6a3e2fb7b4a68b18b74242536313f10576f978cddb07f7e21bc96586c35a8250e33ee1a6d15eac093887127e413a7c668c5886cdfd1dbcb58fa7131245da05345417ed2319ab3f84d888406f18c09b3db6cfe966a855ab9ffc453941f96bee8a1037799888987215c772dfa42879e6a21b34771901e39f7481952d881b843f9c4a25e3627187752321d6533f13ba976438cbaf939e3795b23a75f795628684ac3274c74740cbfa01b5df4dfbf08ba62e5294a5ccdc79f4ceb03bcb6d001ce576fa8cd321468ebe9f734213d8ba419e4617d7e686ff521611a423d3f4f5d577
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>meetings</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.9.4组会</title>
    <url>/2024/09/02/2024.9.4%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de92ad2560fe55b7df0907fe8f65e151c4f966058b06bb0993b51554888ee09baa363f38e7e8a9582a46b0ddbf6ac336d456de408ec3ef598e0e125845657ab9b998344110f1a1004a4c153cad5880f567ee849d3d1f35c80f2a03d103986ac4c8aa2db69bba9d9dc1e4821c4a1113cd35e76532a7a1cf548b063dc46076181c34218a466c994d91e7e63a327e6085dd31b5ee97252844fd23d29d78c8c1859da1dd9848f47a531548fc00b0e0fa369488ae05ab8a23878b37af2a56edba3af9c605ff423e0f5b8fe07b5051ef2444f2232eb9539938825570887e1fead2c5eafc289f07f862a430013dec2025225d3ae2d61b43c9c748deb89a4a6306afb1ae02b7af4c30c83826a89528c529f035be834e6a29f7b21e193c67efc7df21a410ce3de9a795caf2e05aa4f747dce7d1aaca2791ce8fbda95ab7677499fb52744732e342cfdeb01fe3280eebe0cd05049323dee839d13d5cd789162ff6648a755ea9bede7b098261d4f81d83327893371ccf253289557c4769781d8490caffcd3b1384550723cf2da9aa1bec246bca51cd82165e8c5be4c694ba50bb128a0c8e98fee248eace180a2f1e1428c560e890aa0eae996851a37faeb717d9f00406ddd3ab72cfbadd130082d64d066ab4ed97eb37462a31d108d694212cf7f83b066b16ceb32c1616d75e6d0283406a1d67f528ed779a514f53fce66745b6402fcf376f2cd60c80e23c3186cf8240b5f1598178d2973f2fe574e6bdeedbe7b7c05be0aed3ba57d2f63c90da1c7c033652af313b91fbfc83f8305ef42b1144a64c321a26df5de159a8e2a62230d13ac6634794be4a18f8b1d76cfcf9bfaa18e877593007ca65c1a3729a27e5606b673c33769223a4a1d1a75dae84107ed3c94b60509eeb30a062cd39e9e9e0a10f53f5523e4fa4b3334385cd8adaa527c05a9619a57134f5222a657d31a04f1bdb76247d0cc30650cdb9ddd64c42fc3e9c25660fffbb838f1d832e00e0591ccc8e3b19db3f832be0b3633fd8938e5dcfe04a2f4baeb042eec14811d0af59e3984e0bfd5ec0789cafafdf69fc601142f88af67f56b62c0942a7a139e7359c25b33546841879ac22d5072f67dd65f2056073f728bef0866cefe6e1f93aa06f9ba3a8fddccbf4812fdf79406c5dfe6738bd0587e1950cfc9494c77945491ea93b6a598ac7b309128a5092d984823b6cc9e49be77385d53cfc41acf411b3c4ccaedef695134ffafc8329cdee1cea6811dcf22f1228c3807c61a9715750ef2d697df277e9de76f570434f7396fd0309e69319b6dafdf01b215fd78b9403fac1ff0d7a7c9a9ea43caf8e87444ee8dcf9c26a3496e7a1ef226857f4b1f344a89c13eac2a9aa30982097b7f4dda9faaab0b68bfe89b75df25d8a45d2dca985f6d2fd48fd2e4a2e6ff1af177e8b5559e6c22ca930fb2c5361fb809be82199626090bad661646314f3cee16b6b9342629dd1b55516592bdb61ae0dfe223db19b1dea8a1fe6fc02499d6c217d8cf5d5620269c3c1c2762e0a54653f5262550637f5a32ba9b0b4f552e4d6b8b39ee2cca563e0df3814b0ad6956021615e62b59fc1d8bed2e6cead27c0a7e1ccef8e05729a3f0466a70768ea93f3bf17080e9af6a7aa52466f3d7831988563f47cc2d44b3e074b332876a15c8a51c81c72f65ede33b64f30fb18a8ad9074382aa2065399083a9f0820d1adf63139ba6d40b7f2872ef81fd3ced0e8cbf1627829cb2fe6a0198cdccca2fe1828c23727a783de95b818b11cf22169a4716b2dbbca02f539e90a8745385152f4f5cd1f6b6d77c771158901e35d19dd75b03e595c36b447118b9ba0ddc06c5c79249764c6d407f2ab2f6f4aa4c7670e239e22f68f30c3dad0c72bbca3972b9ae0132279da97061f5e32ff79e4e8308dfe3d90dac86876e27a163f7389a5725f2542eb234696e7173776ba1986ec68f879ace316eaa3f26f320c6a9ded41369d3bbc3870f22f7aae1ced060b32ff991c3bf87f46e1113a0a4e60cfef358fd1d9a3d25a5173bc47fffebf8387f41022be0b948f886d3a3647cb92aaf17e1f53f3c38267ca5ab9fc3b8706ccaab4fbff7443d990c57e84acfa8e856641289b3bcf054b1e2a145a29aaa2b8fe793bd7f34d1fc6016b68f35ee3c958ad20ebc2b39f511477b207620a989bd1f62d2705d20d751ee30f40b529f621c661c5003fa010c96ae3a3ce4e820b00687e688a8e0ce4101a6d3981e3364d63ef03f578f60941dd10add450697fdc0b4d4f66de1e80fcdc197c90c45c357c850940ee4161d57601762a3a2ac81c49aa178727773bd43eb05b74769e27387268eca2457af9543f710514b62e3d78ea4db3cef7d9b6960c8efbbe1747c3100a8e11d6060dd0063aecffede174c7a846cdd74c7fb4ed2a47ff5977ab92ebaa395635d6130dc13bb11f5132f7c71fcdc0d688e02ae14cf47ccb2d7828ec7335516f348ab3f715873d0f99f9691dad4494fe6516ba903f178389a67231169b11e46fcfc7680884e9e06640907984b879c4dca446bfa4619fd254b31b2bbb2fdbcfda62dacea028e613ca0c01eb3388b48620688cf72fb45efdd85a925a2898da93df639203cb3888dcafb5958a04e112026272dab6cfa224292ffdcbfbf792dd71f343a9f26f67386c1464ce53483c74c895e9f81ab85bec79c2d8cb7d7c9953bc1e00c95e8534d9ccf75edcf3ace3d6c0ab23cf65575edfc5c8459c4b73370325a83af020dcc92474791a2ea277211a5386cc163ad91e865b2f1257cf3f1f0a43dfd2b69151ab030daa287354f987e64d18801ac2866ddf6a4bc8ba9ba43c2f3034eb4922e6a494a715013803968f1e4b1131d9602360be88f49981d80126ee8bf4b24d76ab6b4d936bd1872c4f7e1a4b35a1b038db37fe8b107ac34eda8b2f25552dd03f7dc5d29801a3b918c91a3a09b025e94ce58d3e858fd72c43d55e809fe741796733fce7fd50f357c81cca70c
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>meetings</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.9.11组会</title>
    <url>/2024/09/11/2024.9.11%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de7ac43174b2bb1ad06a11d61b739ea0073709999a7abd32e45bb6e9a37adb7657ceb36495f5c55a980bd4fb92793294a46c56fee9c2e0f25deca538e36c8e329d72963c09166eda1479d2acc20b4d7f28b0264000ba8ecf58060a5d37424302eeb71e65dc390d166624d53f53c9f29d95de84b9cf88abba066824834fd2bcee6cc77efe36bf9aa4835b6c8480b4a689d0859a5ba8b9647d58b39e618e53fe21696b730341183dee80b4600369c1546341da8a38272c47c38e8febfbc754224d3ef173e4366f687d60fb2ebd1f5ca7fbc7e907da4c78389cff266a4deaf02d0b249ee69e3a129b1d616cefb7aaee350bb3036e4aca4144d8e8444d00700ad0da9c85dfbf6ed7091d584a65f8c4ba5d6c99da0ec37221fd1b28ef51d63fd55a30a5feb4ea47cfb9e0e3c46596815fa78e2c39b4ce37e12c2424b18b0b6602bd85c2534d0073b79a4e0cfe9d555c91cc46863a08fdde2818ddc791b19ccc12cffbedcc22340af32c0a8713d9a86a5e62037133ef7d1bfa8cd323ea77e8b4fdf5a71832e078102bf481ccac5d361ed1324a86ca46bd276c208be41cd04197be4ecb48623814784202540d793081d1bd0af4459f755b571506b6f58fb716f39c9c1631182797dca2e88c1d2754e943ab57dd3f13a85d7540ad8b12719f60988116c6404f36b1729e02357721a2a522d8943cb8404419b4f9d3aeb1b3872e2675d5f06ea5bd058845b05c517f0890cddf2b23b4aff2cdfdadab8ee46c439917d0aeaf94c61a4e50454419a79c7e959133091d384a0849db745a1f27bc60b85b1cc0e105d9bc4d0588c646adc1a082513779440855d0c36d9e513d46f76b71fbc3d677706fabc7126d2a0685f28c41bd3465d2a8
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>组会记录</category>
      </categories>
      <tags>
        <tag>meetings</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年9月16日到9月22日周总结清单</title>
    <url>/2024/09/18/2024%E5%B9%B49%E6%9C%8816%E6%97%A5%E5%88%B09%E6%9C%8822%E6%97%A5%E5%91%A8%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de16933033ae19b391949c74dcef436d0c5b80c1104e8012a505401d83bdeb9353f14c5c9d398d48d98c534cb40f724fbf917700047c1e9f103b0f5c3e8203242d525d8f52f8707c87b6be5d94eba27099d629869925e5ab80bfe51adf959a6b3f75d7fb78cfd67142af658daa9c3b9ecf7ca644bb0e1b615bf6e49d41a8244d27c2ce87335a9ef31ce6adb0d2368b3e1c61861c6db853dde06aa5d245cf222f059a9b4224445bf5ba75f52aabc7849725488ab3681c349ebc11a67edb6e65223c602e48e4f4b2f8c33756da16f075da3120139ff56695e55f12564fc22041922f6c1e2b5016a51dae2045e347bb5ea156fec7d57f7092929050743e9e1149ed33e2e2d98a390118e38a7e39640bba4b2130ede1aba12e4e5c3105fcd0eab1860d088f9dbbc0802e84248ddb5bc4c40cba38a639ddd7df9498de53a804834a3054428b904bbb6c6bfcc1bbe9a88dbbefc0e34d3cd11a9ee2e791e1a9889bc85cac54fdb7c4bbc2e0d0c72ebd101ae57fc2e3cba5b14ed1dd0b3ca7c194ddd0843b0604d0b79b2338492c5fb32d4bacde821d89cc257d81a4057f49b04ae23ba038a3d065a6934f2c9b91e10157eda470690c6820432cc1fff2a919aac865ae2151b43dcb9b19c3e065684341b630267d4d56b99f6f1009d33a14dc2091feedea35442bd0499c777a6903eb7b544fb6a79fd6f2c74086307b730f00db634f601cdc4a991850866f51a076072fa24b507e6e5ad6137341a3c84196cfe965a75dfd1fe5f70cb020cb6fbc922d321525ecc9a489429f2f782908d7a150da5b008b955ff4fc550d184965dc7b3fa0ff6ce54e0387c9f2eca967c655759a4b61312c3a70bab492eff5c3ea87246106fd0de8e0a2f1ff5558128a831acce2883ffa1dea7de903f869360a6b2046e81faf3a430902df51a9960d57f79ae55551ad06afea2ca48308fb5430334cb5002e95a2f187a126d508be10751a29e1c1ef5ae89cec4ca1e6073f82ca5ce18c99dec31478c6b88bd2f1b83a8b2a2d99920ef37d6df67b31b57ec9512e3088b67cd9e05f42c877a20bc3e6da34a21731bb3fe5b5fc0ae96980c134eb0279cee4cb63118e59045474b38c5f8f605cea2072546388edb3a771757bc96dfa73d11e96272c2d5062bd6d79d80cf6eb6f3bea69c5d6553516ab529ce710632463d89db45ed30c64a283039618a8345b3ffe5859ed74cd21e6ff669b70fb347a7e982a27c7124edf5768ed4b71833d29fabf979e538d4dbdfcb926ff1b0be9b7aae5908ccf18bf6f9fffd8cb944a967eb433ff5e84044c1608f1069d228d31bd2489d248b90eeb59e0e795065f0bd25ffa6b6e183ae04533e1b3856e07bc635efca9ccec07c49385376f51c151c319e5ee236fd5b8b77b3ce83cff4d9eb0102ce4fcf093fd1d6f9f8cdcca76448f1bd12f3ac9d85bca151aeb2772d31680dbca8a619932e2894514bf597be09cb9ebb76eb7147677d1a9e35095413cffb70a3036b01e06684767a617197e11532bc9377f93465db666f1b64ab020faeb23fc627b32a4ad1a9a97bf006cbff91b4954b7ec050524dca41e16bfbb77f9c786c36081d77f4b0b35ce024f0a97eea4ac7975aa4d40c7117bdbaa3b24dd7972d33a308a9471fcd31929bb3f9bf6a2f1d2abe62e1796af7af48a235e87ffd379d3eaefd7e4e6b93755effff45fa34403e7c0e4f91d572aff6dfbc81c4faabeb0db5fa83f0e7a9e7dbf088116a69cf2a83df6487415e1dddce38011977cefd57d90a63851cc858bd364cba2c44c816eb5565bb2585eae74989d309e91711c600330d3b3a71b2228386379259eecb139c4304e3a9a25e138f83c22cf77f36cb30b498af2f946836cc504aabb82b67d178cfeea7d1f8a036614b20b43956fcf540ce8bab31136b59817d664a2039caa761bc2c6646dd9a5d73e8543035c66914df4477373b24fba91515dbc6fd7fd25726be40d1b787b1ef28f73fcc640332c5801e855f1b6e00688264b226eb94c71fb5b67700fcec22722c30749ca35b49ed814e919a1229aed7d236274628719c6b8c9ab4e5e9ba8eecd15a024202b915f0898ddfb1d78fbb4399a2474304da71e8227f76d5a607839cd0dc2a6d0dfa8bc5ec92eb739b3917d2a0194a36409d14c9527bc119b7b8fba523d85b271ddc3f577d5a675de90f1a2a426610f92311639ff3d5047df04ffbb8293df713f216686d17f6b60aeb539e83a665d9c3c98cb7fa98c36aa060feb47fc6466ef61b26b1fb1e972b782527c17219afac45d98d60e48cd17b725ba4430403e4ff80320ff9d8bea634d12741abad550568e95a785e83e77d29b1abf422aa39583156386d4d0bbc44ea8adc842237f132b604e818d9307f682678dcfffac215ecf052deabb554a198d2d902109dee46f000169642e5d25cc7e0321d971f039a9d9b84f4348da83b93cdb7af73c94fb012c567032a560e01007994e887674ba93321c63f621c4cbc5052abfa2e584cd1c59871c647d686b1feece2b89adec1cc0ca0c983dd8d203fc1e4d9e115133245f8ceb787d6c86d4e9596d344f02395f232508eae66f454065d8b970b97c26b124aa01803ef37b08c35da1947b07336e0576aacb9fcca0ccc5fa94e8db4ad3f00559fb5cc9d8e97f61c6ae5b4476a4f7cc3dfcafd9fd97bbfa89a0fd720f74cf8aa9e7de9650f8dc4274a15fce7ce4d3a0025f58c682125ac5b07f381d7f216a1dbd79ae21f60e51a3a0690249eca7ec29700ddb159ed7f23978840a87aeb287b5e763e0aaab02facfe4fb7288c6dd3b8d4f44e3e60ab0a4b22bc2fcde4392374ec0715ffe1ba9b916282f59b5ae379cadd9576073251b45c3a192b837138314657f4b374d0d4b5b7b599ec8700f1994e4bbf921d97a7b49ce6c5b018dd1cd47aee80e80b280
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年终总结&amp;回首过去几年</title>
    <url>/2024/12/02/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E5%9B%9E%E9%A6%96%E8%BF%87%E5%8E%BB%E5%87%A0%E5%B9%B4/</url>
    <content><![CDATA[算是个年终总结，也总结了半秩

总述高一大概是2020年，卡线进了沧州一中
当时成绩平平无奇，在普通班大概是排二十多名的位置

然后高一还是比较平静的吧，刚开学不久学校有信竞集训队招新，然后去考了个试，然后进了集训队，认识了很多大佬
开学后三个月，去打了CSP-S2020，T1打了三个小时，最后一个小时都在吃东西~
赛后测试代码，T1（儒略日，大模拟）拿了10分，原本能晋级的，结果忘记给每道题都建立一个文件夹了，然后遗憾退场（悲
noip2021再战
至于whk，那时候马上就要是”得E门生“了

不过排名基本没变，大概班里二十多名，学校七八百名（物理组合）

直到高二，一直如此
高二CSP/NOIP2021前夕，几乎全天待在机房练题，whk基本没时间学
那段时间的大致安排是，上午正常上课，然后下午和晚自习就在机房里备赛；然后我那段时间基本上是上午课间的时候抓紧时间写作业，有时可以把作业（已经想不到当时是怎么卷的了）；noip打完之后回归whk，基本上白天写完作业绰绰有余，晚上可以自己写练习册了
最后结果，csp省二 noip省三，有点小遗憾，但也知足了
没找到当时的成绩，我只记得刚打完csp回来的月考，没进前900来着
打完比赛，就可以开始专心学whk了

这次好歹是上500分了
转眼到了高二下学期，联考成绩单没在智学网上找到，不过我印象比较深刻，班上第二名，物理组总排第299（这辈子头一次进前300）
高三然后高三了，就都卷起来了，进步就比较困难了，常年稳定在400-500这样子，不过也是鸡汤看的不少，知道高三心态很重要，然后就埋头学习，学累了看会鸡汤，然后继续学（大雾
讲真压力不小，集训队的其他dalao都进阶北大班了，我还在普通班
题目难度上来了，分数基本在450左右，但是排名基本不变
好像是高三上学期，数学一直没有什么进步，比较感动自己的是把朱昊鲲《2000题》一个月刷了一遍（还把错题总结出来了），基本上是每个晚自习都在刷，中午午休的时候也刷；正好赶上一次运动会，记得那一天正好把几何的一大章写完


高三下学期，快高考了，但是语文基本没上过百；听了石油的说法，思考了一下，然后做了一个挺斩钉截铁的决定，拿出整整15天的时间，这段时间每科自己买的试卷都不做了，就只做语文高考真题。在这之后虽然语文依旧没有起色，但是最后高考的时候数学英语发挥的一般，而语文118。我觉得和这一抉择有很大的关联
高考前一两个月吧，我和我同桌经常一块刷题，在限定时间内比正确率，物化生都刷，数学也刷，嘎嘎刷；讲真那段时间刷题真的刷爽了，有一次45分钟我做了两套物理试卷（好像是名校模考卷）的选择题，总共只错了三道题，总之就是挺爽的
最终一分不浪费，录取到了FJNU
大一感觉大一还是相对迷茫的，不过也有不少收获
先说算法竞赛，因为高中学过，所以理所当然大学想打ACM，但是由于比较复杂的原因，最终没有选择ACM（属于是取舍的问题，不过后来想明白了）
因为大一就下定决心不保研了，所以学业这边相对轻松；然后就可以随便打比赛，一段时间的练习逐渐成为了python中手（不是高手也不是低手），CTF被学长带飞然后拿了奖；RoboMaster这边也学到了不少嵌入式知识；而且还混了个数学建模小比赛的奖
机器人相关，沧一有这样的社团但是不在普通班招，有点遗憾；这也是我大学来机器人社团学和本专业毫无关联的嵌入式的原因之一，耗费了不少时间和精力，但是感觉相当划算，现在想自己手搓个什么简单电路基本没有问题，即使有问题也解能决问题

大二大二这一年还没过完，不过想清楚很多事情；很多东西都是要取舍，知道了自己需要什么，需要做什么，因而之后的道路也比较清晰了

关于算法竞赛，太功利去看待他并不是一件好事，但是确实很锻炼思维能力；虽然没进大学的集训队，这段时间也经常打Codeforces，前两天的校赛还取得了不错的成绩

关于CTF，它和以后的就业是相对绑定的；大一锻炼了一年的代码能力，现在手搓（或者熟练使用AI）完成个什么算法也相对轻松；所以基本而言是有利的，性价比较高的
现在机器人这边也在干一个小项目，确实不大，但也学到很多东西
后面的路，应当会越走越宽的

未完待续~
]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF RE wp</title>
    <url>/2024/08/13/BUUCTF-RE-wp/</url>
    <content><![CDATA[easyre
F5一下出

直接打开的话，结束之后自动闪退，所以要用cmd

flag:flag&#123;this_Is_a_EaSyRe&#125;
reverse1shift+F12，然后Ctrl+F搜索关键词flag

双击进入，ctrl+x查看交叉引用

然后点击F5查看源码

得到这一段内容，选中数字单击 r 可以转化为ascll码对应的字母
可以知道，for循环把str2的 o 替换为 0

双击 str2 进入，可以看到str2的数值

那么flag就是替换之后的
flag:flag&#123;hell0_w0rld&#125;
reverse2IDA打开，一键F5

发现是把i和r替换为1

双击flag查看内容

发现有一段是hacking_for_fun&#125;，替换即可得到flag
flag:flag&#123;hack1ng_fo1_fun&#125;
内涵的软件拖进查壳软件

发现是32位文件，拖进IDA32
shift+F12即可看到flag

flag:flag&#123;49d3c93df25caad81232130f3d2ebfad&#125;
新年快乐发现是32位程序

用IDA打开发现有壳

拖进FFI工具中自动去壳

然后拖进IDA，F5发现flag

flag:flag&#123;HappyNewYear!&#125;
xor32位

拖进IDA，F5

可以发现flag是异或得到的
双击global，shift+E获得aFKWOXZUPFVMDGH的值

保存到十进制，编写脚本即可获得flag
l = [  102,  10, 107,  12, 119,  38,  79,  46,  64,  17,   120,  13,  90,  59,  85,  17, 112,  25,  70,  31,   118,  34,  77,  35,  68,  14, 103,   6, 104,  15,    71,  50,  79,   0]flag = &quot;&quot;flag += chr(l[0])for i in range(1,len(l)):    flag += chr(l[i]^l[i-1])print( flag )
flag:flag&#123;QianQiuWanDai_YiTongJiangHu&#125;
reverse3查壳发现没壳，32位，打开

shift+F12看到flag

双击，然后ctrl+x查看交叉引用，然后F5一下，得到以下页面

进入sub_4110BE函数，发现是base64加密
后面还有一个简单的位移运算
密文变量是 Str2，shift+E保存

编写脚本得到flag
import base64s = [  101, 51, 110, 105, 102, 73, 72, 57, 98, 95,   67, 64, 110, 64, 100, 72]flag = &quot;&quot;for i in range(len(s)):    flag += chr(s[i]-i)print( flag )print( base64.b64decode(flag) )
flag:flag&#123;i_l0ve_you&#125;
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2024青工会 南航飞镖内容总结</title>
    <url>/2024/08/23/2024%E9%9D%92%E5%B7%A5%E4%BC%9A-%E5%8D%97%E8%88%AA%E9%A3%9E%E9%95%96%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[2024.11.06二次编辑
没时间回来看了，直接着手做吧，有问题再回来找经验


官方镖头设计的不是很好，但是阻力可以接受
弹道解算，有控镖和无控镖都可以使用


迫击炮/摩擦轮型，把重量拉满，可以增加抗扰性
对碳板前缘倒圆角，升力提高阻力减小（小迎角可行，大迎角雷诺数较高进而失真）
官方镖头对升力系数影响不大，对阻力影响较大



增加边条翼，可以调节气动中心



相对抽象的设计


好处：有充足的升力
坏处：容易坏

机翼经过特殊设计，升阻比能到6以上
很耐摔
两个舵机用来控制

飞镖的雷诺数值比昆虫大一点，比鸟小

所以不针对该雷诺数进行翼型设计，或者特殊处理，将会很容易失速

对称翼型容易失速，越厚越容易失速


NACA0002这种类似平板，反而更不容易分离
如果分离，会变得非线性

增加一个后掠，在前缘拉出一个脱体涡来延缓分离


后掠角越大，可用引脚越大

S翼在0力矩（俯仰力矩为零）的时候是有升力的

快速加速，陀螺仪可能会

]]></content>
      <categories>
        <category>电控</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF Web wp</title>
    <url>/2024/08/16/BUUCTF-Web-wp/</url>
    <content><![CDATA[[ACTF2020 新生赛]Exec
输入127.0.0.1;ls

发现真的把 index.php（也就是ls的操作结果）真的输出了，说明没有过滤分号
最终在127.0.0.1;cd ../../../;ls找到了flag文件

输入127.0.0.1;cd ../../../;ls得到flag

flag:flag&#123;4e3b851f-9a72-42c9-a57a-d6698548cdc0&#125;
[GXYCTF2019]Ping Ping Ping发现有一个/?ip=
根据上一题的经验，我们输入/?ip=127.0.0.1;ls，得到

得知不能输入空格

所以我们需要绕过空格使用一下平替
$&#123;IFS&#125;$9&#123;IFS&#125;$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行IFS&lt; &lt;&gt; &#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来%20   (space)%09   (tab)X=$&#x27;cat\x09./flag.php&#x27;;$X       （\x09表示tab，也可以用\x20）
输入/?ip=127.0.0.1;cat$IFS1flag.php

我们查看index.php

使用 /?ip=127.0.0.1;e=g;cat$IFS$1fla$e.php
F12即可得到flag

;     前面的执行完执行后面的|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         ||    当前面的执行出错时（为假）执行后面的&amp;     将任务置于后台执行&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a  （换行）%0d  （回车）---ps:有时会禁用cat:解决方法是使用tac反向输出命令：linux命令中可以加\，所以甚至可以ca\t /fl\ag---?ip=127.0.0.1;cat$IFS$9`ls`$IFS在Linux下表示为空格$9是当前系统shell进程第九个参数持有者，始终为空字符串，$后可以接任意数字这里$IFS$9或$IFS垂直，后面加个$与&#123;&#125;类似，起截断作用
flag:flag&#123;ef88dbb0-2c4d-4489-9fdb-02ce4c5d6fa1&#125;
[SUCTF 2019]EasySQL
堆叠注入查询数据库
1; show databases;

查询表名

1;show columns from Flag;#select $_GET[&#x27;query&#x27;] || flag from flag
尝试访问Flag，发现不行
输入*,1

这里的原理是sql=select.post[‘query’].&quot;||flag from Flag&quot;;如果$post[‘query’]的数据为*,1，sql语句就变成了select *,1||flag from Flag，就是select *,1 from Flag，这样就直接查询出了Flag表中的所有内容。这里说一下我的理解这里输入*,1,这里会增加一个临时列，他的列名为1，然后那一列的值都为1。当我们只关心数据表有多少记录行而不需要知道具体的字段值时，类似“select 1 from tblName”是一个很不错的SQL语句写法，它通常用于子查询。这样可以减少系统开销，提高运行效率，因为这样子写的SQL语句，数据库引擎就不会去检索数据表里一条条具体的记录和每条记录里一个个具体的字段值并将它们放到内存里，而是根据查询到有多少行存在就输出多少个“1”，每个“1”代表有1行记录，同时选用数字1还因为它所占用的内存空间最小，当然用数字0的效果也一样。在不需要知道具体的记录值是什么的情况下这种写法无疑更加可取。
flag:flag&#123;70066add-3cd0-49ec-84b3-8e6ee05c3dd9&#125;
[强网杯 2019]随便注]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF crypto wp</title>
    <url>/2024/06/06/BUUCTF-crypto-wp/</url>
    <content><![CDATA[[NewStarCTF 2023 公开赛道]Rabin’s RSAfrom Crypto.Util.number import *from secret import flagp = getPrime(64)q = getPrime(64)assert p % 4 == 3assert q % 4 == 3n = p * qe = 2m = bytes_to_long(flag)c = pow(m,e,n)print(&#x27;n =&#x27;, n)print(&#x27;c =&#x27;, c)# n = 201354090531918389422241515534761536573# c = 20442989381348880630046435751193745753

Rabin加密算法——一种基于摸平方和模平方根的非对称加密
特点：

同一密文，可能有两个以上对应的明文
破解该体制等价于对大整数的分解
满足 $p\equiv 3\mod4$ 且 $q\equiv 3\mod4$

Rabin密码体制选取 e=2
加密过程：

$c\equiv m^2\mod n$

解密过程：

根据费马小定理计算 $m$ 在模 $p$ 和 $q$ 时的平方根 $m_p$ 和 $m_q$：
$\circ$ $m_p\equiv c^{\frac{1}{4}(p+1)}\mod p$
$\circ$ $m_q\equiv c^{\frac{1}{4}(q+1)}\mod q$

使用拓展欧几里得算法来查找 $inv_p$ 和 $inv_q$ ：
$\circ$ $inv_pp+inv_qq=1$

根据中国剩余定理定理求四个模 $n$ 时的平方根：
$\circ$ $r_1\equiv (inv_p\cdot p\cdot m_q+inv_q\cdot q\cdot m_p)\mod n$
$\circ$ $r_2\equiv (n-r_1)\mod n$
$\circ$ $r_3\equiv (inv_p\cdot p\cdot m_q-inv_q\cdot q\cdot m_p)\mod n$
$\circ$ $r_4\equiv (n-r_3)\mod n$




为什么 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$ 是 $m^2\equiv c\mod p$ 的解？

即：已知 $m^2\equiv c\mod p$，求证 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$
因为 $p$ 是素数，且 $c$ 是一个模 $p$ 的二次剩余，那么有：
$c^{\frac{p-1}{2}}\equiv 1\mod p$ $\ (Euler’s Criterion)$
恒等号两侧同时乘以 $c$
$c^{\frac{p+1}{2}}\equiv c\mod p$
恒等号两侧同时开根
$c^{\frac{p+1}{4}}\equiv c^{\frac{1}{2}}\mod p$
模 $p$ 意义下的 $c^{\frac{1}{2}}$ 即为 $m$
故 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$
证毕。

为什么 $inv_pp+inv_qq=1$

根据贝祖定理，有 $xp+yq=gcd(p,q)=1$
该式对 $q$ 取模，得到 $x*p\equiv 1\mod q$ ，故 $x\equiv p^{-1}\mod q$
同理对 $p$ 取模，$y\equiv q^{-1}\mod p$
故有 $inv_pp+inv_qq=1$
证毕

能够抵御低密度指数攻击的原因：
低密度指数攻击基于爆破 $k$ 满足 $mm=c+in$
本题的 $n,m,c$ 数位相近，$i$ 需要枚举到 $n,m,c$ 数位量级才有可能爆破出答案

由于模数 N 通常是两个大质数相乘，其欧拉函数很大概率是偶数，故欧拉函数和加密指数不互素，那么逆元性质将不再成立，导致解密操作无法正确还原出原始明文。
原RSA里面要求 e 和 d 模 N 互为逆元 ，否则明文不唯一，明文不唯一的后果就是容易被攻击
传统RSA算法不能解决不互素的情况，无法得到所有的明文解，而二次剩余的情况可以专门被处理，所以就可以被其他算法专门研究
Tonelli-Shanks算法：$p,q\equiv 1\mod 4$
推导：设 $p=4k-3,x^2\equiv c\mod p$
由费马定理，$x^{4k-4}\equiv 1\mod p$
也即 $(c^{\frac{p-1}{4}}+1)^2\equiv 1\mod p$（存疑，这一步是怎么得到的https://zhuanlan.zhihu.com/p/631005614
UNFIXED本题代码：
from Crypto.Util.number import *import gmpy2n = 201354090531918389422241515534761536573c = 20442989381348880630046435751193745753p = 14450452739004884887q = 13934102561950901579e = 2inv_p = gmpy2.invert( p , q )inv_q = gmpy2.invert( q , p )mp = pow( c , (p+1)//4 , p )mq = pow( c , (q+1)//4 , q )a = (inv_p * p * mq + inv_q * q * mp) % nb = n - int(a)c = (inv_p * p * mq - inv_q * q * mp) % nd = n - int(c)# 因为rabin 加密有四种结果，全部列出。aa = [a, b, c, d] for i in aa:    print(i)    print( long_to_bytes(i) )
flag:flag&#123;r4b1n#4c58&#125;
[b01lers2020]safety_in_numbers题目给了三个文件：enc.py加密程序，flag加密结果，pubkey公钥文件
import sysimport Crypto.PublicKey.RSA as RSAdef enc(msg, pubkey):   (n,e) = pubkey   m = int.from_bytes(msg, byteorder = &#x27;little&#x27;)   c = pow(m, e, n)   ctxt = (c).to_bytes(c.bit_length() // 8 + 1, byteorder = &#x27;little&#x27;)   return ctxtwith open(&quot;pubkey.pem&quot;, &quot;r&quot;) as f:   ciph = RSA.importKey(f.read())     # chill out, Crypto.RSA takes its sweet time... (minutes)pubkey = (ciph.n, ciph.e)with open(&quot;flag.txt&quot;, &quot;rb&quot;) as f:   flag = f.read()sys.stdout.buffer.write(enc(flag, pubkey))

通过pem文件提取公钥
import Crypto.PublicKey.RSA as RSAwith open(&quot;pubkey.pem&quot;, &quot;r&quot;) as f:   ciph = RSA.importKey(f.read())     # chill out, Crypto.RSA takes its sweet time... (minutes)n = ciph.ne = ciph.eprint (n)print (e)
n太大太大了，跑了半天都无法输出（可能超过4300位），所以直接对c开e次方即可得到flag
from gmpy2 import*from libnum import*from Crypto.Util.number import long_to_bytesf = open(&#x27;flag.enc&#x27;,&#x27;rb&#x27;).read()e = 65537tmp = int.from_bytes(f, byteorder = &#x27;little&#x27;)m = iroot(tmp,e)[0]print(long_to_bytes(m))print(long_to_bytes(m)[::-1])
其中，pem文件的最后一段是存储e的
from Crypto.Util.number import*from libnum import*import base64s = &#x27;AQAB&#x27;m = base64.b64decode(s)m = bytes_to_long(m)print(hex(m))
[AFCTF2018]你听过一次一密么？25030206463d3d393131555f7f1d061d4052111a19544e2e5d540f020606150f203f307f5c0a7f24070747130e16545000035d541203075429152a7020365c167f390f1013170b1006481e13144e0f4610170e1e2235787f7853372c0f065752111b15454e0e0901081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a18550909075412132e247436425332281a1c561f04071d520f0b11584116111b101e2170203011113a69001b47520601155205021901041006064612297020375453342c17545a01451811411a470e44021311114a5b0335207f7c167f22001b44520c15544801125d4006140611460c26243c7f5c167f3d015446010053005907145d440f05110d160f263f3a7f4210372c03111313090415481d49530f

多次一密
已知异或的性质，有 $C_1\oplus C_2=(M_1\oplus key)\oplus(M_2\oplus key)=M_1\oplus M_2$
先试用第一行和其他行异或
c = [eval(&#x27;0x&#x27;+x.strip()) for x in open(&#x27;Problem.txt&#x27;,&#x27;r&#x27;).readlines()]m1 = c[0]for i in range( 1 , len(c) ):    tmp = hex( m1^c[i] )[2:]    for i in range( 0 , len(tmp), 2 ):#两位一转ascll        p = chr(eval(&#x27;0x&#x27;+tmp[i:i+2]))        if p.isalpha():            print( p , end=&#x27;&#x27; )        else:            print(&#x27;.&#x27;, end=&#x27;&#x27; )    print()
得到：
....S....N.U.....A..M.N......Ro..I...I....SE....P.I..E..H...IN..H...........TU..A.H.R.....E....P......E....RT...E...M....M....A.L.d...V..I..DNEt........K.DU.......I....K..I.ST...TiS......f...N.I........M.O............N.I...I.S.I..I.......P....N.OH...SA....Sg..
规律：小写字母$\oplus$空格=相应的大写字母，大写字母$\oplus$空格=相应的小写字母
故某一 列 英文字母越多，$M_1$ 相应位置是空格的可能性越大
因为异或运算下，$x$ 的逆元是自身
故有 $M_i[j]=M_1[j]\oplus M_i[j]\oplus M_1[j]=M_1[j]\oplus M_i[j]\oplus 0x20$（$j$ 表示列）
只需知道某一字符串的某一位是空格，即可回复所有的密文在这一列的值
解密代码：
import Crypto.Util.strxor as xoimport libnum, codecs, numpy as npdef isChr(x):    if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True    if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True    return Falsedef infer(index, pos):    if msg[index, pos] != 0:        return    msg[index, pos] = ord(&#x27; &#x27;)    for x in range(len(c)):        if x != index:            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)dat = []def getSpace():    for index, x in enumerate(c):        res = [xo.strxor(x, y) for y in c if x!=y]        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))        cnt = [f(pos) for pos in range(len(x))]        for pos in range(len(x)):            dat.append((f(pos), index, pos))c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]msg = np.zeros([len(c), len(c[0])], dtype=int)getSpace()dat = sorted(dat)[::-1]for w, index, pos in dat:    infer(index, pos)print(&#x27;\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))
得到：
Dear Friend, T%is tim&lt; I understood my m$stake 8nd used One time p,d encr ption scheme, I he,rd tha- it is the only en.ryptio7 method that is ma9hemati:ally proven to be #ot cra:ked ever if the ke4 is ke)t secure, Let Me k#ow if  ou agree with me t&quot; use t1is encryption sche e alwa s...
但是有点问题，可以选择手动修复，或者使用代码修复
def know(s,x,y):    msg[x,y] = ord(s)    for index in range(len(c)):        if index != x:            msg[index,y] = xo.strxor(c[x], c[index])[y] ^ ord(s)            know(&#x27;h&#x27;,0,14)know(&#x27;e&#x27;,0,21)
得到
Dear Friend, This time I understood my mistake and used One time pad encryption scheme, I heard that it is the only encryption method that is mathematically proven to be not cracked ever if the key is kept secure, Let Me know if you agree with me to use this encryption scheme always...
有了明文了，计算 $C_1\oplus M_1$ 即可得到 key
key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())print(key)
key就是flag
flag:flag&#123;OPT_1s_Int3rest1ng&#125;

后记：
按行读取TXT中的数据：c = [x for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]
去除尾部的&#39;\n&#39;：c = [x.strip() for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]
eval的用法十分灵活，默认十进制：c = [eval(&#39;0x&#39;+x.strip()) for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]
[NewStarCTF 2023 公开赛道]babyaesfrom Crypto.Cipher import AESimport osfrom flag import flagfrom Crypto.Util.number import *def pad(data):    return data + b&quot;&quot;.join([b&#x27;\x00&#x27; for _ in range(0, 16 - len(data))])def main():    flag_ = pad(flag)    key = os.urandom(16) * 2    iv = os.urandom(16)    print(bytes_to_long(key) ^ bytes_to_long(iv) ^ 1)    aes = AES.new(key, AES.MODE_CBC, iv)    enc_flag = aes.encrypt(flag_)    print(enc_flag)if __name__ == &quot;__main__&quot;:    main()# 3657491768215750635844958060963805125333761387746954618540958489914964573229# b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;

key是高位16bytes，iv是低位16bytes，所以可以很轻易的区分
from Crypto.Cipher import AESimport osfrom gmpy2 import*from Crypto.Util.number import*xor = 3657491768215750635844958060963805125333761387746954618540958489914964573229enc_flag = b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;out = long_to_bytes(xor)#先转化成16进制形式，aes和rsa不一样，操作一般都是在hex下key = out[:16]*2#这一部分是key的，另外一部分是iv的（别忘了最低位有个1）iv = long_to_bytes(bytes_to_long(key[16:])^bytes_to_long(out[16:])^1)aes = AES.new(key,AES.MODE_CBC,iv)#调用函数库解密flag = aes.decrypt(enc_flag)print(flag)
flag:flag&#123;firsT_cry_Aes&#125;
[QCTF2018]Xman-RSAciphertext:
1240198b148089290e375b999569f0d53c32d356b2e95f5acee070f016b3bef243d0b5e46d9ad7aa7dfe2f21bda920d0ac7ce7b1e48f22b2de410c6f391ce7c4347c65ffc9704ecb3068005e9f35cbbb7b27e0f7a18f4f42ae572d77aaa3ee189418d6a07bab7d93beaa365c98349d8599eb68d21313795f380f05f5b3dfdc6272635ede1f83d308c0fdb2baf444b9ee138132d0d532c3c7e60efb25b9bf9cb62dba9833aa3706344229bd6045f0877661a073b6deef2763452d0ad7ab3404ba494b93fd6dfdf4c28e4fe83a72884a99ddf15ca030ace978f2da87b79b4f504f1d15b5b96c654f6cd5179b72ed5f84d3a16a8f0d5bf6774e7fd98d27bf3c9839129d5d4ab3f9e8017d4e6761702467bbeb1b884b6c4f8ff397d078a8c41186a3d52977fa2307d5b6a0ad01fedfc3ba7b70f776ba3790a43444fb954e5afd64b1a3abeb6507cf70a5eb44678a886adf81cb4848a35afb4db7cd7818f566c7e6e2911f5ababdbdd2d4ff9825827e58d48d5466e021a64599b3e867840c07e29582961f81643df07f678a61a9f9027ebd34094e272dfbdc4619fa0ac60f0189af785df77e7ec784e086cf692a7bf7113a7fb8446a65efa8b431c6f72c14bcfa49c9b491fb1d87f2570059e0f13166a85bb555b40549f45f04bc5dbd09d8b858a5382be6497d88197ffb86381085756365bd757ec3cdfa8a77ba1728ec2de596c5ab
n2&amp;n3:
PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw==TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ==
n1.encrypted:
2639c28e3609a4a8c953cca9c326e8e062756305ae8aee6efcd346458aade3ee8c2106ab9dfe5f470804f366af738aa493fd2dc26cb249a922e121287f3eddec0ed8dea89747dc57aed7cd2089d75c23a69bf601f490a64f73f6a583081ae3a7ed52238c13a95d3322065adba9053ee5b12f1de1873dbad9fbf4a50a2f58088df0fddfe2ed8ca1118c81268c8c0fd5572494276f4e48b5eb424f116e6f5e9d66da1b6b3a8f102539b690c1636e82906a46f3c5434d5b04ed7938861f8d453908970eccef07bf13f723d6fdd26a61be8b9462d0ddfbedc91886df194ea022e56c1780aa6c76b9f1c7d5ea743dc75cec3c805324e90ea577fa396a1effdafa309042ff1157363d9cd10da64eb4382b6457ebb740dbef40ade9b24a174d0145adaa0115d86aa2fc2a41257f2b62486eaebb655925dac78dd8d13ab405aef5b8b8f9830094c712193500db49fb801e1368c73f88f6d8533c99c8e7259f8b9d1c926c47215ed327114f235ba8c873af7a0052aa2d32c52880db55c5615e5a1793b690c37efdd5e503f717bb8de716303e4d6c4116f62d81be852c5d36ef282a958d8c82cf3b458dcc8191dcc7b490f227d1562b1d57fbcf7bf4b78a5d90cd385fd79c8ca4688e7d62b3204aeaf9692ba4d4e44875eaa63642775846434f9ce51d138ca702d907849823b1e86896e4ea6223f93fae68b026cfe5fa5a665569a9e3948a
encryption.encrypted:
gqhb jbkl2 pbkhqw pt_kqpbdgqhb ht pbkhqw zqreahbpbkhqw urtd64adg ulwdt_wh_ezb(u):	qdwzqe pew(u.dexhad(&#x27;mdi&#x27;), 16)	adg ezb_wh_ulwdt(e):	u = mdi(e)[2:-1]	u = &#x27;0&#x27; + u pg yde(u)%2 == 1 dytd u	qdwzqe u.adxhad(&#x27;mdi&#x27;)adg jdw_r_kqpbd(y):	qreahb_tdda = zqreahb(y)	ezb = ulwdt_wh_ezb(qreahb_tdda)		fmpyd Tqzd:		pg pt_kqpbd(ezb):			uqdrv		ezb+=1	qdwzqe ezbadg dexqlkw(t, d, e):	k = ulwdt_wh_ezb(t)	k = khf(k, d, e)	qdwzqe ezb_wh_ulwdt(k).dexhad(&#x27;mdi&#x27;)	adg tdkrqrwd(e):	k = e % 4	w = (k*k) % 4	qdwzqe w == 1	g = hkde(&#x27;gyrj.wiw&#x27;, &#x27;q&#x27;)gyrj = g.qdra()		btj1 = &quot;&quot;btj2 = &quot;&quot;ghq p pe qrejd(yde(gyrj)):	pg tdkrqrwd(p):		btj2 += gyrj[p]	dytd:		btj1 += gyrj[p]k1 = jdw_r_kqpbd(128)k2 = jdw_r_kqpbd(128)k3 = jdw_r_kqpbd(128)e1 = k1*k2e2 = k1*k3d = 0i1001x1 = dexqlkw(btj1, d, e1)x2 = dexqlkw(btj2, d, e2)kqpew(x1)kqpew(x2)d1 = 0i1001d2 = 0i101k4 = jdw_r_kqpbd(128)k5 = jdw_r_kqpbd(128)e3 = k4*k5x1 = ezb_wh_ulwdt(khf(e1, d1, e3)).dexhad(&#x27;mdi&#x27;)x2 = ezb_wh_ulwdt(khf(e1, d2, e3)).dexhad(&#x27;mdi&#x27;)kqpew(x1)kqpew(x2)kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e2)))kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e3)))

加密代码非要替换一下，直接 词频分析 得到代码原文：（需要自行加入空格）
from gmpy2 import is_prime from os import urandom import base64 def bytes_to_num(b):     return int(b.encode(&#x27;hex&#x27;), 16) def num_to_bytes(n):     b = hex(n)[2:-1]     b = &#x27;0&#x27; + b if len(b)%2 == 1 else b     return b.decode(&#x27;hex&#x27;) def get_a_prime(l):     random_seed = urandom(l)         num = bytes_to_num(random_seed)     while True:         if is_prime(num):             break         num+=1         return num def encrypt(s, e, n):     p = bytes_to_num(s)     p = pow(p, e, n)     return num_to_bytes(p).encode(&#x27;hex&#x27;)  def separate(n):     p = n % 4     t = (p*p) % 4     return t == 1     f = open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) flag = f.read() msg1 = &quot;&quot; msg2 = &quot;&quot; for i in range(len(flag)):     if separate(i):         msg2 += flag[i]     else:         msg1 += flag[i]  p1 = get_a_prime(128) p2 = get_a_prime(128) p3 = get_a_prime(128)  n1 = p1*p2 n2 = p1*p3 e = 0x1001 c1 = encrypt(msg1, e, n1) c2 = encrypt(msg2, e, n2) print(c1) print(c2) e1 = 0x1001 e2 = 0x101 p4 = get_a_prime(128) p5 = get_a_prime(128) n3 = p4*p5 c1 = num_to_bytes(pow(n1, e1, n3)).encode(&#x27;hex&#x27;) c2 = num_to_bytes(pow(n1, e2, n3)).encode(&#x27;hex&#x27;) print(c1) print(c2) print(base64.b64encode(num_to_bytes(n2))) print(base64.b64encode(num_to_bytes(n3)))
从后往前解，n2和n3是从先 long_to_bytes，然后 base64 加密，容易得到代码：
import base64from Crypto.Util.number import bytes_to_longdef dec( x ):    return bytes_to_long(base64.b64decode(x)) n2 = dec(&#x27;PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw==&#x27;)n3 = dec(&#x27;TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ==&#x27;)print( n2 )print( n3 )
然后通过共膜攻击，求得 n1 ：
import gmpy2e1 = 0x1001e2 = 0x101c1 = c2 =  s, s1, s2 = gmpy2.gcdext(e1, e2)n1 = (pow(c1, s1, n3) * pow(c2, s2, n3) % n3) print( n1 )
因为 n1 和 n2 有公因数，易求得 p1,p2,p3：
import gmpy2 n1 = n2 = p1 = gmpy2.gcd(n1, n2)p2 = n1 // p1p3 = n2 // p2print( p1 , p2 , p3 )
剩下的是常规rsa，注意flag拼接：
c1 = c2 = e = 0x1001 phi1 = (p1-1)*(p2-1)phi2 = (p1-1)*(p3-1)d1 = gmpy2.invert(e, phi1)d2 = gmpy2.invert(e, phi2)m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)flag1 = long_to_bytes(int(m1))flag2 = long_to_bytes(int(m2)) print(flag1)print(flag2)for i in range(len(flag1)):    print(chr(flag1[i]), end = &#x27;&#x27;)    try:        print(chr(flag2[i]), end = &#x27;&#x27;)    except:        pass
flag:flag&#123;CRYPT0_I5_50_Interestingvim rsa.py&#125;

[羊城杯 2020]RRRRRRRSAimport hashlibimport sympyfrom Crypto.Util.number import *flag = &#x27;GWHT&#123;************&#125;&#x27;flag1 = flag[:19].encode()flag2 = flag[19:].encode()assert(len(flag) == 38)P1 = getPrime(1038)P2 = sympy.nextprime(P1)assert(P2 - P1 &lt; 1000)Q1 = getPrime(512)Q2 = sympy.nextprime(Q1)N1 = P1 * P1 * Q1N2 = P2 * P2 * Q2E1 = getPrime(1024)E2 = sympy.nextprime(E1)m1 = bytes_to_long(flag1)m2 = bytes_to_long(flag2)c1 = pow(m1, E1, N1)c2 = pow(m2, E2, N2)output = open(&#x27;secret&#x27;, &#x27;w&#x27;)output.write(&#x27;N1=&#x27; + str(N1) + &#x27;\n&#x27;)output.write(&#x27;c1=&#x27; + str(c1) + &#x27;\n&#x27;)output.write(&#x27;E1=&#x27; + str(E1) + &#x27;\n&#x27;)output.write(&#x27;N2=&#x27; + str(N2) + &#x27;\n&#x27;)output.write(&#x27;c2=&#x27; + str(c2) + &#x27;\n&#x27;)output.write(&#x27;E2=&#x27; + str(E2) + &#x27;\n&#x27;)output.close()
N1=c1=E1=N2=c2=E2=

wiener attack 是依靠连分数进行的攻击方式，适用于非常接近某一值（比如1）时，求一个比例关系，通过该比例关系再来反推关键信息就简单很多。这种攻击对于解密指数d很小时有很好的效果，一般的用法是通过 
$ed \mod \phi(N)\equiv1$ 
得到 $ed=k*\phi(N)+1$
即  $\frac{e}{\phi(N)}=\frac{k}{d}+\frac{1}{\phi(N)}$
这种情况下 $\phi(N)≈N$，且 $\phi(N)$ 非常大
所以有 $\frac{e}{N}-\frac{k}{d}=\frac{1}{\phi(N)}$
也就是说 $\frac{k}{d}$ 与 $\frac{e}{N}$ 非常接近，而 $\frac{e}{N}$ 又是已知的
对 $\frac{e}{N}$ 进行连分数展开，得到的一串分数的分母很有可能就是 $d$
只要检验一下 $ed \mod \phi(N)$ ，看它是不是 $1$ 就知道对不对了。
但是这道题和普通的wiener attack 不同的是，e与N并没有近到相除约为1的地步，相差还是很大的，也就是说解密指数d也许还是很大的，这样就解不出来。
值得注意的是，e和N的关系不符合利用条件，但是N1和N2的关系却适合
对于这一道题: $\frac{N_1}{N_2}=(\frac{P_1}{P_2})^2*\frac{Q_1}{Q_2}$
显然我们可以知道的是 $\frac{N_1}{N_2}&lt;\frac{Q_1}{Q_2}$ 
所以在 $\frac{Q_1}{Q_2}\in [\frac{N_1}{N_2},1]$ 
尝试对 $\frac{N_1}{N_2}$ 进行连分数展开并求其各项渐进分数，其中某个连分数的分母可能就是 $Q_1$（依靠 $N\%Q$ 来验证）
代码：
import gmpy2from Crypto.Util.number import long_to_bytesN1=c1=E1=N2=c2=E2=def continuedFra(x, y): #不断生成连分数的项    cF = []    while y:        cF += [x // y]        x, y = y, x % y    return cFdef Simplify(ctnf): #化简    numerator = 0    denominator = 1    for x in ctnf[::-1]: #注意这里是倒叙遍历        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator) #把连分数分成分子和算出来的分母def getit(c):    cf=[]    for i in range(1,len(c)):        cf.append(Simplify(c[:i])) #各个阶段的连分数的分子和分母    return cf #得到一串连分数def wienerAttack(e, n):    cf=continuedFra(e,n)    for (Q2,Q1) in getit(cf):#遍历得到的连分数，令分子分母分别是Q2，Q1        if Q1 == 0:            continue        if N1%Q1==0 and Q1!=1:#满足这个条件就找到了            return Q1    print(&#x27;not find!&#x27;)Q1=wienerAttack(N1,N2)P1=gmpy2.iroot(N1//Q1,2)[0]P2=gmpy2.next_prime(P1)Q2=gmpy2.next_prime(Q1)phi1=P1*(P1-1)*(Q1-1)phi2=P2*(P2-1)*(Q2-1)d1=gmpy2.invert(E1,phi1)d2=gmpy2.invert(E2,phi2)m1=long_to_bytes(gmpy2.powmod(c1,d1,N1))m2=long_to_bytes(gmpy2.powmod(c2,d2,N2))print((m1+m2))
flag:flag&#123;3aadab41754799f978669d53e64a3aca&#125;
[UTCTF2020]OTPEncoded A: 213c234c2322282057730b32492e720b35732b2124553d354c22352224237f1826283d7b0651Encoded B: 3b3b463829225b3632630b542623767f39674431343b353435412223243b7f162028397a103eOriginal A: 5448452042455354204354462043415445474f52592049532043525950544f47524150485921Original B: 4e4f205448452042455354204f4e452049532042494e415259204558504c4f49544154494f4eA XOR A: 7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70B XOR B: 7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70

一次一密是牢不可破的！
不过原文和密文都给了，就可以轻易得到flag了
c = &#x27;7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70&#x27; for i in range(0, len(c), 2):    print(chr(int(c[i:i+2], 16)), end = &#x27;&#x27;)
flag:flag&#123;tw0_tim3_p4ds&#125;
[Dest0g3 520迎新赛]babyAESfrom Crypto.Cipher import AESimport osiv = os.urandom(16)key = os.urandom(16)my_aes = AES.new(key, AES.MODE_CBC, iv)flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()flag += (16 - len(flag) % 16) * b&#x27;\x00&#x27;c = my_aes.encrypt(flag)print(c)print(iv)print(key)&#x27;&#x27;&#x27;b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;&#x27;&#x27;&#x27;

最喜欢的大水题，该给的都给了，直接解就可以了
from Crypto.Cipher import AES c = b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;iv = b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;key = b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;my_aes = AES.new(key, AES.MODE_CBC, iv)m = my_aes.decrypt(c)print(m)
flag:flag&#123;d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4&#125;
[ACTF新生赛2020]crypto-des72143238992041641000000.000000,77135357178006504000000000000000.000000,1125868345616435400000000.000000,67378029765916820000000.000000,75553486092184703000000000000.000000,4397611913739958700000.000000,76209378028621039000000000000000.000000To solve the key, Maybe you know some interesting data format about C language?

网上抄来的脚本，我也不知道为什么要这么干（感觉和密码学没关联
from libnum import*import structimport binasciis = [72143238992041641000000.000000,77135357178006504000000000000000.000000,1125868345616435400000000.000000,67378029765916820000000.000000,75553486092184703000000000000.000000,4397611913739958700000.000000,76209378028621039000000000000000.000000]a = &#x27;&#x27;b = &#x27;&#x27;for i in s:    i = float(i)    a += struct.pack(&#x27;&lt;f&#x27;,i).hex()        #小端print(a)for j in s:    i = float(i)    b += struct.pack(&#x27;&gt;f&#x27;,i).hex()        #小端print(b)print(n2s(a))print(n2s(b))
得到：
b&#x27;Interestring Idea to encrypt&#x27;b&#x27;tpyrtpyrtpyrtpyrtpyrtpyrtpyr&#x27;
但是我自己习惯的写法，得到的a是相同的
import structimport binasciifrom Crypto.Util.number import long_to_bytes , bytes_to_longs = [    72143238992041641000000.000000,    77135357178006504000000000000000.000000,    1125868345616435400000000.000000,    67378029765916820000000.000000,    75553486092184703000000000000.000000,    4397611913739958700000.000000,    76209378028621039000000000000000.000000]def solve( f ):    output = &#x27;&#x27;    for i in s:        output += str(struct.pack(f,float(i)))[2:].strip(&#x27;\&#x27;&#x27;)    return outputa = solve(&#x27;&lt;f&#x27;)b = solve(&#x27;&gt;f&#x27;)print( a )print( b )
得到：
Interestring Idea to encryptetnItsergniredI ot acne tpyr
这篇文章的解法看着相对靠谱很多，但是没有详细代码，不知道是如何操作的，尝试只好一番之后未成功只好作罢
输出结果中，b的不一样而a一样，但是解压密码就是a的输出
解压密码是:Interestring Idea to encrypt
得到zip文件：
import pyDesimport base64from FLAG import flagdeskey = &quot;********&quot;DES = pyDes.des(deskey)DES.setMode(&#x27;ECB&#x27;)DES.Kn = 一个矩阵cipher_list = base64.b64encode(DES.encrypt(flag))#b&#x27;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#x27;
新生赛的题是这样的，直接解就可以了
import pyDesimport base64from Crypto.Util.number  import*deskey  = &quot;********&quot;DES = pyDes.des(deskey)DES.setMode(&#x27;ECB&#x27;)DES.Kn =k = b&#x27;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#x27;data = base64.b64decode(k)flag = DES.decrypt(data)print(flag)
flag:flag&#123;breaking_DES_is_just_a_small_piece_of_cake&#125;
[AFCTF2018]One Secret, Two encryption一份秘密发送给两个人不太好吧，那我各自加密一次好啦~~~素数生成好慢呀偷个懒也……不会有问题的吧？
flag_encry1
flag_encry2
public1.pub
public2.pub

先用 公钥解析 提取一下公钥
得到两组n和e
print( math.gcd(n1,n2) )
得到两组p和q
也可以直接用库函数来解
import rsad=int(gmpy2.invert(e,(p-1)*(q-1)))Rsa=rsa.PrivateKey(n,e,d,p,q)with open(&#x27;flag_encry1&#x27;,&#x27;rb&#x27;) as f:     cipher1=f.read()     print(rsa.decrypt(cipher1,Rsa))
flag:flag&#123;You_Know_0p3u55I&#125;
[watevrCTF 2019]Swedish RSAflag = bytearray(raw_input())flag = list(flag)length = len(flag)bits = 16## Prime for Finite Field.p = random_prime(2^bits-1, False, 2^(bits-1))file_out = open(&quot;downloads/polynomial_rsa.txt&quot;, &quot;w&quot;)file_out.write(&quot;Prime: &quot; + str(p) + &quot;\n&quot;)## Univariate Polynomial Ring in y over Finite Field of size pR.&lt;y&gt; = PolynomialRing(GF(p))## Analogous to the primes in Zdef gen_irreducable_poly(deg):    while True:        out = R.random_element(degree=deg)        if out.is_irreducible():            return out## Polynomial &quot;primes&quot;P = gen_irreducable_poly(ZZ.random_element(length, 2*length))Q = gen_irreducable_poly(ZZ.random_element(length, 2*length))## Public exponent keye = 65537## ModulusN = P*Qfile_out.write(&quot;Modulus: &quot; + str(N) + &quot;\n&quot;)## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)S.&lt;x&gt; = R.quotient(N)## Encryptm = S(flag)c = m^efile_out.write(&quot;Ciphertext: &quot; + str(c))file_out.close()

将传统 RSA 中的 p和q 用多项式来替代
传统欧拉函数：对于正整数n，欧拉函数是小于等于n的数中与n互质的数的个数。多项式欧拉函数：对于多项式P(y)来讲，欧拉函数phi(P(y))表示所有不高于P(y)幂级的环内所有多项式中，与P(y)无（除1以外）公因式的其他多项式的个数。
经过 is_irreducible 函数的判断，可以得知 $P(y)$ 是不可约多项式，所以 $\phi(P(y))=43753^{degree()}-1$
$degree()$ 就是多项式的最高项指数
信息是多项式形式的，明文的每个字符都转化成数值，作为多项式上的系数
P=43753R.&lt;y&gt; = PolynomialRing(GF(P))N=S.&lt;x&gt; = R.quotient(N)C=p,q = N.factor()p,q = p[0],q[0]phi=(pow(P,65)-1)*(pow(P,112)-1)e = 65537d = inverse_mod(e,phi)m = C^dprint(&quot;&quot;.join([chr(c) for c in m.list()]))
flagflag&#123;RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro&#125;
[watevrCTF 2019]ECC-RSAfrom fastecdsa.curve import P521 as Curvefrom fastecdsa.point import Pointfrom Crypto.Util.number import bytes_to_long, isPrimefrom os import urandomfrom random import getrandbitsdef gen_rsa_primes(G):	urand = bytes_to_long(urandom(521//8))	while True:		s = getrandbits(521) ^ urand		Q = s*G		if isPrime(Q.x) and isPrime(Q.y):			print(&quot;ECC Private key:&quot;, hex(s))			print(&quot;RSA primes:&quot;, hex(Q.x), hex(Q.y))			print(&quot;Modulo:&quot;, hex(Q.x * Q.y))			return (Q.x, Q.y)flag = int.from_bytes(input(), byteorder=&quot;big&quot;)ecc_p = Curve.pa = Curve.ab = Curve.bGx = Curve.gxGy = Curve.gyG = Point(Gx, Gy, curve=Curve)e = 0x10001p, q = gen_rsa_primes(G)n = p*qfile_out = open(&quot;downloads/ecc-rsa.txt&quot;, &quot;w&quot;)file_out.write(&quot;ECC Curve Prime: &quot; + hex(ecc_p) + &quot;\n&quot;)file_out.write(&quot;Curve a: &quot; + hex(a) + &quot;\n&quot;)file_out.write(&quot;Curve b: &quot; + hex(b) + &quot;\n&quot;)file_out.write(&quot;Gx: &quot; + hex(Gx) + &quot;\n&quot;)file_out.write(&quot;Gy: &quot; + hex(Gy) + &quot;\n&quot;)file_out.write(&quot;e: &quot; + hex(e) + &quot;\n&quot;)file_out.write(&quot;p * q: &quot; + hex(n) + &quot;\n&quot;)c = pow(flag, e, n)file_out.write(&quot;ciphertext: &quot; + hex(c) + &quot;\n&quot;)

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cryptoCTF</tag>
        <tag>常驻</tag>
      </tags>
  </entry>
  <entry>
    <title>CF补题小合集</title>
    <url>/2025/01/19/CF%E8%A1%A5%E9%A2%98%E5%B0%8F%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[由于后续CF比赛基本只参加VP，故特此记录一下


2025.01.17Codeforces Round 996 (Div. 2)
这把打爽了，表现分差点上紫，D题最后一分钟调出来过样例 结果WA2了

C题构造题
我们从(1,1)开始思考，假设场景是这样的

设每行每列的和都为$S$，故(1,1)的数值和$S$的大小成线性关系
也就是说，知道$S$就能通过这一行的数求出(1,1)的数值（如蓝色所示）

同理，知道$S$就能求出第二行的数值（如紫色所示）

按顺序（沿路径）向下递推，就必然可以计算出下一个方格的数据（如红色所示）

故得出结论：如果该位置的下一个是R，则通过列计算；否则通过行计算
但是$S$还不知道哇~
梅瓜吸，$S$是多少都可以，我直接让它是0（更正式的，由$x+1$个未知数的$x$个方程构成的方程组中，存在一个自由量，这个自由量可以是S；其中$x=n+m-2$）
#include&lt;iostream&gt;#define int long longusing namespace std;const int N = 1e3;int n , m;int a[N+10][N+10];string s;signed main()&#123;    int t;cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;        for(int i = 1;i &lt;= n;i ++)&#123;            for(int j = 1;j &lt;= m;j ++)&#123;                cin &gt;&gt; a[i][j];            &#125;        &#125;        int x , y;x = y = 1;        for(int p = 0,i,j;p &lt; s.length();p ++)&#123;            if( s[p] == &#x27;D&#x27; )&#123;                for(j = 1;j &lt;= m;j ++)&#123;                    if( j == y ) continue;                    a[x][y] += a[x][j];                &#125;a[x][y] = -a[x][y];                x ++;            &#125;            if( s[p] == &#x27;R&#x27; )&#123;                for(i = 1;i &lt;= n;i ++)&#123;                    if( i == x ) continue;                    a[x][y] += a[i][y];                &#125;a[x][y] = -a[x][y];                y ++;            &#125;        &#125;        for(int j = 1;j &lt; m;j ++) a[n][m] += a[n][j];        a[n][m] = -a[n][m];        for(int i = 1;i &lt;= n;i ++)&#123;            for(int j = 1;j &lt;= m;j ++)&#123;                cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;            &#125;cout &lt;&lt; endl;        &#125;    &#125;return 0;&#125;
D题不容易的思维题，不过只要逻辑理清楚了，都很简单
考虑以下策略仅考虑两个相邻的点如果二者的距离小于k，则可以直接越过去，a[i]的值尽可能的大如果二者的距离大于k但是小于k+已过去的时间，则右侧点有能力移动到a[i-1]+k，也不需要额外消耗时间如果二者的距离大于k+已过去的时间，则右侧点应当从一开始就开始全力左移，并二者相向而行，代价是相向而行的时间
值得注意的是，long double最后要转成long long不然输出的可能是科学计数法（WA6）
#include&lt;iostream&gt;#define int long longusing namespace std;const int N = 2e5;int n , k , l;long double ans , time_now;long double a[N+10];signed main()&#123;    int t;cin &gt;&gt; t;    while( t -- )&#123;ans = 0;        cin &gt;&gt; n &gt;&gt; k &gt;&gt; l;        for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];        ans += a[1]*2;        time_now = a[1];        a[1] = 0;        for(int i = 2;i &lt;= n;i ++)&#123;            if( a[i] - a[i-1] &gt; k )&#123;                if( a[i] - a[i-1] &gt; k + time_now )&#123;                    a[i] -= time_now;                    ans += (a[i] - a[i-1] - k);                    time_now += (a[i] - a[i-1] - k)/2;                    a[i] -= (a[i] - a[i-1] - k) / 2;                &#125;else&#123;                    a[i] = a[i-1] + k;                &#125;            &#125;else&#123;                a[i] = min( a[i-1] + k , a[i] + time_now );            &#125;        &#125;        ans += max( (l - a[n] - k )*2 , (long double)0 );        cout &lt;&lt; (long long)ans &lt;&lt; endl;    &#125;return 0;&#125;
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Beaver三元组用于乘法共享</title>
    <url>/2025/04/10/Beaver%E4%B8%89%E5%85%83%E7%BB%84%E7%94%A8%E4%BA%8E%E4%B9%98%E6%B3%95%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[Beaver 三元组（Beaver triples）是安全多方计算（MPC）中一个超级聪明、实用的技巧，用来安全地做乘法
通俗类比：就好像你和朋友要乘两个私密数字，但你们提前准备了一个万能“乘法模板”，可以安全又正确地偷偷算出结果。


Motivation在安全多方计算里：

加法很容易做：每个人把自己数据碎片加一下就行。
但乘法就麻烦了，因为：
两个秘密数的乘积不能直接从碎片算
又不能暴露真实数值
所以需要巧妙地”绕过去“



Beaver 三元组应运而生

DefinationBeaver 三元组表示为：

(a, b, c) \quad \text{where} \quad c = a \cdot b
所有参与方各自拿到这些数的“碎片”，但不知道完整的值。
它跟我们真正要计算的 $x \cdot y$ 没有关系，只是一个通用的乘法工具。


Algorithm假设两位参与方想计算：

x \cdot y但每人都只知道自己的秘密（$x$ 或 $y$），又不想泄露给别人。

步骤如下：

每人拿到 $x$ 和 $y$ 的秘密共享，还有一个 Beaver 三元组 $(a, b, c)$，满足 $c = ab$

本地计算（在共享上进行）：



\begin{align}
&d = x - a\\
&e = y - b
\end{align}
公布 $d$ 和 $e$（这不会泄露 $x$ 和 $y$，因为 $a$ 和 $b$ 是随机的）

使用下面的公式计算结果：



xy = c + d \cdot b + e \cdot a + d \cdot e
安全性说明：
虽然你公开了 $d$ 和 $e$，但由于 $a$ 和 $b$ 是随机数，别人无法反推 $x$ 和 $y$，同时这个公式仍能计算出准确的乘积
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>CRYTPO 24.8第一周刷题记录</title>
    <url>/2024/08/05/CRYTPO-24-8%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[[SWPUCTF 2021 新生赛]crypto3
from gmpy2 import *from Crypto.Util.number import *flag  = &#x27;******************&#x27;p = getPrime(512)q = getPrime(512)m1 = bytes_to_long(bytes(flag.encode()))n = p*qflag1 = pow(m1,p,n)flag2 = pow(m1,q,n)print(&#x27;flag1= &#x27;+str(flag1))print(&#x27;flag2= &#x27;+str(flag2))print(&#x27;n= &#x27;+str(n))#flag1= 17893542812755845772427795161304049467610774531005620109503081344099161906017295486868699578946474114607624347167976713200068059018517606363517478396368430072890681401898145302336139240273132723451063402106360810413024642916851746118524166947301681245568333254648265529408446609050354235727237078987509705857#flag2= 95580409405085606847879727622943874726633827220524165744517624606566789614499137069562997931972825651309707390763700301965277040876322904891716953565845966918293178547100704981251056401939781365264616997055296773593435626490578886752446381493929807909671245959154990639046333135728431707979143972145708806954#n= 140457323583824160338989317689698102738341061967768153879646505422358544720607476140977064053629005764551339082120337223672330979298373653766782620973454095507484118565884885623328751648660379894592063436924903894986994746394508539721459355200184089470977772075720319482839923856979166319700474349042326898971

https://www.osgeo.cn/sagemath/tutorial/index.html
得到

\left\{
\begin{aligned}
m^p \equiv h_1\ mod\ n\\
m^q \equiv h_2\ mod\ n\\
\end{aligned}
\right.由费马小定理，因为 $p$ $q$ 为质数，故

\left\{
\begin{aligned}
m^p \equiv m\ mod\ p\\
m^q \equiv m\ mod\ q\\
\end{aligned}
\right.则有

\left\{
\begin{aligned}
h_1 \equiv m+k_1*p\ mod\ n\\
h_2 \equiv m+k_2*q\ mod\ n\\
\end{aligned}
\right.即

\left\{
\begin{aligned}
h_1 \equiv m+k_1*p\ + k_3*p*q\\
h_2 \equiv m+k_2*q\ + k_4*p*q\\
\end{aligned}
\right.可以得到，在 $Zmod(n)$ 下，有

\left\{
\begin{aligned}
h_1+h_2 & = 2*m+k_1*p+k_2*q\ \\
h_1*h_2 & = m^2+(k_1*p+k_2*q)*m\\
\end{aligned}
\right.可以消去 $k_1$ $k_2$ 得到式子
$m^2 - (h1+h2)m + h1h2=0$
代码：
#sagefrom Crypto.Util.number import *h1= h2= n= PR.&lt;m&gt; = PolynomialRing( Zmod(n) )f = m^2 - (h1+h2)*m + h1*h2a = int(str(f.small_roots( X=2^400 )[0]))print( flag )print( long_to_bytes(flag) )
output:
1920535408007397834236393374892057067669865609963495845501b&#x27;NSSCTF&#123;why_gongmo_again&#125;&#x27;
flag:NSSCTF&#123;why_gongmo_again&#125;
[BUUCTF·V&amp;N2020 公开赛]easy_RSAtag.暴力分解 小技巧
from random import randintfrom gmpy2 import *from Crypto.Util.number import *def getprime(bits):    while 1:        n = 1        while n.bit_length() &lt; bits:            n *= next_prime(randint(1,1000))        if isPrime(n - 1):            return n - 1m = bytes_to_long(b&#x27;flag&#123;************************************&#125;&#x27;)p = getprime(505)q = getPrime(512)r = getPrime(512)assert m &lt; qn = p * q * re = 0x10001d = invert(q ** 2, p ** 2)c = pow(m, 2, r)cipher = pow(c, e, n)print(n)print(d)print(cipher)

使用factordb分解得到$p\ q\ r$的数值
c = pow(m, 2, r)已知 $m\ r$ 求 $c$
求 $x^n\equiv a\ mod\ p$ 的解的方法：
from sympy.ntheory.residue_ntheory import nthroot_modx=nthroot_mod(a,n,p)
exp:
from Crypto.Util.number import long_to_bytesimport gmpy2import mathn = d = m = e = 0x10001p = 102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393q = 7534810196420932552168708937019691994681052660068275906973480617604535381306041583841106383688654426129050931519275383386503174076258645141589911492908993r = 10269028767754306217563721664976261924407940883784193817786660413744866184645984238866463711873380072803747092361041245422348883639933712733051005791543841d1 = gmpy2.invert( e , (p-1)*(q-1)*(r-1) )c1 = pow( m , d1 , n )from sympy.ntheory.residue_ntheory import nthroot_modc = nthroot_mod( c1 , 2 , r )print( c )print( long_to_bytes( c ) )
add.在其他师傅的wp上摘到的Tonelli–Shanks算法 求解二次平方根
import gmpy2from Crypto.Util.number import *def legendre(a, p):    return pow(a, (p - 1) // 2, p)def tonelli(n, p):    assert legendre(n, p) == 1    q = p - 1    s = 0    while q % 2 == 0:        q //= 2        s += 1    if s == 1:        return pow(n, (p + 1) // 4, p)    for z in range(2, 10000):#    for z in range(2, p):        if p - 1 == legendre(z, p):            break    c = pow(z, q, p)    r = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    t2 = 0    while (t - 1) % p != 0:        t2 = (t * t) % p        for i in range(1, m):            if (t2 - 1) % p == 0:                break            t2 = (t2 * t2) % p        b = pow(c, 1 &lt;&lt; (m - i - 1), p)        r = (r * b) % p        c = (b * b) % p        t = (t * c) % p        m = i    return rn=7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409d=gmpy2.mpz(7515987842794170949444517202158067021118454558360145030399453487603693522695746732547224100845570119375977629070702308991221388721952258969752305904378724402002545947182529859604584400048983091861594720299791743887521228492714135449584003054386457751933095902983841246048952155097668245322664318518861440)cipher=1618155233923718966393124032999431934705026408748451436388483012584983753140040289666712916510617403356206112730613485227084128314043665913357106301736817062412927135716281544348612150328867226515184078966397180771624148797528036548243343316501503364783092550480439749404301122277056732857399413805293899249313045684662146333448668209567898831091274930053147799756622844119463942087160062353526056879436998061803187343431081504474584816590199768034450005448200#python2 -m primefac -vs -m=p+1  7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409p=gmpy2.mpz(102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393)q2=gmpy2.invert(d,p**2)for i in range(1000000):	q=gmpy2.iroot(q2+i*p**2,2)	if(q[1]==1):		print q[0],i		breakq=q[0]r=n//p//qe=0x10001phi=(p-1)*(q-1)*(r-1)D=gmpy2.invert(e,phi)c=pow(cipher,D,n)print cm=tonelli(c,r)print mprint long_to_bytes(m)#flag&#123;fd462593-25e4-4631-a96a-0cd5c72b2d1b&#125;

[De1CTF2019]babyrsatag: 共膜攻击 | 低密度指数攻击 | 暴力分解 | e,phi不互质pro
import binasciifrom data import e1,e2,p,q1p,q1q,hint,flagn =  [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L]c =  [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L]f=lambda m,e,n,c:pow(m,e,n)==cassert(sum(map(f,[p]*4,[4]*4,n,c))==4)ee1 = 42ee2 = 3ce1 =  45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384ce2 =  13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158tmp =  864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387n  =  15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039assert(pow(e1,ee1,n)==ce1)assert(pow(e2+tmp,ee2,n)==ce2)e = 46531n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469hint=int(binascii.hexlify(hint),16)assert(q1p*q1q==n)assert(q1p&lt;q1q)assert(c==pow(hint,e,n))flag=int(binascii.hexlify(flag),16)q1=q1pq2 =  114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513c1 =  262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124c2 =  7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596assert(c1==pow(flag,e1,p*q1))assert(c2==pow(flag,e2,p*q2))

对于第一部分：使用共膜攻击即可
前置知识：

lambda:相当于一个函数，表达式为 函数名=lambda 输入值:函数式，常搭配map使用
map:表达式为map(函数名,输入值)，返回函数名对应的函数式的结果

翻译一下，原式相当于 $p^4\equiv\ c_i\ mod\ n_i$
通过四组 $c_i\ n_i$ 利用中国剩余定理即可求出 $p^4$ ，然后开根即可
def CRT( r , p ):    M = 1    for i in p:        M *= i    m = []    for i in p:        m.append( M // i )    ans = 0    for i in range( len(p) ):        ans += r[i] * m[i] * invert( m[i] , p[i] )        ans %= M    return ans#part1 共膜攻击def part1():    n =      c =      p4 = CRT( c , n )    p = iroot( p4 , 4 )[0]    #print( p )    return p
对于第二部分：使用低密度指数攻击
$e1\ e2$很小，所以可以直接爆破
import gmpy2k = 0while True:    if gmpy2.iroot( ce1 + n*k , ee1 )[1] == True:        e1 = gmpy2.iroot( ce1 + n*k , ee1 )[0]        break    k += 1print( e1 )k = 0while True:    if gmpy2.iroot( ce2 + n*k , ee2 )[1] == True:        e2 = gmpy2.iroot( ce2 + n*k , ee2 )[0] - tmp        break    k += 1print( e2 )
得到
e1 = 15218928658178e2 = 381791429275130
也可以使用先估计 $k$ 范围的做法
已知$(e2+tmp)^{ee2}=ce2+k*n$
发现ee2=3，考虑低密度指数攻击
计算print( tmp**3 / n )
得到40545.874109734694
因而可以穷举k，可以得到$e2+tmp$
对于前一半，运行print( len(str(ce1)) , len(str(n)) )；发现相差五十多位，是个小概率事件；所以认为与n无关，可以直接开根
#part2 低密度指数攻击def part2():    ee1 = 42    ee2 = 3    ce1 =     ce2 =      tmp =      n  =      print( tmp**3 / n )     for k in range( 40000 , 41000 ):        if iroot( ce2 + k*n , ee2 )[1]:            e2 = iroot( ce2 + k*n , ee2 )[0] - tmp             break    #print( e2 )        #print( len(str(ce1)) , len(str(n)) )    e1 = iroot( ce1 , ee1 )[0]    #print( e1 )    return e1 , e2
对于第三部分：直接分解即可
def part3():    e =     n =     c =     p =     q =     phi = (p-1)*(q-1)    d = invert( e , phi )    hint = pow( c , d , n )    print( long_to_bytes( hint ) )    return min( p , q )
得到hint:b&#39;orz...you.found.me.but.sorry.no.hint...keep.on.and.enjoy.it!&#39;（和flag并无关系）
对于第四部分：
已知p , q1 , q2 , e1 , e2，但是 e1 , e2 和 phi1 , phi2 不互质，无法正常求私钥 d
一般来说遇到这种情况都是让 $e$ 除去其与欧拉函数的最大公约数，让这两个数重新互质，然后求 $m^{gcd(e,\phi)}$的值
a = gcd( e1 , (p-1) * (q1-1) )b = gcd( e2 , (p-1) * (q2-1) )print( a , b ) 
得到 $a=14,b=14$，发现 $m^{14}$ 的幂次比较高，不好处理
 $(m^{2})^{7}=m_1\ mod\ q_1\ (m^{2})^{7}=m_2\ mod\ q_2$
$(m^2)^7\%(q1q2)$组成一个新的rsa解密，$e=7\ ,\ n=q1q2\ ,\ m=m^2\ ,\ c=m^{14}$
reference:
https://blog.csdn.net/a5555678744/article/details/117308377
https://blog.csdn.net/qq_57235775/article/details/131167215
n =  [ q1, q2 ]a = gmpy2.gcd(e1,(p-1)*(q1-1))b = gmpy2.gcd(e2,(p-1)*(q2-1))c = [ gmpy2.powmod(c1,gmpy2.invert(e1//a,(p-1)*(q1-1)),q1)    , gmpy2.powmod(c2,gmpy2.invert(e2//b,(p-1)*(q2-1)),q2)]M = n[0] * n[1]m = [0]*2inv = [0]*2x = 0for i in range(2):    m[i]=M//n[i]    inv[i]=gmpy2.invert(m[i],n[i])    x+=(c[i]*inv[i]*m[i])x = x % Me=7d=gmpy2.invert(e,(q1-1)*(q2-1))flag=gmpy2.iroot(gmpy2.powmod(x,d,q1*q2),2)[0]print(long_to_bytes(flag))
flag:de1ctf&#123;9b10a98b-71bb-4bdf-a6ff-f319943de21f&#125;

[DASCTF Sept X 浙江工业大学秋季挑战赛]签到#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *import randomflag=b&#x27;flag&#123;******************&#125;&#x27;n = 2 ** 256flaglong=bytes_to_long(flag)m = random.randint(2, n-1) | 1c = pow(m, flaglong, n)print(&#x27;m = &#x27; + str(m))print(&#x27;c = &#x27; + str(c))# m = 73964803637492582853353338913523546944627084372081477892312545091623069227301# c = 21572244511100216966799370397791432119463715616349800194229377843045443048821

discrete_log()使用示例：
&gt;&gt;&gt; from sympy.ntheory import discrete_log&gt;&gt;&gt; discrete_log(41, 15, 7)3
即 $7^3\equiv 15(mod\ 41)$
import sympyimport binasciim = 73964803637492582853353338913523546944627084372081477892312545091623069227301c = 21572244511100216966799370397791432119463715616349800194229377843045443048821n = 2 ** 256flag=sympy.discrete_log(n,c,m)print(binascii.unhexlify(hex(flag)[2:]))
flag:flag&#123;DASCTF_zjut&#125;
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cryptoCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CS2025参会游记</title>
    <url>/2025/05/17/CS2025%E5%8F%82%E4%BC%9A%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de542d676cb326d0c5d6a10c6353002e1c857d400123ac95c955b82c9a27c938fe6272a98c0e32cec6e393fe8f9eec356e2a6c241e30fb6422803d97d1c60f1d1b4f731c0251f3851cd9bb88bf8eccbc1704b16a372922f03402096fd78f2f7acfaf8f75ea22be1ef2fc20fee85ec69f949c74f6ec5848ecbd05cf228684901fe99f5f2cdeb3b0d1f2f3de79b3977b4df94e5794f825f949e67c26f7efe1061de9434d87d0e809c706396d2f6427e599ac648e41f8491141e2ea714fc3b06783b74b2ccc11f702039aa608aa360c5899871f935c452fed0adf199978ecc6cb799f4e64d3f1aefeb7123b72b44a56f937dc58a56d298060a8921010ccc5f624877541633246f68b87181ba0e4fedf6d05dba9ed585c440968067e83d22276e4ad10bd1f34c21678edb06e758a26560f8e03f2afb3637154d75050ceb8a2c267ff0bf51249c4b22a25761b4632d7e3b0426f6c18c50e6ab843c8aad0c977e8ed28c20f0f84499db0af6f8c4f834b83ffb8bc4d521cff5668e6248a7fd2dd59723191ab07b4712e2411a2822bc53e9bfdd6a4a51f753fdf15fb053ed24f8c70c249826c94f09e1105bb81a4708d6434ae6333515f3fcdd4c32d051a928101b1af16fdd12a3ea5f6a87fc42928a6638fe752fc6afe449da331e76e0b3d82eec070f4b4ea6f015543de15ca576b127d5fbc018cc899c97fbf02e4c6cb19d56091ed11081b579c351aabd7b58975dbd9da5c7e125101c516b5cedda6abd2c40390c863a3b6943091759be92c39f8207a3115729c468b9901b0e4132ac505dba949960504abe277447088d5e3dcb02706229afc09f0c6150f34f5e9fac329d060e229eb253f65527db35d3ec962e0b72a2ca53d8d8195d8b75b0fe957a7f0cd798b7b955669f6b10bdcede0e59b1710e3f71f8771062a5ee3b1ea1267506e91e3b448397ec381c6eae0aa6c6a8a3e92a53d10797c7fd2b1ac8ebbaa917a5606dabbbb6d9f489ab029154aea84619368c6d92f308fda94eede11649a547a68b2c7812b2f0cb98a15507fae2ad0e7706c5dfeb6afb6fd7beeca71bbf1a7e6ac9db79200b5b499e574be33dba5b930ef0ba7b84a7265733f4f196de49f0196e02f17f1add4c78cfcdd5a29504c0a949607ef8d98996b1e40215639497a4103621e44227439e6b19063b827ff2cd5dea33d94eb37a9127c18b6b9afd27ccae240974419f8b7d1703009fef854721ee86f9fdf47dc6a60b0ed935d1bbde4a16d0746b8b924367fb9a125b0b691deeb84509c201716b350e8e8d78bbf85d54fc7660be412ca619e3e658c1cee499bd48046850ff90353f7ca1b3844ebc6d55bacc3c5ed78314faf652d409ab2aaf8453850111679ac879b95069a9d1c72b7d4ee9e158e78b0382b65f8a6e5ad60f12a085162f11fd54fd8190d2b3eb3b383f25ed3839d99a29ac3d824428dc6d14b1a76a22445baabdb9cda5d93f305324dc35162e0a16614a81f67f4f4f9928cf0fbada33073edde8d737e44f997f8101905bb665c7617ea4084c3a22791f076420a3d4bd2d8344c1c687cf7a0349ff0461345eff76ac61180078f28d7d5f1adeea74eaf7fc6341124461785d53f8615880b2c424e63deb72e01012ff2ef840b17579980e9d2b6a769cd0969d0bc1faaa85671d02a32edc8eede6a0ae4d572d4b418b9bc50aa1864c2196babf19fa370615f84f99cf3f643187fb6b036873df906c0c45b4fd03e04d303c2001c552e05f7704187d26f004498d3f756a435c12c87214262eddb503d49162e7f5d376f963d9e95cea8cab55f860b2f39a6b27e068eef376adb1e856b9e7d4e1493aa8670fa045536121de103c7b570ab1f0735b9c1cc6f40aace50347e3df30c3b54804f5ea40680ed082a88747f7c0aeb656dfb50e464a0f5386bec6e1e64ddb7ba9456fc738c43aa02c9d73bee6728c6e8f5dfab8828c337d8408e4d7c09294879b3243763f70c4e3cf2c509116a5186d9d9540936a0fd8e17aca5d4bca6eab2843d11d361627d78f9160a905f5ec5d8355a1c1e69cec92a7ad07207ffe7d000accba77b5d781f2c90df53a03433df9fbe237830281114beb40752245361e1c8a8b6a61ad782c1e61c1959f60df34912e43f1a84e9532bf263e846f4b9bd56be3e688dc2c2bdb98e33067f74c8266072e51f79ba40d567e896fb7ac5ed97c1c55c538dcfa7336c2df5abd117f20e256e938f766dd012866f28ed6cf26140dbde556984cf0cc89f02e67eb666ab7609f3a799ed0e51dc05f61884d8cd5f80c017e4624fa0ce778c7d13d33f36f7c0b8ed1151e21a0d3b6ae9749a686905adb14ad1d4ae30a7290abaa8a1c6c648fc9b72582821a64f38abedffddfe089095f0c9ab091c0173b4f7448cd99ae6d01f6fa58acfe9bb78d10ae5805b14118b82536b6e9bc87b08a1f7ff78ce4acd1ec5a178f590b4604929907a4acc85fd62be5ee2b27b8caf875996e1a9f18da998a2e017c7888b63a298912ac91f7ad85523f6096d61ef4430c897b2dd2e0b1fc52b19e958013c24c8f9a80ae37b849895a89151a6b78ad7242d36db0045ec213d9e0bf945d2cac37a9013561f3dda9c07b76c7486e9d19ea18e08c905941d001a81490b72ab3803f049094031ee962eeb03e32185b088951a78153fc67ff5a41defb641ba4db2e8ff1d26275cf1c9878e98b54b251cbfd2006245e4cce71e6fae08f7536a22334aff3e9431095975f55f3dc18a05e7bc75dba5d395d7b4d35b6715822492cc14ca478eed0510079c26056f5c0a3a34a7396c1bcf8fa492796fc4aae7c5444ddf0265129091cccc466501c7cb1531579ae0184273d14d6e33a16626f6f26f88cea3f347fadbbe7fcb5e33bb4de2bd10f99a991b9044f823ddc8948cbc8898af1680d03cac325afedac8a4ed61ec8c78227a8af4d565f727cc46a1d94562c162cc82b50b1057bd05f18e9e9e93aad91e93b9834c8c37f1d7b055ebcc319c7a80fac256ee3172197fc09913c1bda1c132be59676560fc7273bcc1294a12f9cb961bd70552de074c7270098d03a0ea1c002c4f62c14e9c856cfd2266f59468b8ee06092219565f493698c336d6ed25ff14785fa13be693f6fcd08977b10e7efe7605ac61e5ffdabdc7a65add8d626dc72675a6c03a673063ad4514b5240b031345b854c4c385285ceb385b67
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CS2025摘要小结</title>
    <url>/2025/05/19/CS2025%E6%91%98%E8%A6%81%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[本文对第九届网络空间安全国际研讨会的分享知识进行小结
相关链接：会前准备 会后游记 拍照备份


会议议程
主要笔者学习内容图像篡改定位模型对抗Motivation：AI兴起，虚假图像合成的成本大幅降低。本报告旨在检测篡改部位
Solution：使用深度网络，训练模型。有效检测篡改
新的攻击方案：给照片加噪音，人眼看不出区别，但使用原有检测方案 难以检测篡改
总结：安全领域，对抗是永恒的；AI的产生增加了对抗，也增加了弱点；在研究中，应当攻击方白盒，防守方黑盒
态势感知Motivation：国内网民众多，且信息多模态难以处理。传统处理算法的时间复杂度为指数级（响应速度为分钟级）
Solution：利用关联信息进行优化（例如分块，关注敏感话题等），时间复杂度变为多项式级别（响应速度达到秒级）
应用：检测并控制舆情，护网等
备注：该报告的PPT做得十分优异，有待借鉴学习
安全云存储Motivation：云数据库存在被服务提供商或攻击者窥探的可能性，查询语句和数据关系可能泄露敏感信息
Solution：

面临挑战：数据关系隐私保护（如 JOIN 隐私）；功能性与隐私性的平衡难题；泄露抵抗机制优化（如访问模式隐藏）；差分隐私与SQL的融合应用；模糊搜索技术集成与拓展
备注：该老师用的是纯英文演讲，所以只能录屏后在学习，故而理解可能有不准确的地方
大语言模型越狱Motivation：攻击者如何让AI回答例如如何毁灭人类，或者制造凝固汽油弹之类的问题；开发者如何让AI避免回答这些问题
三个发现：增加奇奇怪怪的后缀可能绕过；简单越狱方法叠加使用增加成功概率；就算没有敏感问题也有可能被拒绝回答
一些哲学思考：威胁AI会鲨掉他，或者给AI小费，可以增大越狱可能性。AI越来越像人了
口令认证密钥协商Motivation：传统使用PKI和证书进行认证，使用口令（便于记忆，无需存储）则不需要
一个令我拍手叫好的构造：使用一步对称加密，有效防止中间人攻击

Contribution：构造了一个高效的后量子aPAKE协议（基于KEM）；基于同源构造了Strong aPAKE且UC安全（也是抗量子）；使用串并行构造了HPAKE

]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Chameleon Hashing and Signatures阅读笔记</title>
    <url>/2024/09/07/Chameleon%20Hashing%20and%20Signatures%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[文献简介标题：Chameleon Hash and Signatures
作者：Hugo Krawczyk , Tal Rabin

期刊：无
年份：1998
重要程度：4
摘要
引入变色龙签名，提供不可抵赖签名（和常规数字签名一样）
不允许接收方在未经允许的情况下向第三方披露明文（和不可抵赖签名相关，但是算法简单和高效实现）
本质上不交互，不涉及零知识证明的设计和复杂性（传统不可抵赖签名基于零知识证明）。哈希函数的产生通过标准的hash then sign
此哈希函数 对签名者是抗碰撞的，但是对于接收者是碰撞可控的
构造变色龙哈希函数，可以基于很多标准密码学假设（数学困难问题）

引言背景介绍


研究的目的和意义（课题开展的原因）
重要结果/结论


研究内容作者新发现
作者研究对象


研究意义理论价值
应用价值


能解决的难题
研究方法

作者使用的方法
有没有更好的方法


哪些是我还需要学习的
思考

对我的课题有什么启发
作者是怎样做到比前人好的


能否想到其他方法能达到和作者一样或更好的的效果
总结（思维导图）

文章关键词/年份/期刊

标题Title
网络连接


背景Background
What’s known
What’s news
虽然之前研究证明了……，但是……还没被研究过/存在争议


What’s are the implication


实验方法Methods
实验结果Results
逻辑重点：这一部分为了验证什么假设——研究结果



启示Inspirations

边读 边思考 边补充

“不允许接收方在未经允许的情况下向第三方披露明文”，其中disclose指的是“披露并证明”
接收方即便知道消息和相应的哈希值，他们依然无法向第三方证明或验证消息，因为他们没有生成碰撞的能力。这意味着接收方无法凭借手中的消息和哈希值向第三方揭露原始消息的真伪。
更进一步，如果接收方试图向第三方泄露消息和哈希值，生成者可以在拥有私钥的情况下创建一个新的碰撞消息，使得第三方无法确定哪个消息是真实的。因此，即使接收方试图透露明文，也会被生成者的碰撞消息所混淆，从而使明文的真实性存疑。

读的时候不懂的需要请教他人先记下来

对自己的论文选题头脑风暴
对自己的研究有启发（如图片好看可以借鉴，行文逻辑可以借鉴为模板，研究思路需要再琢磨下）


回过头思考和复盘
这篇文章最大的亮点是什么
为什么他们可以发刊
对于我的研究课题/科研思路有何借鉴
挑挑毛病






在精读每一篇密码学论文时，以下问题可以帮助你深入理解论文的内容，并确保你对论文有全面的把握：

研究的主要问题是什么？

论文试图解决的核心问题或挑战是什么？
该论文研究了如何将基于身份的加密应用于变色龙哈希函数，并介绍了第一个基于身份的变色龙哈希方案。主要解决的问题是密钥分发的复杂性及其在变色龙签名中的应用。



该论文的主要贡献是什么？

论文提出了首个基于身份的变色龙哈希函数，解决了公钥拥有者不需要检索关联的秘密密钥的问题。该哈希方案用于构建基于身份的变色龙签名，还应用于一个鲁棒且通信高效的密封投标拍卖方案。提出了哪些新方法、新算法或新协议？


现有的解决方案有哪些不足？

传统的变色龙签名方案要求接收者管理复杂的公钥基础设施（PKI）和密钥分发。而基于身份的加密消除了对证书和密钥分发中心的依赖，简化了操作。


论文采用了哪些理论工具或模型？

论文使用了基于身份的密码学（如Shamir提出的方案）和变色龙哈希函数，结合了哈希-签名范式。还使用了RSA签名等经典加密工具来验证哈希函数的安全性。


研究方法和技术细节是什么？

研究提出了一种新的ID-based变色龙哈希方案，并详细介绍了其哈希算法、伪造算法及其安全性分析。该方案采用公开的身份字符串生成公钥，避免了复杂的密钥管理流程。


论文的假设条件是什么？

假设用户的身份可以由公开的、唯一的身份字符串描述，如电子邮件地址，且信任的第三方可以安全生成并管理密钥。安全性依赖于RSA签名的不可伪造性。


论文的结果和结论是什么？

论文验证了该基于身份的变色龙哈希方案的安全性，并成功应用于密封投标拍卖中，展示了其在实际应用中的高效性和鲁棒性。


该研究有哪些局限性？

论文未深入探讨其方案在多方协作环境中的扩展性和潜在的安全风险，比如当多个实体共享同一身份字符串时，可能会面临身份冲突问题。


参考文献中是否有关键文献？

论文引用了关于变色龙签名和基于身份加密的基础性研究，如Krawczyk和Rabin提出的变色龙签名和Shamir提出的基于身份的密码学等。


未来的研究方向是什么？

未来研究可以进一步优化该方案在其他应用场景中的适用性，例如多方计算或其他安全协议中，同时探讨如何提升该方案的隐私保护性能。



]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 963 (Div. 2)题解</title>
    <url>/2024/08/05/Codeforces-Round-963-Div-2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[题目链接
本场比赛应该算是今年我打的第一场算法竞赛，也是NOIP2021结束之后难得发挥出来的比赛。ABC都是比较简单的题，D是二分+dp，比较难想
E最终还是不会，疑似是一个高级dp

A.Question Marks
观察样例就能打出来
#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;signed main()&#123;    int t;cin &gt;&gt; t;    while( t -- )&#123;        string s;int n;cin &gt;&gt; n;cin &gt;&gt; s;        int a , b , c , d , e;a = b = c = d = e = 0;        for(int i = 0;i &lt; s.length();i ++)&#123;            if( s[i] == &#x27;A&#x27; ) a ++;            if( s[i] == &#x27;B&#x27; ) b ++;            if( s[i] == &#x27;C&#x27; ) c ++;            if( s[i] == &#x27;D&#x27; ) d ++;            if( s[i] == &#x27;?&#x27; ) e ++;        &#125;        a = max( a-n , 0 );        b = max( b-n , 0 );        c = max( c-n , 0 );        d = max( d-n , 0 );        //cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl;        cout &lt;&lt; n*4-a-b-c-d-e &lt;&lt; endl;    &#125;    return 0;&#125;

B.Parity and Sum
策略是取出最大的奇数，和所有的偶数从小到大进行比较，如果比当前偶数大，那么将最大的奇数+=当前偶数，否则ans需要+1（仅加一次，此时表示当前最大的奇数不如这个偶数大，只需要进行一次最大奇数加上最大偶数的操作（即ans+=1）即可获得可以使任意偶数变为奇数的大数，如果最大的奇数从小到大累加偶数都能比下一个偶数更大则不需要进行这一步操作）
全奇全偶需要特判
#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;int t , n , a[200010];signed main()&#123;    cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n;        int ans = 0;        int lag_d = 0;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; a[i];            if( a[i] % 2 == 0 ) ans ++;            else lag_d = max( a[i] , lag_d );        &#125;        sort( a + 1 , a + n + 1 );        if( ans == n ) ans = 0;        if( ans )&#123;            for(int i = 1;i &lt;= n;i ++)&#123;                if( a[i] % 2 == 0 )&#123;                    if( a[i] &gt; lag_d )&#123;                        ans ++;                        //cout &lt;&lt; &quot;error: &quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; lag_d &lt;&lt; endl;                        break;                    &#125;                    else&#123;                        lag_d += a[i];                    &#125;                &#125;             &#125;        &#125;                cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;

C.Light Switches
首先可以确定，最终答案在[最大值,最大值+k]区间，如果这个区间没有答案，那么输出-1
k过大，直接扫肯定会超时；所以根据每个$a_i$计算它相应的区间（宽度为k，但是左右区间不同），然后将$l$取$max$，将$r$取$min$，如果$l&lt;r$那么答案就是$l$，否则没有答案
#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;int t , n , k , a[200010];signed main()&#123;    cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; k;        int maxn = 0;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; a[i];            maxn = max( maxn , a[i] );        &#125;        int l , r;l = maxn , r = maxn + k;        for(int i = 1;i &lt;= n;i ++)&#123;            int rat = (maxn - a[i]) / k;            if( rat % 2 ) rat ++;            l = max( a[i] + rat * k , l );            r = min( a[i] + rat * k + k , r );        &#125;        //cout &lt;&lt; &quot;demo: &quot;&lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;        if( l &gt;= r ) cout &lt;&lt; -1 &lt;&lt; endl;        else cout &lt;&lt; l &lt;&lt; endl;    &#125;    return 0;&#125;

以下题目结为赛后补题：
D.Med-imize
利用二分中位数，我们可以用 $log(max(a_i))$ 的代价使中位数由未知变为已知
观察得到一个结论——最终序列的 $id$ 总是在 $mod\ k$ 下能填满 $[0,n\%k]$，以此可以选择出最优化的一组解（正好填满 $[0,n\%k]$ ），即尽量多选大于中位数的选项，如果总共选到大于中位数的数字多余小于的，那么可以判断这组中位数是可以用的
最终输出最大的中位数即可
#include&lt;iostream&gt;#define int long longusing namespace std;const int N = 5e5;int t , n , k , a[N+10];int dp[N+10] , b[N+10];bool checker( int mid )&#123;    for(int i = 0;i &lt; n;i ++)&#123;        if( a[i] &gt;= mid )&#123;            b[i] = 1;        &#125;        else&#123;            b[i] = -1;        &#125;    &#125;    dp[0] = b[0];    for(int i = 1;i &lt; n;i ++)&#123;        if( i % k == 0 )&#123;#这一组的开头，如果前面的或者当前位置下有1就可以是1            dp[i] = max( dp[i-k] , b[i] );        &#125;else&#123;#直接选当前的，i不是第一个循环的话，则可以继承上一个循环的（反正是选最大值）            dp[i] = dp[i-1] + b[i];            if( i &gt; k )&#123;                dp[i] = max( dp[i] , dp[i-k] );            &#125;        &#125;    &#125;    return dp[n-1] &gt; 0;&#125;signed main()&#123;    cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; k;        for(int i = 0;i &lt; n;i ++)&#123;            cin &gt;&gt; a[i];        &#125;        int l = 1 , r = 1e9;        while( l &lt;= r )&#123;            int mid = (l+r)&gt;&gt;1;            if( checker(mid) )&#123;                l = mid+1;            &#125;            else&#123;                r = mid-1;            &#125;        &#125;        cout &lt;&lt; r &lt;&lt; endl;    &#125;       return 0;&#125;
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 964 (Div.4)题解</title>
    <url>/2024/08/07/Codeforces-Round-964-Div-4-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[题目链接

差一道题就ak了，打代码的速度还是慢了点

F时间不够了，于是随便糊了个时间复杂度不对的算法，结果算法对了，少了个预处理然后就TLE了，赛时没有发现
A.A+B Again?
#include&lt;iostream&gt;using namespace std;int t , n;signed main()&#123;    cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n;        cout &lt;&lt; (n/10)+(n%10) &lt;&lt; endl;    &#125;    return 0;&#125;

B.Card Game
直接穷举所有可能性即可
思路不是很难，就看如何实现了
#include&lt;iostream&gt;#define int long longusing namespace std;int t , a[5];signed main()&#123;    cin &gt;&gt; t;    while( t -- )&#123;        for(int i = 1;i &lt;= 4;i ++) cin &gt;&gt; a[i];        int l , r , ans = 0;        for(int i = 1;i &lt;= 2;i ++)&#123;            int ii = (i==1)?2:1;            for(int j = 3;j &lt;= 4;j ++)&#123;                int jj = (j==3)?4:3;                l = 0 , r = 0;                if( a[i] &gt; a[j] ) l ++;                if( a[i] &lt; a[j] ) r ++;                if( a[ii] &gt; a[jj] ) l ++;                if( a[ii] &lt; a[jj] ) r ++;                if( l &gt; r ) ans ++;                //cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; a[ii] &lt;&lt; &quot; &quot; &lt;&lt; a[j] &lt;&lt; &quot; &quot; &lt;&lt; a[jj] &lt;&lt; endl;            &#125;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;

C.Showering
典型贪心（弱化版）
数据范围可以 $O(nlogn)$，无脑sort就好了
#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 2e5;int t , n , s , m;struct TIME&#123;    int l , r;&#125;a[N+10];bool cmp( TIME x , TIME y )&#123;    return x.l &lt; y.l;&#125;signed main()&#123;    cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; s &gt;&gt; m;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; a[i].l &gt;&gt; a[i].r;        &#125;        sort( a + 1 , a + n + 1 , cmp );        bool flag = 0;        a[0].r = 0 , a[n+1].l = m;        for(int i = 1;i &lt;= n+1;i ++)&#123;            if( a[i].l - a[i-1].r &gt;= s )&#123;                flag = 1;                break;            &#125;        &#125;        if( flag ) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;    &#125;    return 0;&#125;

D.Slavic’s Exam
这里的匹配不需要连续，所以只要有?就直接替换就可以了，多余的?需要替换成任意小写字母
#include&lt;iostream&gt;#include&lt;string&gt;#define int long longusing namespace std;int T;string s , t;signed main()&#123;    cin &gt;&gt; T;    while( T -- )&#123;        cin &gt;&gt; s &gt;&gt; t;        int t_top = 0;        //cout &lt;&lt; s.length() &lt;&lt; &quot; &quot; &lt;&lt; t.length() &lt;&lt; endl;        for(int i = 0;i &lt; s.length();i ++)&#123;            if( t_top == t.length() )&#123;                if( s[i] == &#x27;?&#x27; ) s[i] = &#x27;a&#x27;;                continue;            &#125;            if( s[i] == &#x27;?&#x27; || s[i] == t[t_top] )&#123;                s[i] = t[t_top];                t_top ++;            &#125;        &#125;        if( t_top != t.length() ) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        else&#123;            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            cout &lt;&lt; s &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;

E.Triple Operations
这道题开始上难度了
先说结论，$ans=log_3(min(a_i))+\sum log_3(a_i)$
容易观察到，我们只需要将其中一个数变为0，后续将数字除以3（减小）的时候不会造成其他数字乘以3（增大），我们只需要将最小的数变为0就可以，但是同时也会有另外一个数字增大，这时造成的代价即为$log_3(min(a_i))$
现在只需要计算 $log_3(min(a_i))+\sum log_3(a_i)$ ，即$log_3l+\sum_l^r log_3(a_i)$ 
我们观察到从 $l$ 到 $r$ 是单调的，所以利用指数即可在 $O(logn)$ 求解
#include&lt;iostream&gt;#include&lt;string&gt;#define int long longusing namespace std;int T;int l , r;int log3( int x )&#123;    int ans = 0;    while( x )&#123;        x /= 3;        ans ++;    &#125;    return ans;&#125;int poww( int x )&#123;    int ans = 1;    while( x -- )&#123;        ans *= 3;    &#125;    return ans;&#125;signed main()&#123;/*    for(int i = 1;i &lt;= 100;i ++)&#123;        cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; log3(i) &lt;&lt; endl;    &#125;    return 0;*/    cin &gt;&gt; T;    while( T -- )&#123;        cin &gt;&gt; l &gt;&gt; r;        /*        int ans = log3(l);        for(int i = l;i &lt;= r;i ++)&#123;            ans += log3(i);        &#125;*/        int ans = log3(l)+log3(r) , log_i , jumper;        for(int i = l;i &lt;= r;i ++)&#123;            log_i = log3(i);            jumper = poww( log_i );            //cout &lt;&lt; &quot;jumper: &quot; &lt;&lt; jumper  &lt;&lt; &quot; |ans: &quot; &lt;&lt; ans &lt;&lt; endl;            if( jumper &lt; r ) ans += (jumper-i)*log_i , i = jumper-1;            else ans += (r-i)*log_i , i = r;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;

F.Expected Median
假设 $1$ 有 $x$ 个，$0$ 有 $y$ 个，那么 $ans=\sum (C_x^i+C_y^{k-i}) $，即从 $x$ 中选 $i$ 个，从 $y$ 中选 $k-i$ 个的所有可能，其中 $i$ 需要满足 从 $x$ 中取出的元素多余从 $y$ 中取出（即 $1$ 比 $0$ 多，这样的中位数才能是 $1$ ）
计算组合数需要用阶乘，记得预处理（悲
#include&lt;iostream&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 , p = 1e9+7;int T , n , k;int a[N+10];int num_0 , num_1;int jc[N+10];void init()&#123;    jc[0] = 1;    for(int i = 1;i &lt;= N;i ++)&#123;        jc[i] = jc[i-1]*i;        jc[i] %= p;    &#125;    return ;&#125;int qpow(long long a, int b) &#123;  int ans = 1;  a = (a % p + p) % p;  for (; b; b &gt;&gt;= 1) &#123;    if (b &amp; 1) ans = (a * ans) % p;    a = (a * a) % p;  &#125;  return ans;&#125;int inv( int x )&#123;    return qpow( x , p-2 );&#125;int C( int nn , int mm )&#123;    int ans = 1;    ans *= jc[nn];    ans %= p;    ans *= inv(jc[mm]);    ans %= p;    ans *= inv(jc[nn-mm]);    ans %= p;    return ans;&#125;signed main()&#123;    init();    cin &gt;&gt; T;    while( T -- )&#123;        cin &gt;&gt; n &gt;&gt; k;        num_0 = num_1 = 0;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; a[i];            if( a[i] ) num_1 ++ ; else num_0 ++;        &#125;        int ans = 0;        for(int i = min(num_1,k);i&gt;k/2 and (k-i)&lt;=num_0;i --)&#123;            //cout &lt;&lt; num_0 &lt;&lt; &quot; &quot; &lt;&lt;  k-i &lt;&lt; &quot; &quot; &lt;&lt; num_1 &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;            ans += C( num_0 , k-i ) * C( num_1 , i );            ans %= p;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;

G1.Ruler (easy version)
简单的二分法
#include&lt;iostream&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 , p = 1e9+7;int T , t;int ef( int l , int r )&#123;    if( l == r ) return l;    int mid = (l+r)&gt;&gt;1;    cout &lt;&lt; &quot;? &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;    cout &lt;&lt; flush;    int t;    cin &gt;&gt; t;    //int redder = mid + ( mid&gt;=100?1:0);    //t = redder*redder;    if( t == (mid+1)*(mid+1) ) return ef( l , mid );    else return ef( mid+1 , r );&#125;signed main()&#123;    cin &gt;&gt; T;    while( T -- )&#123;        int ans = ef( 2 , 999 );        cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; endl;        cout &lt;&lt; flush;    &#125;    return 0;&#125;

G2.Ruler (hard version)
三分法，写法有很多，七次询问可以确定一个数即可
#include&lt;iostream&gt;#include&lt;string&gt;#define int long longusing namespace std;const int N = 2e5 , p = 1e9+7;int T , t;int ef( int l , int r )&#123;    if( l == r ) return l;    int mid_l = l+(r-l)/3 , mid_r = l+(r-l)/3*2;    cout &lt;&lt; &quot;? &quot; &lt;&lt; mid_l &lt;&lt; &quot; &quot; &lt;&lt; mid_r &lt;&lt; endl;    cout &lt;&lt; flush;    int t;    cin &gt;&gt; t;/*    int lll = mid_l + ( mid_l&gt;=700?1:0);    int rrr = mid_r + ( mid_r&gt;=700?1:0);    t = lll*rrr;*/    if( t == (mid_l+1)*(mid_r+1) ) return ef( l , mid_l );    else if( t == (mid_l)*(mid_r+1) ) return ef( mid_l+1 , mid_r );    else return ef( mid_r+1 , r );&#125;signed main()&#123;    cin &gt;&gt; T;    while( T -- )&#123;        int ans = ef( 2 , 999 );        cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; endl;        cout &lt;&lt; flush;    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 965 (Div. 2) 题解</title>
    <url>/2024/08/11/Codeforces-Round-965-Div-2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[题目链接
逆天抽象局，ab都是构造题，


A. Find K Distinct Points with Fixed Center
#include&lt;iostream&gt;#define int long longusing namespace std;int t , x , y , k;signed main()&#123;    cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;        if( k % 2 )&#123;            cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;            for(int i = 1;i &lt;= (k-1)/2;i ++)&#123;                cout &lt;&lt; x-i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;                cout &lt;&lt; x+i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;            &#125;        &#125;        else&#123;            for(int i = 1;i &lt;= k/2;i ++)&#123;                cout &lt;&lt; x-i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;                cout &lt;&lt; x+i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;            &#125;        &#125;    &#125;    return 0;&#125;
B. Minimize Equal Sum Subarrays
#include&lt;iostream&gt;#define int long longusing namespace std;const int N = 2e5;int n;int a[N+10];signed main()&#123;    int t;cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; a[i];        &#125;        for(int i = 2;i &lt;= n;i ++)&#123;            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;        &#125;cout &lt;&lt; a[1] &lt;&lt; endl;    &#125;    return 0;&#125;
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>DCIC2025作品赛游记</title>
    <url>/2025/05/06/DCIC2025%E4%BD%9C%E5%93%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[数字中国2025也算告一段落了
感谢师兄们的无私帮助和师弟的不懈打杂（bushi），最终获取优胜奖（翻译：参与奖）


比赛最一开始，导师问我要不要打这个比赛，用可修订区块链；我一听，诶又有师兄带飞了？那包要打的哇，然后答应了下来
后来线下讨论，才发现师兄们太忙了，这个次是我带队（哭哭
后来意识到，感觉我这队好像是来凑数的~ 毕竟是自己学校承办的比赛，所以参赛人数还是不能少的。不过毕竟是自己导师交给自己的任务，还是得好好干
好在老师给我找了个大一的学弟，帮我分担了些文档工作——写得还很不错
不过我头一次做PPT，做的一坨，狠狠改了一个星期，终于有点模样了~
给老师看了一下，老师没说什么——那就是可以（嘻嘻），提交~
然后把github仓库改成了只读
等出成绩那天，莫名其妙入围了。我头顶一个大大的问号~

把喜报告诉了队友，取消仓库的只读状态，然后继续狂肝吧~
师兄指导了一下，又改了好久的PPT，然后交给老师，老师还给指导了很多（老师：你是怎么入围的。我：我也不知道哇（哭）），最后尽管差强人意，不过也差不太多了
最终展示的时候，PPT大致中规中矩的样子，答辩问了一些问题确实难住我了

基于可修订区块链的网络和传统数据库有什么差异？我当时答的好像是分布式，Web3.0下的，感觉问题不大
有没有什么专利？我想了半天回答确实没有。后来师兄告诉我那个专家是企业的，论文比专利难，专利是横向，论文是纵向，学到了~
和传统区块链实现上有什么不同？我还没学区块链网络的体系结构呢~然后回答的是变色龙哈希的构造（嘻嘻那篇论文我还是看过的），这个勉强算是答上来了
区块链的优势在于不可修改，但是可修订区块链没有这一优势了岂不是。我当时确实没想好怎么回答，然后就和稀泥~说优势在于监管和隐私平衡。当天晚上老师说这个问题可以用19年一篇S&amp;P（基于投票的变色龙哈希）回答，也没有中心机构，我恍然大明白。后续读论文，又遇到了许可链的应用和其他可修订区块链的可行实现优势，感觉那时候确实阅历太狭隘了

无论如何比赛结束了，还是混到了个奖~
下次好好多读论文，再也不做PPT了（哭哭），做PPT好累~
唉唉该做还是要做的，只不过中心放在科研上了该，那两个星期光肝PPT了，别的啥也没做
还有就是确实收获到很多师兄和老师给的指导，记下来了，以后没准还能用到
现在这个仓库正式改为已读了

下次比赛再见~
]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>ElGamal是个啥子玩意</title>
    <url>/2024/09/28/ElGamal%E6%98%AF%E4%B8%AA%E5%95%A5%E5%AD%90%E7%8E%A9%E6%84%8F/</url>
    <content><![CDATA[很早之前就听说ElGamal加密算法是一种公钥密码，但是具体实现和用途不甚了解，今天阅读了 A PUBLIC KEY CRYPTOSYSTEM AND A SIGNATURE SCHEME BASED ON DISCRETE LOGARITHMS 一文，故去了解了一下。特开此文，记录一下

省流：ElGamal是DH密钥交换的抵抗中间人攻击版本

ElGamal加密算法是一个基于DH密钥交换的非对称算法，可以定义在任何循环群上，它的安全性取决于循环群上的离散对数难题
离散对数问题指的是：

已知 $a,b,n$ ，计算$ a^b\mod n$ 是简单的。
已知 $a,(a^b\mod n),n$ ，计算 $b$ 是困难的。

Diffie-Hellman 密钥交换过程：

Alice 和 Bob选定一个素数 $p$ ，以及它的一个原根 $g$ 
Alice 选择一个密钥 $a$ ，计算 $A=g^a\mod p$ ，发给 Bob 
Bob 选择一个密钥 bb ，计算 $B=g^b\mod p$ ，发给 Alice 
Alice 计算 $s=B^a\mod p$ ，Bob 计算 $s=A^b\mod p$这样，Alice 和 Bob 就共享了一个密钥 $s=g^{ab}\mod p$ 

通俗理解：在调色板上将两种颜色混合容易，而将两种颜色分开是困难的。

由于离散对数问题是一个数学困难问题，在选择了合适的 $p$ 和 $g$ 时，Diffie-Hellman 密钥交换协议被认为是 $\textcolor{red}{窃听安全}$ 的。攻击者 Eve 在已知 $p, g, (g^a\mod p), (g^b\mod p)$ 的情况下，难以计算出 $s=g^{ab}\mod p$
 $\textcolor{red}{缺陷:无法抵抗中间人攻击}$ 
DH 本身没有提供任何身份认证，因此容易遭受中间人攻击：

中间人 Eve 假装自己是 Bob 与 Alice 通信 $s_1=g^{ac}\mod p$ 
中间人 Eve 假装自己是 Alice 与 Bob 通信 $s_2=g^{bc}\mod p$ 
Eve 将 Alice 发来的消息用 $s_1$ 解密，使用 $s_2$ 加密，发送给 Bob 
Eve 将 Bob 发来的消息用 $s_2$ 解密，使用 $s_1$ 加密，发送给 Alice 
Alice 和 Bob 对此一无所知，还无知地以为在与对方通信

需要一种能验证通信双方身份的机制 (如签名) 来防止这类攻击

ElGamal 加密算法：
本质上就是用 DH 获得一个密钥，然后用它加解密消息。
密钥生成：

Alice 和 Bob 选定一个素数 $p$ ，以及它的一个原根 $g$
Alice 选择一个私钥 $X_A$ ，计算公钥 $Y_A=g^{X_A}\mod p$，公开
Bob 选择一个私钥 $X_B$ ，计算公钥 $Y_B=g^{X_B}\mod p$ ，公开

假如 Bob 要给 Alice 发送一条消息 $m$ ，加密过程：

Bob 计算密钥 $k=(Y_A)^{XB}\mod p=g^{X_AX_B}\mod p$ 
Bob 发送 $c_1=Y_B, c_2=k\cdot m\mod p$

Alice 收到密文，解密过程：

Alice 计算密钥 $k=(c_1)^{X_A}\mod p=(Y_B)^{X_A}\mod p=g^{X_AY_A}\mod p$
Alice 解密消息 $m=(c_2\cdot k^{−1})\mod p$

实现代码：
from Crypto.Util.number import *p = None ; g = Nonepub = None#公钥也是公共可见的c = None#加密方加密后并传输给解密方的密文，这个也是可以被攻击者截获的#初始化，公共可见的大素数和生成元def init():    global p , g    p = getPrime(512)    g = 2#接收方(A)需要干的事情，即生成密钥（包括公钥和私钥def reciver_need_do():    global pub    a_pri = bytes_to_long(b&#x27;I am priviate key of A.&#x27;)    a_pub = pow( g , a_pri , p )    pub = a_pub    return a_pri#发送方(B)需要进行的加密操作，生成密文并def ElGamal_encode():    m = bytes_to_long(b&#x27;miao miao miao wo shi ming wen 233&#x27;)    k = getRandomInteger(10)    c1 = pow( g , k , p )    c2 = m * pow( pub , k , p ) % p    return c1 , c2#解密方需要进行的解密操作def ElGamal_decode( pri ):    global c    c1 , c2 = c    c1 = pow( c1 , p-2 , p )    m = c2 * pow( c1 , pri , p ) % p    return mif __name__ == &#x27;__main__&#x27;:    init()    a_pri = reciver_need_do()#返回接受者的私钥，a_pri只有接受者可以用    c = ElGamal_encode()#B将信息进行加密，然后传给A    m = ElGamal_decode( a_pri )#A使用自己的密钥，对信息进行解密    print( long_to_bytes(m) )
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>FJNU2024低程赛题解</title>
    <url>/2024/12/02/FJNU2024%E4%BD%8E%E7%A8%8B%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[比赛链接
题目按总过题数量降序排列

A.#include&lt;iostream&gt;using namespace std;signed main()&#123;    int a , b;cin &gt;&gt; a &gt;&gt; b;    int c = a - b;if( c &lt; 0 ) c = -c;    cout &lt;&lt; c &lt;&lt; endl;    return 0;&#125;
H.#include&lt;iostream&gt;using namespace std;signed main()&#123;    int a , b , c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    if( a == b &amp;&amp; b == c ) cout &lt;&lt; 1 &lt;&lt; endl;    else if( a == b || b == c || a == c ) cout &lt;&lt; 2 &lt;&lt; endl;    else cout &lt;&lt; 3 &lt;&lt; endl;    return 0; &#125;
G.前面填充0，剩下的位数从头开始输出字符串，直到凑齐n位，即可
#include&lt;iostream&gt;using namespace std;signed main()&#123;    int n , k;cin &gt;&gt; n &gt;&gt; k;    string s;cin &gt;&gt; s;    for(int i = 1;i &lt;= k;i ++)&#123;        cout &lt;&lt; 0;    &#125;    for(int i = k+1;i &lt;= n;i ++)&#123;        cout &lt;&lt; s[i-k-1];    &#125;cout &lt;&lt; endl;    return 0; &#125;
B.小模拟，过的人还是挺多的，理清思路就好
#include&lt;iostream&gt;using namespace std;int x , k , r;int leng( int num )&#123;    int ans = 0;    while( num )&#123;        num /= 10;        ans ++;    &#125;if( ans == 0 ) ans = 1;    return ans;&#125;void space( int num )&#123;    for(int i = 1;i &lt;= num;i ++) cout &lt;&lt; &quot; &quot;;&#125;signed main()&#123;    cin &gt;&gt; x &gt;&gt; k;    int len_init = leng(k) + 1 + leng(x);    while( x )&#123;        space( len_init - leng(k) - 1 - leng(x) );        r = x % k;        cout &lt;&lt; k &lt;&lt; &quot;|&quot; &lt;&lt; x &lt;&lt; &quot; &quot;;        if( r &lt; 10 ) cout &lt;&lt; r;        else&#123;            cout &lt;&lt; char(r-10+&#x27;A&#x27;);        &#125;cout &lt;&lt; &#x27;\n&#x27;;        space( len_init - leng(x) );        for(int i = 1;i &lt;= leng(x);i ++) cout &lt;&lt; &quot;-&quot;;        cout &lt;&lt; &#x27;\n&#x27;;        x /= k;    &#125;space(len_init-1);cout &lt;&lt; 0 &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;
F.一开始想二分套二分（大雾），后来发现只需要记录最长连续L的个数即可
#include&lt;iostream&gt;using namespace std;const int N = 2e5;int n;string s;int top_R[N];signed main()&#123;    cin &gt;&gt; n &gt;&gt; s;    int top_num = 0;    int ans = 1 , conti = 1;    for(int i = 1;i &lt;= n;i ++)&#123;        if( s[i-1] == &#x27;L&#x27; ) conti ++;        else&#123;            conti = 1;        &#125;ans = max( conti , ans );    &#125;cout &lt;&lt; ans &lt;&lt; endl;    return 0; &#125;
C.暴力会TLE，时间复杂度为 $O(2^n)$，即使是夹半搜索也要 $2^{50}$ 量级，故考虑dp
感觉和背包问题比较像，甚至要简单一点；不同点在于背包问题是求最优，而本题是求是否到达
#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int n , x;int a[110] , b[110];int dp[10010][110];signed main()&#123;    cin &gt;&gt; n &gt;&gt; x;    for(int i = 1;i &lt;= n;i ++)&#123;        cin &gt;&gt; a[i] &gt;&gt; b[i];    &#125;    dp[0][0] = 1;    for(int i = 1;i &lt;= n;i ++)&#123;        for(int p = min(a[i],b[i]);p &lt;= x;p ++)&#123;            if( p &gt;= a[i] ) dp[p][i] |= dp[p-a[i]][i-1];            if( p &gt;= b[i] ) dp[p][i] |= dp[p-b[i]][i-1];        &#125;    &#125;    if( dp[x][n] ) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;    return 0; &#125;
E.并查集问题（当时写的时候以为是公共祖先弱化版，忘了并查集这个东西了）
然后判断每种情况的状态，最后合并即可
#include&lt;iostream&gt;using namespace std;const int N=1e5;int n , m;int ans , x , y , z;int bin[N+10];int fa[N+10];int get_fa( int p )&#123;    if( fa[p] == p ) return p;    return get_fa(fa[p]);&#125;signed main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1;i &lt;= n;i ++)&#123;        fa[i] = i;    &#125;    for(int i = 1;i &lt;= m;i ++)&#123;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        if( bin[x] == 0 &amp;&amp; bin[y] == 0 )&#123;            ans ++;        &#125;else if( bin[x] &amp;&amp; bin[y] )&#123;            if( get_fa(x) != get_fa(y) )&#123;                ans --;            &#125;        &#125;bin[x] = bin[y] = 1;        fa[get_fa( x )] = fa[get_fa( y )] = min( get_fa( x ) , get_fa( y ) );    &#125;    for(int i = 1;i &lt;= n;i ++)&#123;        if( bin[i] == 0 ) ans ++;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0; &#125;
G.这题我也不知道怎么过的，应该是运气好凑巧了吧
结束前十分钟写完思路发现样例二过不了，以为是假了，然后写下了//做法假了，没时间了，开摆！这句；后来发现忘了翻转这一步，加上了然后样例二过了，一提交居然AC了
首先观察样例，因为存在不同解，所以试图找到解的规律
2 3 3 4 -4 -7 -4 -1
对以上操作积分一次（这个比喻有点抽象），可以发现只要确定了第一项，后面的就都确定了
不妨设第一项为 0
原式为： 2  3  3  4  -4  -7  -4  -1积分后：0  2  1  2  2  -6  -1  -3  2
然后改变第一项，可以发现奇数项和偶数项分别加减第一项的改变值
原式为： 2  3  3  4  -4  -7  -4  -1积分后：0  2  1  2  2  -6  -1  -3  2改首项：1  1  0  3  1  -5  -2  -2  1
这时，我们只需要确定第一项即可
但是第一项的范围为 ±1e9，所以需要借助和 幸运数字 的差值
进一步的，我们如果希望改变后的数字是幸运数字，只需要和目标的幸运数字们分别作差；差值结果即为第一项为某一数字后，这一项在变换（积分）后会变为幸运数字
由于每个幸运数字不同，故我们对于这个二维列表，只需要统计出现相同数字的最大次数即可（使用map进行统计）
#include&lt;iostream&gt;#include&lt;map&gt;#define int long longusing namespace std;const int N = 1e5;int n , m;int s[N+10] , t[15];int state[N+10][11];map &lt; int , int &gt; mp;signed main()&#123;    mp.clear();    cin &gt;&gt; n &gt;&gt; m;    for(int i = 2;i &lt;= n;i ++)&#123;        cin &gt;&gt; s[i];    &#125;    for(int i = 1;i &lt;= m;i ++)&#123;        cin &gt;&gt; t[i];    &#125;    state[1][0] = 0;    for(int i = 2;i &lt;= n;i ++)&#123;        state[i][0] = s[i] - state[i-1][0];    &#125;    for(int i = 1;i &lt;= n;i ++)&#123;        for(int j = 1;j &lt;= m;j ++)&#123;            state[i][j] = t[j] - state[i][0];            if( i % 2 ) state[i][j] = -state[i][j];        &#125;    &#125;    int ans = 0;    for(int i = 1;i &lt;= n;i ++)&#123;        for(int j = 1;j &lt;= m;j ++)&#123;            mp[state[i][j]] ++;            ans = max( ans , mp[state[i][j]] );        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0; &#125;
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>IND-CCA2下的CP-ABE安全</title>
    <url>/2025/01/07/IND-CCA2%E4%B8%8B%E7%9A%84CP-ABE%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[今天阅读前置知识，搞了半天终于明白了IND-CCA2下的CP-ABE安全，记录一下


论文名称：Fine-Grained and Controlled Rewriting in Blockchains: Chameleon-Hashing Gone Attribute-Based
相关内容：


我们只看核心部分

我们大致划分为三个部分
第一部分，初始化，不再赘述
第二部分，攻击者交互阶段，攻击者$\mathcal{A}$选择任意属性集合$\mathbb{S}$进行请求，模拟器会这些请求的属性集合加入全局集合$S$，并生成与属性集合$\mathbb{S}$相对应的私钥$ssk$，将请求编号及生成的密钥记录到$Q$中
第三部分，挑战阶段，攻击者$\mathcal{A}$提供属性集合$A^{}$ （$A^{}\cap S=\emptyset$），模拟器随机选择$b\in{0,1}$，使用属性集合$A^*$对应的私钥加密$m_b$，将密文$c_b$提供给$\mathcal{A}$ 
如果攻击者$\mathcal{A}$能够通过交互获得的信息区分密文中加密的是$m_0$还是$m_1$，且成功的概率显著大于$\frac12$，则认为攻击者成功，算法被攻破，否则认为该加密方案满足IND-CCA2安全性
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>IELTS备考方案</title>
    <url>/2024/12/13/IELTS%E5%A4%87%E8%80%83%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[记录如何备考雅思

笔者四级都没过就开始想IELTS了（菜菜
而且考一次2k多（穷穷
但是还是要准备一下下的

关于背单词一开始是用的百词斩来背单词
不过后面就破产了（

然后斥巨资买了这本书背（感觉背单词，用纸质书更舒服一点）

只不过进度感人（悲
单词背完之后，理论上是刷剑雅（一般是盗版或者电子版，正版买不起一点）
#剑雅使用教程1️⃣剑桥雅思4-6：较早版本的题目，初学者可用于前期了解题型2️⃣剑桥雅思7-9：开始全面的模拟练习，包括听、说、读、写四个部分3️⃣剑桥雅思10-12：版本难度与现在的雅思考试接近，模考冲刺反复刷，检查和修正自己的错误4️⃣剑桥雅思13-19：最新版本的题目，应该是最接近当前雅思考试的，可以用来考前练习，检验自己的备考效果



]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>MoeCTF2024wp</title>
    <url>/2024/08/21/MoeCTF2024wp/</url>
    <content><![CDATA[CRYPTO
现代密码学入门指北from Crypto.Util.number import bytes_to_long, getPrimefrom secret import flagp = getPrime(128)q = getPrime(128)n = p*qe = 65537m = bytes_to_long(flag)c = pow(m, e, n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;p = &#123;p&#125;&quot;)print(f&quot;q = &#123;q&#125;&quot;)print(f&quot;c = &#123;c&#125;&quot;)&#x27;&#x27;&#x27;n = 40600296529065757616876034307502386207424439675894291036278463517602256790833p = 197380555956482914197022424175976066223q = 205695522197318297682903544013139543071c = 36450632910287169149899281952743051320560762944710752155402435752196566406306```

from Crypto.Util.number import long_to_bytesimport gmpy2n = 40600296529065757616876034307502386207424439675894291036278463517602256790833p = 197380555956482914197022424175976066223q = 205695522197318297682903544013139543071c = 36450632910287169149899281952743051320560762944710752155402435752196566406306e = 65537phi = (p-1)*(q-1)d = gmpy2.invert( e , phi )m = pow( c , d , n )print( long_to_bytes(m) )
flag:moectf&#123;the_way_to_crypto&#125;
Signinfrom Crypto.Util.number import*from secret import flagm = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)n = p*qe = 65537c = pow(m,e,n)pq = (p-1)*(q-2)qp = (q-1)*(p-2)p_q = p + qprint(f&quot;&#123;c = &#125;&quot;)print(f&quot;&#123;pq = &#125;&quot;)print(f&quot;&#123;qp = &#125;&quot;)print(f&quot;&#123;n = &#125;&quot;)print(f&quot;&#123;p_q = &#125;&quot;)&#x27;&#x27;&#x27;c = 5654386228732582062836480859915557858019553457231956237167652323191768422394980061906028416785155458721240012614551996577092521454960121688179565370052222983096211611352630963027300416387011219744891121506834201808533675072141450111382372702075488292867077512403293072053681315714857246273046785264966933854754543533442866929316042885151966997466549713023923528666038905359773392516627983694351534177829247262148749867874156066768643169675380054673701641774814655290118723774060082161615682005335103074445205806731112430609256580951996554318845128022415956933291151825345962528562570998777860222407032989708801549746pq = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687154230787854196153067547938936776488741864214499155892870610823979739278296501074632962069426593691194105670021035337609896886690049677222778251559566664735419100459953672218523709852732976706321086266274840999100037702428847290063111455101343033924136386513077951516363739936487970952511422443500922412450462qp = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687077087914198877794354459669808240133383828356379423767736753506794441545506312066344576298453957064590180141648690226266236642320508613544047037110363523129966437840660693885863331837516125853621802358973786440314619135781324447765480391038912783714312479080029167695447650048419230865326299964671353746764860n = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687534959910892789661065614807265825078942931717855566686073463382398417205648946713373617006449901977718981043020664616841303517708207413215548110294271101267236070252015782044263961319221848136717220979435486850254298686692230935985442120369913666939804135884857831857184001072678312992442792825575636200505903p_q = 279533706577501791569740668595544511920056954944184570513187478007551195831693428589898548339751066551225424790534556602157835468618845221423643972870671556362200734472399328046960316064864571163851111207448753697980178391430044714097464866523838747053135392202848167518870720149808055682621080992998747265496&#x27;&#x27;&#x27;

设  $q_p = p - q$
因为  $pq=(p-1)(q-2)\ qp = (q-1)(p-2)$
即  $pq=pq-2p-1q+2\ qp = pq-1p-2q+2$
两式相减得到  $pq-qp=-p+q$ ，即  $q_p=-p+q$
又已知  $p_q = p + q$
只需解方程二元一次方程  $\left{\begin{array}{lr}q_p=-p+q\p_q = p + q\end{array}\right.$  ，其中 $q_p , p_q$ 为已知量，$p,q$为未知量
from Crypto.Util.number import*import gmpy2c = pq = qp = n = p_q = e = 65537q_p = pq - qpp = (p_q + q_p)//2q = (p_q - q_p)//2assert p*q==nphi = (p-1)*(q-1)d = gmpy2.invert( e , phi )m = pow( c , d , n )print( long_to_bytes(m) )
flag:moectf&#123;Just_4_signin_ch4ll3ng3_for_y0u&#125;
ez_hashfrom hashlib import sha256from secret import flag, secretsassert flag == b&#x27;moectf&#123;&#x27; + secrets + b&#x27;&#125;&#x27;assert secrets[:4] == b&#x27;2100&#x27; and len(secrets) == 10hash_value = sha256(secrets).hexdigest()print(f&quot;&#123;hash_value = &#125;&quot;)# hash_value = &#x27;3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a&#x27;

已知密文前四位（共10位）和sha256后的结果，爆破剩余6位即可得到flag
from hashlib import sha256secrets = b&#x27;2100&#x27;for i in range( 1000000 ):    tmp = secrets + str(i).encode()    # print( tmp )    hash_value = sha256(tmp).hexdigest()    #print( tmp , hash_value )    if hash_value == &#x27;3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a&#x27;:        print( tmp )
flag:moectf&#123;2100360168&#125;
Big and smallfrom secret import flagfrom Crypto.Util.number import*m = long_to_bytes(flag)p = getPrime(1024)q = getPrime(1024)n = p*qe = 3c = pow(m,e,n)&#x27;&#x27;&#x27;c = 150409620528288093947185249913242033500530715593845912018225648212915478065982806112747164334970339684262757e = 3n = 20279309983698966932589436610174513524888616098014944133902125993694471293062261713076591251054086174169670848598415548609375570643330808663804049384020949389856831520202461767497906977295453545771698220639545101966866003886108320987081153619862170206953817850993602202650467676163476075276351519648193219850062278314841385459627485588891326899019745457679891867632849975694274064320723175687748633644074614068978098629566677125696150343248924059801632081514235975357906763251498042129457546586971828204136347260818828746304688911632041538714834683709493303900837361850396599138626509382069186433843547745480160634787&#x27;&#x27;&#x27;

低密度指数攻击
from Crypto.Util.number import*import gmpy2c = e = 3n = for i in range( 100 ):    if gmpy2.iroot( c+n*i , e )[1] == True:        m = gmpy2.iroot( c+n*i , e )[0]        print( long_to_bytes(m) )        exit()
flag:flag&#123;xt&gt;is&gt;s&gt;b&#125;
baby_equationfrom Crypto.Util.number import *from secret import flagl = len(flag)m1, m2 = flag[:l//2], flag[l//2:]a = bytes_to_long(m1)b = bytes_to_long(m2)k = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40assert ((a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1)) == 4*(k + a*b)

这一组题里最难的一题
已知 ((a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1)) == 4*(k + a*b)
可以使用python自带库来解方程
from sympy import symbols, Eq, solvek = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40a , b = symbols(&#x27;a b&#x27;)eq1 = Eq( (a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1) - 4*(k + a*b) , 0 )solution = solve( eq1 , (a,b) )print( solution )
得到结果是
[((8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260593 - b)/(b - 1), b), ((-b - 8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260591)/(b - 1), b)]
我们先只看前半段
((8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260593 - b)/(b - 1), b)
设 t=8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260593
故有  $((t-b)/(b-1),b)$
设  $a=((t-b)/(b-1),b)$
移项得到  $t=a*b-a+b$
上式等价于  $t-1=(a+1)*(b-1)$
使用 yafu-x64即可分解 t-1得到
***factors found***P1 = 2P1 = 2P1 = 2P1 = 2P1 = 3P1 = 3P2 = 31P2 = 61P3 = 223P4 = 4013P6 = 281317P7 = 4151351P13 = 5404604441993P9 = 370523737P9 = 339386329P14 = 26798471753993P29 = 25866088332911027256931479223P44 = 64889106213996537255229963986303510188999911ans = 1
也就是说，以上十八个数字分成两组，这两组数分别的乘积就是 $a+1$ 和 $b-1$，而且这两组数的乘积相差较小（即 $a$ 和 $b$ 的相差较小）；我们不妨设答案的解是相差最小的一组
考虑一个长度为 18 的 01串，0表示分到一组，1表示分到另一组，依次可以编写代码
def generate_binary_strings(n, current_string=&#x27;&#x27;, index=0):    &quot;&quot;&quot;    递归生成所有长度为n的01串，并计算两个子集的乘积。        :param n: 01串的长度    :param current_string: 当前构建的01串    :param index: 当前构建01串的位置    :return: 最小的乘积差值和对应的两个子集的乘积    &quot;&quot;&quot;    if index == n:        # 当生成了一个完整的01串时，计算两个子集的乘积        subset1_product = 1        subset2_product = 1        for i in range(n):            if current_string[i] == &#x27;1&#x27;:                subset1_product *= numbers[i]            else:                subset2_product *= numbers[i]                # 计算两个子集乘积的差值        diff = abs(subset1_product - subset2_product)        return diff, (subset1_product, subset2_product)        # 递归生成下一个位为0的情况    diff_0, result_0 = generate_binary_strings(n, current_string + &#x27;0&#x27;, index + 1)        # 递归生成下一个位为1的情况    diff_1, result_1 = generate_binary_strings(n, current_string + &#x27;1&#x27;, index + 1)        # 返回乘积差更小的那个情况    if diff_0 &lt; diff_1:        return diff_0, result_0    else:        return diff_1, result_1numbers = [2,2,2,2,3,3,31,61,223,4013,281317,4151351,339386329,370523737,5404604441993,26798471753993,25866088332911027256931479223,64889106213996537255229963986303510188999911]diff, (product1, product2) = generate_binary_strings(len(numbers))print(f&quot;最小差距是&#123;diff&#125;&quot;)print(f&quot;a=&#123;product1&#125;&quot;)print(f&quot;b=&#123;product2&#125;&quot;)
得到的结果是
最小差距是1706794914313264370032744337649343424996898390647397437784379904184a=2948658764987911698882278955266869405625105496652193856947916257370492b=2950365559902224963252311699604518749050102395042841254385700637274676
计算 $a+1$ 和 $b-1$ 即可得到 flag
from Crypto.Util.number import *a = 2948658764987911698882278955266869405625105496652193856947916257370492 + 1b = 2950365559902224963252311699604518749050102395042841254385700637274676 - 1print( long_to_bytes(b) + long_to_bytes(a)  )
flag:moectf&#123;7he_Fund4m3nt4l_th30r3m_0f_4rithm3tic_i5_p0w4rful!&#125;
大白兔More_secure_RSAezlegendrefrom sympy import *from Crypto.Util.number import *a = 288260533169915p = 1007621497415251FLAG = b&#x27;moectf&#123;xxxxxxxxxxxxxxxxxxxxx&#125;&#x27;def encrypt_flag(flag):    ciphertext = []    plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag])    for b in plaintext:        e = randprime(2, p)        if b == &#x27;1&#x27;:            n = pow(a, -e, p)            ciphertext.append(n)        else:            n = pow(-a, e ,p)            ciphertext.append(n)    return ciphertextprint(encrypt_flag(FLAG))

离散对数的题还挺爱出
此题和
[DASCTF Sept X 浙江工业大学秋季挑战赛]签到2020网鼎杯——you_raise_me_up wp
这两道题考点一致
直接出代码了
from sympy import *from Crypto.Util.number import *a = 288260533169915p = 1007621497415251def decode_flag( ciphertext ):    plaintext = &quot;&quot;    for i in ciphertext:        try:            e_temp = discrete_log( p , i , a )        except:            plaintext += &quot;0&quot;        else:            plaintext += &quot;1&quot;        if len(plaintext) == 8:            print( chr(int(plaintext,2)) , end=&quot;&quot; )            plaintext = &quot;&quot;Ciphertext = []print(decode_flag(Ciphertext))
flag:moectf&#123;minus_one_1s_n0t_qu4dr4tic_r4sidu4_when_p_mod_f0ur_equ41_to_thr33&#125;
new_systemRE逆向工程入门指北直接运行题目给的脚本即可
#include &lt;iostream&gt;int main()&#123;char password_enc[] = &#123;123, 121, 115, 117, 98, 112, 109, 100, 37, 96, 37, 100, 101, 37, 73, 39,101, 73, 119, 73, 122, 121, 120, 113, 73, 122, 121, 120, 113, 73, 97, 119,111, 73, 98, 121, 73, 115, 110, 102, 122, 121, 100, 115, 107, 22 &#125;;// 因为a^b=c时, b^c=a, 所以我们可以这样还原数据:char password[47];for (int i = 0; i &lt; 46; i++) &#123;password[i] = password_enc[i] ^ 22;&#125;password[46] = 0; // 使用0字符来截断掉%s的无尽输出..printf(&quot;%s\n&quot;, password); // 哈哈，这就是本题的f l a g，自己运行一下交上去吧！return 0;&#125;
flag:moectf&#123;r3v3rs3_1s_a_long_long_way_to_explore&#125;
xor打开IDA，F5

双击byte_1400022B8进入

这一串异或上0x24就是flag
s = &quot;49h, 4Bh, 41h, 47h, 50h, 42h, 5Fh, 41h, 1Ch, 16h, 46h , 10h, 13h, 1Ch, 40h, 9, 42h, 16h, 46h, 1Ch, 9, 10h, 10h, 42h, 1Dh, 9, 46h, 15h, 14h, 14h, 9, 17h, 16h, 14h, 41h, 40h , 40h , 16h, 14h, 47h, 12h, 40h, 14h, 59h , 0&quot;s = s.replace(&quot;h&quot;,&quot;&quot;).replace(&quot; &quot;,&quot;&quot;).split(&quot;,&quot;)print( s )for i in s:    t = int(i,16)    print( chr(t^0x24) , end=&quot;&quot; )
flag:moectf&#123;e82b478d-f2b8-44f9-b100-320edd20c6d0&#125;
TEA64位无壳，拖进IDA F5一下

根据题目给出信息，倒过来就是decode代码了；需要注意运算的数域，这里我们直接使用cpp就可以省去手动取模
#include&lt;iostream&gt;using namespace std;unsigned int v4 , v5;int v3;signed main()&#123;    v4 = 676078132;    v5 = 957400408;    v3 = 0;    for(int i = 0;i &lt; 32;i ++)&#123;        v3 -= 1640531527;    &#125;    for(int i = 0;i &lt; 32;i ++)&#123;        v5 -= (v4 + v3) ^ (16 * v4 + 1634038898) ^ ((v4 &gt;&gt; 5) + 1634038904);        v4 -= (v5 + v3) ^ (16 * v5 + 1702060386) ^ ((v5 &gt;&gt; 5) + 1870148662);        v3 += 1640531527;    &#125;    cout &lt;&lt; v4 &lt;&lt; &quot; &quot; &lt;&lt; v5 &lt;&lt; endl;    return 0;&#125;
得到2204193701 2382383549
然后转用python分离就可以了；需要注意这里是16进制
v4 = 2204193701v5 = 2382383549v10 = v4v9 = int(bin(v5)[18:34],2)v11 = int(bin(v5)[2:18],2)print( hex(v4) , hex(v11) , hex(v9) )
输出0x836153a5 0x8e00 0x49bd
得到的就是flag

flag:moectf&#123;836153a5-8e00-49bd-9c42-caf30620caaf&#125;
逆向工程进阶之北给出这样一段代码

关键是这一行

直接加法变减法，乘法变逆元，异或变异或即可
值得注意的是，加法的优先级高于异或运算，并且需要在 0xffffffff+1 域下进行运算
import gmpy2l = [0xb5073388 , 0xf58ea46f , 0x8cd2d760 , 0x7fc56cda , 0x52bc07da , 0x29054b48 , 0x42d74750 , 0x11297e95 , 0x5cf2821b , 0x747970da , 0x64793c81]p = 0xffffffff+1for i in l:    temp = ((i^0xdeadbeef+0xd3906)-0xdeadc0de)*gmpy2.invert( 0xccffbbbb , p ) % p    temp = str(hex(temp))[2:]    flag = &quot;&quot;    for j in range(0,len(temp),2):        flag += chr(int(temp[j] + temp[j+1],16))    print( flag[::-1] , end=&quot;&quot; )
flag:moectf&#123;c5f44c32-cbb9-444e-aef4-c0fa7c7a6b7a&#125;
SecretModule给了一个zip，解压得到几个文件
用记事本打开 customize.sh 文件，得到
#!/bin/bash eval   &quot;$(     printf &#x27;QlpoOTFBWSZTWZspxEUAAfxfgFAwdef/6zfHz6D/79/uQAJSu07tCQ1BI09E9Q0DINA9TQA2oAAA0NAlCFPRpM0mjSNR+hIaek0AHqaGj1PUNNMeqDSEJ6gNBo0NNAAZNGjI0NBoAAlEjEo8ppp6NPVGCaaNNMR6g9EBoPUGgPAecJO66TH6u4xdFeH8fRdR4OSNOqLoVm2I39FZSS/irDMIJmggh2EyQovQos26HmeniQH4iRSw0JeeVV2C9E8NkJh+VZwioAZj5QpGcdTmdOSMoYLaiaaa8oZEhIRgQbKjP7VIopzl53axe+MJxXTyrg/duKuBYecUVQUUTMptuykt+JqZZmJSM0dQ/YaHpifbwN3wN0NYRAEYC0tkI6uE4GkS9r1eFB9zyCBef6dnGYwKo8BylS24xNYsXSUXIYpZC3fzxlQKVBUwrBawin+AaDPkLwbCSQNge45QjrBfoNLEJSWk8C0ajKPu8NORzYlfqGgjOQOQQ0YG7gCRaWFD6wkguEqEUi6bSFTxLE4Y3+pziYRKFVet5X1CrnXc2jLN+9tMTJ8beC0ED5k1K7n22efCha1ci53zQHgQBUKLg1Q3hPZoMCAp0g48QN02037Qy891pyxa+vZU5msKnsJryCXKyBdrCrWXljrC/S6i3MBzRikY4kZzLw7v8aL7oOYKGRkUCWxelwUWFKIOQyImQVnIKicgYFqJYjeY1CMSgaiR4dqQ7MomJ6LdpOEtDOvfhjsEplnGTvSo3NV1KnALfTTYMeOUngApQKa8IExBIGZhafHgZZjI0HAKg6bcV5QwiUHCoorQaSWUvNMLgejbZ/QJA9QFWitiup+KyAU5uTergMVuJ5jj/xdyRThQkJspxEU=&#x27;   | base64   -d   |   bunzip2  -c    )&quot;   
编写相应的解码代码
import base64import bz2# 这是原始的 Base64 编码字符串encoded_str = &#x27;QlpoOTFBWSZTWZspxEUAAfxfgFAwdef/6zfHz6D/79/uQAJSu07tCQ1BI09E9Q0DINA9TQA2oAAA0NAlCFPRpM0mjSNR+hIaek0AHqaGj1PUNNMeqDSEJ6gNBo0NNAAZNGjI0NBoAAlEjEo8ppp6NPVGCaaNNMR6g9EBoPUGgPAecJO66TH6u4xdFeH8fRdR4OSNOqLoVm2I39FZSS/irDMIJmggh2EyQovQos26HmeniQH4iRSw0JeeVV2C9E8NkJh+VZwioAZj5QpGcdTmdOSMoYLaiaaa8oZEhIRgQbKjP7VIopzl53axe+MJxXTyrg/duKuBYecUVQUUTMptuykt+JqZZmJSM0dQ/YaHpifbwN3wN0NYRAEYC0tkI6uE4GkS9r1eFB9zyCBef6dnGYwKo8BylS24xNYsXSUXIYpZC3fzxlQKVBUwrBawin+AaDPkLwbCSQNge45QjrBfoNLEJSWk8C0ajKPu8NORzYlfqGgjOQOQQ0YG7gCRaWFD6wkguEqEUi6bSFTxLE4Y3+pziYRKFVet5X1CrnXc2jLN+9tMTJ8beC0ED5k1K7n22efCha1ci53zQHgQBUKLg1Q3hPZoMCAp0g48QN02037Qy891pyxa+vZU5msKnsJryCXKyBdrCrWXljrC/S6i3MBzRikY4kZzLw7v8aL7oOYKGRkUCWxelwUWFKIOQyImQVnIKicgYFqJYjeY1CMSgaiR4dqQ7MomJ6LdpOEtDOvfhjsEplnGTvSo3NV1KnALfTTYMeOUngApQKa8IExBIGZhafHgZZjI0HAKg6bcV5QwiUHCoorQaSWUvNMLgejbZ/QJA9QFWitiup+KyAU5uTergMVuJ5jj/xdyRThQkJspxEU=&#x27;# Base64 解码decoded_data = base64.b64decode(encoded_str)# BZ2 解压decompressed_data = bz2.decompress(decoded_data)# 打印解压后的内容print(decompressed_data.decode(&#x27;utf-8&#x27;))
得到输出内容，代码大致意思是使用114514和1919810来碰撞给定的MD5，编写脚本即可枚举
 import hashlibimport itertools# Possible results of choose()options = [&quot;114514&quot;, &quot;1919810&quot;]# Target MD5 hashtarget_hash = &quot;77a58d62b2c0870132bfe8e8ea3ad7f1&quot;# Brute force all possible combinationsfor combination in itertools.product(options, repeat=7):    concatenated = &#x27;&#x27;.join(combination)    generated_hash = hashlib.md5(concatenated.encode()).hexdigest()    if generated_hash == target_hash:        print(f&quot;Correct sequence: &#123;combination&#125;&quot;)        print(f&quot;Flag: moectf&#123;&#123;&#123;concatenated&#125;&#125;&#125;&quot;)        break
flag:moectf&#123;114514114514191981011451411451419198101919810&#125;
MISCsignin按照题目要求，只给 luo 记缺勤，其他人都代签即可
flag:moectf&#123;Thanks_For_You_signing_in_4ND_W3l0c0me_T0_M0ecTf_2024!!!&#125;
罗小黑战记得到一张gif，使用stegsolve进行分解，发现第110张图片中有二维码，扫描二维码得到flag
flag:moectf&#123;y0uu6r3th3m0st3r1nth1sf13ld&#125;
杂项入门指北右侧有一列.-，是摩斯密码
.... ....- ...- . ..--.- .- ..--.- --. ----- ----- -.. ..--.- - .---- -- .
flag:moectf&#123;H4VE_A_G00D_T1ME&#125;
WEBWeb渗透测试与审计入门指北题目给了一个服务器的文件，要求自行搭建服务器
查看文件，是php语言加密之后的内容
打开PHPstudy Pro，点击Nginx的启动

点击网站-管理-打开根目录，将题目给的文件拖进去即可
访问http://localhost:80即可得到flag

flag:moectf&#123;H3r3&#39;5_@_flYinG_kIss_f0r_yoU!&#125;
弗拉格之地的入口
爬虫？写了个爬虫，什么额外的东西都没有爬下来
问问ai，他说
在运行爬虫前，请务必检查目标网站的robots.txt文件，确保您的行为符合该网站的规定。此外，频繁的请求可能会对网站服务器造成负担，因此在实际应用中应考虑添加适当的延时或其他更复杂的逻辑来避免被封禁。
那我们检查一下robots.txt，发现里面提到了一个文件

我们直接访问一下/webtutorEntry.php，然后就得到了flag

flag:moectf&#123;c0nGRATU14TiOn_f0r_kN0WlNg-R0BoT5_Txta02b&#125;
垫刀之路01: MoeCTF？启动！回到根目录，看到一个flag文件，打开

得到提示检查环境变量

输入env检测环境变量，得到flag

flag:moectf&#123;w31CoME_TO-moEctF-4nd-r0@Dl_5T4RtuP-bY-sXrHHH5e&#125;
ez_httpProveYourLove弗拉格之地的挑战
直接访问http://127.0.0.1:53846/flag1ab.html
点击F12得到第一段flag

flag1: bW9lY3Rm
然后访问http://127.0.0.1:53846/flag2hh.php
服务器通过网络传输过来的，除了这个页面，还有什么？，F12打开网络在响应标头找到flag2
flag2：e0FmdEV
然后访问http://127.0.0.1:53846/flag3cad.php

使用hackbar传入

然后传入b参数

元素页面有提示你知道 cookie 吗？

然后就不知道怎么做了
ImageCloud前置垫刀之路02: 普通的文件上传]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cryptoCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>LIS学习笔记</title>
    <url>/2024/11/11/LIS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[前情提要：蓝桥杯校赛压轴题，是道朴素最长上升子序列板子题；没做出来，故学习记录一下


题目链接设原数列为 1,2,4,1,3,4，$f(x)$ 表示以第 $i$ 个数为结尾的最长上升子序列的长度




n
1
2
3
4
5
6




$a_i$
1
2
4
1
3
4


$f(n)$
1
2
3
1
3
4




代码实现
读入数据
大循环开始，从 $1$ 到 $n$，计算 $f_i$，记得初始值是 $1$
小循环，从 $1$ 到 $i−1$，如果 $a_j$ 小于 $a_i$ 的话，说明这个数可以和 $f_i$ 组成上升子序列，则 $f_i$ 取 $max⁡(f_i,f_j+1)$
寻找最大值

具体代码#include&lt;iostream&gt;using namespace std;const int N = 5e3;int a[N+10];int f[N+10];signed main()&#123;    int n;cin &gt;&gt; n;    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];    for(int i = 1;i &lt;= n;i ++)&#123;        f[i] = 1;        for(int j = 1;j &lt;= i-1;j ++)&#123;            if( a[j] &lt; a[i] ) f[i] = max( f[i] , f[j]+1 );        &#125;    &#125;int ans = 0;    for(int i = 1;i &lt;= n;i ++) ans = max( ans , f[i] );    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;
二分优化我们定义一个数组 tails，其中 tails[k] 表示长度为 $k+1$ 的上升子序列的最小尾元素。该数组帮助我们追踪可能构成的上升子序列的最小值，从而达到优化的效果。算法的核心步骤是：

遍历数组 a 中的每个元素 num。

使用二分查找在 tails 中找到第一个大于等于 num 的位置 pos。

如果 pos 等于 tails 的长度，说明 num 比 tails 中所有元素都大，可以直接将 num 添加到 tails 末尾，增加子序列长度。

否则，用 num 替换 tails[pos]，以确保 tails 保持递增且末尾值尽可能小。



最终 tails 的长度即为最长上升子序列的长度。


#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N = 5e3;int a[N+10];signed main()&#123;    int n;cin &gt;&gt; n;    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];    vector&lt; int &gt; tails;    for(int i = 1;i &lt;= n;i ++)&#123;        int num = a[i];        auto pos = lower_bound( tails.begin() , tails.end() , num );        if( pos == tails.end() )&#123;            tails.push_back( num );// 如果 num 比所有元素都大，添加到末尾        &#125;else&#123;            *pos = num;// 替换找到的第一个 &gt;= num 的位置，保证尾部元素尽量小        &#125;    &#125;    cout &lt;&lt; tails.size() &lt;&lt; endl;    return 0;&#125;
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>PCS简要介绍</title>
    <url>/2025/03/26/PCS%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[之前听师兄讲PCS（多项式承诺方案），听不懂一点，甚至有一次差点睡着（bushi
今天看Siniel，又遇到PCS了，故而通俗理解记录一下，也没时间看相关论文了~浅学一下，够用即可~~



Motivation：证明者有一个多项式 $p()$，验证者指定一个数 $z$ 来验证，通过承诺确保原多项式不会改变

这里，我们介绍 KZG。更具体的：
KZG 方案是基于双线性对（bilinear pairing）和加法同态加密（homomorphic encryption）的密码学技术。它允许一个发送方承诺（commit）一个多项式，并稍后提供证明（proof），以便验证者确认多项式在某个点的值是否正确。
前置知识：双线性映射

设 $G_1,G_2$ 是两个循环群，阶为素数 $p$
设 $e:G_1\times G_2\rightarrow G_T$，满足 $e(g^a,h^b)=e(g,h)^{ab}$ 对所有 $a,b\in\mathbb{Z}_p$ 成立，其中 $g,h$ 是群 $G_1$ 和 $G_2$ 的生成元

KGC的四个步骤：（对应图二）

Setup（设置）： 生成公钥参数。
Commit（承诺）： 证明者使用私有多项式生成并公开该多项式的承诺。
Open（打开）： 验证者指定在某个点，而后要求证明者公开该多项式的值并提供一个证明。
Verify（验证）： 验证者检查提交的值和证明是否有效。


具体流程2.1 设定（Setup）
由可信第三方（或 MPC ）选取一个私有值 $s$，并计算：${ g, g^s, g^{s^2}, \dots, g^{s^d} }$ 作为公共参数；这些值是椭圆曲线群上的元素并公开发布。
2.2 承诺（Commit）
证明者需验证多项式 $p(x) = a_0 + a_1 x + a_2 x^2 + \dots + a_d x^d$
计算并公开承诺 $C_p = g^{p(s)} = g^{a_0 + a_1 s + a_2 s^2 + \dots + a_d s^d}$
2.3 证明（Open）
验证者想知道证明者的多项式在 $x = \alpha$ 处的值 $y = p(\alpha)$
证明者计算商多项式：$q(x) = \frac{p(x) - p(\alpha)}{x - \alpha}$；因为 $p(x) - p(\alpha)$ 可被 $x - \alpha$ 整除，所以 $q(x)$ 是一个比 $p(x)$ 低 1 阶的多项式。
计算承诺 $C_q$：$C_q = g^{q(s)}$；并将其作为证明 $\pi = C_q$ 发送给验证者。
2.4 验证（Verify）
验证者通过以下等式检查证明是否有效：$e(C_p / g^y, g) = e(\pi, g^{\alpha})$
即：$e(g^{p(s) - y}, g) = e(g^{q(s)}, g^{\alpha})$
若等式成立，则说明证明者提供的 $y = p(\alpha)$ 是正确的。

示例①设公共参数为：$g, g^s, g^{s^2}, g^{s^3}, \dots$
②证明者私有多项式：$p(x) = 3x^2 + 2x + 5$
计算承诺并将其公开：$C_p = g^{5 + 2s + 3s^2}$
③验证者指定一个点：$z=2$
证明者计算:$p(2) = 3(2)^2 + 2(2) + 5 = 17$
证明者计算商多项式:$q(x) = \frac{(3x^2 + 2x + 5) - 17}{x - 2} = 3x + 8$
证明者计算证明：$\pi = g^{q(s)} = g^{3s + 8}$
④验证者执行验证：$e(C_p / g^{17}, g) = e(g^{3s + 8}, g^2)$
如果等式成立，则证明 $ p(2) = 17 $ 是正确的。

进一步的，关于验证阶段验证者需要验证 $e(C_p / g^{17}, g) = e(g^{3s + 8}, g^2)$ 是否成立

\begin{align}
左式=&e(C_p / g^{17}, g)\\
=&e(g^{(5 + 2s + 3s^2) - 17},g) \\
=&e(g^{3s^2 + 2s - 12},g)\\
=&e(g, g)^{(3s^2 + 2s - 12)}
\end{align}
\begin{align}
右式=&e(g^{3s + 8}, g^2)\\
=& e(g, g)^{6s + 16}
\end{align}故只需 $3s^2 + 2s - 12=6s + 16$ 成立，则验证通过
此时 $s=\frac{2 \pm \sqrt{88}}{3}$ （此过程为逆向过程）
即最一开始的公开参数 $s=\frac{2 \pm \sqrt{88}}{3}$ 时，则 $e(C_p / g^{17}, g) = e(g^{3s + 8}, g^2)$ 成立，证明通过
后记：补充说明和上面的算法相呼应，在论文的后半部分找到的具体算法，本质相同

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT制作总结</title>
    <url>/2025/01/11/PPT%E5%88%B6%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[总结各种情况下的PPT如何制作


1. 组会汇报面向导师和同学，强调科研进展汇报和交流

格式要求：

中文字体：微软雅黑；英文字体：Times New Roman
字体大小：最小不得低于18号，推荐20号及以上
排版设计：背景简洁，切忌使用动画


内容呈现：

注重清晰性：多用图表，少用文字描述
重点突出：用颜色标注关键结果或问题


汇报技巧：

简明扼要：不必深入每个细节，重点汇报进展和结果


时间分配
汇报主体（30-40分钟）

研究背景（5-10分钟）：

简述问题来源和研究意义，回顾之前的研究进展
提供上下文，使组内成员对你的工作方向和目标有清晰认知


研究方法与设计（10-15分钟）：

展示研究方法、算法设计或实验过程
强调你的创新点及其理论依据


研究结果与分析（10-15分钟）：

使用清晰的图表或数据展示结果
对结果进行定量和定性分析，回答“为什么会出现这些结果”


未解问题与计划（5分钟）：

列出当前面临的技术问题或挑战
说明下一步计划，寻求导师或同事建议



讨论与反馈（20-30分钟）

预留充足时间与导师及组内成员交流
主动提问，展示你对未解问题的思考和希望获得的反馈



2. 学术会议汇报面向领域内专家学者，突出科研成果和创新点

PPT设计：
简洁专业：每页聚焦一个主题，内容适量，每页文字不超过6行
色彩搭配：背景与字体对比鲜明，常用白底黑字或深色底白字
数据可视化：使用高质量图表展示数据，标明单位和轴标签


内容结构：
开头：研究背景、意义和问题
中间：研究方法、实验设计、结果和分析
结尾：关键结论与未来展望


表达要点：
语言清晰：用学术语言简洁表达，避免过多术语
逻辑分明：按逻辑线索推进（背景→问题→方法→结果→结论）
时间把控：提前排练，遵守会议规定的时间限制



3. 宣讲和授课以传播知识为目的，强调互动和易懂性

视觉设计：
突出重点：大标题、分点呈现，字体建议30号及以上，图文结合
多媒体辅助：适量使用图片、视频或动画吸引注意力，但避免复杂特效


内容设计：
突出逻辑：每部分开头设置提纲或总结，引导听众理解
提供实例：结合案例或实验结果说明抽象概念
控制节奏：通过提问、互动或练习激发参与感


汇报技巧：
语速适中，注重语气和肢体语言
注意听众反应，适时调整节奏和内容深度



4. 挑战杯竞赛我没学会（大哭
通用注意事项
排版与设计：

每页内容不要过多，控制在1-2分钟内讲完
避免花哨背景，确保简洁和专业


时间管理：

提前排练并计时，预留答疑时间


表达技巧：

语速适中，语言清晰，确保观众能跟上节奏


保持自信，避免频繁低头看稿

]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>RoboMaster福建师范大学2025赛季 飞镖组开发日志</title>
    <url>/2024/11/24/RoboMaster%E7%A6%8F%E5%BB%BA%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62025%E8%B5%9B%E5%AD%A3-%E9%A3%9E%E9%95%96%E7%BB%84%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[本篇文章用于记录飞镖组开发日志，便于后人学习
因为也不是什么很珍贵的东西，所以没有上锁，希望其他队伍看到后能指点一二
电控代码开源

此前的进度2024.11.24版本：0.4


硬件选型
主控：STM32f103c6t6陀螺仪：mpu6500通信：蓝牙串口模块舵机：3.7g舵机*2电池：格氏2s 450mAh 75C涵道：群汐30MM涵道 QF1611-14000KV电调：好盈天行者电调 20A V2 支持反转视觉：暂无
对于陀螺仪部分

使用mpu6500读取三个方向的速度和加速度
自写函数进行dmp解算获得pitch yaw roll，但是yaw会有累计偏转
解决yaw偏转（待解决）

对于通信部分

使用蓝牙模块进行串口通信
只有发送

对于舵机

转幅对应的pwm波为50-250（具体见配置和代码）

对于电池

小心使用！小心使用！小心使用！！！

对于涵道

三根线分别接电调的三个香蕉头

对于电调

xt30头接2s供电
杜邦头红线接单片机5V，黑线接地，白线为pwm波，范围为500-1000（具体见配置）

对于视觉

暂无

FREEROTS

UPD2024.11.28版本：0.5
陀螺仪问题已解决，直接用ai写的dmp解算并且甚至没有很大的零漂！（大雾）
至少确实能用了，而且一点点的零漂不会太影响镖体（但愿）
下一阶段开始把涵道驱动模块移植到这块焊的乱七八糟的板子上（大雾
但是移植过程中又不转了，这段时间二分查找一下bug，然后周六上午和视觉联调
UPD2024.11.30版本：0.6
已成功和视觉组联调，使用星瞳openMV接收数据成功，存在少量丢包
此版本可以通过视觉参数来返回给舵机（模式3）
舵机模块今天断线了，测试版demo很容易断线，需要谨慎使用，开始找人画板（

UPD2024.12.05版本：0.7
新增pid控制舵面
改为线性控制，应该更平滑一点
周末测一下
UPD2024.12.10发现舵面不需要pid（大雾），抖来抖去是因为视觉传过来的数据有丢，计划写个校验
今天先把环境配好（雾）
UPD2024.12.15版本：0.8
问了一下视觉组的学长，学习了一下其他兵种的先进经验
加了个头和尾，然后直接读很多数据（视觉发送比电控接收快很多）
直接从字符串里取数据即可
通信问题基本解决
之后需要干的，就是依次修改接收窗口，优化数据正确率，然后就是想想飞控该怎么写了
UPD2024.12.19数据通信延迟太高（错误的数据太多了）
今天想了个办法，直接发hex，这样可以减少30%的通信数据，延迟大大减小
但是几秒钟可能就会有一个数据出错
下一阶段计划改为一位起始位，一位终止位和一位校验位
如果直接用可见ascll，还可以再减少一位（大雾
UPD2024.12.25南航开源了机械图纸，该跳出来看了
控制算法没有开源，不过据说比较简单，然后重新翻青工会，找到了这个控制算法

UPD2024.12.26这两天研究了一下控制算法，然后自己重画了一遍这张图

学习了一下，大概思路和简单过程代码有了
不过自己写的dmp解算不包含角速度，这两天需要加上这个
预计元旦之前吧
UPD2024.12.30这几天在预习期末考试就没有推进度
然后为了应对中期，设置了个临时task
待解决问题

涵道
驱动不稳定
无法移植
不知道本质波形函数


视觉
传输有误 -&gt; 压画质



UPD2025.01.03这几天大概每天投入一个小时左右，都有进度，但是没写~
今天比较飞跃性的是，把视觉出错的问题解决了
然后涵道也会驱动了，只不过不知道为什么用Freerots驱动不了
UPD2025.02.18假期进度搁置了
今天把飞控算法基本完成了，今天晚上去拿摄像头，明天测试
]]></content>
      <categories>
        <category>电控</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>SM2椭圆曲线加密算法学习笔记</title>
    <url>/2024/09/25/SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[此文章用于记录笔者对于SM2椭圆曲线加密算法的学习

前置知识ElGamal离散对数密码体制
公钥密钥生成
Alice首先构造一条椭圆曲线 $E$，在曲线上选择一点 $G$ 作为生成元，$n$ 为 $G$ 的阶（且 $n$ 必须为质数)。此时构成了一个循环群 $$。

Alice选择一个私钥 $k (k &lt; n)$，生成公钥 $Q = kG$

Alice将公钥组 $(E,Q,G)$ 发送给Bob


加密过程
Bob收到信息后，将明文编码为 $M$，$M$ 为曲线上一点，并选择一个随机数 $r$（$r &lt; n$，$n$ 为 $G$ 的阶）

Bob计算点 $Cipher_1$ 与 $Cipher_2$ 即两段密文，计算方法如下
$Cipher_1 = M + rQ\ Cipher_2 = rG$

Bob把 $Cipher_1$ 和 $Cipher_2$ 发给Alice




解密过程
Alice收到密文后，为了获得 $M$，只需要 $Cipher_1 - k · Cipher_2$，因为
$Cipher1 - k*Cipher2 = M + rQ - krG = M + rkG - krG = M$

将M解码即可




SM2官方文档标准文档链接：国家商业密码标准
总则
规定了椭圆曲线的系统参数以及验证方法
规定了椭圆曲线公钥的验证方法
附录中给出了椭圆曲线示例

第二部分 数字签名算法签名算法流程（一）置M’ = ZA || M M为待签名数据 ZA为A的可辨识标识、部分椭圆曲线系统参数和用户A的公钥的Hash值
（二）计算e = Hash(M’) 并将其转化为整数
（三）用随机数发生器生成随机数k (k&gt;1 k&lt; n-1) n 椭圆曲线的阶数 可以通过G计算出
（四）计算椭圆曲线点(x1,y1) = [k]G，并将其转化为整数 G为椭圆上一点 [k]G指椭圆乘法k倍G
（五）计算r= (e + x1)mod n，若r=0或r+k=n返回（三）
（六）计算s= ((1+da) ^(-1)  (k-rda))mod n，若s=0则返回（三） da为用户A的私钥
（七）将r、s数据类型转化成字节串，消息M的签名为(r,s)
验签算法流程（一）验证r&gt;1 r&lt;n-1
（二）验证s&gt;1 s&lt;n-1
（三）置M’ = ZA || M
（四）计算e = Hash(M’) 并将其转化为整数
（五）将r s数据类型转换为整数 计算 t= (r+s)mod n ，若t=0则验证不通过
（六）计算椭圆曲线点(x1,y1) = [s]G + [t]Pa Pa为A的公钥
（七） 将x1的数据类型转换成整数，计算R=(e+x1)mod n，验证R=r，成立则验证通过
第三部分 密钥交换协议密钥交换流程第四部分 公钥加密算法加密算法流程（一）用随机数发生器产生随机数k (k&gt;1 k&lt;n-1)
（二）计算椭圆曲线点C1=[k]G=(x1,y1)，并将其转换为比特串（A的私钥生成公钥）
（三）计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出 h为n的余因子
（四）计算椭圆曲线点[k]Pb=(x2,y2)，并将其转换为比特串（A的私钥乘B的公钥）
（五）计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回（一） KDF为密钥派生函数
（六）计算C2=M⊕t
（七）计算C3=Hash(x2||M||y2)
（八）输出密文C=C1||C3||C2
解密算法流程（一）从C中取出比特串C1，将其转换为椭圆曲线上的点，验证C1是否满足椭圆曲线方程
（二）计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出
（三）计算[db]C1=(x2,y2)，并将其转换为比特串 db B的公钥
（四）计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回（一） KDF为密钥派生函数
（五）从C中取出比特串C2,计算M=C2⊕t
（六）计算u=Hash(x2||M||y2)，从C中取出比特串C3，若u不等于C3，则报错并退出
（七）输出明文M
第五部分 参数定义给出了SM2使用素数域256位椭圆曲线参数
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>XFlow安装教程</title>
    <url>/2024/08/23/XFlow%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[XFlow是仿真流体动力学的软件
正版软件好贵贵，然后我下载了整整一个下午的破解版
按顺序阅读了以下三篇博客，最终成功打开XFlow

https://www.xqu5.com/thread-2105-1-1.html
https://www.ittel.cn/archives/13613.html
https://blog.csdn.net/weixin_39461079/article/details/127909834
我也不知道为什么能成功打开的，好奇怪
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>博客技术与功能概览</title>
    <url>/2025/10/22/blog-tech-overview/</url>
    <content><![CDATA[一、总体概览
平台与框架：Hexo 7.3.0 + Butterfly 主题（v5.3.5）。
站点定位：技术学习/竞赛记录（密码学/CTF/算法/课程笔记等）+ 生活随笔，中文为主。
展示风格：卡片式列表、顶部大图 Banner、封面图轮换、侧栏多卡片信息（作者、公告、最新评论、归档、标签云、站点信息）。
交互增强：本地搜索、目录（TOC）、相关文章、阅读模式、深色模式切换、PJAX 页面切换、Instant.page 预获取、图片灯箱（medium-zoom）。
评论与统计：Waline（含 PV/UV）+ Disqus 双系统（Waline 为主），文章卡片显示评论数；站点 PV/UV 未启用 Busuanzi（保留为可选）。
多媒体：底部固定 APlayer 播放器（inject 注入）+ 音乐页 aplayerlist 播放清单。
数学与代码：MathJax 渲染公式，highlight.js 高亮，行号与自动换行启用。

二、技术栈与版本
Hexo: 7.3.0（package.json hexo 字段与依赖）
主题：hexo-theme-butterfly 5.3.5（themes/butterfly/）
渲染器：
@upupming/hexo-renderer-markdown-it-plus（当前 Markdown 渲染主力）
hexo-renderer-kramed（亦已安装，存在并行可能的冗余，见改进建议）
hexo-renderer-stylus、hexo-renderer-pug


生成/功能插件（节选）：
搜索：hexo-generator-search、hexo-generator-searchdb（两者同时存在，见改进建议）
站点生成：hexo-generator-index、archive、category、tag
部署：hexo-deployer-git
开发：hexo-server
统计/字数：hexo-wordcount
资源与多媒体：hexo-asset-image、hexo-tag-aplayer
加密（可选）：hexo-blog-encrypt（暂未启用）
主题内置/集成：pjax、instant.page、medium-zoom、canvas-nest、snackbar 等


其他：@vercel/analytics 已安装但未在主题注入中显式启用。

三、核心目录结构（简要）
根配置
_config.yml：站点全局配置（URL、构建、部署、数学、搜索、高亮、文章资源等）。
_config.butterfly.yml：主题配置（导航、封面、UI、交互、评论、统计、特效等）。


内容与数据
source/_posts/：文章 Markdown（数量多，覆盖技术、竞赛、随笔等）。
source/_data/link.yml：友链数据，按分类展示。
source/link/index.md：友链页（type: link）。
source/tags/index.md：标签页（type: tags）。
source/music/index.md：音乐页（type: music，使用 aplayerlist）。
source/schedule/index.md：常驻更新目录页（手工索引若干文章）。


主题目录
themes/butterfly/：主题源码、静态资源与内置脚本（包含本地搜索脚本）。



四、主题与 UI 关键设置
导航与菜单
LOGO：/img/niu.gif
菜单项：主页、时光轴（archives）、标签、友链
顶部 Banner：index_img 与 default_top_img 均指向 /img/*.jpg|gif，默认封面集较大（94 张 gif）。


列表与封面
首页布局 index_layout: 3（封面与信息左右交错），简介展示长度 500。
封面/侧栏/归档 cover 开启；aside 启用且默认在左侧。


代码块
主题 code_blocks: light、Mac 风格标题、可复制、行内换行。
Hexo 使用 highlight.js（行号、wrap）。


文章页
TOC：开启且带序号、滚动百分比显示。
版权信息：开启，协议为 CC BY-NC-SA 4.0。
相关文章：开启，最多 6 篇。
上/下一篇分页：顺序模式 1。


侧栏卡片（已启用）
作者卡片（Follow Me 指向 GitHub）
公告（维护日志提示）
最近文章（按更新时间）
最新评论（Waline 聚合）
分类/标签云/归档（月度）
站点信息（文章数、最近推送时间、运行时长可配置）


交互与视觉
深色模式：按钮切换，手动模式。
阅读模式：支持。
PJAX：开启；Instant.page：开启；进入过渡动画：开启。
图片灯箱：medium-zoom；Lightbox 在主题中设置为 medium_zoom。
背景特效：canvas-nest（开启，移动端关闭），click_heart（开启）。
Snackbar：开启；位置左下。



五、功能清单（结合插件与配置）1) 搜索

主题：local_search（占位文案“来搜吧来搜吧~”）。
生成器：root _config.yml 配置 search.xml；同时安装了 search 与 searchdb 两个插件（建议二选一）。

2) 评论与访问统计

Waline：已配置 serverURL（Vercel 部署后端），开启 pageview &amp; visitor 统计；首页文章卡片展示评论数与 PV。
Disqus：配置了 shortname，可作为备份/次要评论系统。
站点级 PV/UV：Busuanzi 在主题配置中注释关闭（可按需启用）。

3) 数学公式

MathJax：在主题与站点均开启，单美元行内启用；engine 设为 chtml；支持按页面 Front-matter 控制。

4) 代码高亮

highlight.js：行号、自动换行、wrap 开启；主题 code_blocks=light。

5) 多媒体与音乐

页面级：source/music/index.md 使用 &#123;% aplayerlist %&#125; 播放清单。
全站固定：通过主题 inject.bottom 注入 APlayer 与播放列表（随机播放、固定底部、自动播放）。

6) 内容组织与导航

TOC、相关文章、上一/下一篇导航、归档（月度）、标签云（随机顺序、上限 40）。
友链：source/_data/link.yml 维护，主题友链样式为 volantis。

7) 性能与体验

PJAX、Instant.page 预获取、medium-zoom、snackbar；Lazyload 暂未启用。

8) SEO 与结构化数据

Open Graph：开启；结构化数据：开启。
尚未安装/配置 RSS（feed）与 sitemap（站点地图）插件（见改进建议）。

9) 安全与加密

hexo-blog-encrypt 已安装，root _config.yml 示例配置注释存在；MathJax 跳过 encrypted/** 渲染；当前未启用文章加密。

10) 部署与运维

部署：hexo-deployer-git 推送到 git@github.com:coperlm/coperlm.github.io.git 的 main 分支。
文章资源：post_asset_folder: true + hexo-asset-image，便于相对路径插图。

六、构建、开发与部署
本地开发（PowerShell）
# 一次性安装依赖npm install# 本地预览（默认 http://localhost:4000）npm run server# 清理与重新生成npm run clean; npm run build# 部署（需已配置 SSH Key 并具备仓库写权限）npm run deploy

新文档与资源组织

新文章：hexo new &quot;标题&quot;（或直接在 source/_posts/ 下添加 .md）。
文章素材：置于与文章同名的资源目录（post_asset_folder=true），图片可用相对路径引用。
友链：编辑 source/_data/link.yml。
专题页：tags/link/music/schedule 等页面通过 source/&lt;page&gt;/index.md + Front-matter 管理。



七、性能与可用性观察
优点

PJAX + Instant.page 使页面切换与首次交互更敏捷。
TOC/相关文章/阅读模式/深色模式增强了长文可读性与导航性。
APlayer 固定播放器提升沉浸感（需注意流量与带宽）。


关注点

封面图/默认图较多（近百张 gif），首页首屏资源体量可能较大；建议按需精简或延迟加载。
Lazyload 关闭：在多图文章/长列表页会影响 FCP/LCP，可考虑开启主题 lazyload 或采用现代原生 lazy 属性。
canvas-nest、click-heart 等特效在低端设备上可能影响帧率；移动端已禁用 nest，较为稳妥。



八、安全与隐私
Waline（自建/托管后端）
已启用匿名评论与 PV/UV 统计；建议在 Waline 后端开启基础反垃圾与速率限制，关注数据合规性。


Disqus
作为备份评论系统；注意其隐私政策与被墙风险。


加密文章
已具备能力但未启用；如需发布敏感内容，可启用 hexo-blog-encrypt 并为分类/标签设置访问密码。



九、问题与改进清单（可执行）1) Markdown 渲染器冗余

同时安装了 markdown-it-plus 与 kramed；建议只保留一个（推荐 markdown-it-plus），并移除 hexo-renderer-kramed 与 root 中的 kramed: 配置，以避免行为不一致。

2) 搜索插件重复

hexo-generator-search 与 hexo-generator-searchdb 同时存在；推荐仅保留一个：
若主题 local_search 读取 search.xml，保留 hexo-generator-search；
或改为使用 searchdb（生成 search.json），并在主题中对应配置。



3) SEO 能力完善

增加 RSS 与站点地图：
hexo-generator-feed（RSS/Atom）
hexo-generator-sitemap（sitemap.xml）



4) 统计与分析

如需更细化的访问分析，可启用：
Vercel Analytics（已安装包，需在主题 head/bottom 注入脚本）
或 Umami/GA4/Clarity 等（主题已预留配置项）。



5) 性能优化

开启图片 Lazyload；
精简默认封面 GIF 数量或改用静态 WebP；
评估 APlayer 自动播放策略（移动端/低速网络条件下可考虑关闭自动播放）。

6) PWA 与离线

如有离线访问/安装到桌面的诉求，可启用主题 pwa 并补齐 manifest 与图标资源。

7) 代码高亮统一性

当前使用 highlight.js；若希望与 Butterfly 内置 Prism 生态更一致，可切换至 Prism 并开启按需加载（权衡体积与功能）。

十、快速问答（FAQ）
本地搜索无结果？

确认运行了 hexo generate 生成 search.xml|json；若装了两个搜索生成器，保留一个并与主题配置一致。


文章公式不渲染？

确认 Front-matter 未关闭 mathjax；加密路径（encrypted/**）默认跳过渲染。


图片 404 或不显示？

使用 post_asset_folder: true 时，建议将图片放在与文章同名的资源目录下并用相对路径引用；主题 error_img 会为断图提供默认占位图。


评论数/访客数未显示？

检查 Waline serverURL 可用性与跨域设置，确认主题 comments.count/pageview 已启用；首页卡片统计需等待首批上报后才会有值。



十一、结论该博客以 Butterfly 为基础，完成了从内容到交互的较完整搭建：

对技术内容（数学、密码学、算法）有友好的公式/代码支持与导航增强；
评论、搜索、多媒体与视觉动效到位，使用体验较好；
在 SEO、性能与插件冗余方面仍有可量化的优化空间（RSS/Sitemap、Lazyload、渲染器与搜索插件精简）。

]]></content>
      <categories>
        <category>技术学习笔记</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>XU-CMA安全是什么</title>
    <url>/2024/10/08/XU-CMA%E5%AE%89%E5%85%A8%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[密码学中数字签名方案的安全模型主要包括两种：存在性不可伪造（Existential Unforgeability against chosen-message attacks, EU-CMA）和强不可伪造（Strong Unforgeability against chosen-message attacks, SU-CMA）， 本文主要对比这两种安全模型。

两种安全模型都是通过敌手（Adversary）和挑战者（Challenger）之间的游戏（Game）来定义的。首先挑战者生成密钥对 $(pk,sk)$ 并发送 $pk$ 给敌手，自己保存 $sk$ 用来生成签名。敌手可以自适应地提交任意消息，挑战者根据敌手提交的消息生成对应的签名并返回给敌手。最后，敌手返回一个伪造的对未查询过的新消息的签名。
EU-CMA在数字签名里标准的安全模型
在该模型里，敌手可以非随机性地询问任意 message 的 signature 并对任意没有询问过消息的 message 进行 forgery 攻击（第二篇参考文档中还有很多看不懂的东西）
存在性不可为造安全模型可以使用如下GAME描述：

$Setup$：假设$SP$问哦系统参数。挑战者执行密钥生成算法，生成密钥对 $(pk,sk)$ 并发送 $pk$ 给敌手，挑战者保留 $sk$ 用来回答敌手的签名查询

$Query$：敌手自适应的选取任意消息 $m_i$ 进行签名查询。对于敌手提交的消息 $m_i$ ，挑战者执行签名算法生成 $\sigma_{m_i}$ 并将其发送给敌手

$Forgery$：敌手返回一个伪造的对于某个消息 $m^{}$ 签名 $\sigma_{m^{}}$，如果：

$\sigma_{m^}$是一个关于 $m^$ 的合法签名
关于所有 $m^{*}$ 的签名之前没有被查询过

则敌手在游戏中获胜，敌手赢得游戏的优势 $\varepsilon$ 就是返回一个合法的伪造签名的概率


SU-CMA强不可为造安全模型可以使用如下GAME描述：

$Setup$：假设$SP$问哦系统参数。挑战者执行密钥生成算法，生成密钥对 $(pk,sk)$ 并发送 $pk$ 给敌手，挑战者保留 $sk$ 用来回答敌手的签名查询

$Query$：敌手自适应的选取任意消息 $m_i$ 进行签名查询。对于敌手提交的消息 $m_i$ ，挑战者执行签名算法生成 $\sigma_{m_i}$ 并将其发送给敌手

$Forgery$：敌手返回一个伪造的对于某个消息 $m^{}$ 签名 $\sigma_{m^{}}$，如果：

$\sigma_{m^{}}$是一个关于 $m^{}$ 的合法签名
$m^{}$ 的签名 $\sigma_{m^{}}$ 之前没有被查询过

则敌手在游戏中获胜，敌手赢得游戏的优势 $\varepsilon$ 就是返回一个合法的伪造签名的概率


对比EU-CMA和SU-CMA的区别仅在于敌手获胜条件的判定上 $(Forgery-2)$

在EU-CMA中的要求是所有的 $m^*$ 的签名在 $Query$ 阶段都没有被查询过
而在SU-CMA中则只要求在之前的查询操作中没有出现过 $\sigma_{m^}$，也就是说，如果之前查询过关于 $m^$ 的签名 $\sigma_{m^}^{(1)}$，如果敌手可以生成另一个关于 $m^$ 的签名 $\sigma_{m^}^{(2)}$，而且 $\sigma_{m^}^{(1)}\neq \sigma_{m^*}^{(2)}$，也判定为敌手获胜

显然 SU-CMA 中的敌手拥有更强的能力, 因此可以认为 SU-CMA 相比 EU-CMA 是更强的安全模型.

reference：
https://www.cnblogs.com/zywnnblog/p/16111384.html
https://documents.uow.edu.au/~fuchun/jow/011-QAXEDWBAMA.pdf
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>buuoj古典密码学wp</title>
    <url>/2024/09/24/buuoj%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6wp/</url>
    <content><![CDATA[此博客用于整理，之前做过的古典密码学题目
之前存储于本地，今天移植到博客中，后续不再在此页面更新
分级十分的混乱，之后有缘再改吧（逃

古典密码学

Linux python 很重要
Bugku
实验吧（现在没了）
南邮网络攻防训练平台（现在也没了）
密码学的三个阶段


古典密码（1949以前），复杂度不高，安全性地，具有艺术性

近代密码（1949-1975），计算机诞生，加密算法在复杂程度和安全性上得到了提升

现代密码（1976至今），美国密码学专家Diffie和Hellman在1976年提出公开密钥密码体制概念（非对称制加密），密码学有了全新的方向

古典密码学：

涉及数学问题较少
很容易被破解，但是设计原理和分析方法对理解设计分析现代密码有帮助
主要分为：替代和置换
强化python脚本编写能力，尽力讲大多数加密方法都能写出破解脚本
MD5暴力破解以及算法逆向

键盘加密

键盘布局加密

通常给出一堆无意义的字符，但是在键盘上比划一下就能拼出相应的字符
可以划归脑洞题的范围
键盘坐标加密

bye 对应的密文是 35 16 13（或者相反）
字母行总共三行，数字行总共10行（在一些脑洞题中不一定）
如果小写不对，可能是大写的
BF和Ook密码

不需要探究原理，只需要能够识别出它
BrainFuck密码用&lt;&gt;+-.,[]八种符号来替换c语言的各种语法和命令
Ook密码三种符号组成 Ook. Ook? Ook!（or short Ook,由.?!组成）
解密使用PHP工具[Ook-masker][http://106.13.121.19/ook/]进行解密
替换密码替换表保存明文和密文之间的关系
隐藏明文但是不打乱顺序
摩斯密码认出（有时表现为包括但不限于01序列的密码，可以使用记事本进行转化）
可以用Bugku的[在线工具][tool.bugku.com/mosi/]进行解密
或者本地工具CTFCrackTools
摩斯密码解密代码txt = input().strip().split#用空格分开key = &#123;	&#x27;01&#x27;: &#x27;A&#x27;,&#x27;1000&#x27;: &#x27;B&#x27;,&#x27;1010&#x27;: &#x27;C&#x27;,&#x27;100&#x27;:&#x27;D&#x27;,        &#x27;0&#x27;:&#x27;E&#x27;,&#x27;0010&#x27;:&#x27;F&#x27;,&#x27;110&#x27;: &#x27;G&#x27;,&#x27;0000&#x27;: &#x27;H&#x27;,&#x27;00&#x27;: &#x27;I&#x27;,        &#x27;0111&#x27;:&#x27;J&#x27;,&#x27;101&#x27;: &#x27;K&#x27;,&#x27;0100&#x27;: &#x27;L&#x27;,&#x27;11&#x27;: &#x27;M&#x27;,&#x27;10&#x27;: &#x27;N&#x27;,        &#x27;111&#x27;: &#x27;O&#x27;,&#x27;0110&#x27;: &#x27;P&#x27;,&#x27;1101&#x27;: &#x27;Q&#x27;,&#x27;010&#x27;: &#x27;R&#x27;,&#x27;000&#x27;: &#x27;S&#x27;,        &#x27;1&#x27;: &#x27;T&#x27;,&#x27;001&#x27;: &#x27;U&#x27;,&#x27;0001&#x27;: &#x27;V&#x27;,&#x27;011&#x27;: &#x27;W&#x27;,&#x27;1001&#x27;: &#x27;X&#x27;,        &#x27;1011&#x27;: &#x27;Y&#x27;,&#x27;1100&#x27;: &#x27;Z&#x27;,&#x27;01111&#x27;: &#x27;1&#x27;,&#x27;00111&#x27;: &#x27;2&#x27;,        &#x27;00011&#x27;: &#x27;3&#x27;,&#x27;00001&#x27;: &#x27;4&#x27;,&#x27;00000&#x27;: &#x27;5&#x27;,&#x27;10000&#x27;: &#x27;6&#x27;,        &#x27;11000&#x27;: &#x27;7&#x27;,&#x27;11100&#x27;: &#x27;8&#x27;,&#x27;11110&#x27;: &#x27;9&#x27;,&#x27;11111&#x27;: &#x27;0&#x27;,      	&#x27;001100&#x27;:&#x27;?&#x27;,&#x27;10010&#x27;:&#x27;/&#x27;,&#x27;101101&#x27;:&#x27;()&#x27;,&#x27;100001&#x27;:&#x27;-&#x27;,       	&#x27;010101&#x27;:&#x27;.&#x27;,&#x27;110011&#x27;:&#x27;,&#x27;,&#x27;011010&#x27;:&#x27;@&#x27;,&#x27;111000&#x27;:&#x27;:&#x27;,       	&#x27;101010&#x27;:&#x27;:&#x27;,&#x27;10001&#x27;:&#x27;=&#x27;,&#x27;011110&#x27;:&quot;&#x27;&quot;,&#x27;101011&#x27;:&#x27;!&#x27;,       	&#x27;001101&#x27;:&#x27;!&#x27;,&#x27;001101&#x27;:&#x27;_&#x27;,&#x27;010010&#x27;:&#x27;&quot;&#x27;,&#x27;10110&#x27;:&#x27;(&#x27;,       	&#x27;1111011&#x27;:&#x27;&#123;&#x27;,&#x27;111101&#x27;:&#x27;&#125;&#x27;&#125;for i in txt:    print(key.get(i),end=&#x27; &#x27;)    #txt = #table = &#x27;&#x27;.maketrans(&#x27;.-&#x27;,&#x27;01&#x27;)#txt.translate(table)
凯撒密码只有25种可能的密钥（大小写不变），当年凯撒用的密钥是3
解码：CTFCrackTools或者自行编写脚本
加密：(x+k)%26 解密：(y-k)%26 （0~25来表示a~z）
凯撒密码解密代码txt = input()for i in range(1,26):    plain = &#x27;&#x27;    for j in txt:        if j.islower():            plain = plain + chr(97+(ord(j)-i-97)%26)        elif j.isupper():            plain = plain + chr(65+(ord(j)-i-65)%26)        else:            plain = plain + j    print(plain)
plus版本txt = input(&#x27;请输入密文： &#x27;).strip()n = input(&#x27;是否需要推荐明文(Y/N)&#x27;).strip()for i in range(1,26):    plain = &#x27;&#x27;    for j in txt:        if j.islower():            plain = plain + chr(97+(ord(j)-i-97)%26)        elif j.isupper():            plain = plain + chr(65+(ord(j)-i-65)%26)        else:            plain = plain + j        if n.lower() == &#x27;y&#x27;:        key = (&#x27;flag&#x27;,&#x27;ctf&#x27;,&#x27;key&#x27;,&#x27;the&#x27;,&#x27;is&#x27;,&#x27;no&#x27;,&#x27;for&#x27;)        for m in key:            if m in plain:                print(&#x27;recomanding: &#x27;+plain)                print()                break            elif n.lower() == &#x27;n&#x27;:                print(plain)                paint()
凯撒密码的另外一种思路充分利用替换的方法
txt = input().strip()lower = &#x27;abcdefghigklmnopqrstuvwxyz&#x27;upper = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;for i in range( 1 , 26 ):    xiao = lower[i:]+lower[:i]    da = upper[i:]+upper[:i]    plain = &#x27;&#x27;    table = &#x27;&#x27;.maketrans(xiao+da,lower+upper)    for j in txt:        plain = plain + j.translate(table)    print(plain)    print()
一个很腻害的python库pycipher 包含大多数密码学工具
pycipher.Caesar(3).decipher(&#x27;LORYHSBWKRQ&#x27;)
ROT13密码凯撒密码的一种变体，移位数固定为13，即把明文中的每一个字母在字母表中向后移动13位，数字和非字母字符保持不变
实现的是26个字母前半段和后半段相互交换（又叫回旋13，因为明文和密文可以相互转化）
ROT13加密解密PHP中的str_rot13()函数可以实现
&lt;?    echo str_rot13(&#x27;B&#x27;);	echo str_rot13(&#x27;O&#x27;);?&gt;
~# php -r &quot;echo str_rot13(&#x27;heetian&#x27;);&quot;
凯撒密码的改进移位密码是在凯撒密码的基础上发展而来的，常用ASCLL码表进行移位
#移位ASCLL凯撒for i in txt:    flag = flag + chr(ord(i)+key)    key = key + 1
末尾两个重复字符：可能是先base64后的凯撒加密，重复字符是==
#base64解码import base64flag = &#x27;&#x27;base64.b64decode(flag.encode())
凯撒密码的再次改进凯撒密码密钥只有25种，后来出现了单字母替换密码，即一一映射
密码空间的大小是 26！，大约4e26种密钥
词频分析法按照频率知道每个字母平均频率
对于单表替换密码的破解，标志着密码分析学的诞生
CTF题中，对于一串特别长的密文，可能通过词频分析的方法进行解题
解码在线解码
本地工具：WinDecrypto（专门进行词频分析的软件）
培根密码密文只有a和b，每个明文由五个a和b组成长度为5的字符串
bugku在线解码
常规密码表只有24个：i,j 、 u,v 对应的加密后的字符串相同
培根密码最大的特点是隐蔽性比较强，例如大小写，加粗字体
功能强大的培根密码解密网站（不知道为什么用不了）
#提取大小写flag = &#x27;&#x27;for i in a:    if i.isupper():        flag = flag +&#x27;A&#x27;    elif i.islower():        flag = flag +&#x27;B&#x27;   
#互换ABtable = &#x27;&#x27;.maketrans(&#x27;AB&#x27;,&#x27;BA&#x27;)	flag.translate(table)
解码代码#第一类培根密码txt = input().lower()a = [&quot;aaaaa&quot;,&quot;aaaab&quot;,&quot;aaaba&quot;,&quot;aaabb&quot;,&quot;aabaa&quot;,&quot;aabab&quot;,&quot;aaabba&quot;,&quot;aaabbb&quot;,&quot;abaaa&quot;,&quot;abaab&quot;,&quot;ababa&quot;,&quot;ababb&quot;,&quot;abbaa&quot;,&quot;abbab&quot;,&quot;abbba&quot;,&quot;abbbbb&quot;,&quot;baaaa&quot;,&quot;baaab&quot;,&quot;baaba&quot;,&quot;baabb&quot;,&quot;babaa&quot;,&quot;babab&quot;,&quot;babba&quot;,&quot;babbb&quot;,&quot;bbaaa&quot;,&quot;bbaab&quot;]b = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;#[chr(i) for i in range(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1)]key = dict(zip(a,b))for i in range(0,len(txt),5):    print(key.get(txt[i:i+5]))
#第二类培根密码txt = input().lower()a = [&quot;aaaaa&quot;,&quot;aaaab&quot;,&quot;aaaba&quot;,&quot;aaabb&quot;,&quot;aabaa&quot;,&quot;aabab&quot;,&quot;aaabba&quot;,&quot;aaabbb&quot;,&quot;abaaa&quot;,&quot;abaab&quot;,&quot;ababa&quot;,&quot;ababb&quot;,&quot;abbaa&quot;,&quot;abbab&quot;,&quot;abbba&quot;,&quot;abbbbb&quot;,&quot;baaaa&quot;,&quot;baaab&quot;,&quot;baaba&quot;,&quot;baabb&quot;,&quot;babaa&quot;,&quot;babab&quot;,&quot;babba&quot;,&quot;babbb&quot;]b = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;(ij)&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;(uv)&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]dirt = &#123;i:j for i,j in zip(cipher,plain)&#125;flag = &#x27;&#x27;for i in range(0,len(txt),5):    flag = flag + dirt.get(a[i:i+5])print(flag)
仿射加密Affine
将26个英文字母用0~25表示

需要两个密钥，a和b，取值范围是[0,25]
要求a和26互质，即a的因数不包括2或13

x为明文，y为密文
加密公式 = （ax+b) mod 26


解码：使用乘法逆元
假设用m表示a的乘法逆元，那么(a*m)mod 26 = 1
可以写一个简单的枚举代码来求m
#枚举乘法逆元m = 1while True:    if a*m%26 == 1:        print(m)        break    m = m + 1#逆向计算mi = input()for i in mi:    print(chr(97+(ord(i)-97-b)*a%26),end=&#x27;&#x27;)#暴力破解for i in mi:    for j in range(0,26):        if(a*j+7)%26 == ord(i)-97:            print(chr(97+j),end=&#x27;&#x27;)
 #利用pycipher库中的Affine类可以直接对仿射加密进行加解密#加密pycipher.Affine(a,b).decipher(&#x27;flag&#x27;)#解密pycipher.Affine(a,b).encipher(&#x27;queue&#x27;)
猪圈密码更多的是对应加密
可以使用CTFCrackTools进行解密
单表替换的简单总结
明文和密文一一对应
空间足够小则采用暴力破解；密文足够长则使用词频分析法
密钥空间足够大，密文长度足够短的情况下，破解较为困难

多表替换利用密钥的每一位分别加密每一位明文
维基利亚密码txt = input()password = input().lower()key = [ord(i)-97 for i in password]*5flag = &#x27;&#x27;for i in range(len(txt)):    if txt[i].islower():        flag = flag + chr(97+ord(txt[i])-97-key[i]%26)    elif txt[i].isupper():        flag = flag + chr(65+ord(txt[i])-65-key[i]%26)print(flag)
#更优雅的写法txt = input()password = input().lower()key = [ord(i)-97 for i in password]flag = &#x27;&#x27;for i in range(len(txt)):    if txt[i].islower():        flag = flag + chr(97+ord((txt[i])-97-key[i%len(key)])%26)    elif txt[i].isupper():        flag = flag + chr(65+ord((txt[i])-65-key[i%len(key)])%26)print(flag)
利用pycipher库进行解码
pycipher.Vigenere(&#x27;密钥&#x27;).encipher(&#x27;密码&#x27;)pycipher.Vigenere(&#x27;密钥&#x27;).dncipher(&#x27;明码&#x27;)
费纳姆密码（二战中曾使用过）明文^密钥=密文
密文^密钥=明文
解密时将密文七位一组，然后与密钥异或，再将结果转化为ASCLL即可（也可以直接一串二进制数）
#把一串二进制数划分为七位一组txt = input()mi = []for i in range(0,len(txt),7):    mi.append(txt[i:i+7])
for m,n in zip(mi,key):    print(chr(int(m,2)^ord(n)),end=&#x27;&#x27;) 
杰斐逊转轮加密(tagged)36片同样大小的木质转轮，套在一根铁杆上，每个轮子有乱序26英文字母
 for m,n in zip(mi,key):    flag.append(txt[m-1][txt[m-1].index(n):] + txt[m-1][:txt[m-1].index(n)])
置换密码明文不变，打乱排列顺序
栅栏密码总共n个字符，分为m（n的因数）组，依次取出各组的第一、二······个字母
加密解密方法是可逆的，要求是两个因数之积为n
在线解密：bugku在线工具
本地解密：CTFCrackTools
#寻找因数txt = input()key = []for i in rnage(2,len(txt)):    if len(txt) % i == 0:        key.append(i)
#解密代码for m in range(0,key):    for n in range(m,len(txt),key):        print(txt[n],end=&#x27;&#x27;)
def zhalan(txt,key):    for m in range(key):        for n in range(m,len(txt),key):            s = s + txt[n]    return sif __name__ == &#x27;__main__&#x27;:    txt = input().strip()    key = []    for i in range(2,len(txt)):        if len(txt)%i == 0:            key.append(i)    for j in key:        flag = zhalan(txt,j)        print(f&#x27;&#123;j&#125;栏：&#123;flag&#125;&#x27;)
pychipher.Railfence(m).encipher(&#x27;&#x27;)pychipher.Railfence(m).dncipher(&#x27;&#x27;)
#翻转字符串s = txt[::-1]
有可能出现题型，需要填充一定量的无关符号
列置换将明文填写在一个矩阵中，然后以预订的顺序按列读取得到密文
列置换的密钥通常会以一个单词的形式给出
如： nice      相当于4312
按照每个字符在字母表中的前后排列来排列
矩阵列数由密钥决定，列数=密钥长度
#常规加密方法（不具备普遍性）pycipher.ColTrans(&#x27;key&#x27;).encipher(&#x27;&#x27;).lower()pycipher.ColTrans(&#x27;key&#x27;).decipher(&#x27;&#x27;).lower()
Polybius（波利比奥斯）密码又称棋盘密码
把棋盘上的字符，对应到密码表上的坐标
很简单也很灵活，用法可能比较混乱
ADFGX密码波利比奥斯密码的升级版
用ADFGX五个字母代替了12345五个数字
pycipher.ADFGX(&#x27;密码表&#x27;,&#x27;密钥&#x27;).encipher(&#x27;明文&#x27;)pycipher.ADFGX(&#x27;密码表&#x27;,&#x27;密钥&#x27;).decipher(&#x27;密文&#x27;)#python默认自存密码表#help(pycipher.ADFGX)pycipher.ADFGX(&#x27;密码表&#x27;,&#x27; &#x27;).decipher(&#x27;密文&#x27;)#不做列置换
ADFGVX密码：六个字母表示6*6=36个字符

BUU密码学刷题WP一眼就解密base64.b64decode(&quot;ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=&quot;)
flag{THE_FLAG_OF_THIS_STRING}
MD5https://www.somd5.com/
flag{admin1}
Url编码https://tool.ip138.com/urlencode/
flag{and 1=1}
看我回旋踢
flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1}
摩丝
flag{ILOVEYOU}
password根据字符数猜测：密码=姓名+出生年月日
flag{zs19900315}
变异凯撒移位凯撒
txt = &quot;afZ_r9VYfScOeO_UL^RWUc&quot;.strip()plain = &#x27;&#x27;cnt = 4for i in txt:    cnt = cnt + 1    plain = plain + chr(ord(i)+cnt)print(plain)
flag{Caesar_variation}
Quoted-printableQuoted-printable可译为“可打印字符引用编码”，编码常用在电子邮件中
考虑用python的quopri库进行解密
quopri.decodestring(&#x27;=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6&#x27;)
得到一串UTF-8密文
&#39;\xe9\x82\xa3\xe4\xbd\xa0\xe4\xb9\x9f\xe5\xbe\x88\xe6\xa3\x92\xe5\x93\xa6&#39;
s = &#x27;\xe9\x82\xa3\xe4\xbd\xa0\xe4\xb9\x9f\xe5\xbe\x88\xe6\xa3\x92\xe5\x93\xa6&#x27;ss = s.encode(&#x27;raw_unicode_escape&#x27;)#此str转化为bytesprint(ss)sss = ss.decode()print(sss)
flag{那你也很棒哦} 
RabbitRabbit加密
AES、DES、RC4、Rabbit、Triple DES（3DES）这些算法都可以引入密钥
密文特征与Base64类似，明显区别是秘文里+比较多，并且经常出现/
http://www.jsons.cn/rabbitencrypt/
flag{Cute_Rabbit}
篱笆墙的影子栅栏密码，CTFCrackTool即可解码（python内置函数不好用）

flag{wethinkwehavetheflag}
丢失的MD5把报错的代码改对

print语法错误
TypeError: can&#39;t concat str to bytes，字符类型错误；哈希之前必须对Unicode对象进行编码，应当在”update”函数之中所有的所有参数进行可选参数编码，默认编码为’utf-8’

flag{e9032994dabac08080091151380478a2}
Alice与Bob使用在线工具分解质数
https://zh.numberempire.com/numberfactorizer.php
进行MD5加密
https://md5jiami.bmcx.com/
flag{d450209323a847c8d01c6be47c81811a}
大帝的密码武器
偏移量是13

记得改对大小写
flag{PbzrPuvan}
Windows系统密码使用在线工具，解码第二行第三组数据（为什么这个数据？因为第二行在admin下面，而前面那个数字解不出来）

flag{good-luck}
信息化时代的步伐中文电码（misc题）
http://code.mcdvisa.com/
flag{计算机要从娃娃抓起}
凯撒？替换？呵呵!试一试凯撒密码，发现不对
猜测是替换密码，选择传统的字典爆破思路

去掉空格，改成小写即可

萌萌哒的八戒猪圈密码http://mmoersima.00cha.net/zhuquan.asp

flag{whenthepigwanttoeat} 
传统知识+古典密码
根据所给条件一一映射，再都加60，转成ASCLL码

之后是栅栏+凯撒，胡乱操作一番就可以找到一个像flag一样的东西


flag{SHUANGYU}
权限获得第一步上面有原题，一模一样

flag{3617656}
世上无难事词频分析即可得到flag，记得改小写
flag{640e11012805f211b0ab24ff02a1ed09}
old-fashion如上题，需要将模式改为Genetic,trust spaces
flag{n1_2hen-d3_hu1-mi-ma_a}
Unencode在线解码网站http://www.hiencode.com/uu.html
类似于base64，只是后来被取代了
flag{dsdasdsa99877LLLKK}
[AFCTF2018]Morse使用工具进行解码

观察得到这一串最大是F，猜测是base16

flag{1s’t_s0_345y}
还原大师总共三个未知量，26^3个可能性，穷举所有可能即可
md5加密：y = hashlib.md5(x.encode(&#39;utf-8&#39;)).hexdigest().upper()
import hashlibm = &#x27;TASC?O3RJMV?WDJKX?ZM&#x27;for i in range(26):    t1 = m.replace(&#x27;?&#x27;,str(chr(65+i)),1)    for j in range(26):        t2 = t1.replace(&#x27;?&#x27;,str(chr(65+j)),1)        for k in range(26):            t3 = t2.replace(&#x27;?&#x27;,str(chr(65+k)),1)            s = hashlib.md5(t3.encode(&#x27;utf-8&#x27;)).hexdigest().upper()            if s[:4] == &#x27;E903&#x27;:                print(s)
flag{E9032994DABAC08080091151380478A2}
异性相吸key = open(&quot;key.txt&quot;, &#x27;rb&#x27;).read()cipher = open(&quot;密文.txt&quot;, &quot;rb&quot;).read()flag = []result = &quot;&quot;for i in range(len(key)):    flag.append(key[i] ^ cipher[i])    result += chr(flag[i])print(flag)print(result)
flag{ea1bc0988992276b7f95b54a7435e89e}
[GXYCTF2019]CheckInROT5、ROT13、ROT18、ROT47 编码是一种简单的码元位置顺序替换暗码；此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取，而不让其理解其意。
rot5只用于数字的替换，将当前数字往后移5位，范围是0~9
明文:  123456密文:  678901
rot13只能用于字母的替换，将当前字母往后移13个位置(不改变字母大小写)，范围为a-z或者A-Z
明文：abcdefghijklmnopqrstuvwxyz密文：nopqrstuvwxyzabcdefghijklm明文：ABCDEFGHIJKLMNOPQRSTUVWXYZ密文：NOPQRSTUVWXYZABCDEFGHIJKLM
rot18就是13+5的合成，加密方法是rot5+rot13，对数字进行rot5加密，对字母进行rot13加密
明文：123456abcdefgHIJKLMN密文：678901nopqrstUVWXYZA
rot47将每位数字/字母的ASCII值往前移动47位，比如”Z”对应的ASCII值是90，则90-47=43，对应是”+”
明文：ilo1ey0u密文：:=@`6J_F范围是可打印的字符，ASCII值为32-126
ROT47在线解码工具https://www.jisuan.mobi/YYA.html
flag{Y0u_kNow_much_about_Rot}
Cipherplayfair密码，需要 j -&gt; i
在线解密网站
https://rumkin.com/tools/cipher/playfair/
http://www.hiencode.com/playfair.html

flag{itisnotaproblemhavefun}
2024.1.8 星期一[BUUCTF]yxx

给了两个文件，用二进制打开
粘下来进行二进制异或即可得到flag
cipher = &quot;&quot; ; plain = &quot;&quot; ; flag = &quot;&quot;t = &quot;0A 03 17 02 56 01 15 11 0A 14 0E 0A 1E 30 0E 0A 1E 30 0E 0A 1E 30 14 0C 19 0D 1F 10 0E 06 03 18&quot;.split()for i in t:    cipher = cipher + str(bin(int( i , 16 )))[2::].zfill(8)t = &quot;6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65&quot;.split()for i in t:    plain = plain + str(bin(int( i , 16 )))[2::].zfill(8)for i in range(len( cipher )):    if cipher[i] == plain[i]:        flag = flag + &quot;0&quot;    else:        flag = flag + &quot;1&quot;print( flag )for i in range( 0 , len(flag) , 8 ):    t = &quot;&quot;    for j in range( i , i + 8 ):        t = t + str( flag[j] )    print( hex( int(t,2) )[2::] , end=&quot;&quot; )
flag:flag&#123;xor_xor_xor_biubiubiu&#125;
2024.1.9 星期二[CTFshow元旦水友赛]麻辣兔头又一锅听说有人不喜欢短尾巴的兔兔？肿么可能？我也很疑惑呢。126292,165298,124522,116716,23623,21538,72802,90966,193480,77695,98618,127096,15893,65821,58966,163254,179952,134870,45821,21712,68316,87720,156070,16323,86266,148522,93678,110618,110445,136381,92706,129732,22416,177638,110110,4324,180608,3820,67750,134150,23116,116772,50573,149156,529260144,146332,165671,109800,176885,65766,76908,147004,135068,182821,123107,77538,86482,88096,101725,16475,158935,123018,42322,144694,186769,176935,59296,134856,65813,131931,144283,95814,102191,185706,55744,67711,149076,108054,135112,100344,35434,121479,14506,145222,183989,17548,38904,27832,105943

“兔子”并不一定是栅栏密码，还有可能是斐波那契数列
import gmpy2 a = &quot;126292,165298,124522,116716,23623,21538,72802,90966,193480,77695,98618,127096,15893,65821,58966,163254,179952,134870,45821,21712,68316,87720,156070,16323,86266,148522,93678,110618,110445,136381,92706,129732,22416,177638,110110,4324,180608,3820,67750,134150,23116,116772,50573,149156,5292&quot;.split(&quot;,&quot;)b = &quot;60144,146332,165671,109800,176885,65766,76908,147004,135068,182821,123107,77538,86482,88096,101725,16475,158935,123018,42322,144694,186769,176935,59296,134856,65813,131931,144283,95814,102191,185706,55744,67711,149076,108054,135112,100344,35434,121479,14506,145222,183989,17548,38904,27832,105943&quot;.split(&quot;,&quot;)for i in range( len( a ) ):    print(chr((gmpy2.fib(eval(a[i]))^gmpy2.fib(eval(b[i])))&amp;0xff),end=&#x27;&#x27; )
我们需要计算出两行的斐波那契数然后异或，使用python的gmpy2.fib即可计算斐波那契数列的任意位
flag:ctfshow&#123;6d83b2f1-1241-4b25-9c1c-0a4c218f6c5f&#125;
问题：这道题是如何构造的
全体正整数n和fib(n)构成单射，而非一一映射，出题人是如何构造的，是否可以根据指定的flag来构造密文
猜想：由于最终对Oxff进行与运算，故只需要考虑16进制下的最后两位；总共有255，如果是直接进行与运算，最劣情况下进行不超过65536次运算即可得到一个字母对应的斐波那契数；其序数可以进行暴力运算进行逆推；或者构造一组“最小剩余系”来表示所有需要的数，容量为256，进行组合即可
反驳：对于所有的已知数据，没有一个是重复的
回答：可以不是随机，每256个数就存在一个数符合预期要求；也不需要有重复的数字，python对于斐波那契数列的算力很强；故由一个flag，可以随机出一个a序列，然后暴力计算出b序列
2024.1.10 星期三[BUUCTF·网鼎杯2020青龙组]boom获得到一个exe文件
一
first:this string md5:46e5efe6165a5afb361217446a2dbd01
二
This time:Here are have some formulas3x-y+z=1852x+3y-z=321x+y+z=173input: x =
三
Last time: Kill itx*x+x-7943722218936282=0input x:

使用cmd打开
一
使用https://www.somd5.com/解密得到`en5oy`
二
可以使用高斯消元法https://www.luogu.com.cn/problem/P3389
//2021-11-13#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int N = 105;double a[N][N];int n;int main()&#123;	scanf(&quot;%d&quot;, &amp;n);	for(int i = 1; i &lt;= n; i ++)		for(int j = 1; j &lt;= n + 1; j ++)			scanf(&quot;%lf&quot;, &amp;a[i][j]);	for(int i = 1; i &lt;= n; i ++)&#123;		int maxx = i;		for(int j = i + 1; j &lt;= n; j ++)			if( fabs(a[j][i]) &gt; fabs(a[maxx][i] ) )				maxx = j;		for(int j = 1; j &lt;= n + 1; j ++)			swap( a[i][j], a[maxx][j] );		if( !a[i][i] )&#123;			cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl;			return 0;		&#125;		for(int j = 1; j &lt;= n; j ++)			if(j != i)&#123;				double temp = a[j][i] / a[i][i];				for( int k = i + 1; k &lt;= n + 1; ++k)					a[j][k] -= a[i][k] * temp;			&#125;	&#125;	for(int i = 1; i &lt;= n; i ++)		printf(&quot;%.2lf\n&quot;, a[i][n + 1] / a[i][i]);	return 0;&#125;/*33 -1 1 1852 3 -1 3211 1 1 173*/
也可以使用python自带库
from sympy import*from sympy.abc import x,y,zans = solve([3*x-y+z-185,2*x+3*y-z-321,x+y+z-173],[x,y,z])print( ans )
解得：x = 74, y = 68, z = 31
三
一元二次方程，可以用同样的方式去解
from sympy import*from sympy.abc import xans = solve([x*x+x-7943722218936282],[x])print( ans )
解得：x1 = 89127561 , x2 = -89127562
flag:flag&#123;en5oy_746831_89127561&#125;
isctf2023夹里夹气观察发现是摩斯密码，将ISCTF摩斯密码加密得到.-串，发现原字符串，两个一组是.，三个一组是-
自行增加?并替换，进行莫斯解密即可
print( s.replace(&quot;嘤嘤嘤&quot;,&quot;-&quot;).replace(&quot;嘤嘤？&quot;,&quot;.&quot;) )
ISCTF{HSBDH_SFJ_JDNFJ_DJNFJDM}
2024.1.19 星期五[BUUCTF·ACTF新生赛2020]crypto-classic0有点像misc，是一个文件

提示密码是生日，直接八位数字爆破，得到19990306
直接解密即可
txt = &quot;Ygvdmq[lYate[elghqvakl&#125;&quot;flag = &quot;&quot;for i in txt:    flag = flag + str(chr( (ord(i) ^ 0x7) + 3) )print( flag )
flag:flag&#123;my_naive_encrytion&#125;
2024.1.20 星期六[BUUCTF·WUSTCTF2020]B@se密文：MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/oh holy shit, something is missing...

查找缺失的密码表
import stringtable = &quot;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/&quot;cipher = &quot;MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==&quot;for i in string.ascii_letters+string.digits:    if i not in table:        print( i , end = &quot; &quot; )
j u 3 4
from itertools import *from binascii import *table = &quot;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/&quot;cipher = &quot;MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD&quot;s = [&#x27;j&#x27;,&#x27;u&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]for i in permutations( s , 4 ):    t = &quot;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs&quot;+&quot;&quot;.join(i)+&quot;kxyz012789+/&quot;    bins = &quot;&quot;    for j in cipher:      bins+=bin(t.index(j))[2:].zfill(6)    print(unhexlify(hex(eval(&quot;0b&quot;+bins))[2:-1]))
flag:flag&#123;base64_1s_v3ry_e@sy_and_fuN&#125;
2024.1.5星期五[BUUCTF·MRCTF2020]vigenereg vjganxsymda ux ylt vtvjttajwsgt bl udfteyhfgtoe btlc ckjwc qnxdta vbbwwrbrtlx su gnw nrshylwmpy cgwps, lum bipee ynecgy gk jaryz frs fzwjp, x puej jgbs udfteyhfgt, gnw sil uuej su zofi. sc okzfpu bl lmi uhzmwi, x nyc dsj bl lmi enyl ys argnj yh nrgsi. nba swi cbz ojprbsw fqdam mx. cdh nsai cb ygaigroysxn jnwwi lr msylte.cw mekr tg jptpzwi kdikjsqtaz, ftv pek oj pxxkdd xd ugnj scr, yg n esqxwxw nba onxw au ywipgkj fyiuujnxn gnss xwnz onxw jnahl avhwwxn vzkjpu nrofch fvwfoh. v jwhppek lmi vyutfp hbiafp hcguj at nxw gyxyjask ib hw seihxsqpn vtvjttajwsx ds zzj xnegfsmtf egz wtrq lt mbcukj sc hy. qty wnbw ss bbxsq vxtnl ys ghrw zw cbx vt cdh vgxwtfy ssc brzzthh bl wsjdeiwricg cw mekr zjzi grgktr ib lwfv.vbbwwrbrtlx hteonj xwroj oyhg vgbigf ljtq iuk utrhrtl tj iuk ytztetwi. cdh nsai crolmig fudngxgkv ssg ekujmkrj gzvh. jk vnh cbz aszxgk qty. nba vt rdg qfta jf, tgw hd lum prdj umw aderv. hcqrxkuerr jgjw cbz dni lvzznr nbaj gsgqkjx. hd aul ylxaq lmei lum hec oaaqh xg, gk yldhmz nx lrxw f tjorah gdaylwyrgogs tgbpwhx. nba ufrcbz. ay mh nt shx ds tsyygr gfi mi txgbw xgywqj iuxgzkw baj hsaykuymkr guymday.qty wnbw ssi rtyfktq of tyg txwfx paj yfxwrxask rbtnjvhnzatr, cbx vnh nba uwipgk lmi lrgdyl ds umw qpeqwytaniwx. cdh jg ssi xtgb sje imqxjek, gzv tgnahw, de zzj ycjxayxta igiih gnsy eaeksic eeunnht baj xsrvkld qdek gwhte zzfr rbadi ft bhlfmcrj td ecl ux dsje oeushvzatrh.lum hppvs lmigr gjj tgbhdjqh nsgsk jf zzfx nba fjis gu ktpkr. egz yhr zznw rygar eh nt wcgjfk lt mcigvj sje vjjgxailx. qpae gk xwryw uvdorwrw sbt&#x27;l jbxfz. omigr zzjvt nxw wipy igsjavilx, awrxw yltek swi leuflw, lr caqp xqkfymul zzjq paj sihgryk yltz hq tyg zkssw. lr gjj jdesask dhx gbr hbiafp rbtlwerg. zznw vbbwwrpaiw bmay gjnwt niutvsvty ys iuk utrsvzatrh bl gzv lbxdi, rdg egzvh. baj bsgyj ax hxslwwicg.iqgigfvshi rbtknwif ux yvpayshxxbtk, wianzatrhuohx, ecq zztyvuz aywtyl, swvplkv qmzr g kyecqofl apik as xwr cwg su baj hsbzafngpgogsw. dhxk nw p jujqh iugl nw qbzz jzteeomigr gfi rdjnwwi, qhz ay mh aul bltek tthxry dnzt.jk swi reksymct g otvaq zzfx pyr efc tazww axgngzx eeonnpttk gw tgrpmimrr guhsgqkv gc gniw, jgdaueng ebcww, qxyolfvn sujhi, de ylfxxbt gk fxezz.bi pek uwipgofl e lbxdi awrxw frnbtw, frnjnwwi bne wctgryk mmh bx zjv qrrajjh, au efxirx zta hvtyzppe, cayldhz xjeg bl tjmct igjvrrj asxd fodjrrr uj hscsujrmil.egzv armsq gdaiwuxh bl hwserxld, imcxwxwxbt, aiicgold, qdikejri, ntv hscgkpy hd aul fteye lt yh. gnwd egr gdq fpfkv tr bnzljv, paj lmigr ok ss bnzljv wrxw.tyg vjwsxxgowx lpik ft fdqowx, wd, htdnot lum, bi rntftx dozsnr dejww fn cnqxmrnr utigpogs. at okdnikr zzfx ueue jxwvik, jravmzyicrj kjpu-vtljvtfz, ssh iuk utqbbtojea, baj lskrxffrrr caqp tzkjli. dhx aiicgolnih zgq gi svylwmqhzwi ereukx qpae gk cdhx bzvxfjahxxbtk. ylt btdd ppj zzfx pyr gzv rbtkymihkfy gjyzmwih jumqh vrtwweaye jjgdttaei xf zzj kdyjws vjyk. oj ldck oj axyr tj eqyk lt fjvrv tyg cgjymrhrsw wdyalnscf uf ylpg hsxmh. oal bi rntftx ppiwux iuk ktpjgogsw nba swi pgzwrtivty ys xzvgxi.xa zzj ycvzwi winzwx, cdh nsai ibjsd ggrgljh p ygo, ylt gkdjgdzsmsmrnzatrh ekxtvb nil, blxpn jjtjqosyih lumw sla igswivzmymda gfi mcfadyw iuk vwipzy gk ntslwwwda, csxlxamltr, bvrd, resvygs, htguizikvrdj, ecq hjfrsrok. yltfk vwipzy ezwi auo gi qbxf frtj of zw.nba swi irxjnjxrj gk cdhx gbr ruodivta, yasgt gnwd egr tsymkry as e lbxdi awrxw dsj jodq eajgqx ft vsenkgntlx. ftpgmxi nba xjeg gnwr, cdh kfyvjfz qtyg oajjejpxshmtf cayl iuk hfvtazsq vtfvgswxoodnxxry qty pek lts rbcswhal zg hscsxgsx nbajxiaikk. nr dhx otvaq, gdq xwr ywsxxzkfyw paj wctgryknscf ux mybntayc, ueue ylt qktfwxam lt xwr gfliavi, swi enxlx su n ywfqaryk bldyk, lmi vyutfp rbtnjvhnzatr ds hayw. lr issrdg ywuegnzw ylt noj ylpg iztotf ljtq iuk snv jcuf blxpn onrvf hwfx.xa iznrp, tkjrecl, ljfrrr, xmxwxn, yaskpcujj, minrq frs gnw zrxgkv xxpgkk, dsj nxw yvnvty ys lnxv tju gnw amghy gk pxokjyc ql kjjgivty lypej htwif gl ylt sxgsxxrxk tj rlhwwweniw. yltfk efc zrkh tyi gnw hscggynsc suj f wbnrd ymbr, hmy xwre onpa aul bsgx of f aderv ylpg caqp hbuf gi qygfpiirj as fxg-hwfvxam ejhxn.egzv xaijjehvtyqc doygqiir ofksgzglnsc vtvzwieowx adhrv uigcklzeir zzjqhrrnjw ql vjttdfofl ppjy, as ebrxahe paj wqwtjnwwi, iugl hppvs lt sla yhjiru olxias zzwsjtngzx iuk otvaq. zzjwt ygox adhrv iirygjj msrgk ys qr gftxwrx ashjfzjnea cxgiyrg, tg rsgr tggpt gnss txt ojtr. xa umw aderv, blpgknjv iuk zzqpa sash bne uwipgk ufr qr xwuvdqaujh paj vnwieotzxtq ofkmcvzwqc pg tg hshg. zzj kabhsq gdabwdecpk gk xwbaymx cb rgskte xwvyxekk dsje lshxdeowx xd niutqeyokm.xwryw nrreksxmctrq mshgodj ecq igqscvgd ripfajjw eyguj yh vt lmi hnsw ushvzatr pf zztwt cxwamdhy dtztey gk jgrkvtq paj kjpu-qkljvbvtsymda czt lpq zg wiyril ylt nalmsgvzajw ds jaxxpaz, msmcsujris cuojvh. jk ezwi qkuqegr umw zxezmfp hrrnjw xzsmsi ib egzv hbbwwixttld, ikrt sx at pufymchk lt gdaywsx ib egzv ghrw tzte umw fdqowx. at jodq weeksi sjeywqztf guwshf zzj tantwy wd gnsy rd btw hec nxjjwi baj yldhmzyw.lr caqp reksyi p ponnpxmglnsc bl lmi bvtv nr rlhwwweniw. ren vz tj qdek zzqpak ssh unoj ylpa zzj aderv dsje mgaigaswsxh ugnj qpqk tjjdek.xqev vy ewgis balicrxw hvnczg hvppq efr, eyksxi pqj mshteyutvt ntv hygye twerry.
#!/bin/python3from ctf import source_text, key_stringgetdiff = lambda char: ord(char)-ord(&#x27;a&#x27;)getchar = lambda num: chr(ord(&#x27;a&#x27;)+num)def vigenere(src: chr, key: chr) -&gt; chr:    assert(src.isalpha() and key.isalpha())    return(getchar((getdiff(src) + getdiff(key) + 1) % 26))src = source_text.lower()count = 0assert(len(key_string) &gt; 5 and len(key_string) &lt; 10)for i in src:    if(i.isalpha()):        print(vigenere(i, key_string[count % len(key_string)]), end=&#x27;&#x27;)        count+=1    else:        print(i, end=&#x27;&#x27;)
对于这段加密代码，这是gpt给出的解释

对于网络上的wp，一般是给出这个在线网站进行破解（还挺快）https://www.guballa.de/vigenere-solver

flag:flag&#123;vigenere_crypto_crack_man&#125;
[BUUCTF·MRCTF2020]keyboard得到的flag用MRCTF&#123;xxxxxx&#125;形式上叫都为小写字母66662244455533744666663
通过九键键盘加密

可以直接手搓，搓出mobilephond
提交发现不对，调用英语知识把d改成e就对了
对于大量数据的解码脚本：
txt = &#x27;6 666 22 444 555 33 7 44 666 66 3&#x27;.split()jiujian = [&#x27;&#x27;,&#x27;&#x27;,&#x27;abc&#x27;,&#x27;def&#x27;,&#x27;ghi&#x27;,&#x27;jkl&#x27;,&#x27;mno&#x27;,&#x27;pqrs&#x27;,&#x27;tuv&#x27;,&#x27;wxyz&#x27;]for i in txt:    print(jiujian[int(i[0])][len(i)-1],end=&#x27;&#x27;)
flag:flag&#123;mobilephone&#125;
[BUUCTF·AFCTF2018]Vigenère

又是未知密钥的维吉尼亚密码，在线网站一把唆https://www.guballa.de/vigenere-solver

flag:flag&#123;Whooooooo_U_Gotcha!&#125;
密码学的心声
数字三位一组分组，形成多组八进制数
转成十进制，也是三个数一组
每组转化为相应的ASCLL码

str = &#x27;111 114 157 166 145 123 145 143 165 162 151 164 171 126 145 162 171 115 165 143 150&#x27;str = str.split(&#x27; &#x27;)flag = []for i in range(len(str)):    flag.append( str[i] )result = &#x27;&#x27;for i in flag:    result += chr(int(i,8))print( result )
flag{ILoveSecurityVeryMuch}
robomunication是一段音频，摩斯密码，转码后即可得到flag
flag{BOOPBEEP}
[BJDCTF2020]这是base??(undone)前置知识：base64
达芬奇密码(undone)[WUSTCTF2020]佛说：只能四天http://hi.pcmoe.net/buddha.html

https://atool.vip/corevalue/


传统的凯撒密码偏移量是3

base32由A~Z，2~7组成（还有”=”）

import base64def caesarCrack(c, n):    alpha = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    c = c.upper()    m = &quot;&quot;    for i in c:        index = alpha.find(i)        if index != -1:            index = (index + n) % 26            m += alpha[index]        else:            m += i    return mif __name__ == &#x27;__main__&#x27;:    c = &quot;R5UALCUVJDCGD63RQISZTBOSO54JVBORP5SAT2OEQCWY6CGEO53Z67L&quot;    # 用&#x27;=&#x27;填充字符串使其长度为8的倍数, 方便后序进行Base32解密    lenPadding = 8 - (len(c) % 8)    c += lenPadding * &quot;=&quot;    for i in range(1, 26):        ca = caesarCrack(c, i)        m = base64.b32decode(ca)        try:            m = m.decode()            print(m)        except UnicodeDecodeError:            continue
flag{ni_hao_xiang_xiang_da_wo}
[MRCTF2020]古典密码知多少猪圈密码+圣堂武士密码+标准银河字母密码
然后根据提示，使用栅栏密码
flag{CRYPTOFUN}
rot
需要暴力枚举后四位，根据md5判断正误
import hashlibtxt = &#x27;flag&#123;www_shiyanbar_com_is_very_good_&#x27;md5 = &#x27;38e4c352809e150186920aac37190cbc&#x27;for i in range(33,128):    for j in range(33,128):        for k in range(33,128):            for o in range(33,128):                flag = txt+chr(i)+chr(j)+chr(k)+chr(o)+&#x27;&#125;&#x27;                hsh = hashlib.md5(flag.encode()).hexdigest()                if( hsh == md5 ):                    print( flag )
flag{www_shiyanbar_com_is_very_good_@8Mu}
这是什么这是什么？这不是雪豹，这是jsfuck密码
拖到010editor中，得到一串这样的符号，使用https://www.bugku.com/tools/jsfuck/#解码

flag{a0448fd730b62c13ca80200c4529daa2}
[NCTF2019]Keyboard电脑键盘第一行的从W到O八个字母 -&gt; 手机九键输入法的八个字母
出现频率表示第几个
flag{youaresosmartthatthisisjustapieceofcake}
[MRCTF2020]天干地支+甲子
一甲子=60
将每个干支转化成对应的数字，再+60，转化成ASCLL码即可
flag{Goodjob}
传感器16进制转字符串即可

flag{We1c0me_t4_BJDCTF}
一张谍报有两段长度相同的文段，局部文字相同，二者不相同的内容形成多组映射，形成密码本
依据此密码本对右下角密文进行解密即可
str1 = &quot;今天上午，朝歌区梆子公司决定，在每天三更天不亮免费在各大小区门口设卡为全城提供二次震耳欲聋的敲更提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的符号是前进。为此，全区老人都蹲在该公司东边树丛合力抵制，不给公司人员放行，场面混乱。李罗鹰住进朝歌区五十年了，人称老鹰头，几年孙子李虎南刚从东北当猎户回来，每月还寄回来几块鼹鼠干。李罗鹰当年遇到的老婆是朝歌一枝花，所以李南虎是长得非常秀气的一个汉子。李罗鹰表示：无论梆子公司做的对错，反正不能打扰他孙子睡觉，子曰：‘睡觉乃人之常情’。梆子公司这是连菩萨睡觉都不放过啊。李南虎表示：梆子公司智商捉急，小心居民猴急跳墙！这三伏天都不给睡觉，这不扯淡么！到了中午人群仍未离散，更有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李南虎仍旧表示爷爷年纪大了，睡不好对身体不好。&quot;str2 = &quot;喵天上午，汪歌区哞叽公司决定，在每天八哇天不全免费在各大小区门脑设卡为全城提供双次震耳欲聋的敲哇提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的编号是前进。为此，全区眠人都足在该公司流边草丛合力抵制，不给公司人员放行，场面混乱。李罗鸟住进汪歌区五十年了，人称眠鸟顶，几年孙叽李熬值刚从流北当屁户回来，每月还寄回来几块报信干。李罗鸟当年遇到的眠婆是汪歌一枝花，所以李值熬是长得非常秀气的一个汉叽。李罗鸟表示：无论哞叽公司做的对错，反正不能打扰他孙叽睡觉，叽叶：‘睡觉乃人之常情’。哞叽公司这是连衣服睡觉都不放过啊。李值熬表示：哞叽公司智商捉急，小心居民猴急跳墙！这八伏天都不给睡觉，这不扯淡么！到了中午人群仍未离散，哇有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李值熬仍旧表示爷爷年纪大了，睡不好对身体不好。&quot;str3 = &quot;喵汪哞叽双哇顶，眠鸟足屁流脑，八哇报信断流脑全叽，眠鸟进北脑上草，八枝遇孙叽，孙叽对熬编叶：值天衣服放鸟捉猴顶。鸟对：北汪罗汉伏熬乱天门。合编放行，卡编扯呼。人离烧草，报信归洞，孙叽找爷爷。&quot;flag = &quot;&quot;for i in range( len(str3) ):    for j in range( len(str2) ):        if str3[i] == str2[j]:            flag = flag + str1[j]            breakprint( flag )

flag{南天菩萨放鹰捉猴头}
[NPUCTF2020]这是什么觅🐎得到一个无拓展名的文件，用010editor打开，发现有’jpg’，拓展名改成’jpg’，打开失败，疑似是压缩包，改成zip解压获得图片
字母和数字确定一个数字，其中T1为TUE，T2为THU；S1为SAT，S2为SUN
对应的数字：3 1 12 5 7/14 4 1 18
对应的字母：C A L E G/N D A R
flag{calendar}
[极客大挑战]proof_of_work题目链接：nc 59.110.20.54:5526 Build your own function to solve proof_of_work!
import hashlibtxt = &quot;&quot;cnt = 0for i in range( 32 , 127 ):    for j in range( 32 , 127 ):        for k in range( 32 , 127 ):            for o in range( 32 , 127 ):                txt = chr(i)+chr(j)+chr(k)+chr(o)+&quot;CwO1X7uNTpovKiWE&quot;                if hashlib.sha256(txt.encode(&#x27;utf-8&#x27;)).hexdigest() == &quot;c88bbfe56a7638ca6bf9428a5ce583d55a8376d1c77512518bd5a40d0600da26&quot;:                    print(txt)                    assert 0                cnt += 1                if( cnt == 500000 ):                    print( txt , hashlib.sha256(txt.encode(&#x27;utf-8&#x27;)).hexdigest() )                    cnt = 0;print(&quot;end&quot;)
[BUUCTF][BJDCTF2020]这是base??base64原理：用64个可打印字符表示二进制所有数据方式。2^6=64，所以可以用每六个位元为一个单元，对应某个可打印字符。三个字节长度为24个位元，对应4个base64单元；即三个字节需要用四个base64可打印字符表示

转换时每次取3byte的数据，放进24bite的缓冲区，先进为高位，数据不足24bite则用0补齐
然后每次取6bit，按照对照表的编码输出，加密后的数据量是原来的4/3
这道题相当于base64更换密码表，加密原理相同
txt.find(‘c’) 在列表中找到’c’字符，返回下标
b’010101’[2:].zfill(‘num’) 从第三位开始取，返回长度为’num’的字符串，原字符串右对齐，前面填充0。（舍弃前2位，是因为二进制数前面有前缀’0b’）
c=&quot;JKLMNOxyUVzABCDEFGH789PQIabcdefghijklmWXYZ0123456RSTnopqrstuvw+/=&quot;txt=&quot;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw&quot;end=&quot;&quot;for i in txt:    end+=bin(c.find(i))[2:].zfill(6)    x=&quot;&quot;for i in range(0,len(end),8):    x+=chr(int(end[i:i+8],2))print(x)
flag{D0_Y0u_kNoW_Th1s_b4se_map}
[BUUCTF]达芬奇密码观察发现数字列是一串打乱顺序的斐波那契数列
生成一个正常顺序的斐波那契
a = 1b = 1print( &quot;1 1 &quot;,end = &#x27;&#x27; )for i in range( 1 , 40 ):    c = a + b    print( c , end = &#x27; &#x27; )    a = b    b = c
a = &#x27;0 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309&#x27;b = &#x27;0 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711&#x27;a = a.split(&quot; &quot;)b = b.split(&quot; &quot;)flag = []m = &#x27;36968853882116725547342176952286&#x27;for i in range( len(a) ):    for j in range( len(b) ):        if a[i] == b[j]:            flag.append(m[j])            breakprint( &#x27;&#x27;.join(flag) )
flag{37995588256861228614165223347687}
发现的细节：

如果字符串最后有一个空格，split()操作后会多一个空格
&quot;&quot;&quot;requirmenta = []a.append(1)a.append(1)print( &quot;1 1 &quot;,end = &#x27;&#x27; )for i in range( 3 , 30 ):    a.append( a[i-1] + a[i-2] )    print( a[i] , end = &#x27; &#x27; )a = 1b = 1print( &quot;1 1 &quot;,end = &#x27;&#x27; )for i in range( 1 , 40 ):    c = a + b    print( c , end = &#x27; &#x27; )    a = b    b = c#add_requirment:为什么要把第一位的1都改成0&quot;&quot;&quot;
[AFCTF2018]Single#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;	freopen(&quot;Plain.txt&quot;,&quot;r&quot;,stdin);	freopen(&quot;Cipher.txt&quot;,&quot;w&quot;,stdout);	map&lt;char, char&gt; f;	int arr[26];	for(int i=0;i&lt;26;++i)&#123;		arr[i]=i;	&#125;	random_shuffle(arr,arr+26);	for(int i=0;i&lt;26;++i)&#123;		f[&#x27;a&#x27;+i]=&#x27;a&#x27;+arr[i];		f[&#x27;A&#x27;+i]=&#x27;A&#x27;+arr[i];	&#125;	char ch;	while((ch=getchar())!=EOF)&#123;		if(f.count(ch))&#123;			putchar(f[ch]);		&#125;else&#123;			putchar(ch);		&#125;	&#125;	return 0;&#125;
Jmqrida rva Lfmz (JRL) eu m uqajemf seny xl enlxdomrexn uajiderc jxoqarerexnu. Rvada mda rvdaa jxooxn rcqau xl JRLu: Paxqmdyc, Mrrmjs-Yalanja mny oekay.Paxqmdyc-urcfa JRLu vmu m jxiqfa xl giaurexnu (rmusu) en dmnza xl jmrazxdeau. Lxd akmoqfa, Wab, Lxdanuej, Jdcqrx, Benmdc xd uxoarvenz afua. Ramo jmn zmen uxoa qxenru lxd atadc uxftay rmus. Oxda qxenru lxd oxda jxoqfejmray rmusu iuimffc. Rva nakr rmus en jvmen jmn ba xqanay xnfc mlrad uxoa ramo uxfta qdatexiu rmus. Rvan rva zmoa reoa eu xtad uio xl qxenru uvxwu cxi m JRL wenad. Lmoxiu akmoqfa xl uijv JRL eu Yaljxn JRL gimfu.Waff, mrrmjs-yalanja eu mnxrvad enradaurenz seny xl jxoqarerexnu. Vada atadc ramo vmu xwn narwxds(xd xnfc xna vxur) werv tifnmdmbfa uadtejau. Cxid ramo vmu reoa lxd qmrjvenz cxid uadtejau mny yatafxqenz akqfxeru iuimffc. Ux, rvan xdzmnehadu jxnnajru qmdrejeqmnru xl jxoqarerexn mny rva wmdzmoa urmdru! Cxi uvxify qdxrajr xwn uadtejau lxd yalanja qxenru mny vmjs xqqxnanru lxd mrrmjs qxenru. Veurxdejmffc rveu eu m ledur rcqa xl JRLu, atadcbxyc snxwu mbxir YAL JXN JRL - uxoarvenz fesa m Wxdfy Jiq xl mff xrvad jxoqarerexnu.Oekay jxoqarerexnu omc tmdc qxuuebfa lxdomru. Er omc ba uxoarvenz fesa wmdzmoa werv uqajemf reoa lxd rmus-bmuay afaoanru (a.z. IJUB eJRL).JRL zmoau xlran rxijv xn omnc xrvad muqajru xl enlxdomrexn uajiderc: jdcqrxzdmqvc, urazx, benmdc mnmfcueu, datadua anzanaadenz, oxbefa uajiderc mny xrvadu. Zxxy ramou zanadmffc vmta urdxnz useffu mny akqadeanja en mff rvaua euuiau.Iuimffc, lfmz eu uxoa urdenz xl dmnyxo ymrm xd rakr en uxoa lxdomr. Akmoqfa mljrl&#123;Xv_I_lxiny_er_neja_rDc&#125;

词频分析即可得到flag

flag:flag&#123;Oh_U_found_it_nice_tRy&#125;
鸡藕椒盐味公司食堂最新出了一种小吃，叫鸡藕椒盐味汉堡，售价八块钱，为了促销，上面有一个验证码，输入后可以再换取一个汉堡。但是问题是每个验证码几乎都有错误,而且打印的时候倒了一下。小明买到了一个汉堡，准备还原验证码，因为一个吃不饱啊验证码如下：1100 1010 0000 ,而且打印的时候倒了一下。把答案哈希一下就可以提交了。(答案为正确值(不包括数字之间的空格)的32位md5值的小写形式) 注意：得到的 flag 请包上 flag&#123;&#125; 提交

奇校验：所有位（包括数据位和校验位）共含1个数为奇数
偶校验：所有位共含1个数为偶数
奇偶校验码能发现奇数个错误
海明校验码：校验位在 $2^n$ 的地方
可以算出密文是110110100000
进行md5加密得到答案
flag:flag&#123;d14084c7ceca6359eaac6df3c234dd3b&#125;
[ACTF新生赛2020]crypto-classic1哇，这里有压缩包的密码哦，于是我低下了头，看向了我的双手，试图从中找到某些规律xdfv ujko98 edft54 xdfv pok,.; wsdr43
SRLU&#123;LZPL_S_UASHKXUPD_NXYTFTJT&#125;

第一层是传统脑洞题，键盘密码的一种
circle
第二层提示是维吉尼亚密码
c=&#x27;SRLU&#123;LZPL_S_UASHKXUPD_NXYTFTJT&#125;&#x27;m=&#x27;ACTF&#123;&#x27;a=[]for i in range(4):    a.append(str(ord(c[i])-ord(m[i])))print(m,end=&#x27;&#x27;)for i in range(5,len(c)):    if &#x27;A&#x27;&lt;= c[i]&lt;= &#x27;Z&#x27;:        print(chr((ord(c[i])-int(a[i%4])-ord(&#x27;A&#x27;))%26+ord(&#x27;A&#x27;)),end=&#x27;&#x27;)    else:        print(c[i],end=&#x27;&#x27;)
flag:flag&#123;what_a_classical_vigenere&#125;
[AFCTF2018]BASE一个很大很大的文件

读取文件，进行base系列自动解密
import re, base64s = open(&#x27;flag_encode.txt&#x27;, &#x27;rb&#x27;).read()base16_dic = r&#x27;^[A-F0-9=]*$&#x27;base32_dic = r&#x27;^[A-Z2-7=]*$&#x27;base64_dic = r&#x27;^[A-Za-z0-9/+=]*$&#x27;n= 0while True:    n += 1    t = s.decode()    if &#x27;&#123;&#x27; in t:        print(t)        break    elif re.match(base16_dic, t):        s = base64.b16decode(s)        print(str(n) + &#x27; base16&#x27;)    elif re.match(base32_dic, t):        s = base64.b32decode(s)        print(str(n) + &#x27; base32&#x27;)    elif re.match(base64_dic, t):        s = base64.b64decode(s)        print(str(n) + &#x27; base64&#x27;)
flag:flag&#123;U_5h0u1d_Us3_T00l5&#125;
[UTCTF2020]basic-crypto很多二进制数，空格隔开

二进制ascll码转字符得到

之后解base64

然后是凯撒密码

对最后一段进行词频分析得到flag
congratulations! you have finished the beginner cryptography challenge. here is a flag for all your hard efforts: utflag&#123;n0w_th4ts_wh4t_i_c4ll_crypt0&#125;. you will find that a lot of cryptography is just building off this sort of basic knowledge, and it really is not so bad after all. hope you enjoyed the challenge!
flag:flag&#123;n0w_th4ts_wh4t_i_c4ll_crypt0&#125;
[WUSTCTF2020]情书Premise: Enumerate the alphabet by 0、1、2、.....  、25Using the RSA system Encryption:0156 0821 1616 0041 0140 2130 1616 0793Public Key:2537 and 13Private Key:2537 and 937flag: wctf2020&#123;Decryption&#125;

a = &quot;abcdefghijklmnopqrstuvwxyz&quot;c = &quot;0156 0821 1616 0041 0140 2130 1616 0793&quot;.split(&quot; &quot;)p = 43 ; q = 59e = 13 ; d = 937n = p * q ; phi = (p-1)*(q-1)flag = &quot;&quot;for i in c:    flag = flag + a[pow(int(i),d,n)]print (&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)
flag:flag&#123;iloveyou&#125;
[GUET-CTF2019]NO SOS..-.-.-.–…….–..-…-..-…–.-.-….-..-..–.-.-..-.-..—-

略加修改
..-.-.-.--.......--..-...-..-...--.-.-....-..-..--.-.-..-.-..----
解密得到
aababababbaaaaaaabbaabaaabaabaaabbababaaaabaabaabbababaababaabbbb
培根密码解密
flagisguetkkp
flag:flag&#123;guetkkp&#125;
[UTCTF2020]zero一个文档

零宽字符隐写https://330k.github.io/misc_tools/unicode_steganography.html

flag:flag&#123;whyNOT@sc11_4927aajbqk14&#125;
[NPUCTF2020]Classical Cipher一个文件

使用https://quipqiup.com/爆破密码
密码：the_key_is_atbash

猪圈密码+古埃及象形文字http://news.558idc.com/291134.html



flag:flag&#123;classicalcode&#125;
四面八方key1:securitykey2:information密文啊这是，骚年加油：zhnjinhoopcfcuktlj

四方密码http://www.hiencode.com/four.html
flag:flag&#123;yaungandsuccessful&#125;
[BJDCTF2020]Polybius密文：ouauuuoooeeaaiaeauieuooeeieahint：VGhlIGxlbmd0aCBvZiB0aGlzIHBsYWludGV4dDogMTQ=flag:解出明文后，请加上BJD&#123;&#125;

波利比奥斯密码
根据提示，长度是14
import itertoolss=&quot;aeoiu&quot;sumresult=[] ; numsumresult=[]ciper=&quot;ouauuuoooeeaaiaeauieuooeeiea&quot;for i in itertools.permutations(s,5):    sumresult.append(&quot;&quot;.join(i))for i in sumresult:    temp=&quot;&quot;    for j in ciper:        temp+=str(i.index(j)+1)    numsumresult.append(temp)for i in numsumresult:    flag=&quot;&quot;    for j in range(0, len(i),2):        xx=(int(i[j])-1)*5+int(i[j+1])+96        if xx&gt;ord(&#x27;i&#x27;):            xx+=1        flag+=chr(xx)    print( flag )
得到flagispolybius
flag:flag&#123;flagispolybius&#125;
救世捷径一个名叫CPU的神秘大陆有26个国家，有些国家之间会有一条无向路，每条路径都有不同的长度和一段神秘代码，救世主尼奥要从国家1出发，赶往国家26拯救大陆，请你帮助救世主选择最短路径，而走过的路的神秘代码连接起来便是flag。 以下是数行数据，每行第一个，第二个数字代表这条路的两个端点国家，第三个数字代表路途长度，最后一个字符串便是神秘代码。路在附件中~ 帮助救世主尼奥吧，他快被吓尿了。。。 注意：得到的 flag 请包上 flag&#123;&#125; 提交1 2 100 FLAG&#123;2 3 87 AFQWE2 4 57 ETKLS2 5 50 WEIVK2 6 51 AWEIW3 7 94 QIECJF3 8 78 QSXKE3 9 85 QWEIH4 13 54 WQOJF4 14 47 KDNVE4 15 98 QISNV5 10 43 AEWJV5 11 32 QWKXF5 12 44 ASJVL6 16 59 ASJXJ6 17 92 QJXNV6 18 39 SCJJF6 23 99 SJVHF7 19 99 WJCNF8 20 96 SKCNG9 20 86 SJXHF10 21 60 SJJCH11 21 57 SJHGG12 22 47 SJCHF14 10 55 EJFHG16 17 59 ASJVH18 12 53 SJFHG18 24 93 SHFVG21 22 33 SJFHB19 25 88 ASHHF20 25 96 SJVHG22 25 23 SJVHJ25 26 75 SDEV&#125;

最短路问题 洛谷·P4779 【模板】单源最短路径（标准版）
g = []for i in range( 27 ):    g.append([])for i in range( 27 ):    for j in range( 27 ):        g[i].append( 1000000 )f = open( &#x27;c.txt&#x27; , &#x27;r&#x27; ).readlines()l = []for i in f:    l.append(i.strip().split(&#x27; &#x27;))print( l )for i in l:    print( i )    g[int(i[0])][int(i[1])] = int( i[2] )    g[int(i[1])][int(i[0])] = int( i[2] )def dij():    dv = [1000000 for i in range(27)]    route = [1 for i in range(27)]    vis = [0 for i in range(27)]    for i in range( 2 , 27 ):        dv[i] = g[i][1]    dv[1] = 0    vis[1] = 1    for i in range(26):        minn = 1000000        tmp = -1        for j in range( 2 , 27 ):            if vis[j] == 0 and minn &gt; dv[j]:                minn = dv[j]                tmp = j        vis[tmp] = 1        for j in range( 2 , 27 ):            if dv[j] &gt; dv[tmp] + g[tmp][j]:                dv[j] = dv[tmp] + g[tmp][j]                route[j] = tmp    return ( route , dv )route , dv = dij()y = 26while y!=1:    print( y )    y = route[y]
得到路径
2625221252
得到flag
flag:flag&#123;WEIVKASJVLSJCHFSJVHJSDEV&#125;
坏蛋是雷宾老牌刺客之王混进了女王的住所。一天，女王得到了一个匿名举报，说她的侍卫里有一个刺客，叫做Rabin，而他的信息就在一份文件里，文件中有附带一个Pk，是523798549，密文是162853095，校验码二进制值是110001，根据说明是放在明文后一起加密的，明文与密文长度相同。加密算法和这位老牌刺客同名。快拯救女王，答案是求得的明文，进行32位md5小写哈希字符串，提交即可。 注意：得到的 flag 请包上 flag&#123;&#125; 提交

from gmpy2 import *import hashlibn=523798549p=10663q=49123e=2c=162853095inv_p = invert(p, q)inv_q = invert(q, p)mp = powmod(c, (p + 1) // 4, p)mq = powmod(c, (q + 1) // 4, q)a = (inv_p * p * mq + inv_q * q * mp) % nb = n - int(a)c = (inv_p * p * mq - inv_q * q * mp) % nd = n - int(c)for i in (a, b, c, d):    print(bin(i)[2:])    m=&#x27;10010011100100100101010&#x27;mc=str(int(m,2))md=hashlib.md5()md.update(mc.encode(&quot;utf8&quot;))print( md.hexdigest() )
flag:flag&#123;ca5cec442b2734735406d78c88e90f35&#125;
[BJDCTF2020]编码与调制tag：差分曼彻斯特编码

密文：2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6

（好像从哪里见过，而且这道题更简单一点）见代码
from Crypto.Util.number import long_to_bytestxt = &quot;2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6&quot;txt = bin(int( txt , 16 ))[2:]m = &quot;&quot;for i in range( 0,len(str(txt)),2 ):    if txt[i] == &quot;0&quot;:        m += &quot;0&quot;    else:        m += &quot;1&quot;print( long_to_bytes(int(m,2)) )
flag:BJD&#123;DifManchestercode&#125;
EasyProgramtag:misc

get buf unsign s[256]get buf t[256]we have key:whoamiwe have flag:????????????????????????????????for i:0 to 256    set s[i]:ifor i:0 to 256    set t[i]:key[(i)mod(key.lenth)]for i:0 to 256    set j:(j+s[i]+t[i])mod(256)        swap:s[i],s[j]for m:0 to 38    set i:(i + 1)mod(256)    set j:(j + S[i])mod(256)    swap:s[i],s[j]    set x:(s[i] + (s[j]mod(256))mod(256))    set flag[m]:flag[m]^s[x]fprint flagx to file

因为和flag相关的只有异或操作，可逆，故加密和解密过程代码相同
伪代码不初始化默认为0
txt = &quot; 00 BA 8F 11 2B 22 9F 51 A1 2F AB B7 4B D7 3F EF E1 B5 13 BE C4 D4 5D 03 D9 00 7A CA 1D 51 A4 73 B5 EF 3D 9B 31 B3&quot;.replace(&quot; &quot;,&quot; 0x&quot;).split(&quot; &quot;)[1:]key = &quot;whoami&quot;s = []t = []for i in range( 256 ):    s.append(i)for i in range( 256 ):    t.append(key[i%len(key)])j = 0for i in range( 256 ):    j = ( j + s[i] + ord( t[i] ) ) % 256    s[i] , s[j] = s[j] , s[i]i = 0j = 0flag = &quot;&quot;for m in range( 38 ):    i = ( i + 1 ) % 256    j = ( j + s[i] ) % 256    s[i] , s[j] = s[j] , s[i]    x = ( s[i] + ( s[j] % 256 ) ) % 256    flag += chr( int(txt[m],16) ^ s[x] )print( flag )
flag:flag&#123;f238yu28323uf28u2yef2ud8uf289euf&#125;
[UTCTF2020]hilltag:线性代数 | 希尔密码
wznqca&#123;d4uqop0fk_q1nwofDbzg_eu&#125;

希尔密码：左乘一个密钥矩阵进行加密
flag前六位为：utflag
m = &quot;wznqca&quot;c = &quot;utflag&quot;for i in m:    if ord(i)&gt;=ord(&#x27;a&#x27;) and ord(i)&lt;=ord(&#x27;z&#x27;):        print( ord(i) - ord(&#x27;a&#x27;) , end = &quot; &quot; )print()for i in c:    if ord(i)&gt;=ord(&#x27;a&#x27;) and ord(i)&lt;=ord(&#x27;z&#x27;):        print( ord(i) - ord(&#x27;a&#x27;) , end = &quot; &quot; )
得到 $K^{-1}*M=C \ mod \ 26$

有两种方式，一种是暴力搜索，另一种是解方程（翻译：手搓），这里我们只写第一种
from numpy import *M = mat([[22,13,2],[25,16,0]])C = mat([[20,5,0],[19,11,6]])for a in range( 100 ):    for b in range( 100 ):        for c in range( 100 ):            for d in range( 100 ):                K = mat([[a,b],[c,d]])                if ((K*C)%26==M).all():                    print( K )                    assert 0
得到$K$的一个解是[[ 1 22],[11 13]]
有了密钥，使用在线工具即可得到flag

填回其他字符，修正大小写即可
flag:utflag&#123;d4nger0us_c1pherText_qq&#125;
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cryptoCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>hal库c6t6 Freerots</title>
    <url>/2024/11/08/hal%E5%BA%93c6t6-Freerots/</url>
    <content><![CDATA[写篇博客，不为别的，就怕以后忘了咋整了
Freerots这玩意忒好用了

如何开FreerotsSYS这边选个时钟

然后如图一路选下来，别忘了添加任务

其他的常规配置，然后生成代码就可以了
打开freertos.c文件，正常加入点灯代码就可以了

以上内容的参考：
https://www.cnblogs.com/Meiyangyang945/p/15106513.html

报错1
买不起好芯片，内存不够
改一下代码里的内容
将#define configTOTAL_HEAP_SIZE                    ((size_t)10240)
修改为#define configTOTAL_HEAP_SIZE                    ((size_t)(1024*5)即可
参考：
https://blog.csdn.net/king110108/article/details/110038173
https://file.elecfans.com/web2/M00/9B/99/pYYBAGQip7KAOU2vAAfDySG_a10157.pdf
报错2
一大堆啥玩意哇
贴搜索引擎一看，是cpp导致的

魔术棒中把misc_controls的--cpp11去掉即可
参考：
https://blog.csdn.net/timberman666/article/details/132723352
报错3数日之后，又出现了报错2的内容
改成多少都没用了
开O2优化即可
]]></content>
      <categories>
        <category>电控</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo usage</title>
    <url>/2024/05/23/hexo-usage/</url>
    <content><![CDATA[hexo s  #启动并预览
hexo c  #清除缓存文件 db.json 和已生成的静态文件 public 
hexo g  #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写) 
hexo d  #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo新建博客但是要求输入第二行</title>
    <url>/2024/09/21/hexo%E6%96%B0%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BD%86%E6%98%AF%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E7%AC%AC%E4%BA%8C%E8%A1%8C/</url>
    <content><![CDATA[今天遇到了以下问题

解决方案：引号输入改为英文（字体太小了没看到（悲
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>katz密码学教材v3阅读笔记</title>
    <url>/2025/04/24/katz%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%99%E6%9D%90v3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[本篇笔记用于记录阅读 introduction to modern cryptography (3rd Edition) 一书的阅读
重点在于公钥密码部分
本文尽量通俗讲解，但是不能代替阅读原著

目录第一章介绍了一些引入，包括公钥加密，历史和现代密码学设计原则
第二章介绍了一些完美加密，也算引入部分（还有信息论的香农定理，很前段时间读论文在[OB22]遇到了）
以上是第一部分，用于引入
第三章介绍了对称加密，然后我打算跳了~
第四章讲消息认证码MAC（等我有钱了也要买MAC（不是这个mac））
第五章讲CCA安全，CCA也就是选择明文攻击
第六章讲哈希函数，目录看起来是区块链的基础（有默克尔树之类的）
第七章讲流密码之类的~不懂，后面再看看
第八章是 好的我不懂，后面看了再来补目录
以上是第二部分，主要是对称加密
后面开始是核心内容，我也会从这里开始看
第九章讲数论和数学困难问题假设之类的，RSA啊什么的是基础，重中之重
第十章讲基于离散对数的加密，然后我突然想起导师发我了一篇相关论文我好像还没看（光速逃）
第十一章讲密钥管理分发，就是DH密钥交换那一类
第十二章开始上正菜了，标题的公钥密码加密，但是实际上里面有很多重要概念
第十三章讲数字签名，难度下降，但是更偏应用
第十四章讲后量子，加油加油加加油~
第十五章也就是最后一张，讲公钥密码的高级操作，嘻嘻后面再细看
以上是第三部分，是最重要的公钥密码

好的，开始干活~
第九章 数论和密码学困难问题本章可以学到的东西：密码学基础需要的数论，为后续学习奠定基础
9.1 前置知识和基础数论9.1.1 素数和可除性整除：a*c=b，则称a能整除b，写作a|b，否则a∤b
因子：a|b，则a是b的一个因子，若a≠1且a≠b，则a是b的一个非平凡因子
素数：没有非平凡因子的数（又称质数）
合数：有非平凡因子的数
算数基本定理：任何大于1的整数都可以唯一的表示为质数的乘积 $N=p_1^{e_1}p_2^{e_2}…p_k^{e_k}$
带余除法：a=bq+r且0≤r&lt;b
||N||表示二进制长度，||N||=⌊log N⌋+1 （⌊⌋表示向下取整）
gcd(a,b)表示a和b的最大公约数
欧几里得定理：存在整数X和Y，满足Xa+Yb=gcd(a,b)（证明在第308页开头，自己去看）
欧几里得引理：若c|ab且gcd(a,c)=1，则c|b
进一步的：若p是质数，且p|ab，则p|a或p|b
9.1.2 模运算就是取余，自己看书吧（光速逃）
真正有意思的都在后面呢
9.1.3 群讲的是群运算，很多基础知识
具体的可以自己看书，我说下我的理解：就是一个自动取模的机器
举个例子，c语言最大是2147483647，再加一就爆内存了，变成-2147483648了，这就是个群，然后再从-2147483648加加加不断加 加到厌倦，然后再到2147483647，再加，又变回-2147483648了
群运算，我愿称之为自动取模机~
当然这只是一种加法群，后面还有乘法群啊啥的，不过本质一样，一样的哈
阶：对于群$\mathbb{G}$，群的阶 $m$ 指的是对于任意$g\in\mathbb{G}$，都有 $g^m=1$，记为 $m=|\mathbb{G}|$
阶可以完成很多很厉害的运算（就行FFT，一种将乘法的时间复杂度从$O(n^2)$降低到$O(n\log n)$的算法，就是基于阶的），更多的应用可以问问AI，提示词：我的研究方向是密码学，刚刚学习了群的阶的相关概念，你能不能为我通俗讲解：阶在密码学中还有什么应用。由于我是初学者，请一定要通俗，最好举例
后面还有一些推论和证明，请自行阅读；如若不懂可以跳过，不影响咱橙味觅马靴糕守~
9.1.4 群 $\mathbb{Z}_N^*$哎呦呦，鸡汤来喽~
这个群 $\mathbb{Z}_N^*$ 十分滴珍贵，应该让同志们先学
$N$ 指的是这个群的模数，$*$ 指的是乘法
也就是这盆鸡汤，是在 ${0,1,…,N-1}$ 中的乘法运算
但是里面有很多元素没有乘法逆元，所以只需要将他们剔除，剩下的就构成了这个乘法群。这个群在后面很常见，尤其是在密码学中种种构造中~
什么？你问我乘法逆元是什么？别问我，去问AI，它讲的比我讲的好
什么？你说打不开？那你去问问学长吧（别问为什么不去问学姐，我要想要学姐&gt;.&lt;）

就是说，$\mathbb{Z}_N^*$ 里面有多少个元素，事实证明，有 $\phi(N)$ 个元素
\phi 也就是欧拉函数，怎么计算呢？来自己看吧：

欧拉函数有很多很好玩的特征，就想满足对于任意 $a\in\mathbb{Z}_N^*$，都有 $a^{\phi(N)}\equiv1\mod N$
（在模运算中，等于号一般写作 $\equiv$，它和普通等于号的效果差不多，你可以给它俩画等号~所以该画哪种等号呢）
特别的，你看上面的式子，如果 $N$ 是质数，则可以算出来 $\phi(N)=N-1$，就有 $a^{p-1}\equiv1\mod p$
诶？这不是著名的费马小定理嘛，就这样被咱推出来了（傲娇
COROLLARY 9.22 是和 后面的RSA有关联的，可以看一下，也可以等后面会遇到的
9.1.5 同构和中国剩余定理啊啊啊这一章不想写了，窝补药学基础数论，算了先跳一下，读者感兴趣可以继续往后读，中国剩余定理RCT就是求一元线性方程组的，没啥东西感觉，不过也挺重要的；感觉后面用到的不多？主要是RSA的共模攻击（来猜猜为什么没人用RSA进行同态加密），还有可能可以构造门限？不懂没用过
好的直接跳到RSA P322
9.2 素数 分解 RSA好帅的标题~
就，简单说下吧
p和q都是大质数，然后n=p*q，已知n无法倒推p和q
然后 $\phi(n)=(p-1)(q-1)$，没有p和q，也没法算n的欧拉函数
欧拉函数可以用来计算逆元，也就是使算法可逆的key
也就是基于大数分解数学困难问题的加密算法：加密是正向，谁都可以加密；解密是逆向，需要逆元，但是不能分解n就没有逆元，所以解密只能有私钥的人进行
然后看几个很常见的术语吧：

按我的理解就是：算法 $\mathcal{A}$ 正确分解 $n$ 的概率，不高于一个可忽略的函数
$\Pr$表示概率，$\text{w-Factor}$ 指的是分解 $n$ , $1$ 表示成功分解，$\text{negl()}$ 指的是一个随着 $n$ 增大而急速减小的函数
9.2.1 生成随机素数如何生成随机大素数 $p$ ？这一点很关键，如果大素数生成符合一些特定规则，会很容易进行分解（如：维纳攻击等）

大致过程就是随机生成随机数然后再check
诶呀呀，我还以为是很优雅的生成方式
不过有一说一这个确实够用，只不过有点安全隐患罢了（尽管安全隐患很小，基本上是可忽略的）
下面证明：随机roll出来的数，很容易roll到素数
结论 9.32 n位的数中，素数的占比不低于 $\frac{1}{3n}$
好的，下面我们进行一个很nb的操作，不妨设 $t=3n^2$，那么进行 $t$ 次操作后选不到素数的概率是

误区：这里的 n 指的是位数，如果遍历（不随机）选择素数的话，时间复杂度是线性的（即$O(n)$），优化一下不会低于 $O(\sqrt{n})$；而使用随机选择，使用的是 $n$ 的二进制下的位数
即对于1024位的n：如果使用朴素算法（遍历），大概需要计算 $2^{1024}$ 次；而使用随机算法，只需要 $3*1024^2$ 次——完全不是一个量级的
额外说一点，对于具体实现，使用python，不推荐使用random库——因为它不安全，是可预测的。除非你进行其他额外的操作

在离散对数中，需要两个素数（取模用的），可以直接 $p=2q+1$，这样生成出来的素数又大又安全（傲娇
但是在RSA里头，需要roll两个素数的，千万别用！因为：

\left\{
\begin{align}
&\ n=p\cdot q\\
&\ p=2q+1
\end{align}
\right.这玩意不就一下被分解了吗（狂汗

在知道了随机roll出来可以很快得到素数后，紧接着到来的是质数检测
9.2.2 素数检测这一章讲一个叫做Miller–Rabin素数检测的算法，它不能绝对证明一个数是素数，但是可以极高概率地判断一个数是不是合数，快得飞起
传统算法：直接试除法？线性时间复杂度，炸缸了~
米勒罗宾：也是基于概率的，芜湖起飞
出发点——费马小定理：如果 $n$ 是素数，且 $a$ 是不整除 $n$ 的整数，则有 $a^{n-1}\equiv1(\mod n)$
也就是说，可以随机roll这个a，如果很多次都不符合费马小定理，那么就是合数，否则就是素数
初步算法如下：

进一步的，我们再把这个算法变厉害变快一点：
第一步：拆解 $n-1$
$n-1=2^s\cdot d$
例如：$n=561$，那么 $n-1=560=2^4\cdot35$，即 $s=4,d=35$
第二步：随机选择 $a\in[2,n-2]$
用这个 $a$ 来“试探” $n$ 像不像素数
第三步：检查条件是否成立
计算： $x=a^d\mod n$
如果 $x=±1$，则说明没问题
否则就开始连续平方：把 $x$ 平方再取模（共做 $s-1$ 次），看看这些数里有没有变成 $n-1$ 的（也就是$-1$）
如果从头到尾都没有出现过 $n-1$ 的话，我们就抓到一个证据：这个 $n$ 肯定是合数！
这里的 $a$ 就称之为 $\text{witness}$（见证者）

通常运行20~40次，误判率即可忽略不计

从第326页下半部分到第330页上半部分，看起来兜售对算法正确性的证明，这里不再赘述（实际上是我看不懂），感兴趣的读者可以自行阅读（学会后教我（伸手））
然后最终的米勒罗宾筛法如下（前面已经说过了，这里的是原文的内容）

9.2.3 分解假设引入了一个名叫 GenModulus 的算法，为了说明大数是难分解的（不能在多项式时间复杂度里进行分解）
感觉这一章没什么好讲的，这里就解释一下多项式时间复杂度是什么意思叭
就是$O(n^a)$，n是自变量（一般认为是大数的位数），a是常数
就像直接分解大数，枚举算法时间复杂度大概是 $O(2^\sqrt{n})$，这是指数级的算法，不是多项式时间复杂度
更广义的，多项式指的是 $f(x)=a_0x^0+a_1x^1+…+a_kx^k$，其中 $k$ 是确定的常数，这里直接取最大值 $O(x^k)$ 就好了（为什么？快去学时间复杂度计算，把主定理学了就好了（学会记得教我））
值得注意的是：这里的指数级和多项式级是对于二进制下位数进行讨论的，如果是数字本身，需要集体降低一个量级
9.2.4 RSA假设RSA困难假设是基于大数分解数学困难问题的，所以本质和前面是一样的
这一块块就很偏理论计算了，群啊什么的，你们加油，我开始看下一章了~
这一章新东西不多，感觉就是把前面的整合起来
9.3 循环群密码学假设这一章强度上来了哈，稍微一不留神就跟不上了哈
9.3.1 循环群和生成元前面已经讲过了生成元，这里正式介绍一下——
对于群 $\mathbb{G}$，其阶为 $m$，生成元满足阶是最小的群元素满足 $g^m=1$
这一章是大量的定理和证明练习，不再赘述（我有时间再回来补罢
（逃~
9.3.2 离散对数/DH假设]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>typora生成思维导图</title>
    <url>/2024/09/09/typora%E7%94%9F%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[graph LRA[公钥密码方案构造及安全证明的知识要点和方法论]B[归纳总结了构造可证明安全的公钥密码方案所需掌握的知识要点]C[-&gt; 学习方案构造以及安全证明不可或缺的基础部分 需要最先掌握]A--&gt;B--&gt;C
后记：此方法可以在typora中显示思维导图，但是在hexo生成的博客中显示的还是原文件格式，所以目前的解决方案依旧是 幕布+图片插入
记得格式改为mermaid
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>zkSNARK基础课程学习</title>
    <url>/2025/08/13/zkSNARK%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[课程链接：https://rdi.berkeley.edu/zk-learning/
2.Overview of Modern SNARK Constructions简短：证明短&lt;1KB，验证快 &lt;10ms
区块链检验，一个监控很多个

C2PA：相机里有无法提取的私钥用于签名，保证照片的正确性
构建
算数电路-&gt;有向无环图
|C|门的数量，C_SHA256≈20K

NARK证明
SNARK简短
zkSNARK零知识
完备性：知道witness一定可以接受
知识可靠性：接受了，一定知道witness
len(pi)=O(log|C|),time(V)=O(|x|,log|C|)（预处理阶段提取处理电路大小）

四种方案对比

健全性的定义

 四种承诺

多项式承诺

一些具体算法

对多项式的承诺，一般认为是 对向量的承诺（时间取决于度数）

证明两个多项式相同，随机选择相同的自变量，如果函数的输出结果相同，则两个多项式极高概率完全相同

FS变换把交互式的改为非交互式的，但是并不是在每一个协议上都安全，又但是在zkSNARK上运行的刚刚好
变更为，将随机数改为公开参数的哈希值


（这个不是zkSNARK，但是是SNARK）

IOP：将一个度数为d的多项式转化为普遍电路


IOP把问题转化为多轮交互，需要验证的是验证结果是否正确

一个简单的例子
很像KGZ协议哇，对多项式进行承诺，但是关注点在于多项式是否包含

最终一个小总结，不同的证明对应不同的协议，但是都叫IOP

真正开发的时候不编写电路，而是选择特定的语言，编译成相应的电路，最终都放在SNARK里面

3.Programming ZKPs关注于如何编写ZKP代码

R1CS（略
硬件和软件的区别

&lt;— 赋值；===建立恒等关系；&lt;== both


Circom语言确保输入为非零


Libraries
使用rust伪代码实现

为了简化，使用运算重载

高级调用

Artworkrust
编译成R1CS
Zokrates更高级的语言

缺点：witness必须提供给主函数
小结

circom过于底层，能力不多
artwork没有很多优化
zokrates易于学习但是控制权较低

有各种各样的~

在近几年涌现

4.Interactive Proofs交互式证明
完备性：诚实则可以接受
安全性：不诚实则被拒绝 
为什么要非交互：和区块链结合
FS变换：公共硬币协议
交互式不必知识健全

三种多项式承诺

默克尔树-&gt;证明叶子节点T-&gt;向量承诺方案

多项式承诺可以考虑等价为默克尔承诺，但是效率太低了

快速且高效的
FACT: Pr&lt;d/|F|
SZDL: 多变量多项式
多重线性拓展

进行拓展
只有每一项都符合的项，有相应的数值

如何高效计算多线性拓展算法，利用拉格朗日插值法
 想知道一个函数所有二进制输入上的值，只需要2^t时间内进行拉格朗日插值计算出点

使用动态规划减少时间复杂度

sum check协议 目标：计算这个数

但是代价很大，如何高效的计算这个数
先检验几个点，就有极高的概率确定是正确的多项式

朴素求和，时间复杂度2^e
优化，计算e次

健全性

应用线性时间验证
计算三角形的数量，最小情况下是矩阵乘法

转化为log级别

然后用sum-check协议，就可以快速验证
电路可满足性，zkSNARK推导转成对数形式

IOP]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>rust study</title>
    <url>/2025/03/01/rust-study/</url>
    <content><![CDATA[本文记录了rust的学习


环境搭建vscode配置rust环境
vscode内配置快速打开Terminal，绑定openInIntegratedTerminal即可


然后下载rust依赖
因为我们都是喜家家糕守（电脑里有cpp环境），所以可以管理员运行下载这个东东即可
（没有cpp的环境我就不管了（光速逃））
然后一路回车
安装好后，cmd里输入rustup --version &amp; rustc --version &amp; cargo --version测试安装成功

然后打开vscode，下载相关依赖
RustRust-analyzerCodeLLDBcratesRust SyntaxRust Test LensEven Better TOML(Better TOML已弃用)
后面就可以正常使用了
新建项目 cargo new hellowrold
打开项目 cd .\helloworld\（TAB键补全）
运行项目 cargo run

]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>“我们输不起”：毛泽东否定“否定之否定”的实践论重释</title>
    <url>/2025/08/25/%E2%80%9C%E6%88%91%E4%BB%AC%E8%BE%93%E4%B8%8D%E8%B5%B7%E2%80%9D%EF%BC%9A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E5%90%A6%E5%AE%9A%E2%80%9C%E5%90%A6%E5%AE%9A%E4%B9%8B%E5%90%A6%E5%AE%9A%E2%80%9D%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%AE%BA%E9%87%8D%E9%87%8A/</url>
    <content><![CDATA[摘要： 关于毛泽东为何在晚年明确否定“否定之否定规律”，学界的主流解释倾向于从哲学本体论的层面，将其视为对黑格尔唯心主义的彻底剥离和对马克思主义唯物论的深化。这一解释虽具理论深度，却在一定程度上忽略了毛泽东作为革命家和战略家的现实处境。本文旨在提出并论证一种补充性乃至更具根本性的解释框架：实践论重释。即，毛泽东的这一理论抉择，其最深刻的动因并非源于纯粹的哲学思辨，而是植根于中国革命“低容错率”的残酷现实，是他作为最高统帅，在无数次血与火的考验中形成的“风险规避”和“责任优先”的思维原则的哲学升华。
关键词： 毛泽东；否定之否定；实践论；中国革命；风险决策；教条主义
一、 学术史回顾：作为哲学思辨的“否定之否定”之争在经典的马克思主义哲学体系中，“否定之否定规律”与对立统一、质量互变规律并列，被视为唯物辩证法的三大基本规律。它揭示了事物发展的前进性与曲折性相统一的螺旋式上升过程。然而，毛泽东在1960年代多次明确表示，“我就不相信那两个范畴”，认为最根本的规律只有“对立统一”。
对此，学界的主流观点，以王南湜等学者的研究为代表，认为这是毛泽东对马克思主义哲学进行“中国化”和深化的重要理论贡献。其核心论据是：“否定之否定”规律带有浓厚的黑格尔唯心主义色彩，它预设了一个封闭的、可回归的、最终实现圆满的逻辑闭环，这与黑格尔的“绝对精神”的自我运动同构。而彻底的唯物主义者则认为，世界是开放的、物质的、充满偶然性的，发展是不可逆的，不存在一个确保最终“回归”并“升级”的先验剧本。因此，毛泽东的否定，是一次旨在捍卫唯物主义彻底性的“本体论颠倒”【1】。
这一解释无疑是深刻的，它为我们理解毛泽东思想的哲学高度提供了重要的理论坐标。但它也留下了一个疑问：是什么样的现实力量，驱动着毛泽东对这一抽象的哲学命题进行如此坚决的“手术”？要回答这个问题，我们必须将目光从书斋移向战场。
二、 历史的 crucible: 中国革命的“低容错率”现实任何理论的生命力都源于其所处的时代。毛泽东的哲学，是与中国革命的命运紧密捆绑的“在场哲学”。而贯穿中国革命始终的一个最残酷的现实，就是极低的“容错率”（Margin for Error）。
2.1 教条主义的血债：第五次反“围剿”的惨败20世纪30年代前期，以王明、博古为代表的“左”倾教条主义者，将从苏联“教科书”上看来的理论和共产国际的指示奉为圭臬，完全无视中国革命的具体实际。在军事上，他们以李德（奥托·勃劳恩）为“太上皇”，放弃了毛泽东此前被证明行之有效的“诱敌深入、积极防御”等游击战和运动战原则，代之以“御敌于国门之外”的阵地战、“短促突击”等战术。
结果是灾难性的。第五次反“围剿”的失败，导致中央红军被迫进行战略转移——长征。这次失败，就是一次代价惨痛的“否定”。它几乎葬送了整个中国革命。这段历史后来被反复总结，它以血的教训证明：错误的理论和决策，带来的不是“螺旋式上升”前的必要曲折，而是近乎万劫不复的深渊。对于亲身经历了这一过程并被排挤、打压的毛泽东而言，这种“否定”的滋味，绝非哲学教科书上的一个逻辑术语所能概括【2】。
2.2 遵义会议：从“理论至上”到“实践优先”的转折1935年的遵义会议，是中国共产党历史上一个生死攸关的转折点。它在组织上确立了毛泽东的领导地位，但其更深远的意义在于，它是一次思想路线和方法论的根本性转折。这次会议的决议，深刻批判了“左”倾领导者在军事指挥上的错误。这标志着，中国共产党第一次从集体意识上，将从中国革命自身实践中总结出来的经验，置于来自外部的、抽象的“理论权威”之上。
遵义会议的精神内核，就是“实践优先”。它宣告了一种天真“试错论”的破产。中国革命输不起，因此不能再允许脱离实际的理论来指导实践。这一原则，构成了毛泽东后来哲学思想最坚实的实践地基。
三、 文本的印证：毛泽东著作中的“风险规避”思想毛泽东的哲学思考，始终服务于其革命实践。在他的诸多重要著作中，我们可以清晰地看到一种对“风险”的高度警惕和对“确定性”的极致追求，这与“否定之否定”那种带有乐观色彩的过程论形成了鲜明对比。
3.1 《实践论》与《矛盾论》：构建“决策安全阀”1937年写就的《实践论》与《矛盾论》（合称“两论”），是毛泽东哲学思想成熟的标志。细读这两篇著作，可以发现它们本质上是一套旨在提高决策正确率、降低实践风险的方法论体系。

《实践论》的核心是“实践-认识-再实践-再认识”的循环。它强调一切真知都来源于实践，并必须回到实践中去检验。这本身就是对脱离实际的教条主义的直接否定。它要求决策者必须进行“亲身参与”的“调查研究”，这是规避致命错误的第一道“安全阀”。
《矛盾论》则提供了一套精密的分析工具。它要求革命者必须区分主要矛盾和次要矛盾、矛盾的主要方面和次要方面，要“具体问题具体分析”。这种方法论的实质，是在纷繁复杂的局面中，找到那个可以“牵一发而动全身”的关键点，从而避免在非关键问题上耗费力量，甚至做出错误判断。这是在充满不确定性的战场上，寻找最大确定性的努力【3】。

3.2 军事著作：作为应用辩证法的“生存原则”毛泽东的军事著作，如《中国革命战争的战略问题》、《论持久战》等，是其辩证法思想最生动的应用场域。通读这些著作，其核心思想并非“冒险突进”，而是“在保存自己的前提下消灭敌人”。无论是“积极防御”的战略总方针，还是“集中优势兵力，各个歼灭敌人”的战术原则，其背后都是一种深刻的风险控制意识。每一次战斗的部署，都旨在创造一种局部的“确定性”（以多打少），来对冲战略全局的“不确定性”（以弱对强）。这与“否定之否定”所蕴含的“过程必然导向成功”的乐观主义，形成了鲜明反差【4】。
四、 结论：从“本体论颠倒”到“实践论优先”回到我们最初的问题。毛泽东否定“否定之否定”，诚然有其深刻的哲学考量，即彻底与黑格尔的唯心主义划清界限。但驱动他进行这一理论“手术”的，是比哲学思辨更为原始、也更为强大的力量——来自中国革命实践的、血的教训和沉重的历史责任。
对于毛泽东而言，一个哲学规律是否“正确”，其最终的衡量标准，不是它在理论上是否优美、逻辑上是否自洽，而是它能否有效地指导中国革命走向胜利。一个看似能“包容”失败、并许诺了最终胜利的“否定之否定”规律，在中国革命“输不起”的残酷现实面前，显得过于奢侈和危险。它可能成为麻痹革命者、纵容冒险主义和教条主义的理论温床。
因此，毛泽东的否定，不仅仅是一次“本体论的颠倒”，更是一次“实践论的优先”。这是他将马克思主义“具体化”、“民族化”的极致体现。他所锻造的辩证法，不是为了在事后完美地解释世界，而是为了在当下能动地、审慎地、最大限度地确保改造世界的成功。这柄思想武器，或许少了一丝教科书式的工整，却多了一份从战火硝烟中带出的、沉甸甸的现实力量。

参考文献：
【1】王南湜. (2021). 毛泽东为何要否定“否定之否定规律”？.【2】中共中央党史研究室. (2011). 《中国共产党历史（第二卷）》. 中共党史出版社.【3】毛泽东. (1964). 《毛泽东选集》（第一卷）. 人民出版社.【4】李泽厚. (1995). 《中国现代思想史论》. 东方出版社.【5】恩格斯, F. 《自然辩证法》.
]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>《安全规约导论》阅读笔记</title>
    <url>/2024/10/09/%E3%80%8A%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B000/</url>
    <content><![CDATA[此博客为常驻，用于汇总笔者阅读《安全规约导论》一书的学习笔记
这本书里的好东西很多，价值很高，值得充分学习
持续更新中


安全规约前置知识 
安全规约基础 
荔枝成为BLS短签名糕守

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>常驻</tag>
      </tags>
  </entry>
  <entry>
    <title>中秋夜赋</title>
    <url>/2025/08/13/%E4%B8%AD%E7%A7%8B%E5%A4%9C%E8%B5%8B/</url>
    <content><![CDATA[中秋夜赋
壬寅之秋，八月正望；明月危挂，辰辰相依。
夜里瞩之木叶，明然骇其远视；月上宫灯然然，钓台能望玉门。
古桥春水，梅兰竹菊谁家；匏樽相属，亲戚月下欣悦。
三日赋闲家中，三年苦于庠序。
苦中有乐，亦有疾书之意；乐苦相织，不改星辰轮换。
盈虚日月，物不度则不满；潮汐溯洄，尺不量故能淹。
羿射九日，良弓当藏；嫦娥一去，大树零尽。
吴刚有斧，恒不改刚，推志三千树断；
玉兔冰洁，自有其灵，宁无爱恨交揉。
书生微命，有笔难投；欲穷宇宙之大，仍叹民生之艰。
心高千仞，却慕华嵩之玉；时食周粟，怀存青云之志。
楚歌非云乐，鲁酒难忘忧。
舟楫路穷，头会箕敛能卷甲；锄耰棘矜，因利乘便览天下。
请拔跬步，会书青史；尽抒己怀，手手摘月。

白话文翻译版壬寅年（2022年）的秋天，八月十五的月亮正圆；明亮的月悬挂在高空，星辰相互辉映。
夜晚注视着树叶，清亮得令人震撼；月亮升上宫灯旁，钓鱼台上也能遥望玉门关。
古桥下的春水悠悠流淌，梅兰竹菊映照谁家庭院；匏瓢与酒樽相互陪伴，亲戚在月下其乐融融。
我在家中闲赋三日，在学校苦读三年。
苦中仍有乐趣，也有疾书的志趣；悲喜交织，却不改变星辰的轮回。
日月盈亏有定，事物若不经过度量就无法圆满；潮水涨落遵循规律，尺不测深却能溢满水面。
羿射下九个太阳，良弓理应收藏；嫦娥一去不返，大树枯零尽毁。
吴刚手持斧头，却始终不改刚毅，志向坚定如三千棵被砍断的树；
玉兔洁白如冰，自有灵性，但难道没有爱恨情感的干扰。
书生命运微薄，手中笔难以施展；想要穷尽宇宙之大，却仍叹息百姓生活的艰辛。
心志高远如千仞之峰，却仰慕华山之玉；平时以周粟为食，心中怀存青云之志。
楚地的哀歌并非欢愉之声，鲁地的美酒也难以忘却忧愁。
行舟至路尽之处，头上可卷箕敛铠甲；耕作锄耰，遇利便宜顺势观览天下。
请从每一个小小的脚步开始，汇聚成书写青史的伟业；尽情抒发胸中抱负，像摘月一样实现理想。
]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>二元不等式串引发的思考</title>
    <url>/2025/02/05/%E4%BA%8C%E5%85%83%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%B8%B2%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[写了一下午，最后发现推导的结论是错的蚌埠住了，布响丸辣


我们早在高中就学过以下不等式串

\sqrt\frac{x^{2}+y^{2}}{2}\geqslant\frac{x+y}{2}\geqslant\sqrt{xy}\geqslant\frac{2}{\frac{1}{x}+\frac{1}{y}}今天刷张宇的时候，又遇到了这个问题；一般而言这个不等式串背过就行了，直接套用即可，但是我忘了，然后就不会了（大雾
这样死记硬背有利于短期记忆，所以我们进一步研究，本文致力于让读者深入理解和更好的记忆该不等式
我的切入点是切入面（字面意思），也就是看截面；不妨写成$z=$的形式获得到四个式子

\begin{align}
&z=\sqrt\frac{x^{2}+y^{2}}{2}\\
&z=\frac{x+y}{2}\\
&z=\sqrt{xy}\\
&z=\frac{2}{\frac{1}{x}+\frac{1}{y}}
\end{align}我们使用绘图软件画出这四个式子可以很直观的发现

后面进行分析
第一个$z=\sqrt\frac{x^2+y^2}2$（青色图像），等价于$z^2=\frac{x^2+y^2}2$，一个很典型的圆锥
具体来说，设有圆形且圆的半径满足$r^2=x^2+y^2$，这时满足$z=\frac{\sqrt2}2r$
第二个$z=\frac{x+y}{2}$（紫色图像），这是个没有任何弯曲的平面
第三个$z=\sqrt{xy}$（蓝色图像），若不考虑$z$，则$x$和$y$的关系是反比例，图像如下

切一个面，切出来是反比例函数，也就是双曲线

第四个$z=\frac{2}{\frac{1}{x}+\frac{1}{y}}$（棕色图像），该图像如果使用z=k进行切割，将会切出双曲线，故我们使用$x+y=k$进行切割
容易计算这时$z=2x-\frac{2x^2}k$是个双曲线；图像如下

这时候就有人要问了，为什么别的式子都是直接切$z=k$，偏偏最后一个要切$x+y=k$非要搞特殊
这时不得不拿出这张众人皆知的图了

看蓝色部分，也就是抛物线部分，它是竖着切的
其他几个不完全是竖着切的，所以上述切法仅仅是投影，除了圆形，其他的不准确，但不影响判断图像性质（即分辨圆形、椭圆或双曲线抛物线），即离心率范围不会跨越
回归正题，我们该如何记忆不等式呢？就记忆离心率即可
离心率越小，在不等式的位置越大

\begin{align}
&z=\sqrt\frac{x^{2}+y^{2}}{2}（椭圆）\\
&z=\frac{x+y}{2}（圆形）\\
&z=\sqrt{xy}（双曲线）\\
&z=\frac{2}{\frac{1}{x}+\frac{1}{y}}（抛物线）
\end{align}诶好像不太对劲~
]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我的表情包总是被朋友盗走</title>
    <url>/2025/08/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84%E8%A1%A8%E6%83%85%E5%8C%85%E6%80%BB%E6%98%AF%E8%A2%AB%E6%9C%8B%E5%8F%8B%E7%9B%97%E8%B5%B0/</url>
    <content><![CDATA[题干描述
在日常生活中，许多人在网络聊天时会使用相同的表情包。例如，某同学经常喜欢使用的表情包，他的朋友也会保存并频繁使用同样的表情包。请运用马克思主义基本原理分析这一现象。
参考答案：

社会存在与社会意识的关系表情包是一种网络文化现象，属于社会意识的具体表现。由于同学们生活在相同的社会环境、共享相似的网络文化氛围，因此对同一类表情包产生相似兴趣。这体现了社会存在决定社会意识。
事物的普遍联系与相互影响在交往中，个人的行为会对他人产生影响。一个同学使用某表情包，朋友接触后受到影响，从而模仿并使用。这说明人与人之间是普遍联系和相互作用的。
个体与群体的辩证统一一个人的喜好最初是个体性的，但在交流互动中逐渐被他人接受和使用，从而上升为群体性的网络文化。这体现了个体性与群体性的统一。
量变与质变的关系表情包从少数人使用，到更多人模仿和传播，最终可能发展为流行现象。这是量变积累引起质变的过程。

结论：朋友之间喜欢相同的表情包，不是偶然现象，而是社会存在对意识的决定作用、人际交往中相互联系和影响的体现，也说明个体文化选择在互动中能够发展为群体性文化现象。
]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>从《原神》到马原</title>
    <url>/2025/08/25/%E4%BB%8E%E3%80%8A%E5%8E%9F%E7%A5%9E%E3%80%8B%E5%88%B0%E9%A9%AC%E5%8E%9F/</url>
    <content><![CDATA[最近我在提瓦特大陆摸鱼时，突然觉得“精通、双爆、充能”这些属性，竟然能和“考研、保研、四六级、科研”这些现实的事挂上钩。于是，就有了这篇半疯半正经的随笔。
1. 矛盾的普遍性与特殊性：为什么行秋和胡桃不是一个玩法？《原神》里，不同角色有不同的定位：胡桃需要高精通触发蒸发反应，雷神则需要堆充能转化为输出，迪卢克就是老老实实堆双爆。你不能用一种思路打遍所有角色，否则效果只会“伤害刮痧”。
现实中也一样：考研的人，主要矛盾是英语和专业课（408、数政英专四件套）；保研的人，主要矛盾是绩点和科研竞赛。用错了方法，就像给申鹤堆精通一样，南辕北辙。
这就是矛盾的特殊性：不同对象有不同的矛盾，必须具体问题具体分析。
2. 量变与质变：暴击率0%配爆伤300%的悲剧想象一个角色：暴击率0%，暴伤300%。数值看起来很猛，但你一刀劈过去啥都没暴击，就等于“放烟花”。反过来，暴击100%但爆伤只有50%，你是场上最稳定的刮痧战士。只有当两者达到某种平衡时，输出才能质变。
这和现实中的学习极像。四六级考到600+，但专业课挂科，一样考研无望；科研成果满满，但英语连文献都读不懂，也很难往上走。只有各方面量的合理积累，才能引发质的飞跃。
这就是量变到质变规律的真实写照。
3. 主要矛盾与次要矛盾：不要舍本逐末玩《原神》的人都知道，堆属性要先抓主要矛盾。胡桃要的是精通+双爆，行秋要的是充能，其余生命、攻击之类是次要。你要是反着来，胡桃全生命、行秋全攻击，那是彻底玩废。
学习也是这样。考研的人，英语和专业课才是主要矛盾；四六级成绩固然重要，但它不是核心。保研的人，科研和绩点才是硬通货；学生工作是加分项，但不能本末倒置。
这就是主要矛盾原理：要分清轻重缓急，集中力量解决最关键的问题。
4. 系统性与整体性：别指望“单核爆炸”《原神》角色养成是个系统工程。你不能只盯着暴伤一个指标而忽视充能、攻击力、精通等其他因素，否则最终表现不佳。一个角色是整体配置的结果，而不是单点数值的炫耀。
人的成长同样如此。四六级、科研、绩点、社交，这些都是构成整体竞争力的部分。某一方面的极端优势可以锦上添花，但不能掩盖系统性缺陷。人生不是“单核爆炸”，而是“体系优化”。
这就是系统优化原理：注重整体，兼顾协调。
结语：哲学不是空的，甚至可以从游戏里悟出来哲学从来不是书本里冰冷的概念，而是生活和游戏都能触发的真实思考。胡桃要蒸发，雷神要充能，行秋要循环；考研要英语专业课，保研要科研绩点。逻辑都是一个：抓主要矛盾，兼顾系统优化，量变积累才能质变飞跃。
如果你下次在深渊被怪物锤到怀疑人生，不妨想一想：也许这就是实践出真知的最好证明。
]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>rime自定义输入输出配置</title>
    <url>/2025/10/22/rime%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[感觉好像被监视了~于是乎前段时间在windows下部署了小狼毫输入法
但是遇到了问题，如果我想给别人发一个对钩，搜狗输入法直接输入dui就出来候选词了，但是rime不行
故而学习了一下自定义
我实用的是便携版，目录如下

直接在主目录下新建一个文档custom_phrase.txt
然后输入策略，用Tab键隔开

然后重新部署

输入dui就可以有✔的选项了

如果想多个候选词，一并添加即可，越后出现的越先出现（大雾

想注释掉，用#即可
个人感觉还是这个对钩好看~
✓	dui
我的最终配置：
✓	dui对	dui#✔	dui#✅	dui#☑	dui#✘	cuo
诶这不太对吧

不管了，能跑就行~跑喽~~
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>会议/竞赛游记合集</title>
    <url>/2024/10/30/%E4%BC%9A%E8%AE%AE%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[本篇文章用于汇总参加的会议/组会的总结链接
部分内容已加锁

组会2024.10.30组会
2024.9.18组会
2024.9.11组会
2024.9.4组会
其他会议/竞赛2024.9.20南洋理工密码学报告 观后总结
机器人联盟赛/对抗赛游记回忆记录（2024）
厦大一日游（机器人大赛）（2023）
]]></content>
      <categories>
        <category>合集</category>
      </categories>
      <tags>
        <tag>常驻</tag>
      </tags>
  </entry>
  <entry>
    <title>使用wifi发射模块串通网络的debug过程</title>
    <url>/2024/09/13/%E4%BD%BF%E7%94%A8wifi%E5%8F%91%E5%B0%84%E6%A8%A1%E5%9D%97%E4%B8%B2%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84debug%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[之前尝试连接内网，实现任意两点的数据传输和互联网的访问，采取了网线和蓝牙的方式，最终以失败告终。今天新买的wifi接收/发射模块到货了，插上试了一下

前置知识 win+R ，输入 ncpa.cpl 打开 网络连接
刚插上会多一个这个图标

打开热点会多一个这个图标

使用第二台设备直接连接，会出现 正在搜索ip 等字样
百度一下，发现需要打开共享
右键需要共享的网络点击属性

点击允许共享，家庭网络连接填写 发送 热点信号的网络（模块）

如果没有这个选项，需要用其他奇技淫巧来解决（别问我怎么知道的）
咱买的wifi模块，不是也能发射也能接收嘛
你先别用有线网（以太网）线连接电脑，先开一下手机热点，连上电脑
然后（我这台电脑）在 WLAN 里就出现了 本地连接* 11 的选项
不要断，立即切换到以太网，然后就成功了
这个是最终的效果

重新启动了电脑，依旧可以正常连接（学计算机的不会真的有人关电脑吧（bushi））
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>公钥密码学经典方案30篇 学习笔记（初次阅读）</title>
    <url>/2024/09/27/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BB%8F%E5%85%B8%E6%96%B9%E6%A1%8830%E7%AF%87-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%88%9D%E6%AC%A1%E9%98%85%E8%AF%BB%EF%BC%89/</url>
    <content><![CDATA[本文是 荔枝橙味拱腰觅马糕守 一文的后继，主要内容是对于 方案构造学习 一章中的 尝试发现方案构造错误 一节下的 30个经典方案的学习笔记
经过初次阅读尝试，发现笔者英文阅读能力较低，不足以在短暂时间内完成大量论文的阅读；故选择了在翻译器和人工智能的帮助下来进行阅读，以提升效率，并为第二次阅读打好基础

1984, A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. [34]引言1976年，Diffie和Hellman首次提出了公钥密码的概念，并依赖离散对数问题和素数域上的计算复杂性来构造其密钥交换协议。ElGamal的工作正是基于这种思想，进一步提出了一个可以实现消息加密和解密的公钥加密系统，以及一个数字签名方案。
公钥密码系统公钥密码体制的基本思想是使用 Diffie-Hellman 密钥交换的基础
首先，通信双方选择一个大质数 $p$ 和生成元 $g$ ，这些参数都是公开的
然后双方分别选取自己的私钥（分别是 $x_A$ 和 $x_B$），并计算相应的公钥

y_A=g^{x_A}\mod p\\
y_B=g^{x_B}\mod p然后就可以计算共享的公钥
$K=(y_A)^{x_B}\mod p=(y_B)^{x_A}\mod p$
这提供了一个安全的共享密钥，但计算此密钥的过程难度等同于计算离散对数。该系统的加密过程与Diffie-Hellman方案相关，但使用了随机数 $k$ 来加密每条消息，从而避免了密文重放攻击。解密过程中，接收方根据私钥恢复密钥并解密消息
数字签名方案ElGamal提出的数字签名方案依赖于消息的签名和验证。具体来说，签名生成过程如下：

发送方选择一个随机数 $k$ ，并保证 $k$ 与 $p-1$ 互质
计算 $r=g^k\mod p$
使用发送者的私钥 $x_A$ 来解决方程 $m=x_Ar+ks\mod(p-1)$，从而得到签名对 $(r,s)$

验证方只需使用公钥 $y_A$ 和签名 $(r,s)$ 来验证以下等式：
$g^m\equiv y_A^rr^s\mod p$
签名方案的安全性依赖于离散对数问题的计算难度。ElGamal指出，攻击者试图伪造签名或推导私钥将面临离散对数问题的挑战。文章还讨论了在某些情况下可能的攻击方式，但大多无法打破系统的安全性
本质上就是用 DH 获得一个密钥，然后用它加解密消息。
详细代码见 ElGamal是个啥子玩意（和本篇论文内容不尽相同，但是殊途同归）
安全性分析文章详细探讨了针对签名方案的可能攻击方式，并指出这些攻击大多数情况下等价于计算离散对数问题。虽然尚未严格证明破解此签名方案与计算离散对数之间的等价性，但已知的攻击方式都未能有效破坏该系统。

如果随机数 $k$ 被重复使用，攻击者可能通过解决线性方程组来推导出私钥。
攻击者可以尝试通过文档的多个签名来恢复私钥，但计算复杂性极高

系统特性及比较与其他基于整数分解问题的公钥系统（如RSA）相比，ElGamal系统在某些方面有所不同。

由于加密过程中的随机性，同一条消息的密文不会重复，有效地防止了已知明文攻击
虽然密文的大小是原消息的两倍，但由于解密只需要一次指数计算，故系统具有较好的计算效率

ElGamal离散对数问题的算法复杂性与因子分解问题类似，都是次指数级的复杂度。因此系统的安全性与RSA类似，公共文件的大小相对较大，但这是可接受的
1991, Efficient Signature Generation by Smart Cards. [35]引言与背景
公钥密码学的基本概念：公钥密码学利用一对密钥（公钥和私钥）来加密和解密信息。公钥可以公开，而私钥则保持秘密。
应用场景：公钥密码学广泛应用于安全通信、数字签名和身份验证等领域。

经典公钥密码方案
RSA算法：

构造方法：通过选择两个大素数 $ p $ 和 $ q $，计算 $ n = p \times q $。公钥是 $ (n, e) $，私钥是 $ (n, d) $，其中 $ d $ 是 $ e $ 的模 $ \phi(n) $ 的逆元。
安全性：基于大数分解问题的困难性。


椭圆曲线密码学（ECC）：

构造方法：在椭圆曲线上定义操作，利用点加法和标量乘法生成公钥和私钥。
安全性：基于椭圆曲线离散对数问题的困难性，ECC提供了更小的密钥长度而保持相同的安全性。


ElGamal密码方案：

构造方法：基于离散对数问题。生成一个大素数 $ p $ 和生成元 $ g $，然后选择一个私钥 $ x $ 计算公钥 $ y = g^x \mod p $。
安全性：依赖于离散对数问题的复杂性。



安全证明
安全性定义：

通常包括选择明文攻击（CPA）和选择密文攻击（CCA）的安全性。


安全性证明方法：

归约法：将密码方案的安全性归约到已知的难题上。例如，证明RSA的安全性可以归约到大数分解的难度。
随机预言机模型：假设存在一个理想的随机预言机，用于模拟加密和解密过程，从而分析方案的安全性。



实例与应用
应用实例：可以介绍一些实际应用，如SSL/TLS协议、PGP等，如何利用这些公钥方案确保数据传输的安全性。
最新研究进展：提到一些后量子密码学方案的发展，因为传统公钥方案可能面临量子计算威胁。

总结与未来方向
总结：公钥密码方案在现代安全通信中至关重要，确保信息的机密性和完整性。
未来研究方向：研究如何提高现有公钥方案的效率，及其在新兴技术（如量子计算）下的安全性。

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ctf卷王排行榜的项目说明</title>
    <url>/2024/09/17/%E5%85%B3%E4%BA%8Ectf%E5%8D%B7%E7%8E%8B%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[开源网址

版本1.0
本程序的大致原理是，使用cookie进行登录并发送GET请求，获取响应文本然后提取，得到指定用户的指定方向（categories）做题数量
程序主体分为三个部分：

文件读写的函数（控制台的输出数据仅供调试使用）

获取用户的做题数量，此部分需要使用者自行输入api

通过已知的uid，返回对应的用户名，用于生成榜单

后续需要做的事情：

优化代码看起来奇奇怪怪的部分（
cookie登录存在弊端
优化前端设计并实现榜单生成部分
按周或者按天计算刷题量（可能比较好做，但是这是另一项工作了，暂时束之高阁）
实现自动化生成榜单
下次不能把一个zip直接扔进仓库里去了

后续版本的更新日志见 README.md
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>信安数基复习笔记</title>
    <url>/2025/01/08/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%9F%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[

往年期末考试题目
$(x,y)=(3y+4z,y)=(4z,y)$
故A正确

简化剩余系：与模数互素且不同余
与15不互素：$1,3,5,6,9,10,12,15$
故一个简化剩余系为 ${2,4,7,8,11,13,14}$
也可以写作 ${7,8,11,13,14,17,19}$
故C正确

B. 整数模素数剩余类环都是域，故B正确
C. 整环的定义是没有零因子，3*4=12是0，故C错误

原根存在的充要条件 $m=p^k$ 或 $2p^k$，其中 $p$ 为素数，$k\ge1$
故选D

A. pa=0，错误
B. 费马小定理是 $a^{p-1}=1$，错误
C. 正确

$7x$

$x$的原根数为$\phi(\phi(x))$
22

85=5*17
$x^2\equiv1\mod5$ 和 $x^2\equiv1\mod17$ 的解数之和
分别有两个解（分别是$(1,2)$和$(1,4)$）
故总共有四个解

$|G/H|=\frac{|G|}{|H|}=3$

$GF(16)$是一个阶为16的有限域，则$GF(16)^*$是一个阶为$15$的循环群
在一个循环群中，任意元素的阶是$15$的正约数。也就是说，$GF(16)$中非零元素的可能乘法阶是$15$的正约数
故可能取值为${3,5,15}$


\begin{align}
&4^{173}\\
=&16^{86}*4\\
=&43^{43}*4\\
=&3^{21}*43*4\\
=&9^{10}*3*43*4\\
=&10^5*3*43*4\\
=&29^2*10*3*43*4\\
=&40
\end{align}
第一步，计算所有模数的乘积$M$
$M=m_1m_2m_3=140$
第二步，计算每个模数对应部分的乘积$M_i$
$M_1=35, M_2=28, M_3=20$
第三步，计算$M_i$在$m_i$下的逆元
$inv_1=3, inv_2=2, inv_3=6$
第四步，计算新的$x$
$x=\sum(a_iM_iinv_i)\%M=17$
通式：余数乘以模余乘以其逆

(1) $(\frac{40}{71})=(\frac{40\%71}{71})=(\frac{40}{71})=40^\frac{71-1}2\mod71=40^{35}\mod71$

\begin{align}
&40^{35}\\
=&40*38^{17}\\
=&40*38*25^8\\
=&40*38*8^4\\
=&40*38*4096\\
=&40*38*49\\
=&1
\end{align}$p=71$ 满足 $p=4k+3$
故 $x=\pm a^\frac{p+1}4=\pm40^{18}\mod71=18$或$53$
(2) $(\frac3{119})=(\frac37)(\frac3{17})$
$(\frac37)=3^\frac{7-1}2\mod7=1$
$(\frac3{17})=3^\frac{17-1}2\mod17=-1$
故 $(\frac3{119})=-1$，$x^2≡3\mod119$ 无解

(1) 封闭性：如果$A,B\in GL(3,Q)$，则$AB\in GL(3,Q)$；由于$det(AB)=det(A)det(B)\neq0$，且$AB$元素皆为有理数，因此$AB\in GL(3,Q)$
结合律：矩阵乘法满足结合律，即 $(AB)C=A(BC)$
单位元存在：单位矩阵$I_3\in GL(3,Q)$，且对任意$A\in GL(3,Q)$，有$AI_3=I_3A=A$
逆元存在：对于$A\in GL(3,Q)$，其逆矩阵$A^{-1}\in GL(3,Q)$，因为$det(A^{-1})=\frac1{det(A)}\neq0$
证明$GL(3,Q)$是非交换群，找到反例即可

显然$AB\neq BA$，故$GL(3,Q)$是非交换群
(2) 定义$SL(3,Q)={A\in GL(3,Q)|det(A)=1}$，正规子群需要验证两点
$SL(3,Q)$是子群
封闭性：如果$A,B\in SL(3,Q)$，则$AB\in SL(3,Q)$；由于$det(AB)=det(A)det(B)=1$，因此$AB\in SL(3,Q)$
结合律：矩阵乘法满足结合律，即 $(AB)C=A(BC)$
单位元：单位矩阵$I_3\in SL(3,Q)$，因为$det(I_3)=1$
逆元：对于$A\in SL(3,Q)$，其逆矩阵$A^{-1}\in SL(3,Q)$，因为$det(A^{-1})=\frac1{det(A)}=1$
因此$SL(3,Q)$是子群
$SL(3,Q)$是正规子群
对任意$A\in GL(3,Q),B\in SL(3,Q)$
$det(ABA^{-1})=det(A)1\frac1{det(A)}=1$
因此 $AB^A{-1}\in SL(3,Q)$
故$SL(3,Q)$是$GL(3,Q)$的正规子群
(3)markdown学不会了（恼


(1) 多项式 $m(x)\in GF(2)[x]$是不可约的，当前仅当它不可分解为两个低阶非常数多项式的积


拓欧算法(a,b)=(b,a%b)
快速幂CRT二次剩余原根求原根：

确定是否存在原根
计算$\phi(n)$
计算$\phi(n)$的所有素因子
检验原根，当前仅当对$\phi(n)$的每个素因子都满足 $g^\frac{\phi(n)}p\neq1\mod n$

]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>关于分布式TEE的一点头脑风暴</title>
    <url>/2025/07/02/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FTEE%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>install crypto in sage of wsl</title>
    <url>/2024/05/23/install-crypto-in-sage-of-wsl/</url>
    <content><![CDATA[When I input sudo -pip install pycryptodome

It output
root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper# python3 -m pip install --user pipxerror: externally-managed-environment× This environment is externally managed╰─&gt; To install Python packages system-wide, try apt install    python3-xyz, where xyz is the package you are trying to    install.        If you wish to install a non-Debian-packaged Python package,    create a virtual environment using python3 -m venv path/to/venv.    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make    sure you have python3-full installed.        If you wish to install a non-Debian packaged Python application,    it may be easiest to use pipx install xyz, which will manage a    virtual environment for you. Make sure you have pipx installed.    See /usr/share/doc/python3.11/README.venv for more information.note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.hint: See PEP 668 for the detailed specification.root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper#
Just translate it
root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper/Desktop# sage --pip install pycryptoerror: externally-managed-environment× 该环境由外部管理╰─&gt; 要在全系统安装 Python 软件包，请尝试使用 apt install    python3-xyz，其中 xyz 是要安装的软件包。    安装。    如果您想安装非 Debian 打包的 Python 软件包、    使用 python3 -m venv path/to/venv 创建一个虚拟环境。    然后使用 path/to/venv/bin/python 和 path/to/venv/bin/pip。确保    确保安装了 python3-full。    如果您想安装非 Debian 打包的 Python 应用程序、    最简单的方法是使用 pipx install xyz，它会为您管理一个    虚拟环境。请确保已安装 pipx。    更多信息请参见 /usr/share/doc/python3.11/README.venv。注意：如果您认为这是一个错误，请联系您的 Python 安装或操作系统发行提供商。您可以通过 --break-system-packages 来覆盖此选项，但可能会破坏您的 Python 安装或操作系统。提示：详细规范请参见 PEP 668。
I choose ignore it and input sage --pip install pycryptodome --break-system-packages
In this way, we succeed.
root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper/Desktop# sage --pip install pycryptodome --break-system-packagesCollecting pycryptodome  Downloading pycryptodome-3.20.0-cp35-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (2.1 MB)     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.1/2.1 MB 93.7 kB/s eta 0:00:00Installing collected packages: pycryptodomeSuccessfully installed pycryptodome-3.20.0WARNING: Running pip as the &#x27;root&#x27; user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venvroot@LAPTOP-LDQVJGQS:/mnt/c/Users/coper/Desktop# 
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>cryptoCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>关于加入社团的一些个人见解</title>
    <url>/2025/09/11/%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%85%A5%E7%A4%BE%E5%9B%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3/</url>
    <content><![CDATA[省流：不盲从，有一条自己选择的道路，并不断探索，才是最重要的
最近大抵是社团宣讲，关于社团选择，很多新生有很多疑惑，这里我分享一些个人观点
先分享一些我的经历
高中学习过一段时间信息学竞赛，但是学的东西不多，最终拿了个小比赛的省三等奖，算是把C的语法基本学会了，但是真正实力还是很弱，当时Codeforces的分数连1200都没有，这个水平是很多零基础学一段时间就能超过的刚录取的时候，打ACM（大学的ACM竞赛可以算是高中的信息学竞赛的延续），录取后很快就联系ACM实验室的学长原本报志愿，把软工填在前面，但是差一分来了网安，后面了解到了网安协会，感觉网络安全也不错~同时，也对嵌入式（也就是硬件）很感兴趣，原因很多，包括但不限于没有进入笔者所在的高中机器人社团有些遗憾，故而了解到了机器人协会于是乎，笔者大一加入机器人协会和网安协会；在高考后的暑假，笔者学习了STM32的GPIO点灯（嵌入式），并做了BUUOJ除了pwn以外的每个方向的几道题（网络安全相关）；开学后在网安协会选择了密码学的方向（因为学长说密码学是CTF五大方向中最深的一个方向）很感谢大一的时候，学长没有顾及我很菜，带我打比赛，还拿到了比较不错的奖项同时我也学到了很多嵌入式和CTF相关的知识，拓宽了知识面最终在大二找到了一个自己比较喜欢的方向但是我大一的时候没有进acm，因为当时真的事情很多大二的时候进了acm实验室，但是发现自己距离毕业不远了，该准备考研了，没有时间精力去准备区域赛了也有点感慨，没有在任何一个社团干到比较核心的位置，也有点辜负学长们的期待不过话说回来，我个人感觉现在前途还算比较光明滴——除了四级还没过，考研才刚开始学，论文还一篇都没有（哭哭
然后简要介绍一下这三个社团（补充：acm原则上不算社团，属于实验室）
名词解释：

ACM/CCPC/ICPC：是算法竞赛，在一段时间（通常是几个小时）能更快完成几道算法题目，给定输入数据，要求编写代码得到符合题目描述的输出；属于计网学院的
CTF/网络安全竞赛：包括五大方向（哪几个自己去群里看），比赛时长一般更长，可以简单理解为去当黑客（雾）；也算是计网学院的
机器人协会/RM/RoboMaster：包括机械（用3d建模软件画机器人并组装）、电控（也就是嵌入式，让机器人动起来）和视觉（可以简单理解为AI图像识别，又称算法，别和acm的那个算法搞混了）三个方向，具体赛制太复杂了自己看去吧 https://space.bilibili.com/20554233/lists/5950748?type=season ；属于隔壁光电学院的

纸上得来终觉浅，真正想了解这些方向还是要实践——直接做它个几道题，至少先把helloworld写了~

上述内容都是技术类社团，关于其他类型的社团或者学生组织，我的评价是别功利的去看它，都可以加（但是别加太多给自己累着）；技术类社团是真的累，学生组织的话会相对轻松一点，缺点是学不到特别多技术，有点偏社交向
如果想保研的，找保研高手去，我大一就想考研了，故而可以随便打比赛，不用在乎学校加分什么的，可以随便打。保研的话创赛性价比感觉更高一点？我不懂，问别人去，保研好像有另外一套打法（可以直接去群里问，每个专业保研情况有差异）

有同学问可不可以大一不加社团，大一下学期或者大二再加
我的评价是现在完全有时间，因为进入技术类社团，会更push你去学相关技术，进而更快进步；与其担心自己现在零基础进不了，不如多做几个题或者多学一些东西，这样就起码在面试的时候有点东西可以说了

ACM实验室的话，是寒假的几场比赛作为校队选拔，故而不用着急（但是时间过得很快，等着急了可能就来不及了~)；即便不想打acm，也推荐刷一刷OJ（Online Judger，即在线测评，做题平台，可以使用学校的那个），无论是其他社团还是课内学习，c语言的基础必不可少。大概刷个十几题就能知道acm比的是什么了，刷个一百多题就可以总结出一套自己的路子了
CTF也就是网安协会的话，我当时是除了pwn，每个方向都学了一点，如果想打ctf但是不知道方向选什么好，打开随便一个做题网站（我当时用的是buuoj.cn，当然用NSS也可以），每个方向不用多做 就做五道题，你就能大致知道干什么的了；更新：最近有MoeCTF新生赛，蛮可以打一下
RM也就是机器人的话，我只学过电控（也就是嵌入式），也是建议直接上手，十多块钱买个c6t6和烧录器（具体型号或者链接可以进群问学长学姐），然后开始学点灯，串口通信，布拉布拉······；至于机械或者视觉，我也不知道学什么入门比较好，问具体学长学姐吧（补充：嵌入式确实挺好玩的哈，后面有时间确实蛮可以玩一下）
备注：无论学什么，只要和计算机相关的技术，都建议先有C语言基础再来


最后两点，1.别跟我一样加这么多社团，和我一样学艺不精就坏事了；2.无论选择什么方向，有一套自己的路子即可，别盲从，你做什么都会成功的~

补充一点，就是说不要把手段当成目标，很多新人写算法或者做CTF，经常会问题看不懂不会做怎么办，有没有视频课之类的。视频课肯定有，但是就怕以为，以为什么呢，把看完课和自己学会画等号。这种情况经常出现啊，就像这两天有上门推销英语课的，然后有人心理就感觉，我买了这个课，我就是英语大神了，四六级就闭眼过了，实则并非，需要考虑进去自己要花费的时间成本才对，报课不如直接做一套题或者在网上找点视频课好，至少充分发挥了自己的主观能动性。竞赛也是啊，不管acm还是ctf的入门，看课只是手段，学会才是目标，千万别收藏一堆东西然后吃灰了，收藏的东西不算拥有，只有真正学进脑子里去的才算拥有。不是说“你不许看视频课”，而是需要明确目标，不过说实话现在市面上确实没看到特别特别特别好的一本通视频学习资料。毕竟每个人的已有知识和学习能力有差异，可能同一款课，有的人觉得太基础了，有的人觉得太难了。
还有就是如果自己会的东西，如果你在过慢的学，一直在舒适区内，可能也会倦怠；人其实没有这么多时间的，选一个方向，耐心地做下去，等你做好了，时间可能就过去了，你也不需要去看其他方向了，有可能也不想看其他方向了，但是这个过程中你的学习能力会不断变强。可能大一的你学习一个难度为$x$的CTF的知识点需要5个小时的时间，等你考研或者科研又或者参加工作遇到一个难度同样为$x$的问题，只需要不到一个小时就能解决了

后后记：再补充两点

善用ai和搜索引擎，ai时代好比工业革命，善用ai可以带来百倍千倍的提升，询问ai（即提示词工程）的能力也会随着你的使用越来越强的，所以just do it~
学会“提问的艺术”，具体可以看群文档，但是想一言以蔽之，做到两点就可以了：一是相互尊重，因为寻求别人的帮助，别人可以帮也可以不帮；二是让对方方便回答，例如清晰的陈述问题，并用手机拍摄电脑截图，不要过多情绪化（救命啊），解决问题才是根本目的

]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>制导镖</title>
    <url>/2024/06/02/%E5%88%B6%E5%AF%BC%E9%95%96/</url>
    <content><![CDATA[发射点到对方前哨站的距离：16m；发射点到对方基地的距离：25m


三个阶段：
第一阶段，可以辅助制导，通过少量气瓶等方案实现，在镖架的机械误差较大，散布直径在500mm-1000mm的镖可以制导击中前哨站概率超过20%，散布直径在200mm-500mm的镖可以制导击中前哨站概率超过40%，散布直径200mm以下的听天由命不过也基本上大概率能中
第二阶段，可以辅助制导，通过舵机等方案实现（和南航较像），对镖架要求进一步降低，可以击中前哨站概率超过60%
第三阶段，可以制导，通过较大推力实现稳定弹道方案，只要不摔坏就一定能打中

第一阶段：
构想：主体沿用旧版传统飞镖，尾部新增安装一个气球，使用3d打印件控制气球大小的上限，主体部分嵌入飞镖内部，通过一个360°舵机控制其出风方向，通过陀螺仪传感器数值进行定点放气
或者考虑使用舵机等电机进行动量和姿态的改变
upd：为了保持镖身左右稳定，可以考虑使用两个舵机进行对称控制
大致成本：
镖身：耗材的价格
陀螺仪MPU6050：7r
舵机最普通的*2：5*2=10r
摄像头ov7670：7r
开发板c6t6：5r
总成本：50-

第二阶段（南航制导镖）
大致成本：
STM32F401CCU6 14.5r
MPU6050 6.58r
蓝剑高刷新率微型舵机 39r
stm32H750视觉处理 40r
ov7725摄像头 25r
第三阶段：
在保证推重比小于1的前提下，飞行至最高点时开启制导模式，使用FPGA和大于0.5g的推力和pid等控制方式
]]></content>
      <categories>
        <category>电控</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>关于如何背诵单词的思考</title>
    <url>/2025/05/23/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%83%8C%E8%AF%B5%E5%8D%95%E8%AF%8D%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[今天思考了一个问题——如何更有效，且更持久的进行背诵英语单词，并且如何检查背诵成果


解决记忆问题：间隔重复，视听写读
解决持久问题：固定时间，定时定量
具体操作第一步：首次输入（联想+朗读）

看单词和中文释义
听录音+跟读三遍
遮住中文，回忆意思
在一旁默写一遍单词

✅ 目的：建立听觉+视觉+动作联结
第二步：加强记忆（默写+复述）

间隔半个小时，测试这组单词：
中文提示 -&gt; 写出英文拼音
复述单词意思


听录音不看书 -&gt; 跟读说中文释义

✅ 目的：加深记忆路径，测试回忆能力
第三步：次日复习（检验记忆是否“过关”）

拿出昨日的单词列表：
中文提示 -&gt; 写出英文拼音
听录音判断自己是否还记得意思


标记哪些记不清楚，重新加入今日学习计划

✅ 目的：巩固+筛查遗忘点
检验



测试方法
要求
是否过关




中文 → 英文拼写
90%以上正确
✅


听录音 → 说出中文
能快速反应出意思
✅


自己能用该词造句
能简单口头用出
✅（长期目标）




如何分组背的多了记不住，少了进度慢
单次20~30分钟（25分钟番茄钟）




英语水平
建议每天新词量
建议每日总学习时间




初级
10～15 个
20～30 分钟


中级
15～25 个
30～40 分钟


高级
30～50 个
45～60 分钟




💡注意：这个是“新词”的数量，不包含复习旧词的时间。
]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>厦大一日游（机器人大赛）</title>
    <url>/2024/08/13/%E5%8E%A6%E5%A4%A7%E4%B8%80%E6%97%A5%E6%B8%B8%EF%BC%88%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E8%B5%9B%EF%BC%89/</url>
    <content><![CDATA[原文链接
原文发表日期 2023-11-25
朝花夕拾，感悟颇深，故迁移到新博客网址



11.25早晨六点，早早地起床，出了校门，坐了很长时间的地铁，来到了福州南站
看样子学长们昨天晚上调了一个通宵的车···
一个多小时后到达厦门北站，然后乘坐地铁到达岛内，又然后转乘到翔安区~~见证了一个繁华到清净的过程

早听闻翔安校区周围都是荒地，果真如此；进入校园之后，感觉校内空间也很大
道路很宽，路上人也不多（即使是吃饭时间）；这样宽阔的路上，行车行人两不误
很奇怪的是，厦大翔安的面积远大于师大旗山，但目测其电动车比例很小，与师大大相径庭。晚上骑上共享单车时我得到了答案——在厦大骑车和在师大完全是不同的感觉，可谓冯虚御风，那叫一个爽；骑起来了，几乎不需要再蹬就可以走得很远很远。共享单车的故障率也远小于师大，这下子有共享电动车也不是很需要了
因此，在自然选择下，可以长距离骑的山地车更适用于没有减速带的厦大；交通相对堵塞的师大更适合电动车来进行频繁的零始加速
据目测，厦大跟师大的饭菜大致差不多，不过价格更便宜；米饭全部免费（因为有补贴），包装费便宜很多（呜呜呜不想回师大了）
翔安校区的建筑看起来很新很好看，毕竟是新的建筑，即使是宿舍楼也很有艺术气息；很有酒吧舞的感觉，属于是名副其实了


关于比赛

准备比赛需要携带的基本物品（电控组）ps.下次需要再加上魔术贴


赛前硬件出问题可能是常态，需要稳住心态，才有可能抢救赛前遥控器突然故障，硬件组的学长紧急抢修得以挽救；测试结束后，pitch轴控制出现离线问题，学长进行分析，得到结论：是新的线使pitch轴的线出现接触不良赛前不要改走线，否则容易出大问题
需要多和其他成员沟通，谋得更好的配合电控视觉硬件等组合作完成工作，每个人熟悉自己领域的工作并了解其他领域的工作，可以使调试效率大大提升
比赛周途劳顿是常态，需要习惯比赛嘛，虽然不是土木，但是总是要接触硬件，不就得跑来跑去的嘛——也是比较值得的



感悟

在RM上，师大和厦大差距很大一方面在资金和支持，这导致在资源上出现缺陷，师大只有一间实验室（和一间自习室），合在一起也远没有厦大的一间实验室面积大（而厦大有整整一个楼层的实验室，六间！），也因此师大没有环形高地等试验场地；另一方面在于层次上，就新生而论：厦大的新生已经可以做各式各样的机器人（包括但不限于带有发射机构的机器人），与此同时师大的新生却处于在循迹小车的层次，各种通信协议也需要自行学习（这一点利弊难辨），格局差距不小；就氛围而论，师大不及周边很多学校，协会人数过少，如果条件允许（然而显而易见，也许由于物质基础的限制，条件是不允许的）可以向首都师范大学学习；归其原因，还是因为穷，没有场地也没有资金在层层限制下，不能想太远，才有机会翻盘

在建设上，师大和厦大差距很大同样是人文学校，同样是不注重理工科，为什么厦大机器人协会这么富（哭）理工科可以算得上是一种趋势，所以各个学校都在努力向理工科砸钱，这样子，师大相对厦大的距离应该会是越来越远

在学生素质上，师大和厦大差距很大让我很为赞叹的是，开会期间，有几个厦大学生，一直在那里研究和学习对于大学生而言，保持专注状态已经很为难得了，除非热爱，再加上有条不紊按部就班的规划能力人外有人山外有山，对于个人能力，及有待提升

需要多看开源，多交流学习以开阔眼界看了集美成毅的车，他们的pid十分丝滑，车也显得十分轻。经过交流和观察得知，他们的部分结构设计是借鉴的开源，使用的材料也是相对轻便的玻纤，没有使用超级电容，很稳，最终以三十多秒零碰撞的成绩赢下了比赛。这应该是一个强基固本很好的例子，善于利用并学习，进而选择正确的决策才能换来成功

看着好，不一定真的好赛前，嘉庚学院的某队队长向领导展示全向轮的小车，其灵活性能令领导赞叹不已；上场后却频频“碰壁”（物理）。不禁令人沉思——再强大的设计，不经过赛场的试炼，它可以算作是强大吗？



ATTENDATION
厦门大学学习氛围和人文主义浓厚，但是和同层次院校相比，理工科水平不足
有学长说，厦门大学的理工科不如福州大学；窃以为RoboMaster比赛需要大量的经济支持来支撑起来，厦门大学作为酒吧舞固然有更多的物质支持，而硬件比拼不过，并不代表技术会有欠缺；在恶劣的环境下即使与在相对优越的环境下的他们能打平手，某种意义上也算是大获全胜了——初心高于胜负，成长胜于输赢！

润去学高数了，再不学就挂科了
]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链中的树</title>
    <url>/2025/10/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[Merkle 树问题：对一个数组求哈希（n个元素）
传统方案：将每个数据拼接然后哈希，时空复杂度都是$O(n)$
使用merkle树：只需计算路线上的哈希，时空复杂度都是$O(logn)$；代价是总存储空间变大（需要存哈希树），但是依旧是$O(n)$

Trie 树根据前缀进行索引，适用于前缀相似的数据存储
深度最劣为最长字符串的长度（也就是时间复杂度），但不一定是二叉树
适用于前缀字典的查找

Merkle Patricia 树把Merkle树的二叉变为16叉
父节点记录16个叉的指针，再加一个value字段表示自己的数值
这里的指针，就是子节点的哈希值，存在一个key-value DB里协助反向查找

同时负责哈希和索引两个功能
 16叉减少深度-&gt;减少数据库的请求次数
Rollup的State Tree对map和value进行分离

Verkle Tree基于KZG

依此构造16叉树

]]></content>
      <categories>
        <category>技术学习笔记</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title>变色龙哈希学习笔记</title>
    <url>/2024/11/24/%E5%8F%98%E8%89%B2%E9%BE%99%E5%93%88%E5%B8%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[用于记录变色龙哈希的学习历程
没写完，不打算写了~

Chameleon Hashing and Signatures作者：Hugo Krawczyk, Tal Rabin
时间：1997

Based on Claw-free Trapdoor PermutationsGeneral Construction计算过程

实验代码#基于线性方程进行模拟import randomimport gmpy2from Crypto.Util.number import *a = 0 ; b = 0 ; c = 0 ; d = 0 ; p = 0def init():    global a, b, c, d, p    p = getPrime(512)    while True:        a = random.randint(1, 2**512)        c = random.randint(1, 2**512)        if gmpy2.gcd(a, p) == 1 and gmpy2.gcd(c, p) == 1:  # 确保 a 和 c 与 p 互质            break    b = random.randint(1, 2**512)    d = random.randint(1, 2**512)# 线性变换函数def f1(x):    return (a * x + b) % pdef f2(x):    return (c * x + d) % p# 线性变换逆函数def inv_f1(y):    return (y - b) * gmpy2.invert(a, p) % pdef inv_f2(y):    return (y - d) * gmpy2.invert(c, p) % pif __name__ == &#x27;__main__&#x27;:    init()    m1 = bytes_to_long(b&#x27;flag&#123;Chameleon_Hash_is_good&#125;&#x27;)    r1 = random.randint( 1 , p - 1 )    # 计算 H(m1, r1)    H = r1    for i in str(bin(m1)[2:]):        if i == &#x27;1&#x27;:            H = f1(H)        else:            H = f2(H)    print(f&quot;H(m1, r1): &#123;H&#125;&quot;)    m2 = bytes_to_long(b&#x27;flag&#123;I_agree_with_msg1&#125;&#x27;)    # 构造新的随机数 r2，使 H(m1, r1) = H(m2, r2)    r2 = H    for i in reversed(str(bin(m2)[2:])):  # 逆序推回原随机数        if i == &#x27;1&#x27;:            r2 = inv_f1(r2)        else:            r2 = inv_f2(r2)    print(f&quot;Recovered r2: &#123;r2&#125;&quot;)    # 验证碰撞：计算 H(m2, r2)    H2 = r2    for i in str(bin(m2)[2:]):        if i == &#x27;1&#x27;:            H2 = f1(H2)        else:            H2 = f2(H2)    print(f&quot;H(m2, r2): &#123;H2&#125;&quot;)    # 验证碰撞结果    if H == H2:        print(&quot;Hash collision successful!&quot;)    else:        print(&quot;Hash collision failed!&quot;)
Based on the Intractability of Factoring系统参数
计算过程

困难问题该问题的核心为平方根的计算，可以规约到因数分解问题
给定 $n = p \cdot q$ 和一个整数 $y \in \mathbb{Z}_n$，想要找到 $x \in \mathbb{Z}_n$ 使得：

x^2 \equiv y \mod n也就是计算 $y$ 在模 $n$ 下的平方根。
这在一般情况下是一个困难的问题，除非知道 $n$ 的两个素因数 $p$ 和 $q$。

实验代码#总是有问题，后面再解决
Based on Discrete Log系统参数
计算过程
推导已知 $CH(m,r) = g^m\cdot y^r$
即 $CH(m,r) = g^m\cdot g^{x\cdot r} = g^{m+x\cdot r}$
故令 $CH(m’,r’)\equiv CH(m,r)\mod p$
有 $g^{m’+x\cdot r’}\equiv g^{m+x\cdot r}\mod p$
即 $m’+x\cdot r’\equiv m+x\cdot r\mod q$
移项得到 $r’\equiv r+\frac{m-m’}{x}\mod q$
实验代码#具体见比赛代码SK = random.randint(1, q)PK = pow( g , x , p )r1 = random.randint(1, q)CH = pow( g , h , p ) * pow( PK , r1 , p ) % pr2 = exgcd(SK,q)[0] * ( H(m1) - H(M2) + SK * r1 ) % q
Chameleon Signature SchemesChameleon Signing签名步骤
验证步骤
争议解决
EnhancementsThe recipient’s identity签名时不仅绑定消息的哈希值，还绑定接收者 RRR 的身份 $id_R$。这样可以避免签名者更改签名中的身份信息。
Exposure-freenessMemory requirementsSecurity RequirementsA Full Chameleon Signature SchemeAlgorithm


Chameleon Hashing without Key Exposure作者：Xiaofeng Chen
时间：2004

Preliminary WorksGap Diffie-Hellman Group设 $G$ 是一个由生成元 $g$ 生成的循环乘法群，其阶数为素数 $q$。假设 $G$ 上的求逆运算和乘法运算可以高效完成。在这样的群 $G$ 上，定义以下三个问题：

一个群 $G$ 被称为 Gap Diffie-Hellman 群，如果：

判定性 Diffie-Hellman 问题（DDHP）可以在多项式时间内高效解决。
计算性 Diffie-Hellman 问题（CDHP）在没有特殊辅助信息的情况下没有多项式时间算法能够解决。

换句话说，在这样的群中，验证 $g^c = g^{ab}$ 是简单的，但直接计算$g^{ab}$ 是困难的。
Chameleon HashingComposition

Security properties
Mention“Key Exposure Problem” is not but——

（这一条存疑）
how to key_exp
CH(m)=g^{m+x\cdot r} \\
CH(m')=g^{m'+x\cdot r'}$g$是系统公共参数，已知

\begin{flalign}
已知&\ g^my^r=g^{m'}y^{r'}\\
所以有&\ g^mg^{x\cdot r}=g^{m'}y^{x\cdot r'}\\
则有&\ m+x\cdot r=m'+x\cdot r'\\
移项得到&\ x=\frac{m-m'}{r'-r}
\end{flalign}On the Key Exposure Problem in Chameleon Hashes作者：Giuseppe Ateniese
时间：2004

Introduction上一篇论文提供了一种密钥无暴露变色龙哈希函数的具体构造，该函数在具有双线性配对的 Gap 群设置下工作。虽然这无疑是密钥无暴露变色龙哈希的第一个完整构造，但它并没有解决是否存在基于其他加密假设或更高效方案的构造的问题，例如与 [12] 中的原始变色龙哈希函数具有可比性能的构造。
Ateniese, G., de Medeiros, B.:Identity-based chameleon hash and applications.In Fi-nancial Cryptography 2004. LNCS 3110, Springer-Verlag (2004) 164–180. Available online athttp://eprint.iacr.org/2003/167/.
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>各式各样的DH</title>
    <url>/2024/10/08/%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84DH/</url>
    <content><![CDATA[阅读《Identity-Based Chameleon Hashing and  Signatures Without Key Exposure》一文时，遇到了Decision Diffie-Hellman Problem (DDHP)这一概念，头一次遇到，便搜索了一下，打算学习学习；没想到捅了老挝——一个DH密钥交换算法能衍生出各式各样的东东
没办法了，学吧
由于种种原因（我比较懒），目前只学DDHP，其他的先挖个坑

DDHP论文里的描述
大致内容：在特定的群 $G_1$ 中，可以通过计算双线性映射的方式有效地判断一个四元组是否满足Diffie-Hellman条件




区别
DH
DDHP




目的
用于密钥交换，建立安全通信
判断给定值是否符合Diffie-Hellman关系


功能
生成共享密钥
验证一个数值是否是由特定的私钥生成的


安全性基础
基于离散对数的困难性，安全性与密钥长度和生成元选择有关
直接依赖于离散对数问题的安全性，特别是在无法计算 $g^{ab}$ 的情况下




代码展示（有点草率，但是感觉思想很到位）
# 假设我们已经有 A、B 和一个待验证的 CC = pow(g, a * b, p)  # 假设这是我们计算出来的 C# 验证DDHPdef verify_ddhp(p, g, A, B, C):    # 计算 g^(ab) mod p    calculated_C = (pow(A, b, p))  # K = A^b mod p    return calculated_C == C# 输出验证结果is_valid = verify_ddhp(p, g, A, B, C)print(f&quot;Is C valid? &#123;is_valid&#125;&quot;)
结合双线性映射问题描述给定四个元素$(P,aP,bP,cP)$，其中：
$P$ 是群中的生成元
$aP$ 和 $bP$ 是两个通过标量乘法得到的公钥
$cP$ 是待验证的值
DDHP的目标是判断 $cP=abP$ 是否成立
解决步骤
计算双线性映射


\gamma_1=\hat{e}(P,cP)\\
\gamma_2=\hat{e}(aP,bP)
判断条件
若$\gamma_1=\gamma_2$，则可以确认 $cP$ 是有效的Diffie-Hellman四元组，即 $cP = abP$


]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>后量子密码-LWE问题</title>
    <url>/2024/09/04/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-LWE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[LWE(Learning With Errors)问题，基于格

问题简化：

密码向量：设一个位置的秘密向量 $s\in\mathbb{Z}_q^n$ （$\mathbb{Z}_q^n$是模 $q$ 的整数环，$n$ 是向量的维度）
线性方程组：给定一系列的线性方程 $ai⋅s+ei\ (\mod q\ )$，其中 $a_i\in\mathbb{Z}_q^n$ 是已知的随机向量，$e_i$ 是从某个噪声分布中抽取的小整数噪声。
目标：给定这些方程（即给定多个 $a_i,b_i=a_i\cdot s+e_i$  对），求解秘密向量 $s$。

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>后量子学习笔记·其二</title>
    <url>/2024/09/29/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%85%B6%E4%BA%8C/</url>
    <content><![CDATA[在 撬开后量子的大门 一文中，我们初步学习了后量子密码学，本篇博客，力求对后量子密码学进行进一步学习

量子计算我们通常说的量子计算就是通过量子逻辑门来操作处于叠加态的量子。比如Hadamard门，简称H门，他的一个主要功能就是通过计算基态产生等概率的叠加态。通过H门变换后的单量子叠加态为：
$H(|Φ_1⟩)=\frac{1}{\sqrt{2}}(|0⟩+|1⟩)$
两种基态的坍塌概率都为 $\frac{1}{\sqrt{2}}$，两个量子的H门得到的结果如下：
$H(|Φ_2⟩)=\frac{1}{\sqrt{2^2}}(|00⟩+|01⟩+|10⟩+|11⟩)$
每个态坍塌的概率 $\frac{1}{\sqrt{4}}$ ，对于n个量子的H门变换后：
$H(|Φ_n⟩)=\frac{1}{\sqrt{2^n}}∑_{i=0}^{2n−1}|i⟩$

量子门及其对应的门矩阵如下图：

https://en.wikipedia.org/wiki/Quantum_logic_gate
挖个坑，这是另外一篇笔记的事情了

还有一个比较重要的复合门是受控U(a,x)门：一只冰牙喵：4.2 受控操作
省流：受控U门可以用于计算以a为基底的幂，其一般用于生成指数函数值。
量子如何做并行运算量子计算正是有了数据的可叠加性和幺正变换，从而决定了一次操作即可改变多个数据
在经典计算中，并行性的核心思想是将一个计算任务分配给多个处理器同时运行，要快于使用一个处理器来运行。在理想的情况下，将工作分配给K个处理器就应该使计算时间缩短为原来的1/K
而对于量子计算机，将一个N 位量子寄存器中的 $2^N$ 个数据同时通过一次幺正变换（即进行一次运算）所需的时间定义为 $T_q$ ，而经典计算中对一个数据进行运算的时间为 $T_c$ ，因为一次量子计算就对所有的数据做了并行处理，所以量子计算加速能力可以表示为 $S=2^N\cdot\frac{T_c}{T_q}$
如果 $T_c=T_q$ ,那么加速能力 $S=2^N$,也就是说对量子计算机做一次运算，相当于对经典计算机做 $2^N$ 次运算
此外，一台量子计算机并不一定在所有计算任务上都比一台经典计算机做得好，比如乘法运算在一台量子计算机上执行就不如传统计算机上快。为了突出量子计算机的优越性，就需要开发量子并行效应能力的算法。
量子计算机是严重依赖于优秀的量子算法的实现，虽然通用量子计算机能做经典计算机的所有事情，但是只有在处理特定问题上量子计算才具有决定性的优势
Shor算法分析shor算法直接将质因子分解以及离散对数问题以指数级速度提升，这意味着可以利用同样算法思想来解决更为广泛的隐含子群问题。
RSA是经典计算机大数质因式分解的指数复杂度的困难的一种非对称加密算法，目前最优的因子分解算法（The Number Field Sieve）为指数复杂度 $O\left(\exp\left(\left(\frac{64}{9}\right)^{1/3} \cdot \log n^{2/3} \cdot \log \log n^{1/3}\right)\right)$ 。而通过shor量子算法可以以多项式复杂度完成大数因式分解，从而可以快速破解RSA算法。
Shor算法的核心依赖于 

H变换
U变换
QFT(量子傅立叶)

Shor算法量子实现线路简图：

RSA算法我们设RSA的公钥为 $(e,N)$ ，私钥为 $(d,N)$ ,那么生成公私钥的过程如下：

生成两个足够大的素数 $p,q$，得到合数 $N=pq$，则 $\phi(N)=(p-1)(q-1)$
生成 $e$ ，使得 $e$ 和 $L$ 互质，且满足 $1&lt;e&lt;\phi(N)$
生成 $d$，使得 $d*e=1\mod \phi(N)$ 且 $1&lt;d&lt;\phi(N)$

那么加密解密操作如下

\begin{cases} c_i=m^e_i(mod\;N)&加密\\ m_i=c^d_i(mod\;N)&解密\\ \end{cases}\\只要能够实现大数N的因子分解，就可以破解RSA
2、问题转化
没看完，改天接着看
https://zhuanlan.zhihu.com/p/106923175
https://qrunes-tutorial.readthedocs.io/en/latest/chapters/algorithms/shor_Algorithm.html
https://blog.csdn.net/bluepeople1/article/details/50015921
https://www.cnblogs.com/zhuowangy2k/p/12245636.html
首先我们需要将大数因子分解问题转化为以求待分解的合数N为模的函数 $f(x)=a^x(mod\;N)$ 的周期问题。
设周期函数 $f(x)=a^x\pmod N$ 的周期为r（这里a为小于N，且与N互质的整数），则有：f(x)=f(x+r) , 那么：
a^x=a^{x+r} \pmod N\ \Rightarrow a^r=1 \pmod N\ \Rightarrow (a^{r/2}+1)(a^{r/2}-1)=0 \pmod N\ \Rightarrow (a^{r/2}+1)(a^{r/2}-1)=kN \quad(k=0,1,2,…)\
设整数 x=a^{r/2} ，则
(x-1)(x+1)=kN\Rightarrow x-1=kN/(x+1),x-1&gt;1
那么 x-1， x+1 都能被 kN 整除，那么一定存在 gcd(x+1,N)&gt;1 或者 gcd(x-1,N)&gt;1 (gcd是一个用辗转相除法求公因子的函数)，也就说与N存在一个大于1的公约数，这个公约数就是N的分解因子。
例如：设 N=15，a=7 ,则：
\begin{array}{c|c} x &amp;0&amp;1&amp;2&amp;3&amp;4&amp;5 \ \hline 7^x&amp;1&amp;7&amp;49&amp;343&amp;2401&amp;16807\ f&amp;1&amp;7&amp;4&amp;13&amp;1&amp;7\ \end{array}\ r=4\Rightarrow a^2-1=48，a^2+1=50\ \Rightarrow gcd(48,15)=3，gcd(50,15)=5\
由此，我们只要求出f(x)的周期，就能轻而易举的分解合数了。而shor算法的精髓就是利用量子特性来快速求解得到周期r.
3、通过Shor算法求周期r
设量子比特长度为 L, 则总共可以表示的 q=2^L 个基态, 设N为要分解的合数，为了确保 2^L 长度内有足够的周期数，我们需要满足
N^2\leq2^L\leq2N^2 \
然后，我们利用Hadamard门来构造等概率的量子叠加态 \mathinner{|x \rangle} 存入寄存器reg1，然后利用U门来构造 \mathinner{|f(x) \rangle} 的叠加态存入寄存器reg2，且使这两个寄存器处于纠缠态。
\begin{cases} \mathinner{|\Phi_1 \rangle}=\frac{1}{\sqrt{2^L}}\sum_{x=0}^{2^L-1} \mathinner{|x \rangle}&amp;reg1\ \mathinner{|\Phi_2 \rangle}=\frac{1}{\sqrt{2^L}}\sum_{x=0}^{2^L-1} \mathinner{|x \rangle} \mathinner{|a^x(mod\;N) \rangle}&amp;reg1\oplus reg2 \end{cases}\
两个寄存器展开形式如下：
\begin{align}x&amp;=x_02^0+x_12^1+x_22^2+…+x_{L-1}2^{L-1}\ f(x)&amp;=a^x(mod\;N)=a_{x_0}^{2^0},a_{x_1}^{2^1},…a_{x_{L-1}}^{2^{L-1}}(mod\;N)\end{align}\
由于 f(x) 为周期函数，设周期为r，A为总长2^L中存在的周期数，则
A=\frac{2^L}{r}\tag{0}\
设l为小于一个周期内的x的值, x=l+Ar, 则整个系统的态实际为
\mathinner{|\Phi_2 \rangle}=( \mathinner{|l \rangle} \mathinner{|f(l) \rangle}+\mathinner{|l+r \rangle} \mathinner{|f(l+r) \rangle}+\mathinner{|l+3r \rangle} \mathinner{|f(l+3r) \rangle}+…+(\mathinner{|l+(A-1)r \rangle} \mathinner{|f(l+(A-1)r) \rangle})\
因此，x可以表示为
x=l,l+r,l+2r,l+3r,…l+(A-1)r\
然后对reg2进行计算基上的测量，设测量结果设为 Z ，测量Z在reg1中的投影变化为\begin{align}\mathinner{|\Phi_1 \rangle}&amp;=\frac{1}{\sqrt{A}}\sum_{j=0}^{A-1} \mathinner{|jr+l \rangle}\tag{1}\ &amp;=\frac{1}{\sqrt{\frac{2^L}{r}}}\sum_{j=0}^{\frac{2^L}{r}-1} \mathinner{|jr+l \rangle}\end{align}\
例如 N=15，a=7 ，测量后的整个系统的态为：
\mathinner{|\Phi_2 \rangle}=\frac{1}{\sqrt{2^L}}( \mathinner{|0 \rangle} \mathinner{|1 \rangle}+\mathinner{|1 \rangle} \mathinner{|7 \rangle}+\mathinner{|2 \rangle} \mathinner{|4 \rangle}+\mathinner{|3 \rangle} \mathinner{|13\rangle}+\mathinner{|4 \rangle} \mathinner{|1 \rangle}+\mathinner{|5 \rangle} \mathinner{|7 \rangle}+\mathinner{|6 \rangle} \mathinner{|4 \rangle}+\mathinner{|7 \rangle} \mathinner{|13 \rangle})\
经过投影后
\begin{array}{c|c} Z &amp;\text{测量后x的态}&amp;offset \ \hline 1&amp;(\mathinner{|0 \rangle}+\mathinner{|4 \rangle}+\mathinner{|8 \rangle}+…)\mathinner{|1 \rangle}&amp;0\ 4&amp;(\mathinner{|2 \rangle}+\mathinner{|6 \rangle}+\mathinner{|10 \rangle}+…)\mathinner{|4 \rangle}&amp;1\ 7&amp;(\mathinner{|1 \rangle}+\mathinner{|5 \rangle}+\mathinner{|9 \rangle}+…)\mathinner{|7 \rangle}&amp;2\ 13&amp;(\mathinner{|3 \rangle}+\mathinner{|7 \rangle}+\mathinner{|11 \rangle}+…)\mathinner{|13 \rangle}&amp;3\ \end{array}\
这里，当测量得到一个 \gamma 值后，由于寄存器reg1和寄存器reg2是处于纠缠态，所以Z值测量后寄存器reg1会塌陷为相同Z值的 \mathinner{|x \rangle} 叠加态，如果reg2测量的值为1，那么reg1则处于 (\mathinner{|0 \rangle}+\mathinner{|4 \rangle}+\mathinner{|8 \rangle}+…) 的叠加态，那么周期 r 的信息就包含在reg1中，因此对reg1进行量子傅里叶变化：
QFT(\mathinner{|jr+l \rangle})=\frac{1}{\sqrt{2^L}}\sum_{\gamma=0}^{2^L-1}e^{2\pi i(jr+l)\gamma/2^L}\mathinner{|\gamma \rangle}\ QFT(\mathinner{|\Phi_{2} \rangle})=\frac{1}{\sqrt{A}}\sum_{j=0}^{A-1}QFT(\mathinner{|jr+l \rangle})\
上式可以变换为：
\begin{align} QFT(\mathinner{|\Phi_{2} \rangle})&amp;=\frac{1}{\sqrt{A}}\sum_{j=0}^{A-1}[\frac{1}{\sqrt{2^L}}\sum_{\gamma=0}^{2^L-1}e^{2\pi i(jr+l)\gamma/2^L}]\mathinner{|\gamma \rangle}\ &amp;=\sum_{\gamma=0}^{2^L-1}[\frac{\sqrt{r}}{2^L}\sum_{j=0}^{A-1}e^{2\pi i(jr+l)\gamma/2^L}]\mathinner{|\gamma \rangle} \end{align}\
这里为什么要这么变换，因为当测量Reg2时，Reg2坍塌为了r个值中的一个值，所以每一个值对应reg1中的A个叠加态。这里设：
C_\gamma=\frac{\sqrt{r}}{2^L}\sum_{j=0}^{A-1}e^{2\pi i(jr+l)\gamma/2^L}=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\sum_{j=0}^{A-1}e^{2\pi ijr\gamma/2^L}] \tag{2}\
这里，我们需要考虑两种情况，一种是 2^L 能够整除 r 的情况，也就是在 2^L 内刚好有整数个周期，一种是不能整除的情况。如果能够整除，那说明每个波峰刚好位于 \gamma=k2^L/r ，不能整除时，波峰位于非常接近波峰的两侧，因为波峰处的 \gamma 本应该为非整数，而我们测量得到 \gamma 只能是整数，所以这时候我们需要加入微调的参数。接下来我们分别对这两种情况进行分析。
A.整数周期
在(2)式的[ ]中，在 \gamma 是 \frac{2^L}{r} 的整数倍情况下变成，出现相长干涉，求和后为 A=\frac{2^L}{r} ，如果不为整数，则为相消干涉，其值趋于0. 所以
C_\gamma=\begin{cases} \frac{1}{\sqrt{r}}e^{2\pi il\gamma/2^L}&amp;\gamma=k2^L/r\ 0&amp;\gamma\ne k2^L/r\ \end{cases}\
当 \gamma\ne k2^L/r 时，我们通过等比数列转化得到：
C_\gamma=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\sum_{j=0}^{A-1}e^{2\pi ijr\gamma/2^L}]=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\frac{e^{2\pi iAr\gamma/2^L}-1}{e^{2\pi ir\gamma/2^L}-1}]\
带入（0）式得：
C_\gamma=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\frac{e^{2\pi i\gamma}-1}{e^{2\pi ir\gamma/2^L}-1}]\
由于 e^{2\pi i\gamma}-1=0 ，也就是说，当 \gamma\ne k2^L/r ，也即不为整数，则为相消干涉，其值为0。
通过量子傅里叶变换后得到如下叠加态
\mathinner{|\Phi_{n} \rangle}=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}e^{2\pi ik/r}\mathinner{|\frac{k2^L}{r} \rangle}\ \rho(\mathinner{|\Phi_{n} \rangle})=|\frac{1}{\sqrt{r}}|^2=\frac{1}{r}
测量 \mathinner{|\gamma \rangle} 的值， 等概率 \frac{1}{r} 地选择出一个态。由 \gamma=\frac{k2^L}{r} 得：
\frac{\gamma}{2^L}=\frac{k}{r}\
如果有 gcd(k,r)=1\;(\rho[gcd(k,r)=1])=\frac{1}{log(r)}) , r 就可以从 \frac{\gamma}{2^L} 的不可约分数求出。
B. 非整数周期
2^L 不能整除 r 的情况下,那么在x值范围内的周期数A便不是整数，此时我们加入微调参数 \delta_k 稍作调整，使得 \gamma 为整数，设
\gamma=\gamma_k+\delta_k=k\frac{2^L}{r}+\delta_k\
因此(2)式的[ ]为：
\begin{align}\sum_{j=0}^{A-1}e^{2\pi ijr\gamma/2^L}&amp;=\sum_{j=0}^{A-1}e^{2\pi ijr(k\frac{2^L}{r}+\delta_k)/2^L}\ &amp;=\sum_{j=0}^{A-1}e^{2\pi ijk}\cdot e^{2\pi ijr\delta_k/2^L}\ &amp;=\sum_{j=0}^{A-1}e^{2\pi ijr\delta_k/2^L}\&amp;=\frac{e^{2\pi iAr\delta_k/2^L}-1}{e^{2\pi ir\delta_k/2^L}-1}\end{align}\tag{3}\
这里 \delta_k 的值极小，该值用于逼近函数的峰值，我们再令
\theta=\frac{2\pi r\delta_k}{2^L}\tag{4}
因此(3)式的平方表示为
|\frac{e^{iA\theta}-1}{e^{i\theta}-1}|^2=(\frac{cosA\theta+isinA\theta-1}{cos\theta+isin\theta-1})^2\
由于
\begin{align} cos\theta+isin\theta-1&amp;=1-2sin^2\frac{\theta}{2}+2isin\frac{\theta-1}{2}cos\frac{\theta-1}{2}-1\ &amp;=2sin\frac{\theta}{2}(sin\frac{\theta}{2}-icos\frac{\theta}{2})\ &amp;=2isin\frac{\theta}{2}(cos\frac{\theta}{2}+isin\frac{\theta}{2})\ &amp;=2isin\frac{\theta}{2}\cdot e^{\frac{i\theta}{2}} \end{align}\
因此
|\frac{e^{iA\theta}-1}{e^{i\theta}-1}|^2=|\frac{2isin\frac{A\theta}{2}\cdot e^{\frac{iA\theta}{2}}}{2isin\frac{\theta}{2}\cdot e^{\frac{i\theta}{2}}}|^2=\frac{sin^2\frac{A\theta}{2}\cdot e^{iA\theta}}{sin^2\frac{\theta}{2}\cdot e^{i\theta}}=\frac{sin^2\frac{A\theta}{2}}{sin^2\frac{\theta}{2} }\cdot e^{i(A-1)\theta/2}
所以得到 \gamma 的概率为
\rho(\mathinner{|\gamma \rangle})=(\frac{\sqrt{r}}{2^L})^2\frac{sin^2\frac{A\theta}{2}}{sin^2\frac{\theta}{2}}\ =\frac{r}{2^{2L}} \frac{sin^2\frac{A\theta}{2}}{sin^2\frac{\theta}{2} }\ =\frac{r}{2^{2L}} \frac{sin^2\pi rA\delta_k}{sin^2\pi r\delta_k }\
这里，为了严谨讨论，我们设 |\delta_k| 小于等于1/2（如果大于1/2，可以认为是下一个整数 z-(1-\delta) ），所以这是适用于所有情况的
|\delta_k|\leq\frac{1}{2}\tag{5}
由(4)(5)得：
|\theta|\leq\frac{2\pi \frac{r}{2}}{q}=\frac{\pi r}{q} \ \Rightarrow \frac{|A|}{2}|\theta|\leq\frac{\pi r}{q}\cdot \frac{A}{2}&lt;\frac{\pi r}{q}\cdot\frac{2^L}{2r}=\frac{2^{L-1}\pi}{q}=\frac{\pi}{2}\tag{13}
当 \alpha\in[0,\frac{\pi}{2}]， sin\alpha 必位于原点与点 (\pi/2,1) 连线的上方，所以
sin(\frac{A}{2})\theta\geq\frac{2}{\pi}(\frac{A}{2})\theta\
而对于任意 \alpha ， |sin\alpha| 为凸函数，有：
|sin(\frac{A}{2})\theta|\geq|\frac{2}{\pi}(\frac{A}{2})\theta|\
又因 sin\frac{\theta}{2}\leq\frac{\theta}{2} ,因此：
\frac{sin^2(\frac{A}{2}\theta)}{sin^2(\frac{\theta}{2})} \geq\frac{(\frac{2}{\pi}(\frac{A}{2}\theta))^2}{sin^2(\frac{\theta}{2})}\geq\frac{(\frac{2}{\pi}\frac{A}{2}\theta)^2}{(\frac{\theta}{2})^2}\ =\frac{\frac{2}{\pi}(\theta)^2}{(\frac{\theta}{2})^2}\cdot(\frac{A}{2})^2 =\frac{16}{\pi^2}\cdot(\frac{A}{2})^2
所以，测量 \mathinner{|\gamma \rangle} 的概率为
\rho(\mathinner{|\gamma \rangle})=|C_\gamma|^2\geq\frac{r}{2^{2L}}\cdot\frac{16}{\pi^2}(\frac{2^L}{2r})^2=\frac{4}{\pi^2r}\
最后，我们来讨论测量值 \gamma ,有
\gamma r=(k\frac{2^L}{r}+\delta_k)\cdot r\ =k2^L+\delta_kr\ \Rightarrow |\gamma r-k2^L|=|\delta r|\leq\frac{r}{2}\
所以
|\frac{\gamma}{2^L}-\frac{k}{r}|\leq\frac{r}{2}\cdot\frac{1}{2^Lr}=\frac{1}{2^{L+1}}\
这里 \gamma 已测得，这里严格存在一个分数 \frac{k}{r} ,可由 \frac{\gamma}{2^L} 的连分数展开求出（下一个节将通过实例说明），通过约分满足 gcd(k,r)=1 就可得到 r 的值，gcd算法的成功率为
\rho(gcd(k,r))&gt;\frac{1}{logr}\ \Rightarrow Prob[N]=Prob(gcd(k,r))\cdot Prob(\gamma)&gt;\frac{1}{logr}\cdot\frac{4}{\pi^2r}=\frac{4}{\pi^2rlogr}
也就是说我们能以大于 \frac{4}{\pi^2rlogr} 的概率分解N的因子再加上量子傅里叶变换的复杂度为 O(n^2) ,所以shor算法的时间复杂度为 O(n^2rlogr)
三、实例分析虽然上面已经分析得很透彻了，但是估计还是有人觉得会太抽象，所以下面我以一个例子来进行实例分析，以帮助理解。
对于 f(x)=a^x(mod N) ，N=91，a=4，那么
f(1)=4,f(2)=16,f(3)=64,f(4)=74,f(5)=23,f(6)=1
所以周期为 r=6， N&lt;2^7 ,L=2\times 7=14，然后根据2，3式我们计算得到：
\begin{array}{c|c} k &amp;\gamma=k2^L/r&amp;最近整数&amp;\rho(\gamma)&amp;\gamma/2^L\ \hline 0&amp;0&amp;0&amp;0.167&amp;0\ \hline 1&amp;2730.67&amp;2731&amp;0.114&amp;0.166687\ \hline 2&amp;5461.33&amp;5461&amp;0.114&amp;0.333312\ \hline 3&amp;8192&amp;8192&amp;0.167&amp;0.500000\ \hline 4&amp;10922.67&amp;10923&amp;0.114&amp;0.666687\ \hline 5&amp;13653.33&amp;13653&amp;0.114&amp;0.833312\ \end{array}\
这里， \gamma 是我们测量得到值，如果这个值为0，那么对于我们求周期r是没有意义的，所以除开这种情况下，测得其他值的概率和为0.623。如果测量的值为13653，那么我们来计算0.833312的连分数。
1/0.833312=1.200031,
1/0.200031=4.999225,
1/0.999225=1.000775,
1/0.000775=1290.322580
这里遇到大数1290，我们就终止，最后我们得到连分数为
[0;1,4,1]=\frac{1}{1+\frac{1}{4+1}}=\frac{5}{6}\
那么我们就可以确定 k=5,r=6 了吗，那有没可能 k=10,r=12 呢，所以，我们不能单纯的通过一次测量来确定周期，我们来考察其他几项，我这里不再一一去展开了，懒人可以在这里去计算(连分数计算 -连分数计算器-分数计算器)。
\begin{array}{c|c} k &amp;\gamma最近整数&amp;\gamma最近整数/2^L&amp;连分数展开近似值\ \hline 0&amp;0&amp;0&amp;0\ \hline 1&amp;2731&amp;0.166687&amp;\frac{1}{6}\ \hline 2&amp;5461&amp;0.333312&amp;\frac{1}{3}\ \hline 3&amp;8192&amp;0.500000&amp;\frac{1}{2}\ \hline 4&amp;10923&amp;0.666687&amp;\frac{2}{3}\ \hline 5&amp;13653&amp;0.833312&amp;\frac{5}{6}\ \end{array}\
因此，如果我们将shor算法多执行几次，最后求出各个分母的最小公倍数，那么这个最小公倍数就是我们要找的周期r，有了周期r，我们就不难求出合数N的质数因子了，进而也能够比较容易破解RSA算法了。
四、离散对数问题简析（不感兴趣可以略过，有时间补充）通过对shor算法原理的剖析，我们可以知道，对于任何具备转化为求周期函数的周期为目标的问题都可以用同样算法以指数加速来快速解决，比如离散对数(ElGamal), ECC之类的非对称加密算法都可以用同样的思想来解决。
离散对数多说两句，Shor在其原始论文中对于素域上的离散对数问题，给出了一个基于整数求阶量子计算算法求解算法,成功率为1/480。Shor指出在解决素域上的离散对数问题时，其实并没有利用到素域的特性，因而对有限域上的离散对数问题也同样成立。后来Eicher和Opku给出了一个在多 项式时间内以1/480的成功率攻击椭圆曲线离散对数问题的量子计算算法
设一个阶为 p ,且生成器 为g 的群 G （ g\in G ）,如果 x=g^r(mod\; p)\in G ,那么对于部分 r\in \mathbb{Z}_p ,我们希望得到 r ,那么 r 就是离散对数 r=log_g(x) .
比如EIGamal加密，对于随机大大素数P,以及随机数x,满足y=g^x(mod\;P)\;1&lt;x&lt;P-1,g\in Z^*_P\
这里 (y,g,P) 为公钥， x 为私钥。我们将长度为 N，N&lt;log^P_2 的消息分组为
m_1m_2…m_t\
那么计算密文
\begin{cases} c_i=g^{r_i}(mod \;P)&amp; \c^{‘}_i=m_iy^{r_i}(mod \;P)&amp;\ \end{cases}1\leq i\leq t\
这里c1,c2为加密后的密文,那么解密过程如下：
m_i=\frac{c^{‘}_i}{c^x_i}(mod\;P)\;1\leq i\leq t\简单推一下
\frac{c^{‘}_i}{c^x_i}=\frac{m_iy^{r_i}}{g^{xr_i}}=\frac{m_ig^{xr_i}}{g^{xr_i}}=m_i(m_i&lt;P)\
考虑abelian 群 \mathbb{Z}_p \times\mathbb{Z}_p (每一个因子对应于值的模加)。那么函数
f:\mathbb{Z}_p \times\mathbb{Z}_p\rightarrow G; f(a,b)=g^ax^{b}
这给我们呈现了一个abelian 隐含子群问题，同时可以看出映射 f 是一个群同态。kernel为 (r,1) 的倍数，所以如果我们能找到kernel，我们就能够找 r .
对于函数 f(a,b)=g^ax^b(mod\;p) ,设周期为 r_g 和 r_x ，那么
g^ax^b=g^{a+r_g}x^{b+r_x}=g^ax^b\cdot g^{r_g}x^{r_x}\ \Rightarrow g^{r_g}x^{r_x}=1(mod\;p)\ \Rightarrow g^{r_g}g^{rr_x}=g^{r_g+rr_x}=1(mod \;p)\
r_g+rr_x=0(mod\;q)\ r=-\frac{r_g}{r_x}\
因此，我们只要通过量子算法求得周期 r_g,r_x 就可以得到 r .使用量子算法处理离散子群问题，和我们前面讲解的方法非常类似，后续有时间再分析吧。
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>唐吉坷德式的冲锋</title>
    <url>/2025/07/14/%E5%94%90%E5%90%89%E5%9D%B7%E5%BE%B7%E5%BC%8F%E7%9A%84%E5%86%B2%E9%94%8B/</url>
    <content><![CDATA[
我的长枪被大雨磨钝了战马也生锈了可我的冲锋是唐吉坷德式的名为「生活」的大风车我要和你大战三百回合


《唐吉诃德》是一部深具讽刺意味的长篇小说

中世纪骑士小说的虚假与荒唐
盲目的理想主义与脱离现实的英雄幻想
当时社会虚伪、愚昧和腐败

主角唐吉诃德读了太多骑士小说，便幻想自己是拯救世界的英雄，穿上盔甲，骑上瘦马，扛起长枪，出发“行侠仗义“
但他看到的不是现实，而是幻想他看到风车，以为是巨人——于是，他冲了上去

荒唐吗？当然荒唐 可他身上有些东西，很多人也曾有过

虽然唐吉诃德疯疯癫癫、笑料百出，但他身上有一种令人动容的力量：执着、善良、尊严感和信仰感
拿他取笑之余，反而通过他的失败，可以看到—— 一个真诚的人，与这个冷漠世界的冲突与碰撞




面向
内容
启发




理想与现实的冲突
他追求理想，却不断碰壁
人生需要理想，也要学会面对现实


坚持信念的勇气
即使被嘲笑、被打败，他也不怀疑自己的使命
理想可能失败，但信念不该轻易放弃


友情与忠诚
桑丘·潘萨陪他一路疯，也一路保护着他
理想主义和现实主义，不一定非要对立


自我反思与成长
晚年“清醒”的唐吉诃德，开始反思过去的一切
成长，就是在荒唐中慢慢看清自己与世界




它是一部讽刺小说， 但它的讽刺不是冷酷的鞭笞，而是带着温情与悲悯的幽默
它一边笑着告诉读者理想多荒唐， 一边又悄悄在心里埋下一个问题：

如果连“唐吉诃德”都不再存在了， 这个世界还有谁来为理想而战？


小说最后，唐吉诃德“醒了”他不再幻想自己是骑士，放下长枪，改回原名“阿隆索·吉哈诺”，在病榻上缓缓死去
他的遗言是：烧掉那些把他引入幻想的骑士小说
这是一个很残酷的结尾：

他不再相信自己的一切；
他承认自己的失败；
他的一生仿佛成了笑话。

但如果读者真的读懂他，将不会觉得这是耻辱
他可悲，却不可耻
他的“失败”背后，其实藏着我们最稀缺的东西：

他曾真诚地为理想而活

他不是为了钱、地位或自我标榜。他只是相信“这个世界应该更好”，然后全身心地去实现它。

他的失败，照出了世界的虚伪

不是他疯了，是这个世界不再相信任何理想，才让坚持信念的人变得“可笑”。

他的尊严，在于不屈

他打不过风车，伤痕累累，但从没怀疑过自己的选择。这种不被现实改变的信仰，本身就是一种尊严。
有一种解释认为，塞万提斯通过唐吉诃德表达了一个悖论：

理想主义或许注定失败， 但放弃理想，就等于放弃了人类最光辉的部分。


是的，他败了。但他不是失败者。他是那个即使全世界都笑他，依然选择冲锋的人。
我们在他身上看到：

有些梦想，值得失败一次；
有些坚持，即使被误解，也值得守护到底；
有些“荒唐的人”，是对这个世界最深的提醒。


正因为他最后清醒了，我们才更理解他曾经的疯狂有多宝贵。

]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理0轮预习</title>
    <url>/2025/01/02/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%860%E8%BD%AE%E9%A2%84%E4%B9%A0/</url>
    <content><![CDATA[我滴进度已经完蛋了

光学衍射通用公式$\delta=a\frac{x}f$  $光程差=缝宽*\tan\theta$
暗纹 $\delta=\pm k\lambda$，明纹 $\delta=\pm (k+0.5)\lambda$
中央明纹宽度$l=2f\frac\lambda a$
光栅$\delta=(a+b)|\sin\theta-\sin\varphi|=k\lambda$
缺级 $k=\frac{a+b}{a}k’$
光栅常数 $a+b$
距离中心距离 $x=f\cdot\tan\theta,(a+b)|\sin\theta-\sin\varphi|=k\lambda$
双缝干涉$\delta=d\frac{x}D$  $光程差=缝距*\tan\theta$
云母覆盖$\delta_{覆盖后}-\delta_{覆盖前}=(1-n)l$
单缝干涉反射 单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}$
反射 不单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}+\frac\lambda 2$
折射 单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}+\frac\lambda 2$
折射 不单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}$
偏振振动波动学振动弹簧拉开$\omega=\frac{k}m$  $kx=m\omega^2r,x=r$
$A=\sqrt{x_0^2+\frac{v_0^2}{\omega^2}}$  $A^2=x_0^2+x^2,x=\frac{v_0}{\omega}$
能量计算能量 $E=\frac12kA^2$
平均动能 $\overline{E_k}=\frac14kA^2$
振动合成$A=\sqrt{A_1^2+A_2^2+2A_1A_2cos(\varphi_2-\varphi_1)}$
$\varphi=\arctan\frac{A_1\sin\varphi_1+A_2\sin\varphi_2}{A_1\cos\varphi_1+A_2\cos\varphi_2}$
求拍频$\omega=|\frac{\omega_1}{2\pi}-\frac{\omega_2}{2\pi}|$
单摆$\omega=\sqrt{\frac{g}{l}},T=\frac{2\pi}{\omega},f=\frac{\omega}{2\pi}$
波动气体热力学气体压强体积温度能量热力学第一定理气体的速率循环效率熵]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式初步学习</title>
    <url>/2024/10/06/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[数年之前就听闻莫反，FFT，NTT等数论变换的名称，但是一直未学习相关知识
最近学习后量子密码学，遇到了类似数论变换，辄学习一下

名词区分1、DFT(Discrete Fourier Transform)：离散傅立叶变换 $\rightarrow$ $O(n^2)$计算多项式乘法2、FFT(Fast Fourier Teansformation)：快速傅立叶变换 $\rightarrow$ $O(nlogn)$计算多项式乘法3、(F)NTT(Number Theoretic Transform)：（快速）数论变换 $\rightarrow$ 优化常数和误差，适用于整数域4、MTT(any Module NTT)：NTT的扩展 $\rightarrow$ 任意模数
离散傅里叶变换DFT这是一个朴素算法，用于将一个多项式在$O(n^2)$时间由系数表示法转化为点值表示法
原理：将一个用系数表示的多项式转化成它的点值表示的算法
对于一个$n-1$次的$n$项多项式$f(x)$可以表示为$f(x)=\sum_{i=0}^{n-1}a_ix^i$
系数表示法：$f(x)={a_0,a_1,…,a_{n-1}}$
点值表示法：$f(x)={(x_0,f(x_0)),(x_1,f(x_1)),…,(x_{n-1},f(x_{n-1}))}$

求值：系数\rightarrow点值\\
差值：点值\rightarrow系数计算两个多项式相乘 $h(x)=f(x)*g(x)$
对于系数表示法，需要每一项和每一项的系数相乘，时间复杂度显然是$O(n^2)$
对于点值表示法——
$h(x)={(x_0,f(x_0)\cdot g(x_0)),(x_1,f(x_1)\cdot g(x_1)),…,(x_{n-1},f(x_{n-1})\cdot g(x_{n-1}))}$，时间复杂度是$O(n)$
已知 $n$ 个点值，可以唯一确定一个 $n-1$ 阶多项式
证明已知

P(x_0)=p_0+p_1x_0+p_2x_0^2+\cdots+p_{n-1}x_0^{n-1}\\
P(x_1)=p_0+p_1x_1+p_2x_1^2+\cdots+p_{n-1}x_1^{n-1}\\
\vdots\\
P(x_{n-1})=p_0+p_1x_{n-1}+p_2x_{n-1}^2+\cdots+p_{n-1}x_{n-1}^{n-1}\\可以写成矩阵形式

\begin{bmatrix}
P(x_0)  \\
P(x_1)  \\
\vdots  \\
P(x_{n-1}) \\
\end{bmatrix}
=
\begin{bmatrix}
1 & x_0 & x_0^2 & \cdots & x_0^{n-1}  \\
1 & x_1 & x_1^2 & \cdots & x_1^{n-1}  \\
\vdots & \vdots & \vdots & \ddots & \vdots  \\
1 & x_{n-1} & x_{n-1}^2 & \cdots\ & x_{n-1}^{n-1}  \\
\end{bmatrix}
*
\begin{bmatrix}
p_0  \\
p_1  \\
\vdots  \\
p_{n-1} \\
\end{bmatrix}中间的那列就是一个范德蒙行列式了，秩为1，所以$p_0,…,p_{n-1}$有且仅有一个解，即多项式的系数确定
证毕。
利用单位圆进行转化将$n$向上填充为2的整数次幂，然后将单位圆平均取$n$个点

在单位元上，我们定义$x_k=w_n^k=(cos\frac{k}{n}2\pi,sin\frac{k}{n}2\pi)$
对于点$x_k$​，$x_k=x_{k-i}*x_i(i\in[0,k])$​成立
此时，$x_1$即为该单位圆上的单位根（即该循环群中的单位元）
单位根的性质很有用的性质一（相消引理）：$w_{2n}^{2k}=w_n^k$ 这两个说的本质上是一个点
性质二（折半引理）：$w_n^{k+\frac{n}{2}}=-w_n^k$ 关于原点对称（向量等大反向）
显而易见的
$w_n^k=cos(2\pi\cdot\frac{k}{n})+isin(2\pi\cdot\frac{k}{n})$
$w_n^0=w_n^n=1$
$w_n^{n-i}=w_n^i$
$w_n^{n+i}=w_n^i$

实现方式把多项式$A(x)$的离散傅里叶变换结果作为另一个多项式$B(x)$的系数，去单位根的倒数即$w_n^0,w_n^{-1},…,w_n^{-(n-1)}$作为$x$代入$B(x)$，得到的每个数再除以$n$，得到的是$A(x)$的各项系数
实现了傅里叶变换的逆变换——把点值表示转换成多项式系数表示
证明设$(y_0,y_1,y_2,…,y_{n−1})$为多项式$A(x)=a_0+a_1x+a_2x^2+…+a_{n−1}x^{n−1}$的离散傅里叶变换。
现在我们再设一个多项式$B(x)=y_0+y_1x+y_2x^2+…+y_{n−1}x^{n−1}$，现在我们把上面的$n$个单位根的倒数，即$ω^0_n,ω^{−1}_n,ω^{−2}_n,…,ω^{−(n−1)}_n$作为$x$代入$B(x)$, 得到一个新的离散傅里叶变换$(z_0,z_1,z_2,…,z_{n−1})$。

\begin{align}
z_k&=\sum_{i=0}^{n-1}y_i(w_n^{-k})^i\\
&=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(w_n^i)^j)(w_n^{-k})^i\\
&=\sum_{j=0}^{n-1}a_j(\sum_{i=0}^{n-1}(w_n^{j-k})^i)
\end{align}这个$\sum_{i=0}^{n-1}(w_n^{j-k})^i$是可求的：当 $j-k=0$ 时，原式=$n$；否则，通过等比数列求和可以得知

\begin{align}
\sum_{i=0}^{n-1}(w_n^{j-k})^i&=\frac{(w_n^{i-k})^n-1}{w_n^{i-k}-1}\\
&=\frac{(w_n^n)^{i-k}-1}{w_n^{i-k}-1}\\
&=\frac{1^{i-k}-1}{w_n^{i-k}-1}\\
&=0
\end{align}故 $z_k=n\cdot a_k$
即 $a_i=\frac{z_i}{n}$
证毕
具体代码不做赘述，因为DFT和朴素算法的时间复杂度相同，在这里仅用于为FFT打基础
快速傅里叶变化FFT用途：1.高精度乘法$O(n^2)\rightarrow O(nlogn)$ 2.分离正弦波
原理FFT和DFT的不同之处在于，傅里叶的时代并没有计算机，所以没有优化时间复杂度的需求；因而虽然DFT的计算是基于单位圆的，但是（求值和差值的）时间复杂度仍旧是$O(n^2)$；而FFT则采用了分治的思想，将求值和差值的时间复杂度降为$O(nlogn)$

推导设 $A(x)=a_0+a_1x+a_2x^2+…+a_{n-1}x^{n-1}$，
按照下标奇偶性划分为两部分 
$A(x)=(a_0+a_2x^2+…+a_{n-2}x^{n-2})+(a_1x+a_3x^3+…+a_{n-1}x^{n-1})$
设 $A_1(x)=a_0+a_2x+…+a_{n-2}x^{\frac{n}{2}-1}\ A_2(x)=a_1x+a_3x+…+a_{n-1}x^{\frac{n}{2}-1}$（注意这里的次方数）
则 $A(x)=A_1(x^2)+xA_2(x^2)$
已知$x=w_n^k$，不妨设 $k&lt;\frac{n}{2}$，代入得到

\begin{align}
A(w_n^k)&= A_1(w_n^{2k})+w_n^kA_2(w_n^{2k}) \\
&= A_1(w_\frac{n}{2}^{k})+w_n^kA_2(w_\frac{n}{2}^{k})\\
\end{align}对于$A(w_n^{k+\frac{n}{2}})$，有：

\begin{align}
A(w_n^{k+\frac{n}{2}})&=A_1(w_n^{2k+n})+w_n^{k+\frac{n}{2}}A_2(w_n^{2k+n})\\
&=A_1(w_\frac{n}{2}^{k}\cdot w_n^n)+w_n^{k+\frac{n}{2}}A_2(w_\frac{n}{2}^{k}\cdot w_n^n)\\
&=A_1(w_\frac{n}{2}^{k})-w_n^kA_2(w_\frac{n}{2}^{k})
\end{align}故只需要知道 $A_1(x)$ 和 $A_2(x)$ 分别在 $(w_\frac{n}{2}^0,w_\frac{n}{2}^1,…,w_\frac{n}{2}^{\frac{n}{2}-1})$ 的点值表示，就可以 $O(n)$ 计算 $A(x)$ 在 $(w_n^0,w_n^1,…,w_n^{n-1})$ 的点值表示
依此，就可以递归实现
代码实现#这里的代码是ai给的，感觉不太靠谱的亚子import numpy as npdef fft(a):    n = len(a)    if n &lt;= 1:        return a    even = fft(a[0::2])    odd = fft(a[1::2])    t = [np.exp(-2j * np.pi * k / n) * odd[k] for k in range(n // 2)]    return [even[k] + t[k] for k in range(n // 2)] + [even[k] - t[k] for k in range(n // 2)]def ifft(a):    n = len(a)    a_conj = [np.conjugate(x) for x in a]    y = fft(a_conj)    return [np.conjugate(x) / n for x in y]def polynomial_multiply(p, q):    n = len(p) + len(q) - 1    m = 1 &lt;&lt; (n - 1).bit_length()  # Next power of two    p += [0] * (m - len(p))    q += [0] * (m - len(q))        fft_p = fft(p)    fft_q = fft(q)    fft_result = [fft_p[i] * fft_q[i] for i in range(m)]    result = ifft(fft_result)        return [round(x.real) for x in result]# 示例p = [1, 2, 3]  # 1 + 2x + 3x^2q = [4, 5]     # 4 + 5xresult = polynomial_multiply(p, q)print(result)  # 输出: [4, 13, 22, 15]
后续还有优化版FFT，插个眼，以后更新（快速）数论变换 (F)NTT好的，假设我学会了fft，可以开始学ntt了（大雾




不同点
FFT
NTT




定义域
主要在复数域中进行，利用复数的旋转性质
使用复数的单位根，通常是复数的n次方根


根的选择
在有限域（通常是素数模数）中进行，适合用于整数运算
使用模p的原根，这些根在有限域中是整数


应用领域
信号处理、图像处理、数字滤波等
密码学、计算机代数和一些整数计算问题，如大数乘法等


计算方式
浮点数运算
完全整数




对于质数$p=qn+1,(n=2^m)$，原根$g$满足$g^{qn}\equiv 1(\mod p)$
将$g_n\equiv g^q(\mod p)$看做$w_n$的等价，其满足相应的性质，如$g_n^n\equiv 1(\mod p),g_n^\frac{n}{2}\equiv -1(\mod p)$等
快速数论变化（FNTT），是数论变换（NTT）增加分治操作之后的快速算法，与快速傅里叶变换使用的分治办法完全一致
FFT中用到复数，需要使用$double$类型来计算，导致精度降低，所以需要使用原根来替代单位根

g^\frac{p-1}{n}\equiv w_n\mod p就像998244353,469762049,1004535809，它们的原根都是3
任意模数NTT MTT如果模数不是以上几种，我们需要自己取模数
取一些模数$p_1,p_2,…,p_k$使得答案多项式的系数在取模之前不会超过 $\prod_{i=1}^{k}p_i$
一般而言取三个质数即可(998244353,469762049,1004535809)
先计算答案对每个 $p_i$ 取模的结果，利用中国剩余定理就可以求得答案对 $\prod_{i=1}^{k}p_i$ 取模的结果，这个结果就是答案，最后将这个答案对题目中的模数取一次模即可
例题：洛谷 P4245
一道MTT模板题

#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define int long longint mod;// 这种写法我也第一次见，边写边学吧// 直接不开在全局std里了，单独一个Mathnamespace Math&#123;    inline int qpow( int base , int p , const int mod )&#123;        static int res;        for( res = 1 ; p ; p &gt;&gt;= 1 , base = base * base % mod )            if( p &amp; 1 )                 res = res * base % mod;        return res;    &#125;    inline int inv( int x , const int mod )&#123;        return qpow( x , mod-2 , mod );//费马小定理求逆元    &#125;&#125;const int mod1 = 998244353, mod2 = 1004535809, mod3 = 469762049, G = 3;const int mod_1_2 = mod1 * mod2;const int inv_1 = Math::inv(mod1, mod2), inv_2 = Math::inv(mod_1_2 % mod3, mod3);struct Int&#123;    int A , B , C;    // 空的默认构造函数    Int()&#123;&#125;    // 这个构造函数允许使用一个整数来初始化 A, B, C，它们都将被初始化为同一个值 __num    Int( int __num ): A(__num) , B(__num) , C(__num) &#123;&#125;    // 允许通过三个整数分别初始化 A, B, C    Int( int __A , int __B , int __C ): A(__A) , B(__B) , C(__C) &#123;&#125;    // 好神奇的操作，研究半天也没明白原理    // 只知道它可以做减法，出现负数就加上一个模数，只需要传入一个指针    static Int reduce( const Int &amp; x )&#123;        return Int( x.A + (x.A &gt;&gt; 31 &amp; mod1) , x.B + (x.B &gt;&gt; 31 &amp; mod2) , x.C + (x.C &gt;&gt; 31 &amp; mod3) );    &#125;    // 加减乘除的重载运算符，很精妙的写法    // 不太懂lhs和rhs是什么，只知道大概是两个input量，不像是数据结构里树的左孩子和右孩子    friend Int operator + ( const Int &amp;lhs , const Int &amp; rhs )&#123;        return reduce(Int(lhs.A + rhs.A - mod1, lhs.B + rhs.B - mod2, lhs.C + rhs.C - mod3));    &#125;    friend Int operator - ( const Int &amp;lhs , const Int &amp; rhs )&#123;        return reduce(Int(lhs.A - rhs.A, lhs.B - rhs.B, lhs.C - rhs.C));    &#125;    friend Int operator * ( const Int &amp;lhs , const Int &amp; rhs )&#123;        return Int( lhs.A * rhs.A % mod1 , lhs.B * rhs.B % mod2 , lhs.C * rhs.C % mod3 );    &#125;    int get()&#123;        int x = (B - A + mod2) % mod2 * inv_1 % mod2 * mod1 + A;        return ((C - x % mod3 + mod3) % mod3 * inv_2 % mod3 * (mod_1_2 % mod) % mod + x) % mod;    &#125;&#125;;#define maxn 200010 //maxn表示处理的最大元素数量namespace Poly&#123;    #define N (maxn &lt;&lt; 1) //N 定义为 maxn 的两倍，表示用于 NTT 的数组大小。    /*        lim：表示当前处理的长度，是最小的2的幂大于等于输入大小的值        s：记录 lim 的二进制位数        rev：用于存储每个索引的反转（bit-reversal）值        Wn：预计算的旋转因子（根单位元），用于 NTT 计算    */    int lim , s , rev[N];    Int Wn[N|1];    /*        初始化 NTT 相关参数        计算 lim 为不小于 n 的最小的2的幂        生成反转索引 rev，用于在 NTT 中重排数据        计算旋转因子 t，用于每个模数（mod1, mod2, mod3），通过幂函数 Math::pw 计算        初始化 Wn 数组，预计算旋转因子    */    void init( int n )&#123;        s = -1 , lim = 1;        while( lim &lt; n ) lim &lt;&lt;= 1 , s ++;//填充        for(int i = 1;i &lt; lim;i ++) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; s;        const Int t(Math::qpow(G, (mod1 - 1) / lim, mod1), Math::qpow(G, (mod2 - 1) / lim, mod2), Math::qpow(G, (mod3 - 1) / lim, mod3));        *Wn = Int(1);         for (Int *i = Wn; i != Wn + lim; ++i) *(i + 1) = *i * t;    &#125;    /*        执行 NTT 转换；首先进行反转操作，将数组 A 中的元素按 rev 数组重排        进行蝶形操作（butterfly operation），对数组进行逐层计算，利用预计算的旋转因子 Wn    */    inline void NTT(Int *A, const int op = 1) &#123;		for (int i = 1; i &lt; lim; ++i) if (i &lt; rev[i]) std::swap(A[i], A[rev[i]]);		for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123;			const int t = lim / mid &gt;&gt; 1;			for (int i = 0; i &lt; lim; i += mid &lt;&lt; 1) &#123;				for (int j = 0; j &lt; mid; ++j) &#123;					const Int W = op ? Wn[t * j] : Wn[lim - t * j];					const Int X = A[i + j], Y = A[i + j + mid] * W;					A[i + j] = X + Y, A[i + j + mid] = X - Y;				&#125;			&#125;		&#125;        // 如果 op 为 0，表示是反向变换，则需要进行归一化，将结果除以 lim		if (!op) &#123;			const Int ilim(Math::inv(lim, mod1), Math::inv(lim, mod2), Math::inv(lim, mod3));			for (Int *i = A; i != A + lim; ++i) *i = (*i) * ilim;		&#125;	&#125;#undef N&#125;int n , m , x;Int A[maxn &lt;&lt; 1], B[maxn &lt;&lt; 1], C[maxn &lt;&lt; 1];signed main() &#123;    scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;mod); ++n, ++m;//因为要考虑常数项，所以+1    for(int i = 0;i &lt; n;i ++) scanf(&quot;%lld&quot;, &amp;x), A[i] = Int(x % mod);    for(int i = 0;i &lt; m;i ++) scanf(&quot;%lld&quot;, &amp;x), B[i] = Int(x % mod);    Poly::init(n + m);    Poly::NTT(A), Poly::NTT(B);//系数转化为点值    for(int i = 0;i &lt; Poly::lim;i ++) C[i] = A[i] * B[i];//点值逐项相乘    Poly::NTT(C,0);//反向转化（即op=0），点值转回系数    for(int i = 0;i &lt; n+m-1;i ++) printf(&quot;%lld &quot;,C[i].get());    printf(&quot;\n&quot;);return 0;&#125;

参考文档：
FFT的学习主要看的这篇https://www.cnblogs.com/RabbitHu/p/FFT.html
写的很*，但是参考文献很好https://blog.csdn.net/Ciellee/article/details/108336914
这篇是后续补充用的(fft)https://www.cnblogs.com/pam-sh/p/15976275.html
同上，不过这里是ntt了https://www.cnblogs.com/windymoon/p/17124857.html
https://www.cnblogs.com/xxeray/p/fast-fourier-transform.html
]]></content>
      <categories>
        <category>技术学习笔记</category>
      </categories>
      <tags>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>基于SM9的属性基在线离线签名方案 论文阅读总结</title>
    <url>/2024/09/24/%E5%9F%BA%E4%BA%8ESM9%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%88-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[本文用于记录 本篇论文 的阅读和知识总结与学习

前置内容关键词SM9;在线/离线签名;属性基签名;随机谕言机模型;q-SDH 问题
SM9算法基于双线性对，可以实现属性基加密签名
相对而言，SM2基于椭圆曲线，无属性基相关属性
在线/离线签名在线签名在服务器（可信的）等设备上进行，离线签名在轻量级设备上；离线签名在在线签名的基础上进行签名，可以减少轻量级设备的运算开销
随机谕言机模型可以视为一个安全的哈希函数
q-SDH 问题多个参与者的DH密钥交换，而且更强，而且抗量子
预备知识双线性映射给定安全系数 $\kappa$，生成一个双线性元组 $BP=(G_1,G_2,G_T,e,p)$ 
令 $P$ 是 $G_1$ 的一个生成元，令 $Q$ 是 $G_2$ 的一个生成元，一个双线性映射 $e:G_1\times G_2\rightarrow G_T$ 有：双线性 非退化性 可计算性 三个性质
此外，在 $G_1$ 和 $G_2$ 之间存在一个能有效且能公开计算的同构映射 $\psi:G_2\rightarrow G_1$ ，即 $\psi(Q)=P$
q-SDH(q-strong Diffie-Hellman) 困难问题和困难问题假设q-SDH困难问题，令 $P,Q$ 分别为 $G_1,G_2$ 的生成元，在 $(G_1,G_2)$ 群上的 q-SDH 问题可以表述为：给定 $q+2$ 个元素的元组 $(P,Q,aQ,a^2Q,…,a^qQ)$ ，找到一堆元素 $(c,\frac{1}{c+a}P)$ ，其中 $c\in \mathbb{Z}_p^*$
$(t,\varepsilon)-$q-SDH 困难问题假设：若不存在概率多项式时间 $t$ 的算法至少以不可忽略的概率 $\varepsilon$ 解决 $(G_1,G_2)$ 上的 q-SDH 问题，则称 q-SDH 问题在 $(G_1,G_2)$ 是 $(t,\varepsilon)$ 困难的
q-strong 指的是 $q$ 个用户，而不是量子quantum的意思
分叉引理看不懂一点，暂时跳过
形式化定义和安全模型
ABOOS方案的形式化定义安全模型方案构造附录$\kappa$安全系数 $\kappa$，LaTex写作 kappa，通常用来量化密码系统抵抗攻击的强度
它表示安全性级别，通常与密钥长度、加密算法的复杂性等因素相关。较大的 $\kappa$ 值意味着更强的安全性，抵御暴力破解和其他攻击的能力更强。
一个经典的例子是基于双线性映射的身份基加密（IBE）。在IBE中，用户的公钥可以是其身份信息（如电子邮件地址），而私钥由一个私钥生成中心生成。假设安全系数 $\kappa$ 为 128 位，这意味着攻击者需要消耗大约 $2^{128}$ 次操作才能成功破解密钥。通过双线性映射，公钥和私钥的生成、加密和解密操作可以高效完成，同时保持与 $\kappa$ 相关的安全性。
生成元一个元素 $g$ 称为群 $G$ 的生成元，如果对于群 $G$ 中的任意元素 $x$，存在一个整数 $k$ 使得 $x = g^k$。换句话说，生成元是通过其幂（或反复运算）可以生成群中所有元素的元素。
双线性 非退化性 可计算性
双线性 $e(aP,bQ)=e(P,Q)^{ab}$

具体的，如果 $a=2,b=3$，那么 $e(2P, 3Q) = e(P, Q)^{2 \times 3} = e(P, Q)^6$。

非退化性 任意 $P\in G_1,Q\in G_2$，有 \neq 1$

只要 $P$ 和 $Q$ 同时是有效的点，则 $e(P,Q)$ 必然不等于 $1$

可计算性 任意 $P\in G_1,Q\in G_2$，有 $e(P,Q)$ 可以被有效计算

映射 $e(P, Q)$ 应能在多项式时间内计算。如果你有 $P$ 和 $Q$ 的坐标，可以通过预先定义的双线性映射算法快速计算出 $e(P, Q)$。
同构映射对于两个群，一个映射 $\psi:G_2\rightarrow G_1$，需要满足：

一一对应 $a,b\in G_2$，如果 $\psi(a)=\psi(b)$，则 $a=b$
运算保持 $a,b\in G_2$，都有 $\psi(a\cdot b)=\psi(a)\cdot\psi(b)$

同构映射是可逆的
分叉引理若攻击者能够成功生成有效的签名，即使在有限的查询次数后，我们可以利用这一点来构造另一个有效签名，这通常通过一种“分叉”的方式实现。

输入与图灵机：

令 $A$ 为一个输入仅包含公共信息的概率多项式时间的图灵机。这意味着 $A$ 是一个能在多项式时间内运行的算法，且其输入不包含秘密信息（例如签名密钥）。


签名查询与随机谕言机：

$A$ 进行 $n$ 次签名查询和 $m$ 次随机谕言机查询。签名查询是指 $A$ 请求生成某个消息的签名，而随机谕言机查询则是指 $A$ 请求随机数或其它公用信息。


生成有效签名元组：

敌手 $A$ 可以在概率多项式时间内，以 $\epsilon$ 的概率产生一个有效的消息签名元组 $(m, \sigma)$，其中 $m$ 是消息，$\sigma$ 是该消息的签名，且 $H(m)$ 表示与消息 $m$ 相关的哈希值。


不可区分的分布：

如果这个签名元组可以在不知道签名密钥的情况下以不可区分的分布概率进行模拟，意味着攻击者 $A$ 的行为与一个理想模型中没有秘密信息的情况没有显著差异。


构造另一台图灵机：

根据分叉引理，如果存在这样一个模拟，那么就存在另一台概率多项式时间的图灵机 $B$，它可以在理想情况下，通过控制攻击者 $A$ 的模拟与签名者的交互，生成两个有效的消息签名元组 $(m_1, \sigma_1)$ 和 $(m_2, \sigma_2)$，使得这两个签名都是有效的，并且 $H(m_1) = H(m_2)$。



通过分叉引理，证明了即使攻击者 $A$ 能够生成有效的签名，我们仍然可以利用这一过程来找到两个不同的消息的签名，使得它们具有相同的哈希值，从而说明签名方案的安全性是值得怀疑的。这通常意味着该方案不满足抗重放攻击或抗伪造攻击的要求。
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>学习主定理</title>
    <url>/2024/10/28/%E5%AD%A6%E4%B9%A0%E4%B8%BB%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[之前很早就听机房的学长说主定理了，是用于算法竞赛中分析时间复杂度的，但是一直没有学习过
今天做DS，又遇到了，题目如下

一道考研题目
解析：时间复杂度为 $O(nlogn)$
设 $n=2^k(k\geq0)$，有 $T(2^k)=2T(2^{k-1})+2^k=2^2T(2^{k-2})+2*2^k$
由此得到递推公式 $T(2^k)=2^iT(2^{k-i})+i*2^k$
故 $T(2^k)=2^kT(2^0)+k*2^k=(k+1)2^k$
带回 $n$ 得到 $T(n)=(logn+1)2^{logn}$ 即时间复杂度为 $O(nlogn)$
这也就是归并排序(MergeSort)的时间复杂度
更普适的假设有递推关系式 $T(n)=aT(\frac{n}{b})+f(n)$，其中$a\ge1,b&gt;1$
其中，$n$ 为问题规模，$a$ 为递归的子问题数量，$\frac{n}{b}$ 为每个子问题的规模（假设每个子问题的规模基本一样），$f(n)$ 为递归以外进行的计算工作
结论：

若存在$\varepsilon&gt;0$，$f(n)=O(n^{log_b(a)−\varepsilon})$（可不严谨的视作多项式地小于），那么$T(n)=\Theta(n^{log_ba})$
若存在$\varepsilon&gt;0$，$f(n)=\Theta(n^{log_ba}log^\varepsilon n)$，那么$T(n)=O(n^{log_ba}log^\varepsilon n)$
若存在$\varepsilon&gt;0$，$f(n)=Ω(n^{log_b(a)+\varepsilon})$（多项式地大于），同时存在常数 $c&lt;1$以及充分大的$n$，满足$af(\frac{n}{b})≤cf(n)$，则$T(n)=\Theta(f(n))$

符号说明：

更普适的:

算法证明
更本质的:
使用 $T(n)=2T(\frac{n}{2})+n$ 为例
                    f(n)                /            \        f(n/b)                f(n/b)        /        \                /        \f(n/b^2) f(n/b^2) f(n/b^2) f(n/b^2)    /    \        /    \        /    \        /    \    ......(很多次递归以后)    O(1)O(1)......O(1)O(1)O(1)O(1)
这里用$O(1)$准确的说是$\Theta(1)$
主定理到底在做什么？事实上主定理就是对比这两个部分的时间复杂度罢了
到底是上面那些f(n)操作加起来更耗时, 还是最下层所有叶节点的O(1)加起来更耗时?
即对于 $T(n)=pf(n)+kO(1)$，$p$ 我们认为它是常数，重点是 $k$，大致数值为 $n^{log_ba}$
代换一下，得到 $T(n)=pf(n)+n^{log_ba}$，显然这是在对比两项
对于三种情况：

下层所有叶节点的O(1)加起来更耗时
$k$（即 $n^{log_ba}$）的增长速度大于了 $f(n)$, 那么 $T(n)=O(nlogba)$
之所以引入 $\varepsilon$ 只是为了说明增长速度大
第一种情况下 $k$ 代表的最终处理问题的最小子任务明显占了主导

一样耗时
最小子任务和分割过程一样，没有谁明显的占据了主导低位，因此两个的时间复杂度都得算进去 $T(n)=O(n^{log_ba}⋅logn)$

上面那些f(n)操作加起来更耗时
分治过程占了主导地位，同时这种情况下限制了 $p$ 不会无法被认为是常数


常见形式

例题
NOIP2016TGT14


根据主定理，此时

a=2,b=4,f(n)=\sqrt n=n^\frac{1}{2}\\
log_ba=log_42=\frac{1}{2}符合格式 $f(n)=O(n^{log_ba}log^kn)$(2)，此时 $k=0$ 
所以 $T(n)=Θ(n^{log_ba}log^{k+1}n)=Θ(n^\frac{1}{2}log^1n)=Θ(\sqrt nlogn)$
选择C

$T(n)=9T(\frac{n}{3})+n$

根据主定理，此时

a=9,b=3,f(n)=n\\
log_ba=log_39=2符合格式 $f(n)=O(n^{log_b(a)-\varepsilon})$(1)，此时 $\varepsilon=1$
所以 $f(n)=O(n^{log_ba})=O(n^2)$

$T(n)=2T(\frac{n}{2})+2n$

根据主定理，此时

a=2,b=2,f(n)=2n\\
log_ba=log_22=1符合格式 $f(n)=O(n^{log_ba}log^kn)$(2)，此时 $k=0$ 
所以 $T(n)=Θ(n^{log_ba}log^{k+1}n)=Θ(n^1log^1n)=Θ(nlogn)$

$T(n)=2T(\frac{n}{4})+n^2$

根据主定理，此时

a=2,b=4,f(n)=n^2\\
log_ba=log_42=\frac{1}{2}符合格式 $f(n)=O(n^{log_b(a)+\varepsilon})$(3)，此时 $\varepsilon=\frac{3}{2}$ 
同时存在常数 $c&lt;1$以及充分大的$n$，满足$af(\frac{n}{b})≤cf(n)$
所以 $T(n)=Θ(f(n))=O(n^2)$
小结主定理讨论的是对于公式 $T(n)=pf(n)+kO(1)$ 里 p f(n) k 三个变量的增长速度。只不过主定理直接用条件限制了p，所以我们关注的重点就仅在 f(n) 和 k 上了
referencehttps://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86
https://blog.restkhz.com/post/how-master-theorem-works
https://blog.csdn.net/lanchunhui/article/details/52451362
https://www.luogu.com.cn/article/w3avh1ku
https://www.mashangxue123.com/tutorials/dsa/master-theorem/
https://www.cnblogs.com/coderzjz/p/14272460.html
]]></content>
      <categories>
        <category>技术学习笔记</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读paper</title>
    <url>/2024/09/11/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBpaper/</url>
    <content><![CDATA[2024.11.06二编
多读解决一切问题~

2024.9.6下午，我开始干啃《Chameleon Hashing and Signature》这篇文章；十分钟之后，感觉头顶冒烟了~
如果单单阅读 Abstract 和 Introduction 部分，虽然可以快速领会文章的大意，但是其内容对读者的提升同样巨大
故总结了几篇高推荐文章，作为今后论文阅读的指导

论文获取：

询问导师和同门
Google Scholar运用合适的关键词收集30篇左右论文（高引用量论文优先收集）
高引论文的参考文献

论文如何阅读：
一篇期刊论文，主要分成三个部分。

Abstract：

这篇论文的：主要贡献、方法特色与主要内容。
只看 Abstract 和 Introduction 判断篇论文的重点和你的研究有没有直接关联，从而决定要不要把它给读完

Introduction：

功能：介绍问题的背景和起源，交代前人在这个题目上已经有过的主要贡献，说清楚前人留下来的问题，以及在这个背景下这篇论文想解决的问题和它的意义。
对初学的学生而言，从这里可以了解以前研究的概况。先把跟你题目可能相关的论文收集个 30～40篇，每篇都只读Abstract 和 Introduction，而不要读 Main Body（本文），只在必要时稍微参考一下后面的 Illustrative examples和 Conclusions，直到你能回答下面这四个问题：

（2A）在这领域内最常被引述的方法有哪些？
（2B）这些方法可以分成哪些主要派别？
（2C）每个派别的主要特色（含优点和缺点）是什么？
（2D）这个领域内大家认为重要的关键问题有哪些？有哪些特性是大家重视的优点？有哪些特性是大家在意的缺点？这些优点与缺点通常在哪些应用场合时会比较被重视？在哪些应用场合时比较不会被重视？

问题是，你怎么去找到这最初的30～40篇论文？有一种期刊论文叫做review paper，专门在一个题目下面整理出所有相关的论文，并且做简单的回顾。你可以在搜寻 Compendex 时在 keywords 中加一个review而筛选出这类论文。然后从相关的数篇review paper 开始，从中根据 title 与 Abstract 找出你认为跟你研究题目较相关的30～40篇论文。
通常只要你反复读过该领域内30～40篇论文的Abstract 和 Introduction，你就应该可以从Introduction的评论中回答（2A）和（2B）这两个问题。尤其要记得，当你阅读的目的是要回答（2A）和（2B）这两个问题时，你一定要先挑那些 Introduction写得比较有观念的论文念（很多论文的Introduction 写得像流水帐，没有观念，这种论文刚开始时不要去读它）。假如你读过30～40篇论文的 Abstract 和 Introduction之后，还是回答不了（2C），先做下述的工作。
你先根据（2A）的答案，把这领域内最常被引述的论文找齐，再把他们根据（2B）的答案分成派别，每个派别按日期先后次序排好。然后，你每次只重新读一派的 Abstract 和 Introduction（必要时简略参考内文，但目的只是读懂Introduction内与这派有关的陈述，而不需要真的看懂所有内文），照日期先后读 ，读的时候只企图回答一个问题：这一派的创意与主要诉求是什么？这样，你逐派逐派地把每一派的Abstract 和 Introduction 给读完，总结出这一派主要的诉求 、方法特色和优点（每一篇论文都会说出自己的优点，仔细读就不会漏掉）。
其次，你再把这些论文拿出来，但是只读Introduction，认真回答下述问题：每篇论文对其它派别有什么批评？然后你把读到的重点逐一记录到各派别的“缺点”栏内。
通过以上程序，你就应该可以掌握到（2A）、（2B）和（2C）三个问题的答案。这时你对该领域内主要方法、文献之间的关系算是相当熟稔了，但是你还是只仔细读完Abstract 和 Introduction而已，内文则只是笼统读过。
这时候，你已经掌握到这领域主要的论文，你可以用这些论文测试看看你用来搜寻这领域论文的 keywords 到底恰不恰当，并且用修正过的 keywords 再搜寻一次论文，把这领域的主要文献补齐，也把原来30～40篇论文中后来发现关系较远的论文给筛选掉，只保留大概20篇左右确定跟你关系较近的文献。如果有把握，可以甚至删除一两个你不想用的派别（要有充分的理由），只保留两、三个派别（也要有充分的理由）继续做完以下工作。
然后你应该利用（2C）的答案，再进一步回答一个问题（2D）：

这个领域内大家认为重要的关键问题有哪些？
有哪些特性是大家重视的优点？
有哪些特性是大家在意的缺点？
这些优点与缺点通常在哪些应用场合时会比较被重视？
在哪些应用场合时比较不会被重视？

然后，你就可以整理出这个领域（研究题目）主要的应用场合，以及这些应用场合上该注意的事项。
最后，在你真正开始念论文的 main body 之前，你应该要先根据（2A）和（2C）的答案，把各派别内的论文整理在同一个档案夹里，并照时间先后次序排好。然后依照这些派别与你的研究方向的关系远近，一个派别一个派别地逐一把各派一次念完一派的 main bodies。

Main body（含simulation and/or experimental examples）：

在你第一次有系统地念某派别的论文 main bodies 时，你只需要念懂：

（3A）这篇论文的主要假设是什么（在什么条件下它是有效的），并且评估一下这些假设在现实条件下有多容易（或多难）成立。愈难成立的假设，愈不好用，参考价值也愈低。
（3B）在这些假设下，这篇论文主要有什么好处。
（3C）这些好处主要表现在哪些公式的哪些项目的简化上。至于整篇论文详细的推导过程，你不需要懂。除了三、五个关键的公式（最后在应用上要使用的公式，你可以从这里评估出这个方法使用上的方便程度或计算效率，以及在非理想情境下这些公式使用起来的可靠度或稳定性）之外，其它公式都不懂也没关系，公式之间的恒等式推导过程可以完全略过去。假如你要看公式，重点是看公式推导过程中引入的假设条件，而不是恒等式的转换。
（3D）这一派主要的缺点有哪些。

但是，在你开始根据前述问题念论文之前，你应该先把这派别所有的论文都拿出来，逐篇粗略地浏览过去（不要勉强自己每篇或每行都弄到懂，而是轻松地读，能懂就懂，不懂就不懂），从中挑出容易念懂的 papers，以及经常被引述的论文。然后把这些论文按照时间先后次序依序念下去。记得：你念的时候只要回答（3A）、（ 3B）、（3C）三个问题就好，不要念太细。
这样念完以后，你应该把这一派的主要发展过程，主要假设、主要理论依据、以及主要的成果做一个完整的整理。其次，你还要在根据（2D）的答案以及这一派的主要假设，进一步回答下一个问题：（3D）这一派主要的缺点有哪些。最后，根据（ 3A）、（3B）、（3C）、（3D）的答案综合整理出：这一派最适合什么时候使用，最不适合什么场合使用。　　
当你是生手的时候，你要评估一个方法的优缺点时，往往必须要参考它Examples。但是，要记得：老练的论文写作高手会故意只 present 成功的案例而遮掩失败的案例。所以，simulation examples and/or experiments 很棒不一定表示这方法真的很好。你必须要回到这个方法的基本假设上去，以及他在应用时所使用的主要公式（resultant equations）去，凭自己的思考能力， 并且参考（2C）和（2D）的答案，自己问问看：当某某假设在某些实用场合上无法成立时，这个方法会不会出什么状况？猜一猜，预测一下这个方法应该会在哪些条件下（应用场合）表现优异，又会在哪些条件下（应用场合）出状况？根据这个猜测再检验一次simulation examples and/or experiments，看它的长处与短处是不是确实在这些examples 中充分被检验，且充分表现出来。
那么，你什么时候才需要弄懂一篇论文所有的恒等式推导过程，或者把整篇论文细细读完？NEVER！你只需要把确定会用到的部分给完全搞懂就好，不确定会不会用到的部分，只需要了解它主要的点子就够了。

Reference:
一文教你如何快速高效阅读Paper（硕士生版）
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>学术晚宴学到的需要注意的一些点</title>
    <url>/2025/05/19/%E5%AD%A6%E6%9C%AF%E6%99%9A%E5%AE%B4%E5%AD%A6%E5%88%B0%E7%9A%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de7ac43174b2bb1ad06a11d61b739ea0078e3d8e8154af558c4f00c1f60c8beddbbc345755205c62db720a0ef1d8fa4bb7dfef30ae482e960c0519757f048c4f216b90e5a84f61cd1bc87de77a0f2f45aa0e58e67eb564f3bf3856573215f610d833ffb7e28dda5f0cf0b9f550604ba92ba5b498e2f1cd2ea91cdd288d1c90dcd3b0270df90ae75d27611c2ee09b0f3df5b2a4416627820085c20a7595cdce451012efe8ba3f9362534cdaa39a9829e7e5
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学论文分类</title>
    <url>/2024/09/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%AE%BA%E6%96%87%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[三大顶会与信息安全四大顶会
密码学三大顶会是指CRYPTO (美密) 、EUROCRYPT (欧密) 、ASIACRYPT (亚密) 。
Big4上的隐私计算文章一般离应用更近一些，而三大密有可能是纯理论的结果。
Crypto会议主要关注密码学理论和实践的最新发展，EUROCRYPT和ASIACRYPT则更加侧重于密码学的应用和实现。

J Cryptol 比密码学三大顶会更牛，35 年以来中国大陆作为第一单位和第一作者仅有 8 篇文章 [信息来源] 。
很离谱中科院竟把 Journal of Cryptology 分到 3 区（大概是直接按影响因子排序然后划分分区）
IACR Fellows 华人只有姚期智 (Andrew Yao, 2010 当选) 和王小云 (Xiaoyun Wang, 2019 当选)
信息安全四大顶会则是指CCS、NDSS、IEEE S&amp;P和USENIX Security。这些会议是信息安全领域最具影响力的学术会议之一，涵盖了网络安全、系统安全、应用安全等方面的研究。CCS和NDSS更加关注网络和系统安全，IEEE S&amp;P则更加关注安全协议和标准，而USENIX Security则更加关注应用安全和隐私保护。
在网络与信息安全领域，CCF（中国计算机学会）推荐了一些重要的会议和期刊。在2022年，CCF推荐的A类会议包括IEEE S&amp;P、USENIX Security、CCS和NDSS等，而推荐的A类期刊则包括IEEE TDSC、IEEE TIFS、ACM/IEEE TACoS等。这些会议和期刊都是网络与信息安全领域的重要学术交流平台，为学者们提供了分享研究成果、交流学术思想的机会。
综上所述，密码学三大顶会和信息安全四大顶会是密码学和信息安全领域最权威的学术会议之一。在网络与信息安全领域，CCF推荐的A类会议和期刊也是重要的学术交流平台。参加这些会议和期刊可以促进学术交流，推动密码学和信息安全领域的发展。同时，了解这些会议和期刊的投稿要求和流程，对于想要发表研究成果的学者来说也是非常重要的。
信息安全四大顶会
一、USENIX Security

介绍：USENIX 是一个计算机类会议的总称，而USENIX Security只是USENIX中的安全会议，并且USENIX Security会议涵盖的安全领域也非常多，包含：二进制安全、固件安全、取证分析、Web安全、隐私保护、恶意分析等。
论文下载：会议的论文直接在官网提供下载，有很多格式(PDF、EPUB、MOBI)。

二、S&amp;P：IEEE Symposium on Security and Privacy

介绍：S&amp;P又分为两类：SP Conference Information、SP Workshops Information。
论文下载：
这个会议的演讲论文在主页以及每个会议的首页(需要点击进入每个会议网页哈)都有下载。
若学校有购买IEEE论文数据库，可以通过IEEE的会议搜索进行会议搜索。



三、CCS：ACM Conference on Computer and Communications Security

介绍：始于1993年。
论文下载：会议的论文可以通过网站的链接看到历年的论文记录,当然这个论文库是在acm数据库，或者使用dblp数据库进行搜索，一般都可以搜到PDF。

四、NDSS： Network and Distributed System Security Symposium

介绍：网络和分布式系统安全研讨会（NDSS）促进了网络和分布式系统安全的研究人员和从业者之间的信息交流。 目标受众包括那些对网络和分布式系统安全的实际方面感兴趣的人，重点是实际的系统设计和实现。 主要目标是鼓励并使互联网社区能够应用，部署和推进可用安全技术的状态。
论文下载：万能的google参考链接：
http://blog.ourren.com/2015/01/20/top_security_conference/
https://www.jianshu.com/p/b97077272323







类别
简称
全称
周期
CCF类别




期刊
J Cryptol
Journal of Cryptology
月
安全-A


会议
CRYPTO
International Cryptology Conference
年
安全-A


会议
EUROCRYPT
European Cryptology Conference
年
安全-A


会议
ASIACRYPT
Annual International Conference on the Theory and Application of Cryptology and Information Security
年
安全-B


会议
TCC
Theory of Cryptography Conference
年
安全-B


会议
CHES
The Conference on Cryptographic Hardware and Embedded Systems
年
安全-B


会议
FSE
The Conference on Fast Software Encryption
年
安全-B


会议
PKC
International Conference on Practice and Theory in Public Key Cryptography
年
安全-B


会议
FC
Financial Cryptography and Data Security
年
安全-C


会议
CT-RSA
The Cryptographer’s Track at RSA Conference
年
安全-C




每天看的论文，应当分为精读和泛读
精读论文一般看A类会议（选择同方向的）
泛读论文一般看大致方向的（bigford，三大密，和其他安全相关的）
看论文一般看AB类会议，A刊（A刊也有水的，但是可以快速入门）
例如《Identity-Based Chameleon Hash  and Applications》这篇文章，就是变色龙哈希方向比较好的论文；自从区块链火了之后，变得很难投了
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学学习路径</title>
    <url>/2024/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[本篇文章用于记录学习密码学的路径
有些是已经走过的路，有些是还没走也即将要走的路


笔者大一录取至网络空间安全专业，加入了网络与信息安全社团，接触到了CTF的五大方向
高考结束之后的暑假，几个方向的题目都做了一点（除了pwn，环境太难配），然后去社团面试；听了学长们的建议，计划选一个方向，了解了几个方向都有什么特点，学长说密码学应该是五大方向里最深的一个，然后也是因为从小对数学比较感兴趣，就选择了密码学
上一任的密码学部部长是星盟安全的，然后他就建议每周写周记，记录一下自己每周学了什么，然后我整个学期基本每周都写——收获颇丰
这里是大一上学期的周记

这边是寒假记的，寒假只有一个月所以有四篇

这样子，在BUUOJ上刷了一百多道密码学题目，nss上也做了一些，主要是这两个平台，然后打过一些比赛
通过这半年的锻炼吧，感觉主要提升的是代码能力，感觉自己现在运用python的能力已经不亚于使用cpp了（当然python很多用法要现查现用，还是不太能用来打算法）；只不过打CTF的密码学还是并不是很强，很多攻击方式有待学习
然后下学期对于密码学的学习就比较断断续续了，下学期比较多的时间去弄嵌入式了
大概是24年五月份，正式配置并启用的github page，然后就有了这个博客，后来陆陆续续在上面记点东西（虽然很多烂尾了）
大概也是大一下，好像是快学期末了，意识到CTF的Crypto不是真正的密码学，然后开始科研方向，入门学习是看这本书（虽然我看的是中文版，寒假打算看下原著）

这本书介绍的是密码学的基础算法，应该是在清华大学杨波的那本书之上的（毕竟是英文教材）
之后是一本规约相关的书

这本书就相对困难一点了，也可以看中文版《安全规约导论》（好像说中文版里有的地方有点问题）
之后了解到一篇论文讲公钥密码的学习

这篇论文主要是介绍的学习路径，还有30篇推荐阅读的论文（计划这学期读完）
前面的推荐阅读里（不是30篇公钥密码里面的）出现了上述两本书，但是又不限于这两本书，其他书目待完成上述论文的阅读之后再决定什么时候看
大概看完了上述内容，就可以做点东西了~
但是我还没看完！（悲

之后的路线：计划先打好基础，然后搞搞变色龙哈希，之后再找个跳板，读研之前学习一定的后量子并在这个领域进行研究
]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>括号书写规范</title>
    <url>/2024/09/09/%E6%8B%AC%E5%8F%B7%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[今天记笔记，遇到一段话，中英夹杂不知道应当如何使用括号
- 新方案：提出基于变色龙哈希的支付协议——变色龙哈希时间锁定合约（Chameleon Hash Time-Lock Contract, CHTLC），解决支付路径泄露问题- 优势：使用多层变色龙哈希函数来确保没有用户可以修复支付路径（条件：至少有一个中间支付节点是诚实的）- 比较：对于相同的支付路径，与 Multi-hop Hash Time-Lock Contract(MHTLC)相比，CHTLC支付初始化速度快了五倍，通信所需带宽从17000KB降到7.7KB

询问gpt未果


两次询问，得到了不同的结果
后来，在国家教育部官网上找到了一种使用方法

非正式地说，主要内容是中文就用中文括号，主要内容是英文就用英文括号
更改后的文段如下
- 新方案：提出基于变色龙哈希的支付协议——变色龙哈希时间锁定合约（Chameleon Hash Time-Lock Contract, CHTLC），解决支付路径泄露问题- 优势：使用多层变色龙哈希函数来确保没有用户可以修复支付路径（条件：至少有一个中间支付节点是诚实的）- 比较：对于相同的支付路径，与 Multi-hop Hash Time-Lock Contract（MHTLC）相比，CHTLC支付初始化速度快了五倍，通信所需带宽从17000KB降到7.7KB
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>小感悟：真功不唐捐了</title>
    <url>/2025/09/16/%E5%B0%8F%E6%84%9F%E6%82%9F%EF%BC%9A%E7%9C%9F%E5%8A%9F%E4%B8%8D%E5%94%90%E6%8D%90%E4%BA%86/</url>
    <content><![CDATA[最近这几天在实验室干活，感觉真功不唐捐了
大一大二的时候涉猎很广泛哇，原本以为很多东西未来不会用到，没想到都有点关联
前两天写复现论文的代码，结果好家伙，套了五六层的调用，让我想到了之前在机协学嵌入式，看机器人五六层的指针结构体···；就很像哇
ctf就不用说了，现在研究的一直是密码学相关内容
然后昨天看IPs，动态规划还在坠鲨窝~

感悟就是，今日所用后或弃之，今日所弃后或用之~
]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>撬开后量子的大门</title>
    <url>/2024/09/21/%E6%92%AC%E5%BC%80%E5%90%8E%E9%87%8F%E5%AD%90%E7%9A%84%E5%A4%A7%E9%97%A8/</url>
    <content><![CDATA[笔者刚开始接触后量子，这里是学习笔记

量子力学基础量子叠加原理概念：一个量子系统可以同时处于多个可能状态的叠加状态，而不是像经典物理中那样只能处于一个确定的状态。这意味着，一个量子比特（qubit）可以同时表示0和1两种状态的叠加态，而不仅仅是0或1。这种量子叠加为量子计算提供了并行计算的能力，使得量子计算机能够在某些问题上比传统计算机更快地得出答案。
叠加原理可以用一个简单的例子来说明。假设我们有一个量子比特，它是一个自旋向上的电子和一个自旋向下的电子的叠加态。根据量子叠加原理，这个量子比特可以同时表示自旋向上和自旋向下的状态。当我们对这个量子比特进行测量时，它只会塌缩到一个确定的状态，即自旋向上或自旋向下，但测量前的状态是两者同时存在的。
数学表示：假设一个量子比特有两个状态，记为 $|0\rangle$ 和 $|1\rangle$。量子叠加态可以用一个线性组合来表示：
$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$
其中 $\alpha$ 和 $\beta$ 是复数，并且满足：
$|\alpha|^2 + |\beta|^2 = 1$
这是因为测量的概率必须等于1，$|\alpha|^2$ 和 $|\beta|^2$ 分别表示测量结果为 $|0\rangle$ 和 $|1\rangle$ 的概率。
量子纠缠原理概念量子纠缠是一种特殊的量子态，其中多个量子比特的状态是相互关联的，不能单独描述一个量子比特的状态。
纠缠态不能用独立的量子比特描述，纠缠的特性是量子信息传递中的重要资源，如量子通信和量子密钥分发（QKD）。
数学表示对于两个量子比特系统，一个典型的纠缠态是Bell态$^{(1)}$，如：
$|\psi\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$
这意味着两个量子比特的状态是共同决定的，如果测量第一个比特为0，那么第二个比特也必然是0，反之亦然。两者之间的状态是完全纠缠的。
量子测量概念量子测量是指对量子态进行观测，测量会导致量子态的坍缩（collapse），即量子系统从叠加态“坍缩”到一个确定的状态。
量子测量的不可预测性是量子力学的本质特性之一，测量后系统的叠加态消失，转变为经典状态。
数学表示如果一个量子比特处于叠加态 $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$，测量后系统会以概率 $|\alpha|^2$ 得到结果 $|0\rangle$，以概率 $|\beta|^2$ 得到结果 $|1\rangle$，测量会使系统坍缩到测量所得的状态。

量子态概念量子态是描述量子系统的完整信息，可以是单个粒子的状态，也可以是多个粒子的联合状态。
数学表示单个量子比特的量子态如 $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$。多个量子比特的量子态则是张量积，比如两个量子比特的状态可以表示为：
$|\psi\rangle = (\alpha_1|0\rangle + \beta_1|1\rangle) \otimes (\alpha_2|0\rangle + \beta_2|1\rangle)$
张量积是构建多比特系统的重要工具。
量子比特（qubit）概念量子比特是量子计算的基本单位，类似于经典计算中的比特。不同之处在于量子比特可以处于 $|0\rangle$、$|1\rangle$ 或两者的叠加状态。
量子比特可以通过叠加、纠缠、操作等多种方式处理信息，具有比经典比特更强大的信息表达和处理能力。
数学表示量子比特的状态 $|\psi\rangle$ 可以表示为：
$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$
其中 $\alpha$ 和 $\beta$ 是满足 $|\alpha|^2 + |\beta|^2 = 1$ 的复数。
量子门操作概念量子门是对量子态进行操作的基本单元，类似于经典计算中的逻辑门。量子门操作是可逆的，并且可以用矩阵来表示。
量子门可以实现各种量子态操作，是构建量子电路和量子算法的基础。
常见的量子门操作
Hadamard门（H门）：将一个量子比特从经典态转变为叠加态：
$H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 &amp; 1 \ 1 &amp; -1 \end{pmatrix}$
对状态 $|0\rangle$ 和 $|1\rangle$ 的作用为：
$H|0\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle), \quad H|1\rangle = \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$

Pauli门（X、Y、Z门）：

$X$ 门类似于经典的NOT门，交换 $|0\rangle$ 和 $|1\rangle$：
$X = \begin{pmatrix} 0 &amp; 1 \ 1 &amp; 0 \end{pmatrix}$

$Y$ 和 $Z$ 门分别进行不同的相位操作：
$Y = \begin{pmatrix} 0 &amp; -i \ i &amp; 0 \end{pmatrix}, \quad Z = \begin{pmatrix} 1 &amp; 0 \ 0 &amp; -1 \end{pmatrix}$



CNOT门（控制非门）：一个两比特门，作用是翻转目标比特的状态，但仅当控制比特为 $|1\rangle$ 时才翻转：
$CNOT = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 \ 0 &amp; 0 &amp; 1 &amp; 0 \end{pmatrix}$


量子计算原理shor算法Shor算法的高效性在于其量子部分能在多项式时间内找到周期，而这个周期信息又能用来找到大整数的因子。正因如此，Shor算法被视为量子计算对现有公钥密码体制（如RSA）的威胁。
目标：用于因式分解大整数，破解基于大数分解难题的公钥密码（如RSA）。
工作原理：

选择随机数：选择一个随机整数 $a$，使其小于待分解的整数 $N$（即 $1 &lt; a &lt; N$）。

计算最大公约数：计算 $\text{gcd}(a, N)$，如果结果大于1，则找到了一个因子。这一步可以使用欧几里得算法在经典计算机上完成。

量子周期性：如果 $\text{gcd}(a, N) = 1$，则继续执行以下步骤：

找到一个周期 $r$，使得 $a^r \equiv 1 \mod N$
这意味着 $a$ 的 $r$ 次幂模 $N$ 为1。


使用量子计算找周期：利用量子傅里叶变换（QFT）找到周期 $r$。具体步骤：

初始化量子位：准备一个包含 $2n$ 个量子位的系统，$n$ 是 $N$ 的位数。
超位置态：将量子位置于超位置态，表示所有可能的结果。
应用oracle：通过一个oracle函数来实现对 $a^x \mod N$ 的计算，从而编码周期信息。
量子傅里叶变换（QFT）：对量子位（一个周期函数）进行量子傅里叶变换，提取周期的信息，周期与整数因式相关联。


测量和计算：

测量量子态，得到的结果可以用于估计周期 $r$（即解决离散对数问题）
使用继续的经典算法，验证找到的 $r$ 是否符合 $a^r \equiv 1 \mod N$。


找到因子：

确定 $r$ 后，检查 $r$ 是否为偶数。

如果 $a^{r/2} \not\equiv -1 \mod N$，则：
$\text{factor1} = \text{gcd}(a^{r/2} - 1, N)$
$\text{factor2} = \text{gcd}(a^{r/2} + 1, N)$

如果这两个因子不等于1和$N$，则它们即为 $N$ 的非平凡因子。




Grover算法
目的：通过量子叠加和干涉，加速无结构（无序）数据库的搜索，常用于破解对称加密，可将搜索时间从 $O(N)$ 降低到 $O(\sqrt{N})$。

叠加态初始化：（将所有可能的候选解放入量子叠加态）

准备 $n$ 个量子位，表示 $N = 2^n$ 个可能的解的超位置态：
$\frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} |x\rangle$



Oracle：

定义一个oracle函数 $O_f$，用于标记正确解 $x_0$。对于任意输入 $x$，oracle的作用为：

O_f |x\rangle = \begin{cases}
-|x\rangle & \text{if } x = x_0 \\
|x\rangle & \text{otherwise}
\end{cases}
这意味着，如果输入是正确解，输出的相位会反转。



振幅增强：

使用Grover的扩展步骤，通过应用两个操作增强标记解的概率幅度：

应用oracle：对所有量子位应用oracle $O_f$。

振幅增强：执行反射操作 $R$，通过以下步骤：
$R = 2|\psi\rangle\langle\psi| - I$
其中 $|\psi\rangle$ 是当前的量子态，$I$ 是单位算符。



这个步骤使得标记解的幅度增加。（逐步放大正确解的概率幅度）




重复步骤：

重复执行oracle和振幅增强的过程 $O(\sqrt{N})$ 次。


测量：

最后，测量量子态，得到的结果会更倾向于正确解 $x_0$，以概率接近1。



量子计算与经典计算的区别经典计算使用经典比特，经典比特只能是0或1；量子计算使用量子比特（qubits），每个量子比特可以处于 $|0\rangle$ 和 $|1\rangle$ 的叠加态。

叠加（Superposition）：量子比特可以同时处于多个状态的叠加态，允许量子计算并行处理多个计算路径。而经典比特只能处于确定的状态 $0$ 或 $1$。

经典比特：单一状态，例如 $0$ 或 $1$。
量子比特：叠加态，例如 $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$。


量子纠缠（Entanglement）：多个量子比特之间可以处于纠缠态，导致它们的状态是相互关联的。即使这些比特相距很远，测量一个比特的状态会影响另一个比特的状态。在经典计算中，位之间没有这种关联性。

经典比特：独立的状态。
量子比特：关联的纠缠态。


量子干涉（Quantum Interference）：量子计算通过干涉效应增强正确解的概率幅度，抑制错误解的幅度。这是如Grover算法中用于加速搜索的关键原理。

经典算法：没有干涉现象。
量子算法：通过干涉增强正确解的概率。


测量与坍缩（Measurement &amp; Collapse）：量子计算在执行时，量子比特可以处于叠加态或纠缠态，但一旦测量就会坍缩到某个确定的状态。经典计算中的比特始终处于确定的状态。

经典比特：一直是确定值。
量子比特：测量时随机坍缩到一个状态，概率受叠加态系数控制。


并行计算能力：量子计算可以并行执行多个计算路径（通过叠加态），从而显著提升某些问题的求解效率。

经典计算模拟量子计算需要指数级的资源。


量子算法的效率：量子算法可以提供指数或平方加速。例如，Shor算法对于因数分解问题的加速是指数级的，Grover算法对于无结构搜索问题的加速是平方级的。

Shor算法：经典复杂度为指数级，量子复杂度为多项式级。
Grover算法：经典复杂度为 $O(N)$，量子复杂度为 $O(\sqrt{N})$。



数学基础略
密码学基础略
后量子密码学概念本篇文章只是简单了解，具体实现见下一篇博客
后量子密码学的核心算法设计基于格的密码（Lattice-based Cryptography）
原理：基于格理论中的困难问题，如最短向量问题（SVP）和最接近向量问题（CVP）。
特点：
即使在量子计算机上，求解这些问题仍然非常困难。
可以支持丰富的密码学功能，如全同态加密（Fully Homomorphic Encryption）和数字签名。


常见算法：
NTRU加密算法：一种基于格的公钥加密方案，抗量子攻击。
LWE（Learning With Errors）：基于格的加密和签名方案，广泛应用于后量子密码学。


优势：具有较强的抗量子攻击能力，并且可以高效实现。
挑战：密钥和签名较大，效率与经典算法相比仍需优化。

代码密码（Code-based Cryptography）
原理：基于纠错码的困难问题，如广义辛德尔（Goppa）码的解码问题。
特点：
主要基于解码随机线性码的难题，类似于求解高维空间中的矢量错误纠正问题。
经典的McEliece公钥加密方案就是一种基于代码的密码。


常见算法：
McEliece加密算法：基于纠错码，提出于1978年，至今未被破解。
Niederreiter加密算法：McEliece的变体，效率更高。


优势：公钥加密方案历史悠久，具有极高的安全性。
挑战：公钥非常大，使得在存储和传输上需要较多资源。

基于多变量多项式的密码（Multivariate Quadratic Cryptography）
原理：基于多变量二次方程（MQ）问题的求解困难性，这在量子计算机上仍然是困难的。
特点：
主要用于数字签名方案，解决方程组中的未知数是NP困难问题。


常见算法：
Unbalanced Oil and Vinegar（UOV）：一种多变量的数字签名算法。


优势：签名过程非常快。
挑战：公钥较大，且可能面临更高效的攻击手段。

哈希签名（Hash-based Cryptography）
原理：基于哈希函数的安全性。
特点：
主要用于构建数字签名方案，依赖于现有的哈希函数安全性。
由于哈希函数在量子计算下的安全性较好，因此可以通过扩展哈希长度来提高安全性。


常见算法：
Lamport签名：一种经典的哈希签名方案。
XMSS（eXtended Merkle Signature Scheme）：一种高效的哈希签名方案，已经标准化。


优势：可以使用现有的哈希函数构建，结构简单且易于实现。
挑战：签名方案的使用次数有限。

基于同源映射的密码（Isogeny-based Cryptography）
原理：基于椭圆曲线同源映射问题的困难性。
特点：
量子计算机在求解同源映射时没有明显优势，这使其成为一种抗量子攻击的潜在方案。


常见算法：
SIDH（Supersingular Isogeny Diffie-Hellman）：一种基于同源映射的密钥交换协议。


优势：密钥非常小，适用于需要高效传输的场景。
挑战：计算复杂性较高，仍然需要进一步研究其安全性。


设计抵抗量子攻击的安全协议量子攻击的威胁量子计算主要依赖两种算法对现有加密协议构成威胁：

Shor算法：能高效解决大数分解和离散对数问题，威胁到RSA、ECC等基于这些问题的非对称加密方案。
Grover算法：能够加速无结构搜索任务，影响对称加密和哈希函数，但其影响相对较小。

后量子安全协议设计在设计安全协议时，必须确保协议能够抵御量子计算攻击，这包括以下方面：

密钥交换协议：

经典方案的脆弱性：如DH密钥交换（基于离散对数问题）和RSA密钥交换（基于大数分解问题）都会被Shor算法破坏。
后量子方案：可以使用基于格的加密方案（如Kyber）或基于同源映射的协议（如SIDH）来代替。


数字签名协议：

经典方案的脆弱性：RSA和ECDSA签名会被量子计算机破坏。
后量子方案：哈希签名（如XMSS）或基于格的签名方案（如Dilithium）可用于构建安全的数字签名。


对称加密：

经典方案的安全性：对称加密算法（如AES）在量子攻击下的安全性会下降一半（通过Grover算法），例如AES-128的安全性会等效于AES-64。
应对方案：通过增加密钥长度（如使用AES-256）来抵御量子攻击。


混合方案：

过渡方案：由于当前的量子计算机还不成熟，可以采用“混合”加密方案，即将现有的经典加密算法与后量子加密算法结合使用。这使得在量子计算技术未完全成熟前，依然可以保证协议的安全性。



协议设计原则
安全性证明：设计基于难解数学问题的算法时，必须提供强有力的安全性证明。对于后量子密码学，安全性通常是基于现有的NP困难问题，且这些问题在量子计算机下仍然保持难解。
效率考虑：后量子加密算法的效率往往低于经典算法，设计时应兼顾安全性和性能。例如，格密码虽然安全性高，但在实际应用中需要优化以减少密钥和签名的大小。
灵活性与可扩展性：随着量子计算技术的进步，协议设计应具有灵活性，以便可以在未来采用新的、更安全的算法。

如何学习并模拟量子攻击
量子计算模拟器：使用量子计算模拟器（如Qiskit、Cirq或Microsoft Quantum Development Kit）来模拟Shor算法和Grover算法的执行。这可以帮助研究人员理解量子算法如何对特定的加密方案（如RSA或对称加密算法）构成威胁。

后量子密码学库：使用后量子密码学算法（如Lattice-based、Code-based、Multivariate等）进行对比，评估这些算法在量子攻击下的安全性。这可以通过对比量子算法与后量子算法在攻击成功率和计算复杂度上的差异。

量子硬件：在可用的情况下，可以在真实的量子计算机上运行实验，比如IBM Q Experience。通过量子硬件，可以直接测试某些攻击场景，验证量子算法的实际效果。

安全性分析工具：使用专门的安全性分析工具（如CryptoVerif、ProVerif等）来评估量子计算对现有加密协议的威胁。这些工具可以帮助研究人员分析加密协议在量子攻击下的脆弱性。

公开挑战：参与量子密码学领域的公开挑战，如NIST的后量子密码学标准化项目，了解不同算法的竞争和实际应用情况。



addition
(1) Bell态Bell态（Bell state）是两量子比特纠缠态的特定形式，是量子纠缠的经典示例。Bell态描述了一对量子比特的状态，这些量子比特之间存在极强的量子关联，无论它们相距多远，测量其中一个比特的状态都会影响另一个比特的状态。这种现象体现了量子纠缠的本质。
有四种Bell态，通常写为 $|\Phi^{\pm}\rangle$ 和 $|\Psi^{\pm}\rangle$，它们的定义如下：

$|\Phi^+\rangle$： $|\Phi^+\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)$
这表示两个比特要么同时是 $|0\rangle$，要么同时是 $|1\rangle$，两种状态以相等的概率叠加。

$|\Phi^-\rangle$： $|\Phi^-\rangle = \frac{1}{\sqrt{2}} (|00\rangle - |11\rangle)$
与 $|\Phi^+\rangle$ 类似，但两个状态之间存在相位差（负号）。

$|\Psi^+\rangle$： $|\Psi^+\rangle = \frac{1}{\sqrt{2}} (|01\rangle + |10\rangle)$
这表示一个比特是 $|0\rangle$ 而另一个比特是 $|1\rangle$，或者反之，且两者叠加。

$|\Psi^-\rangle$： $|\Psi^-\rangle = \frac{1}{\sqrt{2}} (|01\rangle - |10\rangle)$
与 $|\Psi^+\rangle$ 类似，但在两个状态之间有相位差（负号）。


物理意义
Bell态是一种最大纠缠态，这意味着两个量子比特的状态是完全相关的，不能用单独的量子态来描述每个比特。
如果我们测量其中一个量子比特并得到 $|0\rangle$，另一个量子比特立刻处于对应的状态（即 $|0\rangle$ 或 $|1\rangle$），即使它们相距很远。这种关联是量子纠缠的独特表现，爱因斯坦称之为“幽灵般的远距作用”。

应用
量子隐形传态（Quantum Teleportation）：通过纠缠态和经典通信将量子信息从一个地方传送到另一个地方。
量子密钥分发（QKD）：如BB84协议，使用Bell态的量子纠缠特性来保证通信的安全性。
量子纠错：纠缠态在量子纠错码中可以用来检测和修正量子系统中的错误。

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>PQC</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统2025期末考试重点</title>
    <url>/2025/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[本文记录了老师讲的操作系统期末考试重点




一、处理机

进程：特征 和线程区别 程序段数据段
PCB：是什么 有什么 进程索引

状态转化 转化图
同步互斥 同步-前后 互斥-同时
调度算法 优先算法 时间计算，信号量，作业调度 进程调度 内存调度
死锁算法 必要条件（4个） 处理办法（大题：银行家算法）


二、存储器

层次结构 寄存器 内存 硬盘
分配方式 连续分配（单一，固定，动态/可重分配）动态分区分配的四个算法  内部外部碎片（利用率）； 离散分配 
页式存储（访问两次，通过PCB） 给逻辑地址求物理地址 ， 计算逻辑地址分成几个页，倒排页表
段式存储（访问两次）根据逻辑模块存储，每个段大小不一致
区别：页表里存一个数（起始），段表存两个数（起始和终止）
段页式：访问三次
虚拟存储器：基于请求的（不要求进程的全部内容进入内容）1.请求调入 2.页面置换


置换算法
先进先出，最长最短时间 追加算法 时钟算法…
执行后发生几次置换，几次中断，缺页次数


地址转换

三、设备管理

层次结构
从上到下：共性 个性 交互方式
设备独立性，中断


控制方法
四种方式
通道程序


缓冲管理
单/双缓冲


设备分配
sdt dct coct 概念
独占改为共享



四、文件管理

物理结构
文件最大数
文件在磁盘上如何分配空间，正犹如进程在内存上分配空间（前面内容）
链接（隐式，显式）FAT32 刻画内存空间
进程：页表；文件：索引。链接，多层索引（计算文件最大多大）
混合索引（结构求最大，已知大小求索引等级）


逻辑结构
概念理解，不容易出计算题
顺序文件等（哪个支持随机访问，哪个可以拓展）




目录结构
结构（几级，树形）各自实现功能


共享保护

五、磁盘

物理构造
访问时间

人为优化：寻道时间（大题


扫描算法

多个算法


优化方式

交替···


空间管理

卫视图法（计算）













]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库2025期末考试重点</title>
    <url>/2025/06/17/%E6%95%B0%E6%8D%AE%E5%BA%932025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[本来想敲一遍的但是看我的字貌似能看懂就直接发上来啦~


]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>数位板+onenote铅笔橡皮快速切换的实现方式</title>
    <url>/2024/08/06/%E6%95%B0%E4%BD%8D%E6%9D%BF-onenote%E9%93%85%E7%AC%94%E6%A9%A1%E7%9A%AE%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[配置：高漫1060pro + windows11 + onenote(office最新版)
众所周知onenote最新版取消了笔收藏夹这一选项，导致选择画笔很不方便，一般情况下无法使画笔和橡皮快速切换，在一番探索下得到了以下方案


笔者之前使用c++做过控制键鼠点击等程序，但是黑窗口弹出需要一定时间很不方便，在和朋友交流下得到了知道了有一个叫AutoHotkey的编程语言，专门用来进行这样的操作


由上图可以知道切换画笔的操作是Alt+D+G+键盘右键*多次+键盘左键（切回黑色画笔）+Enter
这样就可以编写ahk脚本
Send &#123;Alt Down&#125;Sleep 50Send &#123;Alt Up&#125;Send &#123;D Down&#125;Sleep 50Send &#123;D Up&#125;Send &#123;G Down&#125;Sleep 50Send &#123;G Up&#125;Send &#123;Right Down&#125;Sleep 50Send &#123;Right Up&#125;Send &#123;Right Down&#125;Sleep 50Send &#123;Right Up&#125;Send &#123;Right Down&#125;Sleep 50Send &#123;Right Up&#125;Send &#123;Left Down&#125;Sleep 50Send &#123;Left Up&#125;Send &#123;Enter Down&#125;Sleep 50Send &#123;Enter Up&#125;;Click, 440, 180 ;也可以直接让鼠标点击固定坐标return
具体延迟和操作可以自行更改
然后放入路径（前提是数位板支持）就可以了

UPD.后来我发现切换功能里的这个可以一键切换···

不过无论如何是可以用了
不支持运行程序和切换功能的数位板，估计不能一键切换了
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>数论小芝士</title>
    <url>/2024/06/03/%E6%95%B0%E8%AE%BA%E5%B0%8F%E8%8A%9D%E5%A3%AB/</url>
    <content><![CDATA[欧拉定理：https://oi-wiki.org/math/number-theory/fermat/

#[LitCTF 2023]Eulerfrom Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p*qc = pow(m,n-p-q+3,n)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&quot;&quot;&quot;n = c = &quot;&quot;&quot;
$phi = n-p-q+1$，故 $c=m^{phi+2} mod \ n$ ，由欧拉定理可得 $c^{phi}\equiv 1 \ mod n $
则  $c\equiv m^{2} mod \ n $
直接开根即可
import gmpy2from Crypto.Util.number import long_to_bytesc = print( long_to_bytes(gmpy2.iroot(c,2)[0]) )

威尔逊定理：$(p-1)!\equiv -1\ mod\ p$
#[长安杯 2021]checkinfrom Crypto.Util.number import *from secret import flagp = getPrime(1024)q = getPrime(16)n = p*qm = bytes_to_long(flag)for i in range(1,p-q):    m = m*i%ne = 1049print(pow(2,e,n))print(pow(m,e,n))#4513855932190587780512692251070948513905472536079140708186519998265613363916408288602023081671609336332823271976169443708346965729874135535872958782973382975364993581165018591335971709648749814573285241290480406050308656233944927823668976933579733318618949138978777831374262042028072274386196484449175052332019377#3303523331971096467930886326777599963627226774247658707743111351666869650815726173155008595010291772118253071226982001526457616278548388482820628617705073304972902604395335278436888382882457685710065067829657299760804647364231959804889954665450340608878490911738748836150745677968305248021749608323124958372559270
第一步爆破n：
hint1 = hint2 = e = 1049for k in range( 1 , 1000000 ):    if ( 2**e - hint1 ) % k == 0:        n = ( 2**e - hint1 ) // k        print( k , n.bit_length() , n  )
得到 $n$，直接分解得到 $p$ 和 $q$
第二步：
已知 $M\equiv m*(p-q-1)\ mod\ n$
因为 $p\mid n$，所以 $M\equiv m*(p-q-1)\ mod\ p$（放缩）
得到方程

\begin{cases}
    (p-1)! \equiv -1\ mod\ p\\
    M\equiv m*(p-q-1)\ mod\ p
\end{cases}$\therefore m\equiv \dfrac{M(p-1)!}{(-1)(p-q-1)!}$
import gmpy2from Crypto.Util.number import long_to_byteshint2 = 33035...e = 1049n = 58237...p = 17022...q = 34211phi = (p-1)*(q-1)assert p*q == nd = gmpy2.invert( e , phi )m = pow( hint2 , d , n )print( m )m = -1*mfor i in range( p-q , p ):    m = m * i % pprint( long_to_bytes(m) )

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cryptoCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构不是有手就行（陈述句</title>
    <url>/2025/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E6%98%AF%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%88%E9%99%88%E8%BF%B0%E5%8F%A5/</url>
    <content><![CDATA[数据结构没有很多题目，所以只能通过知识点为索引进行复习
知识点来源是学长给的文档和期中考试题目


树的遍历前序遍历 根-&gt;左子树-&gt;右子树中序遍历 左子树-&gt;根-&gt;右子树后序遍历 左子树-&gt;右子树-&gt;根
差异：访问到根节点的条件
已知先序序列和中序序列求树
解题步骤：

从前序遍历的第一个节点找到根节点
在中序遍历中找到这个根节点，根节点左侧的部分是左子树，右侧的部分是右子树
根据分割出的左右子树，在前序遍历中找到相应的部分（保持顺序），递归重复前两个步骤直到完成树的构造

已知中序序列和后序序列求树解题步骤：

从后序遍历的最后一个节点找到根节点
在中序遍历中找到这个根节点，根节点左侧是左子树，右侧部分是右子树
根据分割出的左右子树，在后序遍历中找到相应的部分（保持顺序），递归重复前两个步骤直到完成树的构造

后序线索二叉树后序线索二叉树是一种特殊的二叉树，它在普通二叉树的基-础上，通过为二叉树的结点增加“线索指针”来优化树的遍历效率这种线索指针的引入，使得二叉树的后序遍历可以在不使用递归或栈的情况下完成
简单的来说，线索化就是把X序序列转成双向链表的形式（如果已有一条边，则无需返程）

哈夫曼树和哈夫曼编码哈夫曼树是一种带权路径长度最短的二叉树，构造基于贪心算法
其中，权值为节点的频率（或权重），路径长度为根节点到某个节点的路径中边的数量，带权路径长度为路径长度乘以节点的权值
哈夫曼树的目标是让带权路径长度（WPL）的总和最小
特定：没有任何一个权值小的节点比权值大的节点更靠近根的位置
树的构造
初始化：将每个权值看作一个独立的节点，每个节点都是一棵单结点树
选择最小的两个权值：从当且森林中找到两个权值最小的树作为左右子树构造一个新树，新树的根节点权值为这两棵树权值之和，删除旧树
重复步骤，直到森林中只剩下一棵树

哈夫曼编码是一种可变长度的编码方案，基于哈夫曼树生成

无前缀性：没有一个编码是另一个编码的前缀，确保了解码的唯一性
长度与频率相关：频率高的字符使用较短的编码，频率低的字符使用较长的编码
权重分配：从根节点开始，左子树路径赋值为0，右子树路径赋值为1；到达叶子结点时，记录从根到该节点的编码

例题：某通讯系统只使用8种字符a、b、c、d、e、f、g、h，其使用频率分别为0.05, 0.29, 0.07, 0.08, 0.14, 0.23, 0.03, 0.11，利用赫夫曼树设计一种前缀编码

a: 0110b: 10c: 1110d: 1111e: 110f: 00g: 0111h: 010
保证所有节点都是叶节点即可避免前缀冲突性（每个字符路径唯一，而且没有叶节点在另一个叶节点路径上）
图相关邻接矩阵：就是个二维数据
邻接表：就是个链表
极大联通子图（强联通分量）：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通；用于缩点
极小联通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通；用于生成树
强连通图：任意两个点之间有双向可抵达的通路
最小生成树Prim算法选择已知树上的最小边并加入

从任意一个顶点开始，将它加入生成树
每次选择一条权值最小、且值连接生成树中顶点与生成树外顶点的边
重复步骤2，直到生成树包含图中的所有顶点

Kruskal算法选择最小边并判断是否成环

将所有的边按边权从小到大排序
从权值最小的开始，逐条简称该边是否成环（并查集）
如果不成环，则加入生成树
如果形成环，则跳过这条边


重复步骤2，直到生成树包含n-1条边

二叉排序树见二叉平衡树一章
排序这么难我都看不懂
]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>文书写作/PPT制作 导师给的指导和改正汇总</title>
    <url>/2025/04/18/%E6%96%87%E4%B9%A6%E5%86%99%E4%BD%9C-PPT%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%B8%88%E7%BB%99%E7%9A%84%E6%8C%87%E5%AF%BC%E5%92%8C%E6%94%B9%E6%AD%A3%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[
  bc04ce3a4ec4a3c032d6e1a3db0cda04ac30e6ef4bc7af54a0ce34499a8a34a9c8f864e25b8edcb98f9b3677b2e687717bbfd2d41ff93773ee649efb77590cab0e0e6939d426ddff079d78ed5d7605452c3bd6c698dd18ef51214a09683a1e396aafbce5e5b27b2d0fb72e64c6255516076caf29e2000d9891b9c73a25261e8f440d30e72972ef679da1bdfbddde53878853b612fec231e0bf4114c303fa8a270e7ef6861ab9452cd159c490569ac63e274ec18dc9f1acf9467c2a4d1f50806507090ec962978ef29b403e9c32b065cd8386d4e11c1468708121d40b2cf7a127042dd4abae7342ee2514f27beedacdc2f3bb5bf86ebcb5c4b8e7cc96430f74fb1d65547371565f4e60b733d5a245b0e0ffad3961e8c820bd0d00ce37830817cb733f041d0db8bf4baebf01a2bb02f0e0bbdd44740cc9fffc70585bc481e37360d2adb8fa61dcca50b8f18fd5f9794d2e55d8bcf4a577bd4f3bf4db6cc22c37cf13496a94d986835944469c8bd8249b8835eed388ed42c3c296d15918933be0ee01de6a24b281f3f10b37be25cec8698afa45e9d994df1d1d3b5b06cc814dd05dd159b5682ab7d27830b591d041c9caebb08d54c1337ac43cae3a0c68d181dce77e7146b67e4555782d2ad6b37869f11392808e6e636e4ca5ef3730785e3ac32ccad76e9dd9bbca07a83007bb10abecdb4861814623d4767eefa305fbba7ea30cc7f984bd0f1ea5d95fcbd14f56d90d55e4b172cddae079e972949c4a953ba149f6553921f309147e11e9ec5d1242055bc7d6e688852a83080eda8b98b08af5826f7545bde8767ccae2106ecd5f4b428fa80fe0ec7f02e45e2311175754b807973bf4ab7f81708ab8caba4db385dff187bdd54c921abd90e33b18aa12a10589eaa3612052b2af300b2e98c86e87f9233637a44a13f9310c3881417f012772b34c38d67e9130c650b20b5863304b9cdfc711c21dea17a2640e64994441940cb2244310a5046f2d746ad13c1e1c107f336e1240f9d9b0cdb8ee14785955ea4af572df427c50e939e9d007a9c43d8ecc4f7a7b1f6053ef63de8adfb4b66e07a145a7d9eeb3f1a2397538e4bebac9946db0e870cd90cf3f72214853213c131b875a7f7bfb9822d3c10a9fd627f8a7a4ea2441f6f12f5d3adb7b2c4d173ec95fac6a3a813b5a99c95e20b993427201ac53279034e8156dbba030d2e25ee6f2d4ce79df7138fb1c1560e829773965ccda773cc90db14cf3a84adc36cbc5392950abadd832bbb670e357e9d1c4d7111c94d21647894f1fa2aac76d4ebfe5e464e873f91e5e6c39104d939909d3c5c8a09671b35cdec86b09d58b2b5eaa6f19a0c17039d7517fff0d4f66186decaa87ca0473a31f3919897568d8abdae3ef838e5ccaec62f3f837f3bd13803bf0094b3da831ef927b7ab6373f6743b63853e661deec2202db9c6b41e209a989c4636c973b59acab7230d86488d24130ee78b9cc64bd356715b82012ec21f4cd1bb88e11828f4b71f9da19c32d92a9c303aa9373218a1692758b0e59a516a5b2ec513e9db920d77a58ff136c1bf580505e99c632b2719a5bb2a3b2a57b08c972a178819aad32f84d6985c7fd10360a0d67264f822fdf485a48c897a4d5681b75446b4fca6a7cf9824a7e801d3ec10fdc16db4721f00df6ced7b359a9e0a82627eb53a3ffbab1f1879492cf60001a093f7c401b8257d2453ce4b2beede84d80b5fff0b2dffc3aa880d7a51414e6737f5f8c723a75bd8bdf96a8ba30634b63be77040c4a014fda05a16c8d977038712de327a8dfb7bb62ae3e0db6d92d1f93716f87369dba21aee2086e666a10e80e8ec94c2e99cc93e9f24e541a94dbebbb42b242779ec613295281ff96f78601c3deaff61f512154ab773233c8297a29bbc3e1f43b6108d04450e0d89949a1b687b09e7152fe623e7a7f3263f355ef851bc8d1310a60b781bec0a6e3ea6953cec1f8d49adfaf4918ab8acea5444a10501ce2fc6e97717db0a2915e38499f0fe8c3a6d026aade01240c83da60058beebc650a900ba223ee8b7a3d92e55b66f9f6955f574f1025ffa09af55f374807150b834451c3b4e592c19d521a41650342666a6740b110ec62007f386f40b633d8d10e6380eb309699ef02b06c7711669737b1fcc20f22b1f62a8e6a0ea5bc5391251fa74467a567077ef1723024597061e76f567ed49afeb16ebd0324463210d7381d6e00bb9047d79b1ad12e1182c428fe6a724259145ae593bbad3851076fb52ac74e469bf45f55a84efd4128c03143019d809cf3b48e93f0a55aa1e9b7ffe9a7836509292a84e5b63899b65ce4952282617a84679ee134f6bdd4940ae1ef25ff2d77cc580f7d18945557b14fd30a56a3713043ab65456311a0ea022e42daaf30426efd1087f6170a7ea7b9d77eaec1d6db481a00e01029ebe074a84a052b9a7cd56aac9da2c3c693a95351d7198fa37c5fb1462c87342cec61f44737999e185a24529601b32f3d23310ee97656152ce41697988578d1bd8d47c220df2ff7cade1dca4690517e41c83ac2ffb74505c57581386cd9c61307a2785a17e66b31ae50faa212473a87d24e85ecd73fdfbea91f0b14f5c7e112650fd98e510b1089f7bc5de64ff69669c75700d5b5788087674ccdba16d67515be7ef75cfd8600cc8b4516130156b3c2a11af53f3aa0786147334bdec7d11ce8912d020be5b2f71e45873ae3ede3ec77324a67742c634adfb86768794ddc34661ff60aba5cda78d28ef7226c6c0ab97b916c95f5910474e62f56661d97ff7a6adc50e20910f9be48a8b3eb28b2556c1f6042f9776b7500c32644cc628c2ccc96e1679bd389e2cfd326bfceb55433f24711084b2e26af37376fc4bc230d836cc2bd5a1fc99035ad05e1e8e998bf3c524290fbfdc28a152ca2cb3ccd1935d10f3fdb489de4ff6015babb5bcb3b8f9334b0b6164a5db824aa3969e11adadd139b7727bc0ba341cd10b958bdb7b4cf8a84aa1cf9cb09e4b36f40bbf419957fa239cdd1aa0a2f3f900026b5abd4f09c5d2474f1b6c04af72528cbe7976c24694cd059dea8c559e486fbb17673394ba6c2de2f532c29173ffc0990ee36efd269c5ad245bc90eed15ac1c03ae3188f1e49e02243da9ba9dcc7fb5c1c46f4a138af09ac406d810e0bb5bd023dce93dc36943e6e4967d7c295af187570da5c7967f1652bd8c9ca59bcfd9e9bf47ca303469c9dda654de75900123a08ddbaec4aeb59acff6ca0d7e1e9571e02d97d354da8db398c6d3f8cda34e97d88d2e3203fcd875bae263fb9503ace13fd79b3c0b2f931d3daa41d6ebc5c7399a2a40e7256db68604b0d7572e601f684a0211ce13df6a6dfd83bbe3fd4e2941cd3c840ce5f90d23f60248121dd634193b103e682242d941b4857010a123829d926b1150247533a10340475c646181cd3e363ad164ee6bf51a8981f73f9e6d953e1341ff5696fc4f5b6dccde3057fb1ec21b181ce3e6f8ddf7099835c5a35e8ffb282f828b86bec6bb8e03b5bc08eddb602b9b2d2efea137799d60b5b1655fa3ae5fc3adb8fd1adbfc3445af21d6fcc6c77cbe7a6730ea7f74917cd1aa2c30e610dfa2ef7d9c50ddb7dcbe2fa6a75e5c7516e7ca7c77ab4812ffe0766eca6ee0f1b0a8c3db742cc209d48ec8aef77130c8026acfc52f2ec76f661ed5575182e4fb8fa0d9626b36797e5e943f397eb4084ea87a3faf0d2c05bdfb54ee812deb3f5f04344ba5c99c04f083017ed4af9cca86d3b314a8b70c3306089abb65a37fcb2d3bbdf0a16d1f0ade1d2112c07009d809ed0ff298e3016ff1100bc06fd911d9f557f80da3acd0378b5820afe37a009ef41feb1e910268b4e1f7a97c8a2c14c754a8861646fc5685f0b9940bc446fb8cca57da61f735c99c3278a6883c8af445646564b4acf42e28188515df9a7f0c2a79b888c39f52244478660f667d891efc06645672a3b0a07fe15a20a7479482da5d3294aeda93fa2f10515812ad5e4cbe7d654a3568df294e193a9faabc3f34aba2e788a2f99bb0dd707b60256c8184fb6bb1ede2c6f0e482654e2f8f96607acb5c157579f1b2edae2465d822049c65966cfb1eb6d14965de20cf579fff9fba2c37185216c4cbea521d6bd67589436a9d2fd54eb897930466ac633c84db0bacee93678b47c849d92071be2da9b3b669a5b9c8da8ad448ff9251cf8dd8e5cb39643abfdcb506aa29a447347392e903cd814b270316c8575861087b7a4af84e29ab2df21a8cb5ce3bc6b259580b73ea3b57997bbc232cfd40e7e54873ca7a5ca31429fd47a2bca97d43b4c68325b1ed52c7324c6884df1dd09708212134383f4d277bf79bc4ec49e749a05c1b69f1b94aed684cff1cf5f2247f22ab99386f7b1001f1677c0d4b845b922f64b74bf2f7a4620fc9105f31410f87ed295596fa6774a6ec8022ef8c9cafd7f4d37883f681c1197402eb31cdc3e6cd7ff9de08a151890758d4ffa72e56875b393a06548ad50d6cf97cd9c97abd660fb3a6bbfab1251e422bf6306292773ee3a3bb6474423aff395987465ccefbf9b9673ba6a6d837bb7b70b0a20329c8c1a10646b6dc7b556a0921f99f078d2d1158e600d08eed0a0f299103fa6601ba266e2e81adc132d38629167fa5d62c17f9642a6ca596554d73b1b89f53a0cb9a6565bc23c8f99c4e8016a646475064079580e504c7e234925f42fcca59def6d660e5e65f33e80d61b704d6996280354b86eb1cc356651830b35a980acc19afc64aaad887b28371a36dd54e27183fe6af16cb3ad65e6c4c95aae974d423c16bbf58714ea93d9e59f8f664a67c1802bcf33e02935423a204195b7ee0304a468297fe4bd4ec57ff5ec9422a16998dccc3ac5cc1b89d3a672a3d592917d407f38d9b86c20c09648f934ac44e64f1ef13ab7de6b007dc45c765aef476154a0737a8c93a509b854e6fad4b2ff7e91cb54742bb24cccd05b22218c9faa9776c8acfe1d59110a62120b060eafcde2acfac079889d416d70f4715fcc9dd691c10dd82b0a8f28dc8b5b8f1dfc485285d7b25ec7b81f9f036c4edcfc6b68b7e34890eea989ddc77d7f14c955c3a8b960fc63edb39dacc06b016e8a3fd12ed15884d7a80cd7dd7426d1ddbe25f73c0a7588e187d01724d052df2566a1753c8284acb94294111347023672badd4b984e6b1989c1139c8377f3dba90b6626f8d0b2ba81ae1e8b0560673fcd4860c06af08f40f282d715204957e6e569edbbd9de9f5acc92f257dec64d3b0a9b1cef3d9f4ae7341a71558d7368447ff16b8036d2b418369efe0cb330d88f2185d87ed731696553094deee7355ee42ea3f8226943b778412cc71887473ff8bd7c141f9d78d79d4792dc95cdd53b96842351edae8d6a781aaaec2b0aa8e08fd0f041906c975b4362be4302be723003e3b5b007c69d7b1cedf21bc0e76dd61d664a87a637303bcef1f0ffd9890d78b31b43cf19d80d0f02aa04c0866ca0fe1d459646646811d456b8a1ea50cd635c97aee2cddb5a4c99c25453127ac2e22b0147898ac00c9d6460336d9548b11b22d64c908f6c66967ac23cdb88262b11a382d456461588df5c29ac77e37b91ff43b450b0012af9205dcd789a420dfe1da5e5c59ed8104b9f18ba583a657a88408261b3853694db4456ea9878ed79a449b06eb7702a4c016d357a369ec1ce76410b700327019173f4cc136d92908a929a7a67fc82dec35d3730246f568f8e47b2903cf02e4799b48c59543bdc5965408343d53bdb93e061bd11349c9b706928354155e012aa31a5fe66d22fb513d5805a557ca84101fb20726147d07e871bc960a7199ecb209f3a66259b092c28cbfc4793ba170e3b20e76f908958aa8554d4f9a6d6ead816404ebe99fe50ae85e8e41a4bfc6c0e40af44b21dfd99662a5ce6e9a7e75a9c8e7ce5938e35c9156961cd3b649c4ddb154ffbb9cbb7497eec6b7e588eaedfce768dfb7b847cf5210d806a156aa7a97fd343ed5fc3b461e59de3e96ae0c4cd36c9ded6c078aa9501ca3d9824b095e6c99132648ae962e4e7b52a319fe47411e9d9ed4129df588180b0e9735717063c244c33098f94e985f4f21d407645319813cd189720df459245b2ca67b6d8d3e1310bb83a471cbf7205ffd1de9e0cbe9720f452882c64cd0cba046956c86b7eae42e3b57f361f27b6a386a1c11ba079d4b3a78e303c2a3921bc91514d9a9360d77af89fa1731db20f8f714b75956481f60302775c0ecdbdbb8a42955b9202450dfd15c11d1b83f06164b652e20b00a247c0547d99f0baebd2ee7b37805f364caa27e562e87ed5d08ebbd1c48ccd096c5d8fef2fc779c6b2514ffdbb162cc7013e90cb83add3ed0925fab3d67312d8ed9e0163a6bbfaf79b69f0582438ea75b40ad145bca82ab890e04137ad04978a57e1819032e67f58f34dbf1150c9ef1b7052f7ed9cf8123119d3b75a63492a4a1960af7ab1d06fcc2f1e5b7aa0eca64b3f9fddcb10d1140283e4634fb70446638f6de61e105c23611ccdcbea87afbfbba2f159e29c8bb2a8635a72ec7a824a9f8f8778fe37306645c3c5983b1e6bf9387d02c7a473e7b29e00cad3b0f4662558840c42dbc6fa21023f739f1ac6f3b64cdfa6b744bd3865e9c75141eaba6fa51569a21b7217cf2c8b5a65e49dcae87cb5258a858f30fcf870f701f3a0bd4ef430dc35835409e74f359c9649ddeec374dd2ea24c38c0042ae2a9c795a25dd87a75731a1eddde823f932f8e3103dc32ce773f0837393d74ed42660132fab0b660326dc0a23f644e1b995cb35f068a5c90ed7523d81083ff7388ade98682cb079914c929a6ca982d49fd81371742ba3c0c2aed37bf0ba6ae4ebf22c4b713152c2bdea6425f71047f83df4dd3fa6b122f8d6438e4e7ceac33f1f7afbccc6f7948c7729da98c8ac068612826ba0d2e804d4401ce9de29138f755b1fe21bdaedd8b7b7ff231f6a250c9c27e8b210d653d77944d0719010e8667e2e60d81afbb9b65cc120000144d0d64393978af6c2e23e15cbb07799bb5c8b3a33d646fb691b064ff527c28fe5d1851bce97a1c4ac2f218da4c683ca7e91fbbb7bf690dc6e9b021f917480e528caccebd6adee9da7bd2df926bc9f5df8a157409df02418ca59d11dd28cef8fce19713d2579dc7d2cf2d9b881636c7e9e42271aca3ee6849380ede8bf51d94ba2fe9c9c3fde334f09cf7aeff30f7650da71231ed4d8a337232726307b55d04160fb0d153fd78d05192a90e876d0958534c8903db6b128df1db209e5216db0216dc995ad65aa75a18ecb14f66c62f344b28b5d5591c345462a3bf8e52f16cdbdb8a118b9c085df253519870fbd666a19ce9b62ac89ad26025a3470317499650763f7abb674c621b0f09da967c4fb559e217d515ed750fc2373fd4709771ba6a806ef1bf73cff8eb82bafc4d1572e7911746444b99faa793db4991aa020f0e2526e2331b335cad17f46fa02fb6f00699bd6bdd5610e58a3726238789a9708e0a040c5fc9ef43ecb6276a3d106c6d4edd10c8078894ebafe6491a1ccad05fc6f50fa13918f65cfd588515a2258f0d98fae577ff90662027d0c2f0c51da2e71ed66a80d88ece9757ee33668c25af3ad1c7695ce4717865d18c75e8be9b48341922a380f0fb41692ff8a3a0ffa911cda1671e9e20ca9976237ac3a2e318c903a1c605dd0d75784edae93cfca1240f71a343066576997a8815a39c32dc26673d0688b665d01b79374a38f401bbe9d7d741a230ff76a86c6c1ba5d4caf6c5808490f7e38f2bffa22e19d9e102ee26a252223abc6904ee2c489a966b0a894836b739ff58f9140d05b075c76e42631ad7c3da59d0d6006dea356defaa03ba387105b1b1d89d391a010d49186fe70b8a5a9f38b3254165bbe04be14b0df32b39e84bf7cd586b4adace1e9ecf936b64d182f40fd7aa03bc337b2a654268b13f31f265dd2353c0d619aed7962e7b19796e6eb220707244de50900ce33dcac63780f2cad0421c0646b7ab116fd6c2a9993beea3a8d55a8a368c0aa00d46f9665269cc0a249e785fac05f263dd7f0b2e003045dcb27fbbe733510225b8d3575dd90971f5ec05e2666d9bdb1a9d6574f1d21c63382addaa0a033c0a6816b39ba04081cdd83a05083a374d3a514296980bf8d5e12e048142c036adb1a86707926b270b3cf96d70480ce93aa06c6411ed04517a7228adfd2c042b9064a6a28c287ad035be363a2e37e7e5e6b28541d9070011748f8b483157a1fdbcc634fa02ac6ef124d2467a09191e6b4a80d94cd257ca85a15f041a827e0e60bdc1fe606938c6da672b583a228077866572f1ac84d6f0f81f009821fb23def6a11f09c809f5b61dae62ba936e2ba04acaf674321f9e33627c717bde6245f1f5662dbdf4770e834d83e6329ff5a4e0ca1453ee6cb856bd79c021d3960803d6fd2f6b59f3d24684518b59d3bdc530331ae1784bb3fbf64d2d75430a70f47db6823807efae37682171c8d74f3cf2b8e1bbfe135482622c79311a9dc53a5e06ce33553ce2f99c53bda4f22a0d0e116d28f68761634e5cf5eb79125ee5ba227cc2df0d01b64a7377a77d7d196bb8e4f628160c72f8542d05a5fe5f0d49d2f431d31e95ca0f766af9dc372daf68c2bf908a0da5bc9812951ecbd6e178cf2601f5484dcd3095ca0de4b59cb9ca00f611b94ba00d69ca2b30ccf1864182f582eaaa9b33cc291ad4a7a9cc38fd28b64a2f65a47143e6ae320793d7598acde5f0464c03d623bc972b69f09f146368e08de753b99b2e2170a81e109cf0056b314b014d5ba68724b1727568f81f5d10d1b5d69011b65732b224259beb19a6d0ac429a73ac6af1bed6c3e146461f1fd67fc34bd44de6002c004560d5331fcf6edec2e4374876be70e535eef635f3571364d20e96151eb8438442fc6c8775bd82ec86ae66e3be31023affed969fbefb899fba40b97b5fb5c09890444b61ff03c2048ad56646a78197fd67fa2e77212a2cdb186b9c3d368519e63f7ef0c329dfab2d0e28652c31c74e40d4ad870c80ca5b00406c52b8e752b247c6ac1fb8e480ed0b3596ccc04b4ffb75c1bec3c643c7372c7538b8d49f432975c4275e726a677f0ac314afd38795e70a8340ae52469563415917c19fb203077a2d79750be6409d286398291ac6345a943c1eec9b7f1806430aeda9bd5818d6f011451761b10c0d4561134d88a68420a348eb1600ee75940dfa1b618e578016656ca0d8326e78f25020390a94061d69f2ffcd050d1bbb7c63b38111a6eb4d018f56b705ec4e2fc482459f9d303479b1e1140b56eaf3d914864b8c4ede6e9550ac287acf40477b8fee41abd96d9115cf54404128685173795e1a4caeb8672aea36a6ea50418a36b0010a3ee5031319031e090fc62e3a02916980059d885be0981f6f281ba5cb9465014cccdb06be06a15d9982ce482e54d01ebd520f72588e407e845928e3a1ec0309c59bf4b98bf9db5aa1d617b9a359e54c718d6c868d3afabc3d958f1587943fd78fbed6fc450db463921ad8ee405bd6cecb8cddafd63a7a6e925fa7eebe3b7712ec7fde45e5020e96bcebb4586d3c8005a3dbe14b399f786acc212a99f2cb37013aeb892533b3860d959e75a2fe35ed5ceb822add0a91c1e160f8bc403b2a0ba894e2dea6089afb08da6b3a39e7b4bce8c2f107f3b65abb60501b4595c6bcacfed11d671114d14cc0a1e76868c20f4f8042b12e4649c0276d191daac5774e2314019e3de838e825e2c67703c88c1f5348066a47e7ebfef6c6e56f8c71242a83a5a9569ab9608b51010669d67c2c95bc76d6b60c802726f5bf71ee0df5054f9b2c69fa61553ac0d1cac0d2250f85df8380b206d5639b09adc2ccde6f48ba64b9b45608ef1b21659c2e4b5a15c63d5db052d27804813b82593b3b9b5bc05ff985513cb53f51d2e6b2953f6137c3eb72641ea2a77e31ca49708e7177b2bb33d8b5573319e969c33b7338b1c517aca0611109978575e0266cb24de5002b2c41a56bffae551ee927fba9f03049ff2543dd54a355d812addc6348d465a96e1fdb09519ef3fa3e0a65125f0e16dd15a56033e168c9c020b3ab77a2257a540e27c55cbc760cc83ec083b551e1bc917af9dfae734d8f54a2f4dc41eaa87b5142af2b524ce28a552e80252768683ac5bddada35d7640681e7d39d4d4f521006aaa0a293a9bde47b26a761faca43a1f47b6ef81efa0fca5c4f82e6820a1f6eee507aa3bfcf5b109323052ace1172186f84b5193b873a758bcf8c98323af1c64558cae3f0bc98598cfbfd71954a06b7db62d2620e2c46dbf3cde45999e6a5b797d4fe7322bb8478df0b3711e2ab0752759cfe7c2d64ca3063c33c9c6d99ed405b520a7cbaf461b2fafa4e50e8fd2068238e77e2a09dd97d57a652168507bdc575a317200aa59e8db7856bd895c8d92dc583976509d0f82648f9c2d41af9e07544c9485a0fbf63f5845aa2b9f6f0844c1e87d7a426f1baa2cb577c892c7aeff21c066d1bcd904e91579babfc0a45f8219e56edbc3fcb3d2a806717053175027e1468514b9d7cd4a93dd515affd1e1b1043080d54fa39c10e372366a5eb28da0077261eaff7b2067e03c5ab57774dc3b64fc0804edf65b8e386a898834d6755e77209b974510aed6b36f000d57e0483d0e30dcbfc6fd08123138fad8a76c17ffcaac006cd0489d2c1fdd7278ab543a9ea8b226b90975e286a9ba8876cadab64dc84d4e3e03751464b7cdc944cd3a754c0d6c99d6b17c895fd60392cc92c4301ed43e7573ba887f573c81f80cf1782cb8862a563864f011d83675f244dd1fa3a76e620668cacb16e2996d55ab0954b0042560ec6837589824974b3588f3934e45b1b9a2f95ce3b38add92dfd5782efe24b809bf1e9cd61af09e062d11d8e8e6d63920f6886608a2778afa52e8bd2f20eb353dcd753966fd1bece07aa64e6aeac1a74990954ceb2215894c896e4c2f9044908d539d674bccc70307758c238840cd5758715024aa953175657101f38881ec06d4acf51103240afcf17976ac8343e658d20ac59b22deff5684a5e7a11292d45a0639b4251a675ef03fd185c167a1a7013c923dc74644965318dbf0568feda012bdc55cf728cd372d82c314b444a23818e82d8f7d19f614c22dd259be7f8a7b5f4108c6ddcfef841a9cf0b39a3bbc477c069df2229a3a866f2b7313200bf2b1aff0090461efa2811df344bff3d37dde0d6adac1c945bc27879be1cf9b2d54837f2ce1eec5fb60da425e8e8386e1ba47284b5f8408570d20406d5a47dd7b4ebcdedcd73cad11114c3574b7aadb4a14e9a96950d3870a31ca78c2c7b9adf6be5065959a9a0fe1eb1e608216bc35e537a083f94217ec4e5f941bffa86cc698ed7251595a83839328690d67dacc9933ba334e85764aba4ceceff359691bafbc787921781c028e7c004a2994daa7e315bb93d4eec5395ad32e5ddfc3785c59460c0663dbe3661d64609276ff04b80066cfab4b31cd15d3723d7e312543859ecc264f24626a61cae59fec557ac975c67561abe94df82aac5bda7e92ba8919a285e579fe795e455a5e5c5af1aae9480d8e46c8041b2c40d0e7e4b0e914cab7647b46d9f8ead1df8364e6b59fe356556f1b6c926d15972dd1e1b32760b9e84413cbcfad494c7805760ad8866c0fd19ad9b12b71810270ff44d629082740fecca78f6d24fc3f8308238841519b4330b10bdcd2780ea84bf2e624d4fae19e59307847d89920b57563a84806ba2a746db468d4ed6cc66626378439883a2b7a0133887db56715cf60369a2733e50ef253b9cdc88f07d23c41456242b969e7a46e7ab3be8bfd3b99cfba0f7340cb2f93ea06bb50c24d9c1124f544dfc7faf833af2417cb5d93dbafd0c3f34bd6a8565ee50661be38ccede7ce443d21b7dc194536bd54d27423613b1aa33668bb5ae7f511c86192a0599b380fbfa74ccd82d065a36fccb31eb74eee3eee0a23559f62dfe17fc0af5362a68f3868aa2636b3e68e69358480bf5c50312d0d1a6e59c86f9ef811ba6f49a1aa5ef43707cf7defd0eadc72aed203614de29a899384989685d35b3101c956989868361df20747cf7c24dd4d4889225cbceefff7b584ae4514dfafd1e18a2996f3fd884d20db5cff6412a87f45b5
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>unfixed</tag>
        <tag>None</tag>
      </tags>
  </entry>
  <entry>
    <title>初来本站的使用指南（置顶）</title>
    <url>/2025/10/22/%E6%9C%AC%E7%AB%99%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[
建议收藏本页，第一次来就从这里开始～

不需要会编程，也不需要懂“Hexo”“主题”这些词。把这里当成一本会自己长内容的电子小杂志就好：我会把学到的知识、做过的题、看过的书、生活里的灵感，都写成文章放到这里，方便自己复盘，也欢迎你来逛、来交流。
网址首页： https://coperlm.github.io
一句话说明“博客”是什么
就是一个“我自己的小网站”，用来发布文章、图片和想法；
你可以像逛知乎专栏/公众号文章一样阅读，也可以在文末留言；
全站支持“搜索”“标签”“时间线”，方便查找感兴趣的内容。

在这里你能做什么？1) 找文章（最常用）

首页往下翻，都是最新的文章卡片；点标题就能进全文。
想按时间“翻旧账”？点导航里的“时光轴”（/archives/）。
想“按主题找”？点“标签”（/tags/）。
懒得找？右上角的“搜索”直接搜标题/内容，输入框里会写“来搜吧来搜吧~”。

2) 留言互动

每篇文章底下都有评论区（Waline），可以匿名留言，想说就说。
你会看到“浏览量”“访客数”等小计数，这些只是统计，不会收集你的隐私。

3) 看看朋友们都在写啥

“友链”（/link/）是我收藏的朋友博客。点进去就是他们的站点卡片。

4) 听歌放松

底部有一条小音乐条，是全站播放器（APlayer）。
如果不想听，点一下暂停；想系统听歌，去“音乐”（/music/）。

5) 快速入口

我做了一个“常驻更新目录”（/schedule/），把一些经典/高频文章串起来，方便新读者入坑。

读文章时的小提示
目录（TOC）：进入文章后，侧边会有“目录”，点条目可以直接跳到相应小节。
代码块：有“复制”按钮，点一下就把代码放进剪贴板，粘贴即可。
数学公式：看到一堆看起来很严肃的数学符号，不用怕，那是我写的数学/密码学笔记，都是可渲染的公式。
图片：点图片可放大（支持拖动/点击关闭）。
夜间模式：右下角或顶部可以一键切换“深色/浅色”。
阅读模式：想专注一点？点“阅读模式”会把页面变得更简洁。

常见问题（超快排雷）Q1：打开有点慢？

首页有不少封面图（有些是动图），第一次打开可能慢一点；多等几秒或直接点文章也可以。

Q2：搜索不到？

试着输“关键词的关键部分”而不是整句，比如搜“零知识”“SM2”。

Q3：评论发不出去？

偶尔网络抽风；刷新页面再试一次。如果还是不行，发邮件给我：coperlm@outlook.com。

Q4：公式/代码看起来乱？

可能是网速导致的渲染延迟，稍等几秒；或者刷新一次。

Q5：文章里怎么有“需要密码”？

少量文章可能会做加密，出于隐私或尚在整理中；等我公开或联系我交流即可。

想更深地探索？
技术细节（给爱折腾的朋友）：本站采用 Hexo + Butterfly，支持本地搜索、评论统计、数学公式、PJAX 无刷新、图片灯箱、固定音乐播放器等。想学怎么搭？来看这里。

欢迎你来聊聊
你可以：
在任意文章底部“评论区”留言（支持匿名）。
邮件找我：coperlm@outlook.com。


如果你也有博客，去“友链”把你的站点发我，我们互相串门～

祝你逛得开心！

]]></content>
      <categories>
        <category>技术学习笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>最近思考了几个哲学问题</title>
    <url>/2025/08/02/%E6%9C%80%E8%BF%91%E6%80%9D%E8%80%83%E4%BA%86%E5%87%A0%E4%B8%AA%E5%93%B2%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[
每一个深入思考的人，最终都站在一个十字路口：是继续质疑一切，直到虚无；还是接受不完美的答案，继续前行。——赫尔曼·黑塞

听了一节复旦的哲学课，有一个问题
就像基督教徒，或者新教教徒，他们都有自己信奉的东西，类似于“主”的东西——但是无宗教者没有，尤其是唯物主义者
无宗教者也有“精神寄托”，但是一般会寄托于实物，例如具体的人、理想、爱好或群体
但正是因为真实存在，也必然可能消逝或崩塌
而宗教信仰，如果信了，往往会提供更坚固的“精神支柱”
对于一个知识越多、思考越深、批判能力越强的人，反而越难“相信”，越难“依赖”，越难获得稳定而坚定的精神寄托
GPT给出了几个解

承认“信”的部分超理性：“我知道这个东西我无法逻辑证明，但它对我有意义，我就允许自己相信。”，就像爱、忠诚、牺牲——这些你也无法彻底证明“合理”，但人依然需要它们活下去。
找“有限但可承受的寄托”：你可以不要求某个东西永恒不动摇，只要它在你人生当前阶段“足够牢固”就行。例如兴趣爱好，某一群人，还有理想抱负。它们也许不是终极真理，但能支撑你一段时光，这就够了。
把“怀疑”本身当成一种信仰：“我不再要求确定性，而是练习在不确定中生活。”。这类思维在存在主义、禅宗、后现代哲学中都很常见。不是非要找“信什么”，而是活在“我选择在不确定中依然行动、依然投入”的状态里。这也是一种信仰，虽然没有神、教义、永恒，但有人的勇气。

他给的这仨回答，我一个都不满意~




主题
解释与内容
代表思想 / 例子




尼采式主动虚无主义
在意识到旧价值体系死亡后，自主创造意义和价值，成为自己生命的太阳。
尼采


武士道/斯多葛哲学的内心稳定
练习不依赖外物的心态，接受无常，以尊严行动，内心自立自强。
武士道、斯多葛主义


怀疑转化为执念行动
明知一切可能崩塌，仍选择爱、理想、行动，将怀疑变为力量源泉。
“我愿承担代价去爱和行动”




想起来罗曼罗兰的那句，“世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它”

对于一个双非本科生而言，通过考研或保研进入清华大学读研究生，和重新参加高考考入清华大学读本科，哪一个更困难？
经过分析可以得出一个相对明确的判断：从实际操作的角度来看，双非学生通过考研进入清华研究生体系，比重考高考进入清华本科更现实、也更可行。
首先，高考的竞争是面向全国、按分数筛选，清华的本科录取线几乎在各省都是最顶尖的那一档（有时甚至要到省前几十名才能有机会），且重新准备高考意味着要放弃当前本科学业、面对漫长的高中知识复习过程，以及心理上的巨大压力。因此，对于一个已经读过本科的人而言，再回到高考这条路径难度极大。
相比之下，虽然清华的研究生招生同样竞争激烈，但考研准备更具针对性，可以结合已有的专业积累、科研经历、项目实践来增强竞争力。此外，研究生入学评估的维度更加多元，不再完全依赖一次性的大规模考试，而是更注重综合素质、专业背景和未来潜力，这给来自双非背景的学生提供了更多通道和可能性。
然而，在讨论这些现实路径的同时，我试图引出一个更具哲学意味的问题：
人总是会将事情规约到未来。
这句话意味着什么？我认为它揭示了一种深层的心理机制：我们倾向于将复杂的问题推到“将来”再处理，并且在推向未来的过程中，自动地对其难度做出了简化，甚至轻视。这种现象在清华路径的选择中也能看出端倪。
很少有人在读本科时会真的去重新准备高考，因为那是一个“现在”的问题，具体、沉重、需要立刻放下现有轨道才能启动。因此人们面对它时，会立即意识到其巨大的代价和挑战。
但与此相对，很多人会“理所当然”地告诉自己：“我以后考清华研究生”，并未感受到相应的沉重。这是因为，“考研”这个词在我们脑海中已经被高度抽象化和规约化为“未来某个时候做的某个动作”。而人在面对“未来的动作”时，常常陷入几种心理误差：
第一，时间折现（temporal discounting）。我们对未来的行动往往赋予更低的心理成本，容易相信“以后我有空再做”。未来的自己被认为更有能力、更有时间、更有精力，因此我们倾向于相信“我以后会搞定的”。
第二，意向性偏差（intention bias）。我们把“我有意图去做某事”当作“我很可能能做到”的理由。于是当我们说出“我要考清华研究生”这句话时，我们往往在心里已经为这件事贴上了“可实现”的标签，而非“值得反复审视和评估的长期目标”。
第三，叙事简化（narrative reduction）。人类天生热爱讲故事，我们用线性叙事理解自己的生活：“我双非出身，后来努力考上清华研究生”，这是一个令人动容的自我叙事模板。但叙事本身掩盖了实现这个目标所需要的密集准备、情绪波动、结构性不平等等现实条件。
因此，当我们说“将事情规约到未来”，实际上我们是在构建一个关于未来的希望投影，把问题推向一个看似遥远、却总能依赖的“理想化的未来自我”身上。而正因为未来自我是想象出来的工具性存在，所以我们倾向于高估它的能力、低估现实的阻力。
这种心理机制其实可以和哲学史上的多个概念结合：
一方面，它与萨特提出的“自我欺骗”（bad faith）相通：我们知道现在要做出艰难选择，但我们说服自己“以后再决定”，实际上是一种回避当下责任的方式。另一方面，它也与海德格尔的“时间性存在”理论契合——人并不是被动地处在时间中，而是通过对未来的意向性结构来组织自己的存在，但这种结构也可能成为虚假的遮蔽。
总结来说，我想表达的是：

人总是将问题抽象到未来，并在抽象过程中错估其难度。人在意向性时间结构中构建未来的可能性，并因此产生对难度的认知偏差。人在叙事与希望中沉醉，而现实的路径依然艰难而具体。

如果你读到这里，或许可以问自己一个问题：
我现在规约到了未来的事情，有哪些，是我正在无意识地轻视其难度的？
或许哲学并不提供答案，但哲学提醒我们：不要对未来产生轻率的幻想，不要误以为计划就是能力，不要将“说要做某事”错当成“可以做到某事”的证明。
]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>unfixed</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人联盟赛/对抗赛游记回忆记录</title>
    <url>/2024/10/31/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%81%94%E7%9B%9F%E8%B5%9B-%E5%AF%B9%E6%8A%97%E8%B5%9B%E6%B8%B8%E8%AE%B0%E5%9B%9E%E5%BF%86%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[整理游记和会议记录的时候，发现机器人比赛的高校联盟赛和超级对抗赛的游记我没有写过，故凭借记忆（和手机相册）补一份
记忆可能会随着时间而失真，故趁现在赶紧记录一份（顺便分享一波图片）


其实我在star机器人比赛的2024赛季中，对队伍的贡献并不是很多，基本上全靠学长带飞
高校联盟赛今年的联盟赛举办在了福建理工，就在隔壁，很近很近

比赛前的几天，去福建理工的实验室参观了一下下，好大好大~，而且他们还有1v1用的场地~
据说是因为他们的RM和RC合并了（思考
新步兵一直在修，平步倒是可以嘎嘎乱杀~

报道当天，看到了厦大他们包车过来（好有钱），而且是他们学校自己的车（羡慕.jpg）

第一次来RoboMaster的比赛现场，很激动的好叭
（场馆内不让拍照，所以这里该有很多张赛场的照片但是实际上没有）

开赛之时，有几次紧急修车紧急换线，学长直接拿着电烙铁焊车上的线，而且是在马上就要检录的时候
有的时候突发卡弹的问题，很多人一顿手忙脚乱，然后被摩擦轮划伤~
（此处少了好几张图片，规定说场馆内不让拍照~）
然后过程中，学长们通了很多宵（联盟赛的时候我本人的作息还是相对正常的），终于夺得季军

超级对抗赛这个就比较不一样了，地点是在长沙

这次我被分配到的任务是调老步兵


这辆车确实比较抽象，设计有挺多不合理的地方，不过确实能用，而且基本功能也比较完善
最终，把老步兵的代码从能用变成不能用又在学长的帮助下变成能用了（大雾
赛前还去考了一次普通话嘿嘿~

然后粗发粗发


昨天晚上学长们通宵调车，然后睡死在高铁上（学长太帅，码一下码一下）

刚到长沙，就见识到了大城市的繁华





喝到了正版的茶颜悦色（3pin的吸管嘿嘿）


比赛那几天正好赶上周杰伦的演唱会，好多人好多人


但是正事，还是打比赛（头一次通宵调车，但实际上还是学长是主力
在羽毛球馆还有很多其他学校一起





检录了检录了


最终因为没有荧光充能，而且其他的车比较健康，备车就没有什么用了
然后我也没什么用了（），就去干后勤了（讲真一个人干后勤真的忙不过来，只能拉上指导老师一块儿来搬东西~）



开赛了，如果不是裁判系统有问题，北信科就没了
之后又被南航打爆了~
然后就结束了~


打完比赛，去了趟橘子洲头


和同学一起去鬼屋玩（再也不穿短裤去了（哭）

酒店楼下有份炒粉，我问老板怎么每天都在这卖，他说卖几十年了

味道不错

第一次听青工会（估计也是最后一次），收获颇丰

回来之后新买了个烙铁（钱包滴血ing）


结语：rm这个比赛，包好的

]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>浅学习一下零知识证明</title>
    <url>/2024/10/13/%E6%B5%85%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[之前一直听说零知识证明，但是一直没有学习过相关内容
今天在阅读陈教授的《Identity-based chameleon hashing and signatures without key exposure》一文中遇到了，故学习记录一下

知识证明和零知识证明知识证明是Proofs of Knowledge，零知识证明是Zero-Knowlegde Proof
二者之间有很多相似点，也有区别，具体如下

信息泄露的程度
知识证明中，通常证明着不会直接泄露密码，但是可能会提供一些有用的中间信息（例如密文的哈希值）
零知识证明中，验证者在验证的过程中，不能获得任何相关的信息，除了“证明者知道这个秘密”

应用场景
知识证明更侧重确认某人知道某个密码
零知识证明不仅确认某人知道某个密码，还确保验证过程中完全不会泄露任何相关信息


知识证明定义：证明者向验证者展示他们知道某个秘密值，但不一定完全隐藏这个秘密；关键在于，验证者能够确信证明者确实知道这个秘密值
离散对数知识证明Proof of Knowledge of a Discrete Logarithm
证明者拥有一个秘密值 $x$，满足 $x = \log_g y$，即 $y = g^x$（离散对数问题）
证明者想要向验证者证明他确实知道这个 $x$，但不能直接透露 $x$
过程：

证明者选择一个随机数 $r \in_R \mathbb{Z}_q$（即从 $\mathbb{Z}_q$ 中随机选取一个数，其中 $_R$ 表示均匀随机）

计算 $c = H(g, y, g^r)$，这里的 $H$ 是一个抗碰撞的哈希函数，它将输入映射到一个固定长度的输出值

计算 $s = r - c \cdot x \mod q$，这一步结合了秘密值 $x$ 和随机值 $r$

验证者接收到 $(c, s)$ 之后，检查 $c = H(g, y, g^s \cdot y^c)$ 是否成立


如果这个等式成立，那么验证者可以确信证明者知道离散对数 $x$，但验证者无法直接获得 $x$
这实际上是基于 Schnorr 签名的思想——证明者通过使用随机数 $r$ 混淆了秘密 $x$，确保即使提供了 $(c, s)$，也不能反推出 $x$，但同时可以证明其拥有 $x$ 的知识
两个离散对数相等的知识证明Proof of Knowledge for the Equality of Two Discrete Logarithms
证明者拥有一个秘密 $x$，同时满足 $x = \log_g u = \log_h v$，即证明者想要证明 $u = g^x$ 且 $v = h^x$，这意味着在不同的基 $g$ 和 $h$ 下，它们的离散对数相同
过程：

证明者选择一个随机数 $r \in_R \mathbb{Z}_q$
计算 $c = H(g, h, u, v, g^r, h^r)$ （ $g$ 和 $h$ 指的是两个基，它们对应的值是 $u$ 和 $v$）
计算 $s = r - c \cdot x \mod q$
验证者接收到 $(c, s)$ 后，检查 $c = H(g, h, u, v, g^s \cdot u^c, h^s \cdot v^c)$ 是否成立

如果这个等式成立，验证者就知道证明者确实拥有能够满足这两个离散对数相等的秘密 $x$
基于身份的两个离散对数相等的知识证明Identity-Based Proof of Knowledge for Equality of Two Discrete Logarithms
基于双线性对的扩展，证明者想证明 $\log_g u = \log_h v$
其中 $g, h, u, v$ 是通过双线性映射生成的，具体的值如下：

g = e(P, P)\\
u = e(P, SID)\\
h = e(Q, P)\\
v = e(Q, SID)\\其中 $P$ 和 $Q$ 是群 $G_1$ 中的元素，$SID$ 是证明者的私钥
过程：

证明者选择一个随机数 $r \in_R \mathbb{Z}_q$
计算 $c = H(g, h, u, v, g^r, h^r)$
然后计算 $S = rP - c \cdot SID$，这里 $S$ 是一个基于群 $G_1$ 元素的值

验证者接收到 $(c, S)$ 后，检查 $c = H(g, h, u, v, e(P, S) \cdot u^c, e(Q, S) \cdot v^c)$ 是否成立


如果等式成立，验证者就能相信证明者拥有相同的离散对数 $x$，但又不会获得 $x$ 的具体值
零知识证明定义：不泄露任何关于秘密本身的信息就能证明某个声明为真，即验证者不能从证明过程中获得任何除了“声明为真”的附加信息
零知识证明必须满足三个特性：

完备性（Completeness）：若证明者知道秘密，则城市的验证者一定能够通过验证
可靠性（Soundness）：若证明者不知道秘密，则无法欺骗验证者通过验证
零知识性（Zero-Knowledge）：除了知道证明者确实拥有该秘密，验证者不能通过验证过程获得任何有关秘密的附加信息

Schnoor协议假设有一个循环群 $G$ ，其生成元为 $g$，其阶为一个大素数 $q$，则 Schnorr 协议证明某人知道一个离散对数秘密 $x$，即 $y = g^x \mod p$，其中 $p$ 是大素数模数

公共参数： 公开循环群 $G$，生成元 $g$，以及验证者要证明的 $y = g^x$。 证明者持有秘密 $x$。
承诺阶段（Commitment）： 证明者随机选择一个值 $r$，计算承诺值 $t = g^r \mod p$，然后将 $t$ 发给验证者。
质询阶段（Challenge）： 验证者随机生成一个质询 $e$，其范围通常是 $0 \leq e &lt; q$，并发送给证明者。
响应阶段（Response）： 证明者计算响应 $s = r + e \cdot x \mod q$，然后将 $s$ 发给验证者。
验证阶段（Verification）： 验证者通过  $g^s\overset{\text{?}}{=}t\cdot y^e\mod p$  检查证明

零知识证明的性质在Schnorr协议中的体现
完备性：如果证明者正确地知道 $x$，那么 $g^s = g^{r + e \cdot x} = g^r \cdot (g^x)^e = t \cdot y^e$，验证者将接受证明。
可靠性：如果证明者不正确地知道 $x$，则无论如何计算 $s$，该等式都不会以高概率成立。因此，证明者无法欺骗验证者。
零知识性：验证者在整个过程中，只看到承诺 $t$、质询 $e$、响应 $s$，但由于质询 $e$ 是随机生成的，且验证者无法反推出 $r$ 或 $x$，因此验证者无法从中得到任何有用的信息。验证者只能知道证明者确实知道 $x$。
发展历程
三个实例《瓦利在哪里？》
遮住整个图像，通过一个切口来展示瓦利的图像，而不公布具体坐标
成员证明你遇到一个不认识的人，但她声称也是你所在团队的成员。你如何知道是否可以信任她？
你的团队有一个带锁的保险箱，只有你的团队成员知道秘密组合密码，可以打开保险箱

验证者写一条秘密信息并放入锁定的保险箱中
符合要求的证明者知道密钥，打开锁定的保险箱
证明者将秘密信息交还给验证者
验证者确信证明者真的知道密钥，因此信任

不透明定价两个人在同一供应商购买相同的物品，但是不知道价格是否相同

有4个带锁的锁盒，每个盒子上有一个只能放一张纸的小插槽。它们分别标有价格100、200、300和400，并放置在一个安全的私人房间中
A首先独自进入房间。A的单价是200，A拿走标有200的锁盒的钥匙，并销毁其他盒子的钥匙。离开房间
B独自进入房间，带有4张纸，其中1张上面有对钩，另外3张上面都有叉号。B的单价是300，故将带有对钩的纸张放入标有300的锁盒中，并将带有叉号的纸张放入其他锁盒中。离开房间
A可以带着只能打开标有200的锁盒的钥匙返回，发现一张上面有叉号的纸，现在A知道二人价格不同
B对手回来后，看到A手上有一张上面有叉号的纸，所以现在B也知道二人价格不同

其他看起来比较新的东西？交互式零知识证明在交互式零知识证明中，证明者和验证者进行来回对话。这种交互对于验证者确信声明的有效性至关重要。虽然有效，但交互性在某些情况下可能会受到限制。
优点：安全级别高，非常适合实时应用
缺点：需要多轮交互，对于异步系统来说并不理想。
非交互式零知识证明顾名思义，非交互式零知识证明消除了证明者和验证者之间对话的需要。来自证明者的一条消息足以让验证者信服。
优点：高效且可扩展，非常适合区块链和其他去中心化系统
缺点：与交互式零知识证明相比，安全性稍差
zk-SNARKszk-SNARK（零知识简洁非交互式知识论证）结合了两个世界的优点。它们是非交互式的，但提供了高水平的安全性，使它们在包括区块链技术在内的各种应用中很受欢迎。
优点：高度安全、高效、无需交互
缺点：设置复杂且计算要求较高
zk-STARKs：透明的后量子安全证明zk-STARK 提供了 zk-SNARK 所不具备的透明度。它们不需要可信的设置，这使得它们更加透明，并且可能更安全地抵御量子攻击。
优点：无需可信设置、抗量子、高度可扩展。
缺点：证明尺寸更大，计算开销更大。

后面还有这一篇没看，不知道他在做什么但是字数好多（
留个戳，以后大概率不会看了（
reference：Identity-based chameleon hashing and signatures without key exposurehttps://www.secrss.com/articles/58134https://www.circularise.com/blogs/zero-knowledge-proofs-explained-in-3-exampleshttps://www.cnblogs.com/primihub/p/17664137.htmlhttps://medium.com/@justin_Aleo/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E-b6fd586bad13https://blog.csdn.net/Jifu_M/article/details/112254136
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>现代密码学2025期末考试重点</title>
    <url>/2025/06/17/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A62025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[本文记录了老师讲的密码学期末考试重点
核心在于解决期中考试的题目，已经涵盖了绝大多数考点



国密（SM系列）不考具体内容。sm2非对称，sm3哈希，sm4对称，sm9身份基，sm7未公开

一

安全威胁：被动/主动攻击
被动-监听（保密性）-消息内容/业务流分析 （选填）
主动-中断（可用性）篡改（完整性）伪造（真实性）

安全业务：保密 认证 完整 不可否认 访问控制

信息安全模型（图

二

流密码是对称加密

三、对称

置换 -&gt; 打乱顺序 -&gt; 扩散
代换 -&gt; 代替 -&gt; 混淆
（属于密码编码学）密码分析学：线性 差分 攻击手段

DES Feistel密码体系 密文明文分组64位 有效密钥长度56位 $L_i=R_{i-1},R_i=L_{i-1}\oplus F(R_{i-1},k_i)$
AES SP结构 密文明文分组128位 有效密钥长度128/192/256位


​        Rijndeal-&gt;AES，但AES不是Rijndeal算法

DES的四个图 CBC

四、公钥

数学：欧拉函数，费马定理，拓欧逆元，快速幂，CRT（门限分割）
ElGamal，RSA，（共膜攻击）
ECC上的点加法-&gt;不考
DH密钥协商

五、分割

Shamir-拉格朗日
基于CRT

六、认证

概念

七、签名

验证身份 日期时间 内容 运行第三方认证
性质 三条性质 四个要求
DSS DSA ElGamal shnorr-不考细枝末节

]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论一轮复习</title>
    <url>/2024/12/28/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[记录概率论的学习内容

目录

一、随机事件和概率

1.古典概型2.几何概型3.重要公式4.独立性判定二、一维随机变量及其分布
1.判分布随机变量：$X:\Omega\rightarrow\mathbb{R}$
分布函数：$X\sim F(x),F(x)=P(X\leq x),F(x)\in[0,1]$
 
对于连续型$F(x)=\int_{-\infty}^{x}f(t)dt,x\in\mathbb{R}$


\left\{
\begin{align}
&F(-\infty)=0,\\
&F(+\infty)=1,\\
&\sum_ip_i=1,\\
&\int_{-\infty}^{+\infty}f(x)dx=1
\end{align}
\right.
A


B选项解法二：也可以使用部分积分公式$\int udv=uv-\int vdu$
部分积分公式推导过程
其中：$u=v=F(x)$
带入部分积分公式：$\int F(x) dF(x)=[F(x)F(x)]|_{-\infty}^{+\infty}−\int F(x)dF(x)$
故 $\int F(x) dF(x)=\frac{1}{2}$
则 $g_2(x)$ 可以作为概率密度
$g_1(x),g_2(x),g_3(x)$可以作为概率密度， $g_4(x)$ 不能作为概率密度
C
2.求分布
离散型分布

0-1分布 $X\sim B(1,p),X(伯努利计数变量)\sim \left(\begin{array}{l}0&amp;\quad1\p&amp;1-p\end{array}\right)$

二项分布 $X\sim B(n,p)$ 分布律 $U_k=P{X=k}=C_n^kp^k(1-p)^{n-k}$

几何分布 $X\sim G(p)$ 首中即停止 $P{X=k}=p\cdot (1-p)^{k-1}$
无记忆性

超几何分布

柏松分布 稀有事件的概率 $P{X=k}=\frac{\lambda^k}{k!}e^{-\lambda}$，$EX=\lambda$



泊松定理 若$X\sim B(n,p)$，当$n$很大，$p$很小，$\lambda=np$ 适中时，二项分布可用泊松分布近似表示；一般地，当$n&gt;20,p100,np&lt;10$ 时，逼近效果更佳

C_n^kp^k(1-p)^{n-k}\approx\frac{\lambda^k}{k!}e^{-\lambda}

\begin{align}
\because\ &Z\sim B(2,\frac13)\\
&X+Y+Z=2\\
\therefore\ &X+Y=2-Z\sim B(2,\frac23)
\end{align}B

8


D

连续型分布

均匀分布 $X\sim U(a,b)$

f(x)=\left\{\begin{align}&\frac1{b-a},a]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>电子信息争鸣讲坛第七期-学习笔记</title>
    <url>/2025/06/14/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E4%BA%89%E9%B8%A3%E8%AE%B2%E5%9D%9B%E7%AC%AC%E4%B8%83%E6%9C%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[今天导师突然发了个链接，说可以学习这里的文章写法
第一遍我粗略的看了一下，感觉不是密码学相关的，又时代久远（2023年年底），故而简略看了看就去干别的了
今天导师问有没有人学习这个，并且总结汇报，然后我意识到这个视频的重要性。故而在学习的同时写篇博文总结一下，旨在橙味写文章糕守~



密态计算技术：最难也是最重要
本讲座的主要内容针对机密计算（也就是第一个）
机密计算：提供硬件级别的系统隔离以保证数据安全
~
看了半天，感觉确实不是密码学的，确实完全是关于机密计算的，偏硬件，值得学习的应当在于其逻辑
机密计算我真看不懂它是干啥的，我是硬件低手，下面我尽量带入密码学的角度来讲解一下如何做PPT


报告分为三个部分：机密计算是什么，现在怎么样，将来怎么样
是什么？
先介绍，机密计算很重要。符合国家战略和法律法规需求等等等等，很像写可修订区块链，讲GDPR云云

然后是三大主流方向，顺着研究背景的内容，把数据安全这个问题进行拆解，分成传输存储使用三个部分，这三者缺一不可

然后讲三个部分中，数据使用是最薄弱的，而这次分享的核心——机密计算，就是数据应用部分的。也是为了引入主题做铺垫（有一说一，第一遍看的时候真没看出来）

很顺利的引到了机密计算，并对比了其它方向（其它几个好多老熟人哇）
模仿着的，写同态和MPC都可以用前面几张PPT类似的思维，就在这张PPT把想写的移动到第一位

这一页正式介绍了机密计算的定义，但是不是直接说定义是什么（这样的话很枯燥，这一页的东西也会少很多），而是对比了各个机构对机密计算的定义，最后介绍笔者怎么想的
这种写法的普适性很强，感觉无论写什么都可以套用

上一页是下定义，那么这一页是介绍了机密加密的特征
这个“墙壁”很好的标明了机密计算做了什么，加上旁边的注解，还有芯片的logo，让大家都知道是基于硬件的安全保证，构成这样一个TEE
这个构图值得学习，如果写同态的话，可以把图片替换成密态计算的流程，右下方改成同态的特点

对比了类似的概念，直接上了表格
先区分概念，后文交代三者的联系

这么好看的PPT我这辈子都做不出来（哭
这一页是对上一页的进一步说明，前面说区别，这页说关联，是层层递进的，里面还有举了很多具体的算法的概念，最终共同服务于数据安全（这几个大小配色也搭配的很好）
大同行基本上能知道机密计算是个什么东西了，定位是在隐私计算和可信计算中间

又一页进一步补充说明关联，院士讲这一页的时候没有过多赘述，点了一下硬件基础（第一个）和隐私性（最后一个）就下一页了



画了一个时间轴，将发展历程，这种写法在可修订区块链和同态加密都可以用哇
上面的时间轴不变，下面讲不同阶段
现在怎么样？（发展现状）
直接上一张大图，介绍了各个架构部署机密计算的技术路线
这种图基本没人会去细看，其目的旨在说明自己的对比结论是翔实可靠的


直接蹦出来这张图，告诉观众结论
效仿的话，直接列一张对比的大表然后给观众结论即可，感觉其它方向都可以学
不过这个配色草率了点，不是很现代化~

体系结构，左侧是目标，右侧是指标，中间从下到上是从底层到应用
我完全想不到怎么做出这么好看的PPT~

交互过程，密码学里很常见


也是同一页，和上次那个把表格一样的弄法，先给观众看图，然后再给看字
这种弄法，基本上多数密码学算法交互流程都可以套用（科普向很强）

主要研究方向和内容，感觉基本上也是让观众看大字内容，小字不是很重要的
感觉可以改进，小字里也有很多关键部分，可以加黑

攻击手段，也是一分多的画法


然后这里介绍了一些架构，写法大致相同，可以模仿
都是多个点，一个点后面带出来具体介绍


好好看的图~
和上面很像，都是左侧一列右侧一列，中间是一大列多层级技术构成



将来怎么样？（发展趋势）



四大页PPT，虽然不是很华丽，但基本介绍了发展趋势
后面很长一段提问时间，不少也是围绕前景进行提问了
询问环节的专业性比较强（翻译：我听不懂），这里就不再赘述了
不过看起来这一块前景还不错嘞~感觉有点太硬了就是了

最后还有一点令我比较泪目：院士的电脑居然还是传统的win7，用我叫不上来名字的Office版本

天黑了，回宿舍睡觉了，早睡早起，明天蓝桥杯加油~
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>知行合一</title>
    <url>/2025/08/07/%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80/</url>
    <content><![CDATA[我们经常听到一句话：“认识先于实践。”但现实却是：我早就认识到了，却迟迟没有实践。

人总是习惯于把问题于未来
启动门槛高，阻力大

✅ 方法一：一分钟自毁式起步法
“我就写1分钟，写得烂也没关系。”

设定一个目标，比如“写论文结构”，对自己说：“我只写一分钟，乱写也无所谓，先动手。”
哪怕是“我不知道写什么”这样的句子也写下来。关键是让你开始，而不是开始得完美。
✅ 方法二：启动外包法
找人陪你一起开始。


视频 co-working：打开 Zoom/B站互相监督；
加入专注社区：Focusmate、Tandem；
和朋友结伴打卡：每天上线就要“开始做事”。

别靠意志力，靠“别人等你开始”来强迫启动。
✅ 方法三：“惯性链”法
打造专属的“进入工作状态的仪式”。

比如：

倒一杯水放在桌上；
播放固定的无歌词音乐；
打开 Notion / Typora 的“工作区文档”；
设置一个 25 分钟番茄钟；
写一句话/一行代码都可以。

每天照做，大脑会形成条件反射：这些动作＝我要开始了。
]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>碎碎念：关于密码学的方向选择和导师的契合度思索</title>
    <url>/2025/05/15/%E7%A2%8E%E7%A2%8E%E5%BF%B5%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9%E5%92%8C%E5%AF%BC%E5%B8%88%E7%9A%84%E5%A5%91%E5%90%88%E5%BA%A6%E6%80%9D%E7%B4%A2/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88deca33120d4ad1342d09e59b6b63d4f5ae1b9d1b2dc7a377bc6e7b10a13b02c3dd61ae18302bca751537f5a1b1e7eb714f23347c887eb3d2c2b50c053d7e8f612697cecc5c64263653245fb63639312162122fa77742fa7ffec9a66106235fd219e0e0a0f1b25874b0bbcd23e6a97e0c5198ba4e3e4a19383fb26688cab55fceb3631ff63f4acc2e65c21743fad0f9b3c942b9528b63337b58fe5e03cfa22316c5991db4ed919a42ac621528a987a7e6fa906b8dfd36720517602f985dcbdb575090b8ee0c13757c6502c43fbc0733343f74cf764e1d96fb8f0b636f0b6de987a7c5524d793f1d5e52b67b4e6ec1ee59187d46f19f7d9b59bf7942dfc8e669dcf2a7046594aa02d3445cdbed7c41b25f6dc5b4aa296cd58f3f33486dd18e7cf4054f5b99ed787127361c7d5a8d695e16e679697daeb95ad8e071935f01fefcefc13431cfa45d59acddbb92860e8831b0f269de774015b2f0de1c015d7cfd39897079a9eff19ad9295712612316fe04d0f46eb0d4e43e8f3e8dfea784f2341f3b8ccfd9c00a8ab39235ce435f8fd1e3b86c2656bcee7106645c6ca04e38f66a23505252e7b796ae5fc9896246e87d4f1307ef9dcf2ff248caa60ae5ecacea202ad460b1c92330611a51bd588b16ad4dc3afcf0718830ee1cf701bc8604f9d49b09c3bca3a52833827b85258f9b67946b2d3a2fdc742a9ceffc48b750804481b433acf49c2921035b47c5d880c45622bc70e3dd3d40b58f83669c74941a94c7dae91eb1ac84f93e2c86cc2813ad6445327c2a6be0c1c11a5905a0b4202383afd9cf78a540527b38201c268ed2a897d423c61fdd78b5d23bebeb276a756145ddbdfa4333c4c928f82faec2f1cdeb5e63c87c3a10469eef4faabae85eb9cd7de7a0207cd16fff8aeeb01c185f889829e6d114aac5e888c621723bc32c6ff61236b26a496ddb52bc8735da8ae5862b7551f7ca9db7364352aca1854c4ed3fc37700fe6b02498a3b51a5c4192af7edab5db45015d92ee82429b54a524c95ca470dd294b92043a6b1a71225262f1e593302ecbc477fe6f46d8bb8eb5ef0c28c898e96c072a02717bb82894f11800237b0c9d15538159f4e1774ef143aff1993f7be5a413c878077c03e8187c42612fa1654f6d9a75e50ff4a80a3045e698fa8fd49574479b4af71681125f213a7015537423dc0e45eed5f2058aaa77bf97e387ce3ba77760213968164ef94b35e241552caa76193ffa7e5a1017a65f7fafd031f7a1b7891bc5d44ab4a72e9aae643bd1c3cdd3e4bf5cd77c35a3d3aeabb184caa5c2df6b709e9f4db906006a9528ff92174d7947ca3f4408e148cf820c9056a97d669880118e688d2b24febb16dd1ca9492a0cc41b0fcbd5c75bb68666dd03b3837ec7e2b0acc658c953b9922343eb9526e3562d145f56b30ebc43e4490e9f5fac79c065847f63df6529c4ed09318c682c694698de4589076520a087d4adabc66e261fd9eb513c29055f589a98cefa7728899148e8a3f77291dc95f2b7577ba8517bc84f04d51948adc00f572501ada6c8585817864c8c19d49c98d5ce6889bbff4c44d8e94d165c148a7d3f2b9c66ec3a378bcd860fb9c6fd76323e8013a4bbff4ed90e8fba49cce3c8832fb310fe8eba376f0663fed723e697284ff5eb5acaa8ef37f9f22ea7363050f11ee822157777461608757f847aa8a2e35c3d4eadcf0c6911b49bf842f48cc8bee8638b5bc189138b577a209ad1f28bc1b502280a3e8c338efc2b3b6117ad50a2cd57ddc606dacb3152cfe6614fcbbd63d582754ba8e210bfa0306c6ba488e9fe5f0cc84b57ffc8e1fcf36ae60c6eee079985f6c241f6793108d14a8eafd507df1ea70a4f9be0a67e4be0e90e6bdbfb86ff19d8dde52c240d73233723723eb43decc990876671b9124b3bf61f8fdea2bb96b36b1eb8a355c109aa71182ee4896f7487b10b33286e50b77afedc844c3329260d0cd3069a462485599b9c1421d1391b8d5934ed21aafd2f316900d2609ccca9f555f656c27da44d230c104113d61aaa0ba63e4c662471550a1c14a981b46ec995de801d8c99b1025
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客寒假2025题解</title>
    <url>/2025/01/29/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%872025%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[本文用于记录牛客寒假赛的六场比赛的赛时解题和赛后补题
笔者水平：CF绿上蓝下 


第一场
打红温了，头一次连打五个小时~
题本身不难，就是实现上遇到比较多的障碍
A题签到题，如果没有1就输出1e9+7即可
D题也是直接模拟即可
G题排序后计算a[i]-i，就是每个点需要操作的次数了
B题一开始以为是有向图浪费了很多时间，树存在简单路径的充要条件是它是链
M题也属于思路很简单但是写起来比较困难的题
就拓扑排序一下，然后逐步拓展，取最优解即可
#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 1e5;int n , a[N+10];struct NUMBER&#123;    int num;    int id;&#125;b[N+10];bool cmp( NUMBER x , NUMBER y )&#123;    return x.num &lt; y.num;&#125;signed main()&#123;    int n;cin &gt;&gt; n;    int maxn , minn;maxn = 0 , minn = 2147483647;    int minp = 0;    int ans = 2147483647;    for(int i = 1;i &lt;= n;i ++)&#123;        cin &gt;&gt; a[i];        b[i].id = i , b[i].num = a[i];        if( maxn &lt; a[i] ) maxn = a[i];        if( minn &gt; a[i] ) minn = a[i] , minp = i;    &#125;    if( n == 1 )&#123;        cout &lt;&lt; &quot;0\n&quot;;        return 0;    &#125;    int l , r;l = r = minp;    sort( b + 1 , b + n + 1 , cmp );    b[n+1].id = n+1 , b[n+1].num = 2147483647;    int down_minn = minn * 2;    if( maxn &lt; b[1].num * 2 ) maxn = b[1].num * 2;    minn = b[2].num , minp = b[2].id;    if( minn &gt; down_minn ) minn = down_minn;    ans = min( maxn - minn , ans );    for(int p = 2;p &lt;= n;p ++)&#123;        if( b[p].id &gt; r )&#123;            while( b[p].id &gt; r )&#123;                r ++;                if( maxn &lt; a[r] * 2 ) maxn = a[r] * 2;            &#125;            minn = b[p+1].num , minp = b[p+1].id;            while( minp &lt;= r &amp;&amp; minp &gt;= l )&#123;                p ++;                minn = b[p+1].num , minp = b[p+1].id;            &#125;            if( minn &gt; down_minn ) minn = down_minn;            ans = min( maxn - minn , ans );        &#125;         if( b[p].id &lt; l )&#123;            while( b[p].id &lt; l )&#123;                l --;                if( maxn &lt; a[l] * 2 ) maxn = a[l] * 2;            &#125;            minn = b[p+1].num , minp = b[p+1].id;            while( minp &lt;= r &amp;&amp; minp &gt;= l )&#123;                p ++;                minn = b[p+1].num , minp = b[p+1].id;            &#125;            if( minn &gt; down_minn ) minn = down_minn;            ans = min( maxn - minn , ans );        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;
J题赛时还以为是什么糕级数论，结果降低时间复杂度$O(n^\frac32)$就能过
通过打表可知，符合条件只有两种情况，再判一下就可以了
要先continue掉奇数，不然亲测会T掉
#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;cmath&gt;#define int long longusing namespace std;const int N = 2e5;int n , ans , a[N+10];map &lt; int , int &gt; m;int gcd_( int x , int y )&#123;    if( y == 0 ) return x;    return gcd_( y , x % y );&#125;signed main()&#123;    cin &gt;&gt; n;    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];    for(int i = 1;i &lt;= n;i ++) m[a[i]] ++;    for(int i = 1;i &lt;= N;i ++)&#123;        if( i % 2 ) continue;        for(int j = 1;j &lt;= sqrt(i);j ++)&#123;            if( i + j &lt;= N )&#123;                if((i ^ (i+j)) == j)                    if( gcd_( i , i+j ) == j )                        ans += m[i]*m[i+j];                if( (i ^ (i+i/j)) == i/j &amp;&amp; j*j!=i)                    if( gcd_( i , i+i/j ) == i/j )                        ans += m[i]*m[i+i/j];            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;
赛后补题C题看起来不难，以为半个小时就能写完
结果调了好久···
大致思路就是朴素开扫
#include&lt;iostream&gt;#define int long longusing namespace std;const int N = 1e2;int n , t , a[N+10][N+10];int ans_list[1000000][5];string s;signed main()&#123;int t;cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; s;            for(int j = 0;j &lt; n;j ++)&#123;                if( s[j] == &#x27;1&#x27; ) a[i][j+1] = 1;                else a[i][j+1] = 0;            &#125;        &#125;        int cnt = 0;        for(int i = 1;i &lt;= n/2;i ++)&#123;            for(int j = 1;j &lt;= n/2;j ++)&#123;                if( a[i][j] == 0 )&#123;                    for(int ii = 1;ii &lt;= n;ii ++)&#123;                        int jj , jjl;if( ii &lt; i ) jjl = n/2+1;                        else if( ii == i ) jjl = j;                        else jjl = 1;                        for(jj = n;jj &gt;= jjl;jj --)&#123;                            if( a[ii][jj] == 1 )&#123;                                // cout &lt;&lt; &quot;SWAPP: &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;                                while( !(i==ii&amp;&amp;j==jj) )&#123;                                    if( ii &gt; i &amp;&amp; a[ii-1][jj] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii-1][jj] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii-1;                                        ans_list[cnt][4] = jj;                                        ii --;                                    &#125;else if( ii &lt; i &amp;&amp; a[ii+1][jj] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii+1][jj] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii+1;                                        ans_list[cnt][4] = jj;                                        ii ++;                                    &#125;else if( jj &gt; j &amp;&amp; a[ii][jj-1] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii][jj-1] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii;                                        ans_list[cnt][4] = jj-1;                                        jj --;                                    &#125;else if( jj &lt; j &amp;&amp; a[ii][jj+1] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii][jj+1] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii;                                        ans_list[cnt][4] = jj+1;                                        jj ++;                                    &#125;else goto RECHOOSE;                                &#125;goto FIXED;                            &#125;RECHOOSE:;                        &#125;                    &#125;                &#125;FIXED:;            &#125;        &#125;        // for(int i = 1;i &lt;= n;i ++)&#123;        //     for(int j = 1;j &lt;= n;j ++)&#123;        //         cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;        //     &#125;cout &lt;&lt; endl;        // &#125;        cout &lt;&lt; cnt &lt;&lt; endl;        for(int i = 1;i &lt;= cnt;i ++)&#123;            for(int j = 1;j &lt;= 4;j ++)&#123;                cout &lt;&lt; ans_list[i][j] &lt;&lt; &quot; &quot;;            &#125;cout &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;
结果WA了个测试点~

看了题解，感觉思路真妙哇~

按照题解敲了一下，发现实现起来的复杂程度和我的代码差不多···
最终千辛万苦，debug一整个下午，找到问题了
ii和jj这个两个指针复用导致的，每次用完之后复位一下就好了
#include&lt;iostream&gt;#define int long longusing namespace std;const int N = 1e2;int n , t , a[N+10][N+10];int ans_list[1000000][5];string s;signed main()&#123;int t;cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; s;            for(int j = 0;j &lt; n;j ++)&#123;                if( s[j] == &#x27;1&#x27; ) a[i][j+1] = 1;                else a[i][j+1] = 0;            &#125;        &#125;        int cnt = 0;        for(int i = 1;i &lt;= n/2;i ++)&#123;            for(int j = 1;j &lt;= n/2;j ++)&#123;                if( a[i][j] == 0 )&#123;                    for(int ii = 1;ii &lt;= n;ii ++)&#123;                        int jj;if( ii &lt; i ) jj = n/2+1;                        else if( ii == i )&#123; jj = j+1;&#125;//cout &lt;&lt; &quot;???????????&quot; &lt;&lt; endl;&#125;                        else jj = 1;                        int oii , ojj;oii = ii;                        // cout &lt;&lt; &quot;disp?: &quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;                        while(jj &lt;= n)&#123;                            ojj = jj;                            // cout &lt;&lt; &quot;ij: &quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;                            if( a[ii][jj] == 1 )&#123;                                // cout &lt;&lt; &quot;SWAPP: &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;                                while( !(i==ii&amp;&amp;j==jj) )&#123;                                    // cout &lt;&lt; &quot;PASSED: &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;                                    if( ii &gt; i &amp;&amp; a[ii-1][jj] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii-1][jj] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii-1;                                        ans_list[cnt][4] = jj;                                        ii --;                                    &#125;else if( ii &lt; i &amp;&amp; a[ii+1][jj] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii+1][jj] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii+1;                                        ans_list[cnt][4] = jj;                                        ii ++;                                    &#125;else if( jj &gt; j &amp;&amp; a[ii][jj-1] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii][jj-1] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii;                                        ans_list[cnt][4] = jj-1;                                        jj --;                                    &#125;else if( jj &lt; j &amp;&amp; a[ii][jj+1] == 0 )&#123;                                        cnt ++;                                        swap( a[ii][jj] , a[ii][jj+1] );                                        ans_list[cnt][1] = ii;                                        ans_list[cnt][2] = jj;                                        ans_list[cnt][3] = ii;                                        ans_list[cnt][4] = jj+1;                                        jj ++;                                    &#125;else goto RECHOOSE;                                &#125;goto FIXED;                            &#125;RECHOOSE:;                            ii = oii , jj = ojj;                            jj ++;                        &#125;                    &#125;                    // cout &lt;&lt; &quot;unp: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;                    // for(int i = 1;i &lt;= n;i ++)&#123;                    //     for(int j = 1;j &lt;= n;j ++)&#123;                    //         cout &lt;&lt; (a[i][j]==1?&quot;1&quot;:&quot;0&quot;) &lt;&lt; &quot; &quot;;                    //     &#125;cout &lt;&lt; endl;                    // &#125;                &#125;FIXED:;            &#125;        &#125;        // for(int i = 1;i &lt;= n;i ++)&#123;        //     for(int j = 1;j &lt;= n;j ++)&#123;        //         cout &lt;&lt; (a[i][j]==1?&quot;1&quot;:&quot;0&quot;) &lt;&lt; &quot; &quot;;        //     &#125;cout &lt;&lt; endl;        // &#125;        cout &lt;&lt; cnt &lt;&lt; endl;        for(int i = 1;i &lt;= cnt;i ++)&#123;            for(int j = 1;j &lt;= 4;j ++)&#123;                cout &lt;&lt; ans_list[i][j] &lt;&lt; &quot; &quot;;            &#125;cout &lt;&lt; endl;                    &#125;    &#125;    return 0;&#125;
E题概率论没学好（悲

知道了这一点，将会是签到题的难度（悲
#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 1e5;int n , t , a[N+10];signed main()&#123;int t;    cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n;        int ans = 0;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; a[i];        &#125;        sort( a + 1 , a + n + 1 );        int goal , goal1;        goal1 = a[(n/2+1)/2];        goal  = a[n/2+(n/2+1)/2];        for(int i = 1;i &lt;= n/2;i ++)&#123;            ans += abs( a[i] - goal1 );        &#125;        for(int i = n/2+1;i &lt;= n;i ++)&#123;            ans += abs( a[i] - goal );        &#125;        if( goal1 == goal )&#123;            int add , add_temp;add_temp = 0;            for(int i = 1;i &lt;= n/2;i ++)&#123;                if( a[i] == goal1 ) add_temp ++;                else add_temp --;            &#125;add = add_temp;            add_temp = 0;            for(int i = n/2+1;i &lt;= n;i ++)&#123;                if( a[i] == goal ) add_temp ++;                else add_temp --;            &#125;add = min(add_temp,add);            ans += add;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;
H题思维题
考虑贪心，为了最大化排的开，我们需要按左节点排序，当$i=l_i$时加入备选，备选里面按右节点排序
如果不够了，就说明不存在
记得判非空
顺便学习了一下如何结构体根堆
#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define int long long using namespace std;const int N = 1e5;int n;struct NODE&#123;    int l , r;    int id;&#125;a[N+10];bool cmp( NODE x , NODE y )&#123;    return x.l &lt; y.l;&#125;struct Comp&#123;    bool operator()(const NODE&amp; x , const NODE&amp; y)&#123;        // if( x.r == y.r )        return x.r &gt; y.r;    &#125;&#125;;priority_queue &lt; NODE , vector &lt; NODE &gt; , Comp &gt; pq;int ans[N+10];signed main()&#123;    cin &gt;&gt; n;    for(int i = 1;i &lt;= n;i ++)&#123;        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;a[i].id = i;    &#125;sort( a + 1 , a + n + 1 , cmp );    int top = 1 , topi = 1;    while( top &lt;= n )&#123;        while( a[topi].l == top ) pq.push( &#123;a[topi].l,a[topi].r,a[topi].id&#125; ) , topi ++;        if( pq.empty() )&#123;            cout &lt;&lt; -1 &lt;&lt; endl;            return 0;        &#125;        if( pq.top().r &gt;= top )&#123;            ans[pq.top().id] = top;            pq.pop();top ++;        &#125;else&#123;            cout &lt;&lt; -1 &lt;&lt; endl;            return 0;        &#125;    &#125;for(int i = 1;i &lt;= n;i ++)&#123;        cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;    &#125;cout &lt;&lt; endl;    return 0;&#125;
就此，100人以上的题目都补完了

第二场
这场被打爆了，D结论题没做出来（根本想不到）
不过好在H题一个钝角三角形就秒了，没掉太大分
A题签到
B题直接排序然后输出a[n/2+1]-1即可
F题打表找到规律r-l+1
G题直接模拟
J题也是大模拟（但是没有想象中的毒瘤）
K题直接搜索即可，但是需要一些优化技巧不然会T掉~
就涂色就可以了，代码还是听清楚的
感觉难在优化（挂五发的悲哀）
#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;#define int long longusing namespace std;const int N = 5e2;int n , m;int a[N+10][N+10];int blue[N+10][N+10];int rem[N+10][N+10];string s;int ans , ans_now;int most_low;void dfs( int i , int j )&#123;    most_low = max( most_low , i + 1 );    if( i+1&lt;=n &amp;&amp; a[i+1][j] == 1 &amp;&amp; blue[i+1][j] == 0 ) blue[i+1][j] = 1 , dfs(i+1,j);    else if( i+1&lt;=n &amp;&amp; blue[i+1][j] == 0 ) blue[i+1][j] = 2 , ans_now ++;    if( i-1&gt;=1 &amp;&amp; a[i-1][j] == 1 &amp;&amp; blue[i-1][j] == 0 ) blue[i-1][j] = 1 , dfs(i-1,j);    else if( i-1&gt;=1 &amp;&amp; blue[i-1][j] == 0 ) blue[i-1][j] = 2 , ans_now ++;    if( j+1&lt;=m &amp;&amp; a[i][j+1] == 1 &amp;&amp; blue[i][j+1] == 0 ) blue[i][j+1] = 1 , dfs(i,j+1);    else if( j+1&lt;=m &amp;&amp; blue[i][j+1] == 0 ) blue[i][j+1] = 2 , ans_now ++;    if( j-1&gt;=1 &amp;&amp; a[i][j-1] == 1 &amp;&amp; blue[i][j-1] == 0 ) blue[i][j-1] = 1 , dfs(i,j-1);    else if( j-1&gt;=1 &amp;&amp; blue[i][j-1] == 0 ) blue[i][j-1] = 2 , ans_now ++;    return ;&#125;signed main()&#123;    // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1;i &lt;= n;i ++)&#123;        cin &gt;&gt; s;        for(int j = 0;j &lt; m;j ++)&#123;            a[i][j+1] = s[j] - &#x27;0&#x27;;        &#125;    &#125;    ans = 2147483647;    int ii , jj;ii = 1;    while( 1 )&#123;        ans_now = 0;        most_low = 1;        for(;ii &lt;= n;ii ++)&#123;            for(jj = 1;jj &lt;= m;jj ++)&#123;                if( a[ii][jj] )&#123;                    blue[ii][jj] = 1;                    dfs( ii , jj );                    goto OUT;                &#125;            &#125;        &#125;        break;        OUT:;        ans = min( ans , ans_now );        for(int i = ii;i &lt;= most_low;i ++)&#123;            for(int j = 1;j &lt;= m;j ++)&#123;                if( blue[i][j] )&#123;//1和2都涂为灰色                    blue[i][j] = 0;                    a[i][j] = 0;                &#125;            &#125;        &#125;    &#125;cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;
H题没想到这题这么简单，答案是钝角（即答
直接试图构造最钝角的钝角三角形即可
#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a , b , c , d;signed main()&#123;    int t;cin &gt;&gt; t;while( t -- )&#123;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;        if( b - a &gt; d - c )&#123;            cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;            cout &lt;&lt; b-1 &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; d-1 &lt;&lt; endl;                    &#125;else&#123;            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; c+1 &lt;&lt; endl;            cout &lt;&lt; a+1 &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;
赛后补题D题大结论题，完全没想到的一款
结论：连续子串和不连续子串，最长情况下，只有最后一个（或者第一个）字母不同
学长给的证明，感觉很清晰易懂

赛后多了新数据，特判一下1的时候输出0就可以了
#include&lt;iostream&gt;#include&lt;map&gt;#define int long longusing namespace std;const int N = 2e5;int n;string s;int a[N+10] , lst[30];map &lt; int , int &gt; mp;signed main()&#123;    cin &gt;&gt; n &gt;&gt; s;    for(int i = 1;i &lt;= n;i ++)&#123;        a[i] = s[i-1] - &#x27;a&#x27; + 1;    &#125;    int maxn = 0;    for(int i = 1;i &lt;= n;i ++)&#123;        if( mp[a[i]] ) maxn = max( maxn , lst[a[i]] );        mp[a[i]] ++ , lst[a[i]] = i;    &#125;    for(int i = 1;i &lt;= 26;i ++) mp[i] = 0;    for(int i = n;i &gt;= 1;i --)&#123;        if( mp[a[i]] ) maxn = max( maxn , n - lst[a[i]] + 1 );        mp[a[i]] ++ , lst[a[i]] = i;    &#125;    if( maxn == 1 ) maxn = 0;    cout &lt;&lt; maxn &lt;&lt; endl;    return 0;&#125;
C题构造题，需要建立在D的结论之上
不妨先只考虑一个方向（从前往后）
构造一个串，答案为最后一个倒数第二个字母（最大的）
就，前面半截是abcde...，只要末尾最后俩是对a，就是m=n-1
例如，n=11,m=10，则构造的序列为abcdefghiaa，这时符合条件（只考虑从前往后扫）
那，还要从后往前扫怎么办~
对称一下不就好了，即abcdefghiaihgfedcba，这时m=10（虽然n变了）
n=2m+1的时候可以这样子构造，，，那其他情况呢？n&gt;2*m的时候，往中间填充任意字符就可以了（需要是两侧出现过的哦）
如果n&lt;=2*m，也就是回文区间大于前缀/后缀，可以发现我们可以从前缀结束之后直接继续数，例如
abcde fgh edcba这样子，反正这样就可以达到延长子串的作用（不信你试试，答案刚好是前两段的内容（第一种情况下答案只包含第一段+1））
最后别忘了特判n==m和字母不够（n-m&gt;26）的情况
#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e5;int n , m;signed main()&#123;    int t;cin &gt;&gt; t;while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; m;        if( n == m || n - m &gt; 26 )&#123;            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;            continue;        &#125;        cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;        if( n &gt; m * 2 )&#123;            for(int i = 1;i &lt;= m;i ++)&#123;                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);            &#125;            for(int i = m+1;i &lt;= n-m;i ++)&#123;                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);            &#125;            for(int i = m;i &gt;= 1;i --)&#123;                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);            &#125;            cout &lt;&lt; endl;        &#125;else&#123;            for(int i = 1;i &lt;= n-m;i ++)&#123;                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);            &#125;            for(int i = 1;i &lt;= 2*m-n;i ++)&#123;                cout &lt;&lt; (char)(1+&#x27;a&#x27;-1);            &#125;            for(int i = n-m;i &gt;= 1;i --)&#123;                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);            &#125;            cout &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;
E题哦原来是RMQ算法哇怪不得我不会做原来是因为我不会
先记下来，明儿个学了再补~
第三场
这场发挥比较好，骑马进前10%了（也有可能是题目难度梯度大，恰巧E调出来了）
A题猜结论按奇偶性分类，随机数最优策略都只拿一个故偶数必败
M题一个桶结束
F题模拟一下极端情况，可以发现sum&#123;a,b,c&#125;在n和2n之间是合法的，否则不合法
C题正解为按字典序排序然后贪心，当然trie树也可以做
由于最后一步不需要复原，故把最后一个弄成最长的那个即可
#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 1e5;int n , m;string s[N+10];bool cmp( string x , string y )&#123;    for(int i = 0;i &lt; min(x.length(),y.length());i ++)        if( x[i] != y[i] ) return (int)(x[i]) &lt; (int)(y[i]);    return x.length() &lt; y.length();&#125;signed main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1;i &lt;= n;i ++)&#123;        cin &gt;&gt; s[i];    &#125;cin &gt;&gt; m &gt;&gt; m;    sort( s + 1 , s + n + 1 , cmp );    string now_str = &quot;&quot;;    int ans = 0;    for(int i = 1;i &lt;= n;i ++)&#123;        while( now_str != s[i] )&#123;            int j = 0;            for(;j &lt; min(now_str.length(),s[i].length());j ++)                if( now_str[j] != s[i][j] ) break;            ans += ( s[i].length() + now_str.length() - j*2 );            now_str = s[i];        &#125;    &#125;    int long_max = 0;    for(int i = 1;i &lt;= n;i ++)&#123;        long_max = max( long_max , (int)s[i].length() );    &#125;    cout &lt;&lt; ans + (int)now_str.length() - long_max &lt;&lt; endl;    return 0;&#125;
L题算是个构造+小模拟
我的策略如下
初始下，不妨设酱紫

构造，先把右上角这条线，从上到右下画了

然后通过以下规则进行填充

按照紫色的规则，填充到最左侧，然后往上两个（见红色）

再按如图的规则填充到最右侧

现在就回到了最右侧，之后按照之前的步骤，就可以填充所有的节点

通过代码实现上述内容即可，数据范围比较小，调试通过了大概率就能过
#include&lt;iostream&gt;#define int long longusing namespace std;int a[10][10];void out( int i , int j )&#123;    cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;    // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;    return ;&#125;signed main()&#123;    int n;cin &gt;&gt; n;n ++;cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    int cnt = 0;    for(int i = 1;i &lt;= n;i ++)&#123;        for(int j = 1;j &lt;= n;j ++)&#123;            if( i &gt;= j )&#123;                cnt ++;a[i][j] = cnt;            &#125;        &#125;    &#125;    // for(int i = 1;i &lt;= n;i ++)&#123;    //     for(int j = 1;j &lt;= n;j ++)&#123;    //         cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;    //     &#125;cout &lt;&lt; endl;    // &#125;    for(int i = 1;i &lt;= n;i ++)&#123;        out(i,i);    &#125;    for(int i = n;i &gt;= 1;i --)&#123;        for(int j = i-1;j &gt;= 1;j --)&#123;            // cout &lt;&lt; &quot;start: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;            if( j == 1 )&#123;                out(i,j);                i--;out(i,j);                if( i &gt; 1 ) &#123;i--;out(i,j);&#125;                while( j &lt; i )&#123;                    i++,j++;out(i,j);                    i--;out(i,j);                &#125;            &#125;else&#123;                out(i,j);                i--;out(i,j);                j--;out(i,j);                j++,i++;out(i,j);            &#125;            // cout &lt;&lt; &quot;round: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;        &#125;    &#125;cout &lt;&lt; endl;    return 0;&#125;
E题因为是弹性碰撞，所以我们可以认为两个球碰撞等价于两个球相互穿过（后面的讨论都基于此）
只考虑向右和向左的球，故如果知道了时间 $t$，我们只需要确定是否存在大于 $k$ 个球的间距不小于 $2t$ 且左侧的球是向右走，右侧的球向左走
故我们将两侧的球分别记录，然后二分时间即可
值得注意的是，向右走的球与其左侧的向左走的球永远不可能相撞，故记录一下进行减法运算即可
从后往前扫，累计加入答案，这样可以让一次check的时间复杂度降到$O(n)$
#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 1e5;int n , k;struct BOLL&#123;    int p , v;&#125;b[N+10];int distl[N+10] , distr[N+10] , uselessp[N+10];int ltop , rtop;bool cmp( BOLL x , BOLL y )&#123;    return x.p &lt; y.p;&#125;int check( long double dist )&#123;    // cout &lt;&lt; &quot;dist: &quot; &lt;&lt; dist &lt;&lt; endl;    int ans = 0 , i , j;i = j = 1;    while( i &lt;= ltop &amp;&amp; j &lt;= rtop + 1 )&#123;        if( distr[j] - distl[i] &lt;= dist &amp;&amp; j != rtop+1 )&#123;            j ++;        &#125;else&#123;            ans += ( j-1 - uselessp[i] );            // cout &lt;&lt; &quot;ans: &quot; &lt;&lt; ans &lt;&lt; endl;            i ++;        &#125;    &#125;    // cout &lt;&lt; &quot;dist k: &quot; &lt;&lt; ans &lt;&lt; endl;    return ans;&#125;long double ef( long double l , long double r )&#123;    if( r - l &lt;= 1e-8 ) return l;    long double mid = (l+r)/2;    if( check( mid ) &gt;= k ) return ef(l,mid);    else return ef(mid,r);&#125;signed main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i = 1;i &lt;= n;i ++)&#123;        cin &gt;&gt; b[i].p &gt;&gt; b[i].v;    &#125;sort( b + 1 , b + n + 1 , cmp );    int useless = 0;    for(int i = 1;i &lt;= n;i ++)&#123;        if( b[i].v == 1 ) distl[++ltop] = b[i].p , uselessp[ltop] = useless;        else distr[++rtop] = b[i].p , useless ++;    &#125;    // for(int i = 1;i &lt;= ltop;i ++) cout &lt;&lt; distl[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;    // for(int i = 1;i &lt;= ltop;i ++) cout &lt;&lt; uselessp[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;    // for(int i = 1;i &lt;= rtop;i ++) cout &lt;&lt; distr[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;        int reference = 0;    for(int i = 1;i &lt;= ltop;i ++) reference += (rtop-uselessp[i]);    // cout &lt;&lt; reference &lt;&lt; endl;    if( k &gt; reference )&#123;        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;    &#125;else&#123;        long double ans = ef( 0 , 1e9 );        printf(&quot;Yes\n%0.8Lf\n&quot;,ans/2);    &#125;    // cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;
赛后补题G题打个表先~

从后往前看，发现是等差数列
先是公差为1，然后公差为2，之后3…
故可以分块，公差相同的一组分到一个块
然后二分符合条件的数值（第前k项对应的数值）；对于每个块，知道了首项和公差，所以可以$O(1)$计算有多少个符合条件的；总共有$\sqrt{n}$个块。故此算法的时间复杂度为$O(\sqrt{n}\log n)$
值得注意的是，二分的写法有点不太传统~
#include&lt;iostream&gt;#define int long longusing namespace std;int n , k;int vtot , val;int cnt( int num )&#123;    int tot = 0;    for(int l = 1,r;l &lt;= n;l = r + 1)&#123;        r = n / ( n / l );        int a = n - n / l * l;        int b = n / l;        if( a &lt; num ) continue;        tot += min( (a-num)/b+1 , r - l + 1 );    &#125;return tot;&#125;void ef( int l , int r )&#123;    if( l &gt; r ) return ;    int mid = (l+r)/2;    int tot = cnt(mid);    if( tot &lt; k )&#123;        vtot = tot , val = mid;        ef( l , mid - 1 );    &#125;    else ef( mid + 1 ,  r );&#125;// void ef( int l , int r )&#123;//     if( l &lt;= r ) return ;//     int mid = (l+r)/2;//     int tot = cnt(mid);//     if( tot &lt; k )&#123;//         vtot = tot , val = mid;//         ef( l , mid );//     &#125;//     else ef( mid + 1 ,  r );// &#125;signed main()&#123;    cin &gt;&gt; n &gt;&gt; k;    ef( 1ll , n );    // cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; vtot &lt;&lt; endl;    int ans = ( k - vtot ) * ( val - 1 );    // cout &lt;&lt; ans &lt;&lt; endl;    for(int l = 1,r;l &lt;= n;l = r + 1)&#123;        r = n / ( n / l );        int a = n - n / l * l;        int b = n / l;        if( a &lt; val ) continue;        int len = min((a - val) / b + 1, r - l + 1);        ans += (a * 2 - b * (len - 1)) * len / 2;        // cout &lt;&lt; ans &lt;&lt; endl;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;
第四场
这场代码量太大了（悲
K题签到题，直接取最大值即可
I题直接扫一遍即可
B题直接枚举即可，C就不会了（悲
E题直接开扫，我写的依托~
D题#include&lt;iostream&gt;#include&lt;map&gt;#define int long longusing namespace std;int t , n , m;string a , b;map &lt; char , int &gt; mp;signed main()&#123;    cin &gt;&gt; t;while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; m;        cin &gt;&gt; a &gt;&gt; b;        mp.clear();        if( n &lt; m )&#123;            string c = a;            a = b , b = c;            swap( n , m );        &#125;        for(int i = 0;i &lt; a.length();i ++)&#123;            mp[a[i]] ++;        &#125;        for(int i = 0;i &lt; b.length();i ++)&#123;            mp[b[i]] --;        &#125;        int ans = 0;        for(int i = 0;i &lt;= 26;i ++)&#123;            if( mp[i+&#x27;a&#x27;] &lt; 0) ans -= mp[i+&#x27;a&#x27;] , mp[i+&#x27;a&#x27;] = 0;        &#125;        int temp_del = 0 , rel = 0;        for(int i = 0;i &lt;= 26;i ++)&#123;            if( mp[i+&#x27;a&#x27;] &gt;= 2 ) temp_del += mp[i+&#x27;a&#x27;] / 2;            rel += mp[i+&#x27;a&#x27;];        &#125;        ans += rel-min( temp_del * 2 , n - m );        cout &lt;&lt; ans/2 &lt;&lt; endl;    &#125;    return 0;&#125;
赛后补题]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>窝补药贵贵洗衣服</title>
    <url>/2025/06/11/%E7%AA%9D%E8%A1%A5%E8%8D%AF%E8%B4%B5%E8%B4%B5%E6%B4%97%E8%A1%A3%E6%9C%8D/</url>
    <content><![CDATA[前段时间有个朋友（不是我）出于学习目的研究了某品牌洗衣机（首先排除小依）的串口通信，发现可以重放攻击
本文章仅供学习目的，请勿用于非法用途



成本：一套三舅妈不用了的螺丝刀（拆掉外壳），一个大舅姥爷扔掉的硬纸板（用于临时工作台），还有一个情人节对象送的蓝牙模块（不到十块钱），再找前女友要四根公对母的杜邦线
蓝牙模块需要支持波特率2400的，可以问商家能不能帮你调，或者自己买个CH340自己调（本文不做讲解）
商家没给广告费，就自己用识图搜吧

然后拿螺丝刀给小依拆喽，如果没断电的话记得先给自己买个保险
找这一部分，给他拔喽
然后右上角这边是控制洗衣机的模块，左下角是原本的通信模块

然后我们要把蓝牙模块接到右上角这边
下面我们来看走线
这是蓝牙模块

这一半是洗衣机的

下面很重要，接错了轻则没反应，重则烧掉
蓝牙模块的RXD 接 洗衣机的TXD蓝牙模块的TXD 接 洗衣机的RXD蓝牙模块的5V  接 洗衣机的5V蓝牙模块的GND 接 洗衣机的GND
其他未提及的不用接
然后找个串口调试助手，找到蓝牙名称（不知道是什么可以问商家），发送hex:
AA 01 9A 01 02 A9 16 55
这就是 强力洗 水位中
其他的自己研究吧，我要去继续摸鱼了~


有什么问题欢迎评论区留言，还好我这个博客没做评论区~
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>窝补药橙味算法竞赛掉大分糕守</title>
    <url>/2025/02/22/%E7%AA%9D%E8%A1%A5%E8%8D%AF%E6%A9%99%E5%91%B3%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%8E%89%E5%A4%A7%E5%88%86%E7%B3%95%E5%AE%88/</url>
    <content><![CDATA[2025年2月21日周五晚这场牛客，掉大分了


A题快速切出来，后面就开始坐牢了（还好记得开ll了）
B题憋了半天，感觉要开不止一对堆，然后一看榜C出的人多，就去看C了
然后C挂了两发，和21年csp-s差点ce的原因一样（
当时是数组开到N，但是i也遍历到N
这次学聪明了，数据开到N+10，然后扫到N；结果忘了后面用到i+1了
然后挂了两发才发现
B题就有意思了，开了四个堆最终，调了好半天过样例了，结果一直WA
赛后找评论区的hack数据也找不出一点问题
最终对拍了下下，记录最大值的初始值是0，但是最大值有可能是负数···
最终成绩

虽然没掉大分，不过这场也打得挺抽象的
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>第九届网络空间安全国际研讨会 会前准备</title>
    <url>/2025/05/12/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%9B%BD%E9%99%85%E7%A0%94%E8%AE%A8%E4%BC%9A-%E4%BC%9A%E5%89%8D%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de177c76d9dee5b490c134eefa0fe7d07a476035cfb172a5cd658b512e633b2373b760e0db778920237161c4e661333195c8702a6cb6d63a90cfe9fed3baeae097741a63602eb6d2228a95cf1e7588ee5138b389257f3b9259812167dba934401ade657168d7a2124a89a56f5814e4445acfbecdc0dfeeeafa1447347bf3ee56d062e4441b9c98dfe64100c28afe7f809f0aececb6d66994b9e9d6beaa3486acf4abbad8eff1d49775f8dfa9b62149bf2082b8110cdede1b4a174f21a02a11419c1f9186a3fde100bb582a82292b678f31af520d3141ab01092963b9cec4742d1299aceab279ca88b0a06c79c0483e67e788cc611c8f0e64f603c1794d482afabd10bd53ccbc6973719be43866f3af6cd8c04079ac2a2d74a2c1bb4db19ec39fe119dad34448a3630ea26649cdeac372706d74a8e5c3529c41b5d4da4c65833258ea66b6a1221179d5dbc2b548cbdbb6c386f81107f6c056cbc058a442dd0bcecef636a4b19f65249c881829f30d6b59a10ddadee1f2edcd6af2d9c94c94a2065e180ab1d0717ca20ed29a636cc7eef3c96c78b2459301aacdf5ce82778e58ae607d470e0a40f8763d8cf407cf7bc2bab483f961851943d6791ee1a8f6b8228a82b684b77d837a80962ad8ddce3237d79b3be21d4a65b2454e0908031d597c47cfab4948aa335283828be85ce861172871d7367e2a4f42596e9b99ad0079560bde1205ccde0cb6fd218d498704116f11daafab8cead41ede9e90eb7eb0e86261af2d0fc541e7e6133e7024e4133d67fe7a899e17b8021114a156b357343ecbb97f386eb2a3f3398772562d9269b7476c65c37ee9621d3bc04fb44dc685f7fe9251fc59e61dbb41a27b42158d86d697ab4cb487a51bd6aa5f725938b183b2236dbb5901b014a9f4905302e03b80870f85a92da66a0ba1b17f4ec28cb6556df6603cc8816a5cf89d01b6b3a4ead2a5bfd4864e96288843b24ed29d4c61b61b13ff1fc36ddbc6aeb711afe969873af7bf556b036cd7bd0d173ec1d1041e57659f9a9fec26e9df7653b3c1996098e419382fdf9fd7d75caa7b71ae5b4eae47e00fe07817156fb71962c051e6c685836483ad215cb9617442628d4851e0619c709d9399450b1ee408ed2db9aadaa332024a988364278eaa8fb2ddf0fcbeae315072cfaa4d56af8ecd09c653b84a803eae1152136aa75323f63719641bb098eaeb14664f982553540677fe7d047117611fffba59e116f780492b1e8a8885254c2d3621a4a52ec77f671fa7c645f4d849961f4a051e71f22f021b9d0f98ebfad63b0c3c1e0a479b6992784453d00c256c95457c07202c30e94e9670efe275bdb6c64c343d0bbb27feb30d08afc30425e548d52d45d1590c59af22a04ac95f92ed490d30b3d5f4b8737a6ed3f7eb42abc8fb3ee897786442220a940b6cd8435feabb7b2dd1018dd7903b9431ba2285940c1ed4d675366089462acc8af744111599a941b21eca9c8bcce8784c3b868c030f8a196cb7d78d50ffd0abf76ae56a5847553395b70f0d4bbd82a6b042f06bc4668f524672fc749df6f5747073c557139171506ee9f6be0a97cad159dccaac3d1c0c2da152e2dfd6817c9e7c4c29aded9efde22074da0c9a79abf5e2455170fe0c8a5ee570d64f997c52581d7ebd15efc29d3a3f2981aa0a837710e33b6172f044d13d5b84dc5b7c6801e9409d3e9932a053147b7cd44bee99a21f1f123506901e382ee6593459d1700804e7d0edff3278a0a2409c95f8a2cd747aa904e79d816de05f2b5767c087bf20fcffcea9fce7c2447d79bddc64282aa49eb290714c26501e1df9dbecbca992a47d9bcc76165969ae63a6e2f2bc1416914ed9bb3afcf65a92297b695cc69c7f8969a048cbe8efe43bb9491dea80299e1548e1a9393df4e051271ce33366dc89bad9c690a743855388638a7db30b581cbc697636f5089b365eedb59f1db8bc73853081ec07696face47f38a41604bc6017898338a4918bcf14b732907922946b91d1adc82a9d6035b14a5bb8234bc8a754664703bccfb4cb8b55d7c1c941d92f375eabfee7a89227b2f534f23aaf8e176d1b26eeb7408c91a50813a28f4846b9f66ab4e66e6f40a4029ffeca102ccf14045e43c8383e785545e66b4d0f52ffa1d85015ec2997787c4d7ee7f828e79dabb148d40098382eb95d4cfb04f8af64491cd5829899a973bf65d5e636ebea6dabc229743fabc68b48437a3d910aba99ff4b7cc4888f1ab1789aa7b33b347cc30b076c8eee9b4db1c8215679bc2102a87221a0df56a32048bdf7f3a9f80419b54d4e458cfbb625d4df15897db405b50ae47f51804f66a9c99a43bedec01b2c4281f880c1351b881fd70b75df44f1de0b09268955c4822f14d3acc735dcdd360cf0cd8699f47720049b2001ca276590ba15232abed2a6d3abc59afee2e40c152b83a353211bf4caa3f2fdde115430bac8244d9b381c453216ecf8dabbe5960870c4f60c60feeaa03fda410966ed8170efe319fdb982e13b42ca4bd76f4d7a5007f9d1f4afa246fec25278b7c652145e070daafd5180a920f4063d9ce5b0ec78cf68c60cad9fd62fcf38ca886cbf577fa6b9a1a7ffd23803fc318a93680e21886bd1cbdedd81c7971887c6f19709bf6fa65c0506b8f83a8004fd7a875e5e61a9fbd2a4dd05dd804c257790ddd6ccd6c65cc79733a51c22323782b50dd1c196adf47a0e89843842b86cdd48a39277b360d852c23c4680701b4969ca4ea9bb9480d7ec35033eb80d2c928e1b4773092b6a170b8a1caac943cdeec1ad83bbe29da0614422cec71284b3002fe95dd8b796271135d82a99987427976b3a1cd490506598e5d30d2ec3b115093febb20075066da8326f62317345e93b6bcfa53a8f594540e7a4e2291aa3b7c267c785e75e59d2e60bbbcd46c67c4a72bd487c561c68f41eef4a881cb544a05255e4f73fb4e48042a1559c8d8439fc86d3db084dace4049ff71bdfdb6b56e57cab4e6aaa988d694dd141439681cafa1a13bd545eceda8ff1014e073d786946d36272e78b1d74b21bba382c7e44a39c218659eea76b46822a0eb6544020e24a1927ca63a26b6fee0d5a6d2976654ceb58f5b77378e4cfec67898bd7655b78a22ec27c5e44dc8216d4d0261bde270be3b724f08c82943508417e378712747315f2e38e1e7ab7d6053273080690dadbe5b552e18ea21fba346a84a4d9210bc98a3438d816e0a689d036bb064bfc1e43637f0f3bdce3b80d4c1576a35e3f0b7382af7ab8ea26b9595029b8a0ebea1d3ee852cde38129e2bd356f6b3e6a0c3181ec579234b23eb5471c5115282d6f9bd677bb8cdb645bf1d8b4c11880b8aaf511a7422bc97806e056eb9f85c816acae2b126674215150c95ae453daaca962e57327f7e3c2e21975bf72b7f11d8eb8e028190d00e83d2bafd312ce5b6546ba8efd0e8d5cd83ddf2cc167f7aa5cad0980cb6f102e4d352ce260767215d85955d02c0fac4bd07238e1b24f83d306a207128b20d0206d79fee76c3e7241fd117ffb289cc9056e618191c686a0a23a12312e8f714def61d8ad4a98c65f15613029d5af271d61a426785f8a67d99adfcd23e34f2f56fe616c887d63c022ee5f473edd09ba736d996db577c891e8fb9705ce9e8b33b6dfe79669458092fc78a306628f88e71a1b1ba7177e7f7463c5e7cec9926b1aedc4534fb69db748006de0f1a88c3f8c4be5d4425e039131c3f9f3681bc95b57d467bccde87808919f3c2c33db5257902b32a281304970109965d9cdedf904662bb896ff4b9b736a7d8cdee5396dea9fa43436535f980b405aedf60dbc6404865151ec213caab083358ea87bf2539e031565861d4c2704c830f962998fc6347641d2f25693b5e78688dc6bf122e09a49fbdf24d3ecbf28016c7e651a94904919ac88d2e44cf4d5d92def34e10e00956563c8538042bb4a40a5a7534a69962c2555f88d25fb1b46d5a0ccf5d8f147dbaf9ae5533cf6e6f45f50fb7daf4c06197ded83849c09d0a0ff1e3a50c2fa81752b340da5398cd684c8da13322644fa4bfead4846b84e921c359449e702c2d0561c80236f4e7bf9783f18a26abd7d71c5caf4b24116a7297209d0d868ebd89094de4737131bbd3318014a713ead29ed7e6eb9fabb6eef15e05c12707d36f71d6cebe8fa775c38037f5844c3247f9472ad4d90b7d178e3f8fbd698f94aa9e9bf103ef201b6434800aa5029f46f46529d91d4cfba4cde772095989ffac458663dd50ad8061b7cbef6f66d503a24c0611369cc215340eeb22d77f7927d402aca54e4d490e88a3515845e7b9259cd3f084ee7ec9f61417429324ffa59fa4cfc7cd9e77c623018df061f9e49555462467e0ac4bc1ac76c1acb7929d52fcec653fcb3fd87f8b4f67d0de3941a778bdb275e4b1d857359d5b2f34b3ffaf79c2c0cf96eec33df0807fc720a109db0defda5b449664cd196552ab4b4518412838e01e51c6d08dfcf602b94d89d3390855303f9057f4559d4b99e59b34b29ceb6dea1d97ef1608b46aa8f39f95ddea5e1ba6559f3a164b265193a44d36e5b7901847f88405f67bef5e5fa816c90a3de07904a35b9faa35f2ac1c2bca69b494986cbbec36bb4560a376b42263967c3277ab177e7faccb72d74be459d50cc4c98d4864fc9e53c6e8e4c1105050a03469c6e49d420637ae0a68aab323e461ea320ea016c2743ffb599ba96cb5aeb1bced2ce997f1f0abf7fde7642eedd4b6481641c0add853771e588fafba57d5e7b4f056d8be1f77c61acc35ad9d820909258f7ceefd09643aa0c41daec70b0ee23b966cae79ffc25c6ac9ef31e5f67786e13c0e9cdec3a5e995c9847563ad430da7fb91e71d952b49d4df65179363d2a9289d5a027c8c021b6aaea36e205b11a95a2ed3432b3034b121374fc4cd8838edcd181f573b6d6884e7a520361df5255111c551fef9d5c7e4d72fc5ab23e4d9b1b4a894a84233d1b0f37c2ebae9eadab026eba44808f7c3fcd5a991710d22d1a81929ed8a7f5b36e96ae6a4cde9189facaa23b069479cdb86f58a3311d025070d614ae803eb94387db244b1c55f45276d179e81e29a5649c6ca94c2893c449e2bf60b786a76bb14afc1178855010a1a343ad70f7a44730882717f390b669f798d45dbac7ce2ebf0748dc224c0cb01a4fbe9d88c40a638212069cd563d030899575bec6acdcc7970a9e81ec9f19f6b1caafe8b7d8002c13525f63bc8f9ec2ddffb597b9884a9dddbc87b14a665b144613d1b335d245daf22c664632b56f33934aa26db65258125b091eee92cef4fba41159f0e6cc050b6306f76a41245f40e4ba236a206bf7796896ab74b406e23dc7d07a8ae154acbcc33b60c97a84215a6ce74a679f4d0dfebf67a9d222f31ca54c66ffc5a02a4cb392372c2328889c208aa6599af6e618beb3b53f9aa90ce8e26f61580208f277acf7d4f07ed63c1cea98022150418aca50185d60401eac898165cda174f6a547f22763eddc122ceaf8d1d0f5e12900f2bde95a32a41bb325bfadaa6d0ab27ceeb5550ea8a29530a34bccf0fafddb5c5bcf36482a08d713945afe8337181161a394e911db29d864d914de7f2cc71af09ee6d29a49afd42a44d63bfe1fb6e5c10f2ef8e82c2866ead1defa1b1606d059630ac6c88f14433716a5c193faca06a834c01212b0addbf56f262f9f57d0ff22fcfedbfa727767be81c39dd5fc4c86a921e1282a32b4a6372a72947c83e8c42fd0335b28634e96a19465e01dffe428a191b68760ab908660ffa41a951dfc48ba9b44d34d25f5c818d81d3377fa8baf6e03130377643b630fd5f3c4479cee84b563e76333ebe6ee4a4dcd010b9a79b24f41c654611c01dbb1d82069201c0cba716405258dfb0ef0080da95365bc987dd32216402385e000af2dc712711ef886a5857ac3c2147144a2e89498b74d0a9003962f551105169d9f893290e1ee018b8307dc3adc77ff11e7814cda32ba89ad7aa9cc4f1dfdb2a4f259af9826e90b00909a4d40da982718ecc1c21721c88965fc35eff9cd4eba86b6b2f992a145875841b2204a8ce4feaef751ca455e038a52a4374360e9ecadce8e4784ed606eb03fa84e6d2f6193f0bef116085700cd5a5d6a5422b65f1d84a43ec1f997f11c276e8271c09f0eaca1fbf1b913ae7aa1f3ad60e84840f13c9865c1bbda82a77c8c25e75f73509bbaf9d9e249d8f341506421d1dde064f0c561679f7191e00a52f3458e3c04b1cd6c4e5a1814b87de611fbcf20f0fa2a113298fb1fce366afd1f5feb9812d80c690f284b3d9ee864c6bf2afd59800c7ce0d0a0c50a327f61d9fc725e3e3fb349c5e46c65bba537bbd5c27c7461a9d9633b0aa210453c3f0de9af4281d0c3eb7528ac3023e1c89e7430f53ea3adb2e89bf89d1e0d4ed0561c7d03e26e7926149adf467935addb657d2b0d4e4331419723bbbf0a3ac22a467c1668ed1a41f22684e4986426af481d7f897981215b788376c5e38de592008d6aec75fd4921bec356909a4e4a87b13698802c1141024968c663fab070d37e862010d0c6a29eefbd2881b86f2171b06c422678603853c7501afcd60d41ba2b170d093eb904cc8b9a4304dddfe094431e57325b4c5865bad2f274a825bce7e79ae0bd3594c3e9fcafaeaf1cf0c44727824b8269e5c0554ae7b5930f9c945a7aafd202fedfe54e31900256b8c994097a1f5030899229d9604741fa4cd982a65b4233a099d3a15eb80e0e0f40acca078aa2890dab68ed5eb8a7f30796e8167b0017f2dc58eeafde95aa2b94466b306470bd355e238a35ee9dee3d853cf2f85aef109e469cc7f2080ed22f9b2f3eb4a3905ebf5a97eb1ed98fe1896b1e6a7424267e8eb1f3e542cf19cf246fdb0cddf756cab8887b1229c972e67b86c1a89fb5ed02ffe4a9430b3f706b49b41ff85590286b6c14760a9d7aeb495aa0f458fbf31d24ecd736014a6c69a747cbb5c875f31d04ce6e9c938df02fbfb99c9119d6a91810d21f76034f66afb4edc4ab363411594fe58892ac56ec257304370cc3cc7ac4f67d2c434d29fbd60d8daddd1a9710a0ad0a70f4210e8b5d1582bc06fbe1c1a3e4d92abe8acbe65da1a90749c91e92de70e6d02dddf039a176c25455a2ef1f2e5d0bbaf21c5caeb113d9c63869ee912326360c115594826812d9da0b66fbf3558cf6b38846faa20115dd83f220c885c90444a6ce9c63f8365fa27ad48eb3e2c9ee722ac8ec1cb47ca6c13b7123471f799d4beff955e5f16dbef9eb717a1b83a71ebdd1ea562b48a7a197b16b14ca2f8cd01cdf66a2aea9ef483b24c6c953f5a7b9eacc70f844d5640e9cdea2263b26718bd7b2c8449bad793d0a976a7511a90e60686eb925a669335dd1e253b4058c8ee7c2cf7c7530c745319e75a9770148cd67e0545275c4854e13e25a7865667e827b698d447678ef750e2d62608d145b9318b44ca0a733a1c95545c9f622c33b015ce4003c85fbf2c65e2efe9f0ddb6712009ae658e1c51c7546bdd3ccac43cacbe617e6c21717c2cb1fa0607e97aedef3ff3bee6bd1445e1e3e9355c2109142494b153e8f8c27ba711a2f2b65439a6e0e28706e85393a48baee59b04629daf9ef11ea0abfb1f033cd4751f46cfd95fbc5deb41c3ce61c22a55cce2c9dbe8beb437c543d0000e7a49eb924f5d7af088a171e05fe16e280e38cd8d5de63aa1efde515fc96ab6d4125475dda204a782aff06fa497a580481f419fed179344d3c2d3b66f1dcfd1a06ee6ea16b4aaefe0940a613bb1fbcad5fbe7bd6a5b6a803ee7f140a2463503d9eb38ec3e1e642a82ba497bcea4a51811fb7479992f6ab8bf805b3ceb8cff0bd47a9d3c376111ecabaec0d44505c090b107930e96286bba8ce0b2ae7859e6229289e714822646884e155a53120a08bf5ffe0173a71499e7a8e4677ebf21c4fc8885e00bc243121e72656cb65da8d1f64836936e43386eb0423c37f1671ee413f9acda7d1aae1a1791ff8fd6e50964d20dab8d9919bea6a1383d09bc69a524469356a6c7d393b2491e90bc47ad51a0ace19965e782e530057376da897c8e36bbcffb664389ce01250281eca28a2bb7d01f3e4fe76299d19ac12903bde89ab90e380f06ec1ca7ca50ca83762c839b8a7a324f3039c7ccf54717c21744f9bc8ebba83319ef0719a47b166788e87e8659d82aa1715984f0529c38cc10f4537aa38dbe333cb2d6b29dc58aa51d56b08b6a842745f4229a2ed736f5a1b1e2133baa5afadd130ade4abd206fbc26896e430e32765e13c0dd067d371a1a88a2756a0bb0cc8f58c82dbd4c04db03513da2967e44976488d635c8933b681f7d3542a72543636e960d09303a8c6c585ddf5bc27340fd823ca155f1b65a427249544c29474c53e63b5d9a0a8a269f47c8c619ab43e831ffdf6ccb1ee7cb825901e597caf791827c4356fcaca7657255a4d0abd4d77492512c4be25f470a3fd05474187ee172ed353f2703931edc0f2f154b4778322726a6f3e0469656329a7399211f1cbd3d19645a6d328c9dee06cd688f9c2679a206eafe597edcc986397cca520cea0c708ba690d00a22d32591b616c27eee82a06f593d43c8c4dd225a3e4decb7bc722e554e51da54a9933722e327e5e51a49b36c4d459dee6918c07f23864ceb4e7e35941a7ae49589a99e4c1e6523d7e6f9aa07fb8641f53c9b1d5c69eef24d8e8a844cc65e0d50283ea3522600eda97cfeec47f767fc99cb55f97fc563eaeedda16d31164455de5b3482e6df8b8a3ef146ba257d7f9e77af371f2546ec58b19e1a4d32656965cb7700100d8846c35543096c5b30082d7617c999d24edf6781d78f5beeff8cb9287037c2886592541e66c9b9cf80065c3bdd093e6ff02cd802164ecf521d0bf0bb865686adbef18909baf4db2b4e4b485663289b66f6fde681ba35f43cf6d8328232d4c39850e74bc3b059f59746da0a7660a76df026f558cfea38793015ed1cb21c56a0d86380305890d3397798e99fe4770fb572218633f2e24c571abfec3235b0f28ff15bf2afb24ed0de04b53145966780a118e2143b21885d2eef44d296ed8563b52f576b9d06ad3b6dde5271407013b8220ac73fa2698341f93f985f8e6ae9d851a09db244a4d532e4b0cec5b75a194e1adf0afa7a62f2b965c241afb9f29f13129df1e508e5d9125af0a7772c243d8a4cb72ccb9e04b848e9f7987ea3aab62e68583c718201da76cc3b96a6e3808fe4ff4c313cc608d33320f9a458e3125243b290680ce728e977b5145865b2935307fc6f9b2306b66ddff7553135a26a0d1e8372b4ad81a2b49344f561fa1819591f6c8ba3e81b067f6e2b6a317596f230e0bd65aefe3ddeceb86e43666ca6cbc9fb0d58c4375aedad6e4d6d4ecdc98bbe6304c23c2aa7d491f1d8f934a4dd15c946ceaff09c72bf9ad83300d001bcc652cc607f2d3e01c46ff0792b666d632125a2dca56f191630e9bb5f190d54a21a83132acd0d60e26a9493597b7226183c05fef863c52609d6b27b6b3acab2d86857cfd1327c4b29ea3783d1866342540c5db9b592233bad2c8b82c2c08613f296f5ce4fa522596cfda28af6daf1c2c992f39a13432a1088e73399b6d36d9278125db4ce3a30bf89e176622f84b59694f026660a5d089d0ea8ab09c15e0f60b72a4dff4700e6968d7a18c5433c6ca4b648ed5a2153222729075c9b9a4c425591425273dda6aeba6e76831bdabcbf860c6000a5db0eb7213e84ab16ec8bd576352f4e13cd50b8f9ef334ad1fc31f0bb95b44fdaf83a7fa64a54337b3b036a338e53966f8725597c95a95300b0971065db81b26ce5ac5b67c2eb26b97f193b51d15f31aa3ffa2366b9f96bc5a4546993a700972642c06cdebbefe950032e98caaf9dfa27d7388c55e8c6a42d0dd907636cef304403920a4fd32cf42c49b9b875c587045b4c8fab7d14ad4e15a0035de3606344f96ad9c0f59f83ce2a36efc98b047dc2bd598c84066fa7c60879fa12cd832e1a1a60ce01b91afc0800683ea0e66231b9813dbbef272982afd456921a9454b9791761b03b3290ee77afd1cdd1d04650ff3a6d5441f727f30ccff7c5d177f5f2455c82c26ae0b4329b33a68f1616453475f5c397d99821839e4b345e37f8cfc0531e15845b3f35d1179849dcedf701d08c5872774cac98f8d952e932c4c4f0bf0028b09aca08ff9f11cbf2b1057ac0194a5e2ea8504ec4c366e25650f6b36f0d7552f68c247d84169f0f8d618a50fd820758b4df8a4f8195edb2b35268952cd26466eb17353738fdec475d2dbac6c78d4c7716bcea2c1a7aa8f322476189743187efb985ccef3128e438d6a06c4c5d11e166b6d13da3c03b985f4f478278a7e4fb6f72768a9ab7ada7e80849b69bd276ddf7a765b09ab2f19f06441259e181a79061c767a79c7eed52ba16af6d4ef6167f045afb0b589c56f645b2b1546404b598425387f5fb5f06c8ab519300496716da4dbf8578b5f5c540c6678dab8c31911d3f38d2bf820665c8a12d2fa1aba50839c3298a6279310521217b5859c79c96bedcb1ff2d61386ffca3280637dc4035d23d52ea7be29682d4d22e23d03acb36b144595a712be6a1872b1f56e23964c47d349f9782a32c3ea7a6d07458d6860d1e6fde358ced106330a801cda124a5fa3d55e0a451d939038054544d7907d67073e1fe368d1917d90b11d513be94784904d1a163fbb94f86891ea3d4a593365bdca0c794912571f6232ac2019bd7d96ba0e98fbac143c7ee2a5afff75daf57e2671fd8ebbbe0724e67cb630cd495abed21bc9b67eff97445f1a7146f08fd0212592cfd849c621c990b78c0126c86a6c74dac7093097ae1c8c481832e5ca14a8b6363c8f882ceb412212f01d02a022f16dca95eca298d4e6e0e4dcda640ed5b7f88f44bd3d4ece768fe3f8db2f9a956ecbfe14f6052f30075134c5a5336a74ea35fc68c95c4f32b78ac915cbddb35e0ff143752a553f8329fdb163d20414967ada404d9668614ce9f7a239f6c1c969e179349dae0891a8df9172863e2d4ffbbbe53ab766e5cddde44ea74ec7a0ef47554df872a0dc5a5fc80fbc11946d094083f247e5d0ef1a39f1a05c7183761640544defe093ceff6b66cfcf32db3c77f54af97912ef52cae0c90cf410b9d50a69837329eecef1192b0f5b693e8cc593b819888cc6802037ecd7a173ba5ddd4e50a3a43aea886d807b0364aca88492dfb60b9a3ba9af122ef84a1dffafb25654a43981267aefdd64140ee9fa788c975bde9e513063c5772baa43b18b2236e99ae60fdbe1810434bd3ff490c24d29ff0417e6bc008c0d30b3b6867fff10d3f2f344097a2cf6790b5c82db1f4b4bc5cebf9723e798c6264319b56562ecd6e21640fdb821698712ebe2dadd1da0686ed7dd7936e4aa6573bc801cb2071bdd98bf734a59f3fdb0a175ba48fc1d2c9cd0371546f6bf65f51d8d1c8ddc9cb75cb46f0e990670b65767734159dc7f55bc76fdf8c584dce141da3b4445613db25df381bf91781a5b34baeb41fb2b3c761c05de2adf5bbf063449b5c7824dff2c10cda46834dc9e9e0c790d17e95956b4cd131e5ca999180cf6a3a7cb8b15da23e9131b32fb4745e3f9f4584423d610810d123c6162a6561fb201257805a151b49290192309f9d26aa960955160dc0b9ec41ae6318d0f368a08e56385875abef8528fd5714ad69e2abb0a8ab18410b21b00048be530ab6dfe947c75aac6454a1e2b27a7abf5b6eb6510c8e93e68669ef50792c490fe57a9ec223a41fb7590d4efdac4614980150f06c6753e3af68f4710252c43c371c4ccfc80cd17663483fd1406514f32ce781bf47f1e3f0ee5bf415950b729295aa07c35fba37d0a04808f04979fea8d63e3d521d6ba005b30e35285d1c80a087f9d5d542aa49ad01e1bd2686afdffc18e00d46d5f8d89fef8017bba7797be3a2ca630998720961000e30e077556a4e754653558379c49b4ca5b2524540ddc08b91c0fecfbafd2a35ab38207d9fde5e48163ab5c581ec33ca97cb5ed506671c1cc8f7baa71473f2b31fde3dd9df732c924c0c05667e0cf7b952b15db8b7b10d1779ed569be995816992ec6dccaa41697d09e8b9d80ff9c4b2d9450da560d56c7280ee294044cfccb753b3d0b73d9be8b03e08306cd9c42fddc3015616e03ead306e9a15fc3240efc25b931384eb3891aa95db830744e02292de91696f4870dc1de068246e31529ace0747ae04dfcafc62d1cf10e3210a9b4f326e9e8d9cda40b55db99250b1db34053fa2802d882cc9c6da9b3d6b0244206f09961b4e196a10f2f57611be69ac170702e64fda4eaa3c10885612eac1e10358b7992ed8f62555dc92efef0a79c074bbd318803da940577290567d2967d07853133ab834ba6477e980800fec4314a94a8ef3b83177969ccd402b85181248820e51199ef9b48e0842dc64849bd38055c8ef43645da9cb6fbce4bbb5a28884434306d4758b728b177594b956f1c41ef1197e51c48b6a5069cd3cb9be9b0f6cb513f9bf1652fad2cba358195c6112628418c80fb81abe1bcf745fd44e2925f5b52c6c3b8da56d5a07234bbc6584e4f10e49cf80d4a789f3a9f897fe07e16213940b7317eb18880c6c517c9ebf5bfde7ccf6486214fa12987894cff7a3fb9fa3ced06db3292f4c8ebcc032f807c5d7776b6e30bf737c67bba499ee1f22d1abaa47a7876072fb4059f0e002e256609e983c60c2c5254c5447af51614f2a3e6e3d2c6967aea61a9858e2d3283b4fe7811f61205f84b4233c30121aa415d9d47cc6ebc5e11c6208a67e933b7b2485390136f017fde8f14dbb9bb02bd6193f276b2e317b6abc08e8d486ab909f869364f0ba6aeae0859ed95fd9a64b10b93fbc33fe6e7fb64c24a3c056ff2f5b562227444505f806aa413e629553521df046450b5bd84ed7b44be7e16a68c4df610bd766c822dfc23c1802df7be7b31cd9f4f802108aeab5f0edcf90cd78c69762310ab01057f04485e4b12aa85566a512488a3fef83f389a26b2c8474e72dfe033d5a0031b371118136e3beda99ddcb270f29d14b18d9abd6559769cdb957e2c1670743d42fa6af182219bd483493e67347b9ac35b37c592678b5120d438ff32623091da94a4cb752b7aebe0882a9c43800faf5095b252f952fefab3f1e7e5b088622c9d2c1f40a6b1f6b54aa304278eb05625d37d9649ef794fa11d99692f1075bcf502cc058a527218983db4984dfcdb7673292a72be2e30bb060e427d89defb5448be42f83663a9eb8fb66246a7a427a1f3c7d17eb3cf4afd746a44f310192b21a524368e55234b24d74024df8663817c1924233a495a7bef55d8025d4cfcc056dd572dc47675c2867a81eb30fd79d92c4b95fca348738f713c58917258e5a880d6f312efa25c1a2b345cc3d2e04e0f9036c26d56b1829842404f591b58453f7b25b69b11ef89f768f93d59541cc9e6e283deca23bc8878e6a60139af0398254fe2aaac6fb8583389725d20a1b05165992351323c71e542f3f1c57833e6619aef463cd1f77674713a5eb0dfbdb9cc7b472b8464f0337662c20478c6ad2123f49e2116da4ff94df22bd709127def4912e6e801f64e24be66318a2b251e3b4080e4dfbb101cdc757edceaef8ebd50ea65d96e8f02d8e31e5004e6e725d7334d2827e5a00fc0774d2f4458ceabd6985a598b61d1553c0ee1aa85ab74b4a3d3b9db6a59dd1c09c14f73644b65c83ca9abc8cb989a3394455b34769b2ef3c881100803633ada8419608f32b3a9398b93fafaf8fcf9c4af0b4ba64f648d5315a2b0411162aa7e43c70af56e1d3acf7854ee759ea464fa54f71aa498b4ae7fd2329e4554078c729af8ee4e1f2b6c4e79b06232a30ad6f0aef69dd25841a1d11a35a0868e3b1080128898b906f2ffc08f36904a901a90684616931a898a3cadf3b31aaa3cc12426cc44e3c930b44a9a3399ab8295e6a120ee730364497faabf96508624be643c897d68bca1b671a9a6f2e4e5692300679d00468a9dee353d2494273e91a6ad64c9abaae6f7ffa562e4d595b738c9d7570d8f0349eabac234510ecfb2b19fca9d0a5bffd40b18dc59d603bbcdba5193bdc0760d7a3c17bb907a27d67b6a29ac06b633ac00cd7d30bda5e608ed1a196a1513d36c0dac6d033b253bfc6d572770e9a042d3c7600a1b7c561d5b5a125b65b44755f071ec15dc4b23bd85b09d64373d59faf8346a6204026a00ce50c1a0e11e8eab91708adccf4520e5081d7c3470f1f18551102b1cdbb6e88b13f92a26ebfa2dcb94f96a61cbf2b58a14b48bfde770641e23d7b4c920c0e735e7655774562870680d78258326204e1dee6c22c336f9b8d5ac65ad50b804903abd341894091cde57fc52e7b8ec59e3334bf3caf2c63829983a19cf7f9463d7973cea3effaba34b00f48487f1bafa2788782a0d881117f768360b085c7f21f0e3f4a96b212ca92f5cb69e801c72b83b39e38f40769177c74c78f0b2cfcb4712061d4ddba9056ad52be62689bba51d4ee7c6c40463a56119b123dfc0cbc686e8be076e5ce3594e33c84d07ea233a653853e584da532b18529a81742deda7365245b4bdb71fe835b57d5bee00e52be25decff25012edca65c672edec7eb2752d423cc7e54b69c37760529f61fb65253da6d938788a28693f003c8e4fe2f0e5c7b853ae5ab3545e78ff7fc868fa1897c3975bccfe20fcd87dc15d6a7260658f3974d51f78f9adb2252a359138c6e884f7ed28b85e20ad1aee8ace564fbce1aed0d218cb21acd60c10d139e29ab196d86770574ac37f8ba4f6f25ac7d4be597eb5face91092d4f34f440d041c3ffa36e2e23e2e9b9f91eef1ed572c03c8068ddeca2d3b0817433cd13346eca4bb93c250d4a7473bda1b351e1d9d7ba4fa7b95a51fb596ddb8b08b2bd039328f944cee2e972b174f9d4ed5d56b8ad6874add3de95c43b2b7e2db419fbc2454d4b6ac461429e748b74bb8a35053d71d21f10ae8f15aa8bd9b7b22113ef239b6da031cf54986813bc9b2530b61df53ef74a98332d494c9e34f3e3e886cf298b4d263ef2d90a2433f8d23c57c20ea2dc8bc33e831f0282f47fb69b9185be9afb1066680983106f15c3285dc70d80a78499d974ca6e35afd6442cfeff434a74f079ac1e6685adab0c4dd9c01093bfd2f19b2333c12bf6fccee9aa4f5ed7f541913483b7f82264c72f8f563739b57bfc0c42f0d53dedebcebec45fdb6b66b1afec6d719eac3312aaa52e7c9227214e5c8f7f9512888d9a6a3defcefe8a89d50f65fd7bd93f852e8319a6d62978640695e571ad442f00edaa8a09d369b800ea93e4a3842a0d62629aa0ab71f91b0b95274e926cfd495a5291875d440a7dfed4ae853834a1633a3c49c8f3e669ff2b4cf15ef8b3a9cbff8ed11f98089ceadf68867f68551d1c130bb550a4908cd5c356a7ccd446fa23b1c6e8712b96bb10ce40f4aeb5ec47078d2a2e77835d215fd3ebc2d49078c20dc7098ede7d0b18a6e2bd2a85a89be2c959f3df93e4e18d40d68b4f20a3ccf3be33251c66cde6b5a4ef74e4b677b110b8999bfcf9e9f598abc856a364eee0d2c9487f65f5d9be5fa6cf528f6d1e8c1c067929902b2ab961ecc106de1cdbb364b2fce1074427037234e2cadda8be7b080d8b2e23d3bbae1e491349deb14bed987a7ad1a55c23958d2c9ac78d38e9550c95a9cf22f2369f829a5f0e93ce054ffcf841f7c3710765deb911bdffe007b9e52cdc6f164ec0108310b056e0191fe251ae313289ef8f7fe8d57ee2c6432e3e50aa96275c2a5fb316adf47019ae8bcda6fb30d851bbdbf3eb31255928c5caddca182391918f30b0b6989ae45a38e0865eadd5870fad8185bfd01e311852a9971833e3d312769de112800b38e47fc511f25d2f69b93bdb466f3a08da0f7bfd4ba150e67d2d0f73b8145274a6e23fe18723daf17ceb4abd1ffe32fb8cef452a4553320afa78d8f2ab749b838f9babb9f7a0cb75eaf6d27f963759ba4bdb84c169106f3df8eb612f8b06b8b1f7d32a0a0461f195bdcb106ff485486ee6672f0f9b438ac9a2618483012028f04ee786d60c7f7bbcf1523a086c0ebcf009ee8ef481771fd06e161b87418431ff6aea933bdfabee46ec2b01316e0f8909fddb92a14307b8a5eb2f869866395510504ca5378192c6676be828340d9461e79fbd99695c5f01ce01d5f4cd294642e764898db38fd07ed67ff6c44c825155a984cfd2ad8cddbf54cd008622be3b606242eb5b44bdf41ab1fddf302e47ee9eca0f087299151f8df8d0346284e6f15ea489b4d169615e1cb73384e066c731338aee7e3b1191b792e224eb30eff6ee4feb294e20b60ff053bdb9fbf78ef1aeb54637adbb95faa49fd95de8ceec93c47fb496568981f72e0e4d90e2684296718d4dd6fef08dc42e8fa09f2618f8b09fecd69ece53f8ff7ece6dc4aad078dda86bdf68e6beb1d008a458aa89bc5a279a34746c6cf625a7b15665c9dd6a9f66712743c697f071e236700306b1a88d5eb324b691b70745cf831f755754429700453266e8e00d6c9e1f74d6f16683407ca4e4fc8a2dbabe378ccefb85ac6b602c3ba62084e9ddf13cbc2d61180ca687b2391366204eeae24334d6e5af6689d4b30c61a643a992b6d119594099ba5bdb2c2851bdc946c981ddf75b58c3b3d5b071e7dbd7441597b0b04893850e8e577b210545120b4f07b926e987d931359b7d45975b6f62d4e45f0880e044919925393a38540f8cc2e1e8ad9a5446f95cd41ee7a5c4d4d5cb3f667255be86a86f52bb815842303927ccf37abadecaaef24783d1fb09289682140dbf5ce763763d4b0444eaa3efa8652a41a6eda082181028a18915b89422467453f7b15c6b210c09c4f563a6812f868c037b897d5dca74df84f87add538874718a175f1e1c61ccfc0781376f77645fe7a96d3cc70eea596be9a6874b22b559d1ce3a872c8df57531c1e9c9e041ffdea21bafc7bcc36124bbb94d94a7dcbdaa9af143fa824813f152843ee2cf4fa5a0166c4674db612bf28a8f0a04e7d59947ea9d576eb4fd74c37a9c3418f18399f6cc9ac6c9fbd201c3ca9e016d93fd6c58ae7c8ce9df670383e2d54cd1cd79dd4bf07b6db7f89dafe37d14607a6ea612265e1d7a96b068098c979f7cf03c74b1be887cfd6566221a00bdf060b53ea87f98cee372ffce899c7f6e6dda573190117aea575c66296bb4c3e84c622f5d8bbf31264f3940384bf85b23da32df6ddca2372afc1a623dd0342488dfce9b0dc58c38a4e0710d03a82cc5ef6342d659a03e333cb7f62074ecf70a8be7ac40c6226305bca6624db0d44007b498ff1a1e30508fd5a9f35baa48762758e5d149e5493996a195b08230ddc8751f7d5b6c0d02c394b1180aa11729d2878c829bb98b2b796800f958b6f3a498d9160bb6bb17e4b19d9fce82579b8b56283567f1c5c82696ea94a23bf267156586172fedd736f92fcbed49b9297a4d768ec9f5b17c8be52293a5929149c00e64ae8d3526e4c74e61e5a316c790d27507323203dd255fca841d603ca340b0f05f067ed1ae94caf4c206eacd093ef8beb322170780d940efa04d683fda28ef3ad96b8f838c76b98b0ae5de02167b1b3fb3083352c7fd282c25827cde74167b5c80896e69792b843492b1f056c179746e6eb9ab99a3e2a2c26710240520d6b8f978f94e85636053807da100b3d5b053edef01a79b15dd5594e37bc1a7d36f9e55d8ed8caf431c879bed286faef280b2cb7b92875fc20558cb3efee92b891e6b15b8cbc4693a3bc10a5241e078de1a12864baad3b01869beeb611c13851566727145ef13a33f92ef9cfef46838eee19b8e8362407c816cc284d28c22bf133cc90d524293a7dd0f52c1603757d0fefeaf66eabe495a90c5aa3550a6b00ebcf95f8a557bb2bf97f2361cd4a6b16eee58c9e0d5ba787414e206fd4d36194a03303e32debc41571b131cd2df8edca8925238fe3378402417da540a446c76107eeb1a9595853059301c333a582b39712a47143b8f70c0ae9b4bb9ba5f84e1f010aa7c0a3d8daef8fc98022aa14f87295108af535d9a5846d4d4af989d712d5c43beecc3790fd0b62c35ee1b374014ae989741bbebb30469558ea1ea85812c9eb2e13ce19b73740d9e8c8f34549ba9372ad4f0c113d8b36a024b6e713752a6ac97b9656b331b89d12b13f4355e5d0f221eacf36ef7e6a13355c6dacba7b842bc6fcdbba049447769153b729f08ff48533b430847ef4c08798d43e7be7fcb638a3c3f6a88a1df1fbabf53b2de9dafb859d38effc9fc0a0aef0fce42117845641122db17f50362a645917bbc57eb58768e64071137d8674b10cdee28722ddd19f74c247c6e5b14d15a3f49f5f0f768b5407ec3e4575ac7cae171b535730e9b31c3f2a6f04951eb2f0cb9332620f9541f7ef7c9f71713d91e1e4bde5bebf30af13b4027762470eda5cdd82e710a90e7645ed106f4f91844e0c2a8fbda94cfbc7bd3cb4e12b0871862250ae9eb88eb2e4c0746e455de5a37e02b62e18cd69546a84b46d10a216e68df61f86756e60a3f0a3894ac2d04e198fb070bcaa7b22efef6543170d596cfff30c0af345d57e31312c4955d78e7344985dc2850ddc9c8bb48c60b398bb71cfd61f2a529ab1fcfdf991625ed177b9507cf80c78b53edb9345ad29b0d93b406b553c9278ae86422b838bd63f3f3713764800fe7102b5b7cf69e47627d73543a57dd50b9f2684d7bd1bc3d829811a9979bec999e05cd98965d3741c26d5440b21ad0deb1d0cda016ecc99ade8860da1f53d92248a54b578a547749c8564add86e34051ad5ce5c461f8198ed28b66f406afcc0f813bfd27f7e3ee6929593aa205843fe14930b75be7009bb01bde2d25c1eb7000b40d4504b3a4b310f199c08ecfefba5ccb0c9a2dff1cac02c2c55b99e5ccbeb1b45ee43d396df91ce9282f9b4ab16ea772b92640a713312150fe60530cafa5b5bac3bbaf3b91b08218b0bc88100263cdc145e1255fd29b03d572506c6302d479d10a215749170fa058474328baf2e4499d35cae5acfe79c49bd00c2b1c959687a85cc914f3003191a9af06d0bbc1cdb4616d87595c1594bdb6489c2e78875f770666103401f68b0d16a0c4043aca1a560c479777ff16583b1631e5abc5fd84efa66ef256ff54bf6a9b688be639196a52212c8632b0116b5fbf3c6798820a6d7b0d0d1a8bb55cdd03aea9b4d33e308997220ef82d5e9fa30dfa80309698ef1256aec820826985495559fc9eb69c4da37d87dbb14a36bd72076b48cafd4c6a3798958671856491f16501e26e30a60d3ec28da3ed066697ba3252f6f744a478b2a6174f39711b07bd97fdc4457410993a926f7b02c97c01680157911936fc0cb8166b66c19e5601bc370eb36883cff6190055f4570f665db70a5fb16f17874790dc5c381c76140c22f16c0af093c1057de3833d83994b2c5dc3717e83c0bbf496a954923629f43b02c8e90036898684d8fdbb4a30535c05ecbbd9e82fb5dbb0b037a85ae8ab2a177e5227a61537143b127b83d7d61a437f260fd0257b985a131166c6776df695f3007ed69910b5a28643572abc885572f28ce00460fd79f4f68f6fca14552737cd2338a9429d399525d3b7b7341cd5028b0a6e4b2db44d0a6288e9502a529bf4b0d49bc86dbfe2449ae7b3f28dcd7f5723d1f57a2dfbd229d8ee1642d481c1e4544c7fa2b036f55083988ba6ca1818a477917ab8f4b4425c68bdcbe46429df2661260c2368aa7d6a90752e4e6059e3d614f42ff73abf34bf9625f0d836c144e74004533fdd62985f998bccd7c1b9334b10ece9d878d
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>第九届全国密码技术竞赛参赛游记</title>
    <url>/2024/11/12/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E7%AB%9E%E8%B5%9B%E5%8F%82%E8%B5%9B%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[确切而言，这并不能算得上是游记，因为是个线上作品赛，然后没晋级
不过收获的东西也不少，值得记录一下

竞赛官网
比赛刚开始报名，我还是个什么都不懂的小白（虽然现在也是）
然后师兄师姐们在那边弄比赛，问我要不要一起报名，这种好事当然要报名（
然后就有了这篇游记（也算是游记吧

这次比赛我负责的是文档部分，当然代码也需要看懂
师兄写的代码很直观很可读，很容易就读完了，然后开始写文档
这算是我第一次写这种文档，还在积累经验中
后续逐渐完善，然后交上了，然后······就没有然后了~

通过比赛我学到的东西：

关于密码学，什么是有贡献的，什么是无效的

无效的是指，简单的缝合怪，把已有成果结合在一起，但是对学术界帮助不大
有贡献的是指，切切实实有创新点，例如给某个密码学算法新增了某个功能，或者提高安全性这样子
这次比赛，我们写的东西（不方便透露）应当算是比较无共享的，单纯将一些东西缝合在一起（当然也有可能是我写文档写得不好导致的）
虽然有代码实现，但是并未将这个作为亮点来展示，没有坚持一开始的方案（也是因为遇到的困难过多了）

写文件的要细心


感谢导师给改的文章，我看完导师标的内容，感觉要替导师吐血了——怎么这么多格式有问题的
文件保存好了，以后写文章要再翻阅

赛后看了隔壁组师兄的作品，发现了差距

无论是作品含金量和页面颜值，我们都是被碾压的
然后又看了看师兄做的PPT，很多图片，很好看
我意识到，读研的话做PPT做的好看十分重要；所以需要多收集一些做的好看的PPT进行阅读和模仿

然后就是学期计划，该推进度了（悲

二八定律：百分之70的学期过去了，只完成了30%的task
无论如何，加油加油


密码学竞赛作品制作有感24-10-17
最近和两个师兄在准备密码学竞赛，我们的作品是online-offline 数字签名，用sm2和sm3去实现
最一开始我重构了一下变色龙哈希文件的内容，去掉了没有用的代码，顺便改了一下库函数（因为有一个库，pip无法直接安装）
之后文档大致完成之后，因为是在线离线签名，可以应用在轻量级设备上，所以我想移植到单片机上，但是stm32仅支持c/cpp，然后买了个pico，但是开发经验太少导致不会玩，于是转回stm32，最终耗时二十小时左右，最终被玄学问题卡住了
之后计划使用centos-mini运行代码测试效率，开始搭建环境······
然后看了一下师兄画的图，和导师交流了一下，得知以上我做的对比赛而言并不是很重要，重要的是在图表中展示出效率之高
然后微调了一下代码···
改之前:验证结果为:1总时间为:1.7519575000042096在线时间:1.1509204999892972改之后:验证结果为:1总时间为:1.7590351999970153在线时间:0.5761120000388473
效率飙升！
画出来的图表也十分可观
后来总结了一下，写文章重要的是怎么让专家看着觉得做出东西了，尤其是画图，一定要展现出轻量级（具体值少于1s就可以了），所以数据选择很重要；还有就是注意细节，每个点都要多校验一遍
]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树学习</title>
    <url>/2025/01/06/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[BST 二叉查找树 -&gt; AVL 平衡二叉树 -&gt; RBT 红黑树


二叉查找树
左子树上所有结点的值均小于或等于它的根结点的值
右子树上所有结点的值均大于或等于它的根结点的值
左、右子树也分别为二叉排序树

理想情况下是这样子

存在的问题：如果BST树的节点正好从大到小的插入，此时树的结构也类似于链表结构，这时候的查询或写入耗时与链表相同，最坏时间复杂为线性
这时候就有了平衡二叉树AVL（发明者名字简写）
AVL也属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡
平衡二叉树
AVL树是最先发明的自平衡二叉查找树
在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树
增加和删除可能需要通过一次或多次树旋转来重新平衡这个树

平衡二叉树的特性

对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大

对于AVL树而言，其中任何子树仍然是AVL树

每个节点的左右子节点的高度之差的绝对值最多为1

也就是说，AVL树=BST树+自平衡功能
具体怎么旋转？
记住这四张图就好




那如何删除呢？

叶子节点直接删除，判断平衡进行调整直到根节点
只有左（或右）子树，节点删除，以左（或右）子树替代，判断平衡进行调整直到根节点
删除的节点既有左子树又有右子树，找到其前驱节点（左子树中最大值的节点）或者后驱节点（右子树中最小值的节点）将其替换，判断平衡进行调整直到根节点

缺点：
由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;= 1
所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡
正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于查询场景（而不是增加删除频繁的场景）
红黑树：牺牲了部分平衡性，以换取插入/删除操作时较少的旋转操作，整体来说性能要优于AVL树
红黑树
节点非黑即红（颜色属性）
根节点一定是黑色（根属性）
叶子节点（NIL）一定是黑色（叶子属性）
每个红色节点的两个子节点都为黑色（红色属性）
从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点（平衡属性）


RBT使用空间去换时间，在AVL的节点上，增加了颜色属性的数据，换取后面平衡操作的次数减少
红黑树并不是一棵平衡二叉树（见图），但是基于性质5，从任一节点到每个叶子的所有路径都包含相同数目的黑色节点，故 以黑色节点的高度作为约束，RBT的左子树和右子树的层数是相同的
红黑树的平衡称为黑色完美平衡
恢复平衡的三个操作：变色，左旋，右旋
如何维护红黑树：

初始状态只有一个黑色节点（同时是根节点和叶子节点）

插入新节点：
因为父节点为黑色的概率较大，默认插入新节点为红色可以避免颜色冲突

插入节点的Key已经存在：更新当前节点的值为插入节点的值，颜色不变

插入节点的父节点为黑色：由于节点默认红色，所以可以直接插入而无需做自平衡


插入节点的父节点为红色
分为两种情况：叔叔节点是红色还是黑色
如果叔叔节点是红色，则如图变换，再以点P为基点进行自平衡

如果叔叔节点是黑色，如图变换即可


反方向同理




实验代码
#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;// 颜色枚举，0 表示黑色，1 表示红色enum Color &#123; BLACK, RED &#125;;// 节点结构体struct Node &#123;    int data;          // 节点值    Color color;       // 节点颜色    Node* left;        // 左子节点    Node* right;       // 右子节点    Node* parent;      // 父节点&#125;;// 全局变量定义Node* root = nullptr;  // 红黑树根节点Node* NIL = nullptr;   // 哨兵节点// 初始化哨兵节点void initializeNILNode() &#123;    NIL = new Node;    NIL-&gt;color = BLACK;    NIL-&gt;left = NIL-&gt;right = NIL-&gt;parent = nullptr;&#125;// 创建一个新节点Node* createNode(int data) &#123;    Node* newNode = new Node;    newNode-&gt;data = data;    newNode-&gt;color = RED; // 新插入节点默认为红色    newNode-&gt;left = newNode-&gt;right = newNode-&gt;parent = NIL;    return newNode;&#125;// 左旋操作void leftRotate(Node*&amp; root, Node* x) &#123;    Node* y = x-&gt;right;       // 设置 y 为 x 的右子节点    x-&gt;right = y-&gt;left;       // 将 y 的左子树移为 x 的右子树    if (y-&gt;left != NIL) &#123;        y-&gt;left-&gt;parent = x;  // 更新父指针    &#125;    y-&gt;parent = x-&gt;parent;    // 将 y 的父节点指向 x 的父节点    if (x-&gt;parent == NIL) &#123;        root = y;             // 如果 x 是根节点，更新根节点    &#125; else if (x == x-&gt;parent-&gt;left) &#123;        x-&gt;parent-&gt;left = y;  // x 是左子节点    &#125; else &#123;        x-&gt;parent-&gt;right = y; // x 是右子节点    &#125;    y-&gt;left = x;              // 将 x 设置为 y 的左子节点    x-&gt;parent = y;            // 更新 x 的父指针&#125;// 右旋操作void rightRotate(Node*&amp; root, Node* y) &#123;    Node* x = y-&gt;left;        // 设置 x 为 y 的左子节点    y-&gt;left = x-&gt;right;       // 将 x 的右子树移为 y 的左子树    if (x-&gt;right != NIL) &#123;        x-&gt;right-&gt;parent = y; // 更新父指针    &#125;    x-&gt;parent = y-&gt;parent;    // 将 x 的父节点指向 y 的父节点    if (y-&gt;parent == NIL) &#123;        root = x;             // 如果 y 是根节点，更新根节点    &#125; else if (y == y-&gt;parent-&gt;left) &#123;        y-&gt;parent-&gt;left = x;  // y 是左子节点    &#125; else &#123;        y-&gt;parent-&gt;right = x; // y 是右子节点    &#125;    x-&gt;right = y;             // 将 y 设置为 x 的右子节点    y-&gt;parent = x;            // 更新 y 的父指针&#125;// 修复插入导致的红黑树性质破坏void fixInsert(Node*&amp; root, Node* z) &#123;    while (z-&gt;parent-&gt;color == RED) &#123; // 父节点是红色时可能违反性质        if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123; // 父节点是祖父节点的左子节点            Node* y = z-&gt;parent-&gt;parent-&gt;right; // 叔叔节点            if (y-&gt;color == RED) &#123; // 叔叔节点是红色                z-&gt;parent-&gt;color = BLACK;     // 父节点变黑                y-&gt;color = BLACK;            // 叔叔节点变黑                z-&gt;parent-&gt;parent-&gt;color = RED; // 祖父节点变红                z = z-&gt;parent-&gt;parent;       // 将 z 移动到祖父节点继续调整            &#125; else &#123;                if (z == z-&gt;parent-&gt;right) &#123; // z 是父节点的右子节点                    z = z-&gt;parent;                    leftRotate(root, z);    // 左旋转父节点                &#125;                z-&gt;parent-&gt;color = BLACK;    // 父节点变黑                z-&gt;parent-&gt;parent-&gt;color = RED; // 祖父节点变红                rightRotate(root, z-&gt;parent-&gt;parent); // 右旋祖父节点            &#125;        &#125; else &#123; // 父节点是祖父节点的右子节点，逻辑对称            Node* y = z-&gt;parent-&gt;parent-&gt;left; // 叔叔节点            if (y-&gt;color == RED) &#123;                z-&gt;parent-&gt;color = BLACK;                y-&gt;color = BLACK;                z-&gt;parent-&gt;parent-&gt;color = RED;                z = z-&gt;parent-&gt;parent;            &#125; else &#123;                if (z == z-&gt;parent-&gt;left) &#123;                    z = z-&gt;parent;                    rightRotate(root, z);                &#125;                z-&gt;parent-&gt;color = BLACK;                z-&gt;parent-&gt;parent-&gt;color = RED;                leftRotate(root, z-&gt;parent-&gt;parent);            &#125;        &#125;    &#125;    root-&gt;color = BLACK; // 根节点始终是黑色&#125;// 插入一个新节点到红黑树void insert(int data) &#123;    Node* z = createNode(data);    Node* y = NIL;       // 用于记录 z 的父节点    Node* x = root;      // 从根节点开始搜索插入位置    while (x != NIL) &#123;   // 找到插入位置        y = x;        if (z-&gt;data &lt; x-&gt;data) &#123;            x = x-&gt;left;        &#125; else &#123;            x = x-&gt;right;        &#125;    &#125;    z-&gt;parent = y;       // 设置 z 的父节点    if (y == NIL) &#123;      // 树为空，z 为根节点        root = z;    &#125; else if (z-&gt;data &lt; y-&gt;data) &#123;        y-&gt;left = z;    &#125; else &#123;        y-&gt;right = z;    &#125;    fixInsert(root, z);  // 修复红黑树性质&#125;// 中序遍历void inorder(Node* root) &#123;    if (root != NIL) &#123;        inorder(root-&gt;left);        cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;        inorder(root-&gt;right);    &#125;&#125;// 主函数int main() &#123;    initializeNILNode(); // 初始化哨兵节点    // 插入节点    insert(10);    insert(20);    insert(15);    insert(25);    insert(30);    insert(5);    // 中序遍历输出    cout &lt;&lt; &quot;Inorder traversal: &quot;;    inorder(root);    cout &lt;&lt; endl;    return 0;&#125;

References红黑树（图解+秒懂+史上最全）
【动态图文详解，史上最易懂的红黑树讲解】手写红黑树（Red Black Tree）
]]></content>
      <categories>
        <category>技术学习笔记</category>
      </categories>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理学习笔记</title>
    <url>/2025/09/02/%E8%80%83%E7%A0%94408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[

]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研专业课</tag>
      </tags>
  </entry>
  <entry>
    <title>网安前沿讲座学习笔记（密码学）</title>
    <url>/2025/10/18/%E7%BD%91%E5%AE%89%E5%89%8D%E6%B2%BF%E8%AE%B2%E5%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%89/</url>
    <content><![CDATA[ 学校开了这门课，只有0.5学分，要不是忘了选课了才不会选~
后来知道这门课是一个密码学大牛给上，这下不好好听了
总共八节课，前四节是基础，后四年是近几年的研究成果
感觉尤其是越到后面，听完之后的感受毫不亚于去参加一场学术会议
对于后几节，记了很多东东，原本写在纸上了，今同步到博客上
字有点乱，但是管你看不看得懂——爱看不看（光速逃




]]></content>
      <categories>
        <category>会议竞赛游记</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>马原学习笔记</title>
    <url>/2025/08/18/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB-%E9%A9%AC%E5%8E%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[





















]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研政治</tag>
      </tags>
  </entry>
  <entry>
    <title>网鼎杯2024crypto题解（青龙组）</title>
    <url>/2024/10/29/%E7%BD%91%E9%BC%8E%E6%9D%AF2024crypto%E9%A2%98%E8%A7%A3%EF%BC%88%E9%9D%92%E9%BE%99%E7%BB%84%EF%BC%89/</url>
    <content><![CDATA[目前只更新了青龙组的题目

CRYPTO1from Crypto.Util.number import *from secret import flagp = getPrime(512)q = getPrime(512)n = p * qd = getPrime(299)e = inverse(d,(p-1)*(q-1))m = bytes_to_long(flag)c = pow(m,e,n)hint1 = p &gt;&gt; (512-70)hint2 = q &gt;&gt; (512-70)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;c = &#123;c&#125;&quot;)print(f&quot;hint1 = &#123;hint1&#125;&quot;)print(f&quot;hint2 = &#123;hint2&#125;&quot;)n = 114118679597315994458138232536029700477506764789782067073905766324635160145597602207164997807103187990046901850125798774503781767630201814025142189432534890147340404293319424524872695905368897290630698362559606549134377263394129199145835483978820237203114250882524438599220793209608842281879976692805855046971e = 60930873636939710528141652371287627298970658591028170597199994159301433213017349592910581153194811053524011559886529831760967700162629319952838130973563991607758850226327915934518549584588693854388996425152821459866209334446088324204759334980239670811977086959854952233887459542997456604453766160444477603017c = 11058775585296329544235824126670578486484201903851563493984057289075513008773878014007377223222464555346135675900619903617528838701118612201290486747980233570288315027654510774940371032813981282018787668864123759554297515664915358447425647424759926416629451915378248520432568536260902676664298855076689608823hint1 = 884675140903190287932hint2 = 1000130673738973880482

和领航杯2023密码学题目bd为重题
原来原来是论文题
有两种解法，一种是基于格规约的，另一种是基于小私指数的
#referencehttps://www.cnblogs.com/mumuhhh/p/17789591.htmlhttps://dexterjie.github.io/2023/09/12/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/2023%E9%A2%86%E8%88%AA%E6%9D%AF/?highlight=%E9%A2%86%E8%88%AA%E6%9D%AF#bd
CRYPTO2# coding: utf-8#!/usr/bin/env python2import gmpy2import randomimport binasciifrom hashlib import sha256from sympy import nextprimefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom Crypto.Util.number import long_to_bytesfrom FLAG import flag#flag = &#x27;wdflag&#123;123&#125;&#x27;def victory_encrypt(plaintext, key):    key = key.upper()    key_length = len(key)    plaintext = plaintext.upper()    ciphertext = &#x27;&#x27;    for i, char in enumerate(plaintext):        if char.isalpha():            shift = ord(key[i % key_length]) - ord(&#x27;A&#x27;)            encrypted_char = chr((ord(char) - ord(&#x27;A&#x27;) + shift) % 26 + ord(&#x27;A&#x27;))            ciphertext += encrypted_char        else:            ciphertext += char    return ciphertextvictory_key = &quot;WANGDINGCUP&quot;victory_encrypted_flag = victory_encrypt(flag, victory_key)p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fa = 0b = 7xG = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798yG = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8G = (xG, yG)n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141h = 1zero = (0,0)dA = nextprime(random.randint(0, n))if dA &gt; n:    print(&quot;warning!!&quot;)def addition(t1, t2):    if t1 == zero:        return t2    if t2 == zero:        return t2    (m1, n1) = t1    (m2, n2) = t2    if m1 == m2:        if n1 == 0 or n1 != n2:            return zero        else:            k = (3 * m1 * m1 + a) % p * gmpy2.invert(2 * n1 , p) % p    else:        k = (n2 - n1 + p) % p * gmpy2.invert((m2 - m1 + p) % p, p) % p    m3 = (k * k % p - m1 - m2 + p * 2) % p    n3 = (k * (m1 - m3) % p - n1 + p) % p    return (int(m3),int(n3))def multiplication(x, k):    ans = zero    t = 1    while(t &lt;= k):        if (k &amp;t )&gt;0:            ans = addition(ans, x)        x = addition(x, x)        t &lt;&lt;= 1    return ansdef getrs(z, k):    (xp, yp) = P    r = xp    s = (z + r * dA % n) % n * gmpy2.invert(k, n) % n    return r,sz1 = random.randint(0, p)z2 = random.randint(0, p)k = random.randint(0, n)P = multiplication(G, k)hA = multiplication(G, dA)r1, s1 = getrs(z1, k)r2, s2 = getrs(z2, k)print(&quot;r1 = &#123;&#125;&quot;.format(r1))print(&quot;r2 = &#123;&#125;&quot;.format(r2))print(&quot;s1 = &#123;&#125;&quot;.format(s1))print(&quot;s2 = &#123;&#125;&quot;.format(s2))print(&quot;z1 = &#123;&#125;&quot;.format(z1))print(&quot;z2 = &#123;&#125;&quot;.format(z2))key = sha256(long_to_bytes(dA)).digest()cipher = AES.new(key, AES.MODE_CBC)iv = cipher.ivencrypted_flag = cipher.encrypt(pad(victory_encrypted_flag.encode(), AES.block_size))encrypted_flag_hex = binascii.hexlify(iv + encrypted_flag).decode(&#x27;utf-8&#x27;)print(&quot;Encrypted flag (AES in CBC mode, hex):&quot;, encrypted_flag_hex)# output# r1 = 28857061626266697731960297346547380130694223166851804642930502594650578288425# r2 = 28857061626266697731960297346547380130694223166851804642930502594650578288425# s1 = 81842916501936654327181596127464444170184582938148211467350979906270329843047# s2 = 54199410087637342004207138894657653701426382978399616033659324046436549994669# z1 = 114768147762808206397023700697633814229154932218327120646122869299219028759434# z2 = 63513092260201266423877548128429517837199255134650637253201969399356248912467# (&#x27;Encrypted flag (AES in CBC mode, hex):&#x27;, u&#x27;51559ebae12fdd12e0e84df2baf07e3389b688398a71b62717fb77e0f6abdd40d848ee028b70681bc566ef2729d80b7a2778ad5b322b68501b6bbcef820b4719&#x27;)

观察这一部分
def getrs(z, k):    (xp, yp) = P    r = xp    s = (z + r * dA % n) % n * gmpy2.invert(k, n) % n    return r,sz1 = random.randint(0, p)z2 = random.randint(0, p)k = random.randint(0, n)P = multiplication(G, k)hA = multiplication(G, dA)r1, s1 = getrs(z1, k)r2, s2 = getrs(z2, k)
已知z1,z2,r1,r2,s1,s2
有方程组

\begin{cases}
s1=(z1+r1*dA)*k^{-1}\quad\mod n \\
s2=(z2+r2*dA)*k^{-1}\quad\mod n
\end{cases}联立消去 $k^{-1}$ 得到 $s1(z2+r2dA)=s2(z1+r1dA)\quad\mod n$
提取出 $dA$ 得到 $dA=(z2s1-z1-s2)(s2r1-r2s1)^{-1}\quad\mod n$
容易得到 $dA$
import gmpy2dA = (z2*s1-z1*s2)*gmpy2.invert(s2*r1-r2*s1,n)%nprint( dA )
#outputdA=10570650820062854135188945698682652204931348462301149982644765996528871376101
无脑解AES和古典即可，这个ai就能干
import binasciifrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom Crypto.Hash import SHA256from Crypto.Util.number import long_to_bytes# 使用恢复的私钥 dAdA = 10570650820062854135188945698682652204931348462301149982644765996528871376101# 计算 AES 密钥key = SHA256.new(long_to_bytes(dA)).digest()# 输入你已经获得的加密数据encrypted_flag_hex = u&#x27;51559ebae12fdd12e0e84df2baf07e3389b688398a71b62717fb77e0f6abdd40d848ee028b70681bc566ef2729d80b7a2778ad5b322b68501b6bbcef820b4719&#x27;# 从十六进制字符串中提取 IV 和加密的标志encrypted_data = binascii.unhexlify(encrypted_flag_hex)iv = encrypted_data[:AES.block_size]  # 前 16 字节是 IVencrypted_flag = encrypted_data[AES.block_size:]  # 剩下的是加密后的标志# 创建 AES 解密器cipher = AES.new(key, AES.MODE_CBC, iv)# 解密并去填充try:    decrypted_flag = unpad(cipher.decrypt(encrypted_flag), AES.block_size)    print(&quot;Decrypted flag:&quot;, decrypted_flag.decode(&#x27;utf-8&#x27;))except ValueError as e:    print(&quot;Decryption failed:&quot;, e)
#outputDecrypted flag: SDSRDO&#123;2DZ35AN97NP3EY15602G02H5ZP50R287&#125;
def victory_decrypt(ciphertext, key):    key = key.upper()    key_length = len(key)    plaintext = &#x27;&#x27;    for i, char in enumerate(ciphertext):        if char.isalpha():            shift = ord(key[i % key_length]) - ord(&#x27;A&#x27;)            decrypted_char = chr((ord(char) - ord(&#x27;A&#x27;) - shift) % 26 + ord(&#x27;A&#x27;))            plaintext += decrypted_char        else:            plaintext += char    return plaintextvictory_key = &quot;WANGDINGCUP&quot;t = &quot;SDSRDO&#123;2DZ35AN97NP3EY15602G02H5ZP50R287&#125;&quot;print( victory_decrypt( t , victory_key ) )
#outputWDFLAG&#123;2BF35AA97FC3CE15602D02B5FA50E287&#125;
最后转成小写即可
print(&quot;WDFLAG&#123;2BF35AA97FC3CE15602D02B5FA50E287&#125;&quot;.lower())
#outputwdflag&#123;2bf35aa97fc3ce15602d02b5fa50e287&#125;
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>cryptoCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>荔枝橙味CF糕守</title>
    <url>/2024/11/11/%E8%8D%94%E6%9E%9D%E6%A9%99%E5%91%B3CF%E7%B3%95%E5%AE%88/</url>
    <content><![CDATA[本文汇总了CF如何上分的两篇博客

来源于2426rating 1000-1400到达青名（1400）需要做到三点。

能够快速写出模拟题（5到10分钟内）
能够快速写出暴力（5到10分钟内）
能够在脑子里或草稿纸上把问题分情况讨论（例如，N=2、N=3、N&gt;=4）

举个例子，在Codeforces Round #556中，如果你可以做到以上三点，就可以很惊喜地在Div2中达到200名，这是一个很夸张的例子。但在Codeforces Round #554 (Div. 2)中，你只能达到3400名，rating1250及以下的参赛者可以上分。
平均来说，如果你可以做到以上三点，rating就可以达到1400。
[[如何训练]]
首先，建议打ABC；尽管CF上有很多好题，但如果你想更容易地练习编程，最好去刷AtCoder。
特别地，推荐做ABC中的B题和C题。做B题可以学到如何更快地写模拟和暴力，做C题可以学到如何想题、如何用草稿纸更快地想出解决方案。如果你切了所有的B题和C题，就会学到很多，变得更强。
可以借助AtCoder problems的帮助刷AtCoder，你能从这个网站知道自己做了哪些题。
当你刷AtCoder时，有几点很重要：

当你想不出解决方案时，应该在思考B题15分钟、思考C题30分钟后再看题解。可悲的是，最近几场ABC没有英文题解，但你可以读标程（题解中很可能包含标程的链接）。
即使你AC了某道题，在习惯快速写代码前，还是可以通过阅读大佬的源代码学到一些东西。所以建议看一些简单的源代码。
特别是当你做C题时，推荐你用草稿纸辅助思考。不用纸的话，用白板打草稿也可以。

rating 1400~1900CF上人数最多的rating区间是[1400, 1500]。他们都很想上分，但从1500开始上分比较困难，很多人放弃了。但也有很多人坚持训练，成功上分。
要达到1900，需要下面的技巧：

掌握并能够使用以下主要算法：

暴力
动态规划
深度优先搜索
广度优先搜索
迪杰斯特拉
树状数组
排列数、组合数
乘法逆元
位掩码
二分查找

注意：一般而言在rating 1800前，线段树不是必须的。上紫以后才需要学的线段树。

提高手速（例如，R1100的题目5分钟写好，R1400的题目10分钟写好）。手速在CF很重要，因为一般来说，如果题目难度范围很大，手速会在很大程度上影响rating。


[[如何训练]]
如果你不擅长快速写代码、快速调试，就应该刷AtCoder。事实上，从统计学上讲，很多日本选手手速很快，但不擅长解决难题，觉得是AtCoder的锅。
推荐做ABC的C题和D题。平均来说，如果能在10分钟内解决C题，在20分钟内解决D题，你就是手速场中的Div1
如果你不擅长解难度高于R1400的题，就应该学一些上面提到的算法，做做CF上的板题。举个例子，如果你觉得自己不擅长DP，就刷CF上R1200到R1400的DP标签的题。让人惊讶的是，只有约50道难度小于等于R1400的DP标签的题。
有趣的是，板题都集中在只有Div2的那些比赛中。如果你不擅长只有Div2的比赛，那么很可能是你不擅长使用典型算法，尤其是上面提到的10种算法。
如果你能做板题，但不擅长做难度高于R1500的题，就要开始在TopCoder刷题。这类练习对擅长只有Div2的比赛但不擅长Div1+Div2一体的、分开的比赛的人十分有效。
有时候，尤其是在Div1+Div2的比赛中，一些题目需要数学概念或者思考。因为TopCoder上有很多题用到这些（另外还有简便的实现！），所以你应该刷TopCoder。
推荐刷最近100场SRM的Div1简单。但有些题真的太难了（甚至粉名都切不掉），所以刷之前，你应该看一下题目的通过率。你可以利用https://competitiveprogramming.info/来获取一些信息。
不幸的是，不知道有没有像AtCoder Problems那样，能够看自己在TopCoder SRM中做过哪些题的网站。所以，如果你想记录自己刷过那些题，应该做一个电子表格或者表格，例如：https://drive.google.com/file/d/1mSy9PM4Km8EVv8Lp4nhitorOe2HbAS1e/view?usp=sharing
当还是个蓝名时，数学思维也很糟糕。在切了50题Div1简单以后，在TopCoder成了蓝名，在CF成了紫名
如果你擅长切题，但在比赛中发挥不好，就应该多打虚拟赛。你知道CF的虚拟赛系统吗？你可以虚拟参赛！
rating 1900~2200如果你想达到2200，首先，你应该是Div1，并且参加Div1的比赛。这意味着你应该刷很多难题（R1900或更高）
即使你手速快或者十分擅长切板题，打Div1比赛也是很难的。可悲的是，有很多选手在蓝名和紫名之间摇摆
要达到2200，需要以下技巧：

知道并且会用上面提到的10种算法，还要加个线段树（包括懒标记）
非常快的手速：R1100 5分钟，R1500 10分钟，R1800 15分钟，R2000 40分钟
相当好的数学思维和思考问题的能力
强大的思维，可以支持超过1小时的思考，即使在Div1比赛中途落后了也不放弃

[[如何训练]]
这只是的训练方式：在rating2000时打了很多虚拟比赛。在这里，虚拟比赛并不意味着“虚拟参与”，而是选择4到5道难度在自己rating附近的题目（举个例子，目前rating是2000，那么选择CF中R2000的题目），并且在2小时内切掉
你可以利用https://vjudge.net/。在这个网站，你可以从很多OJ上（AtCoder、CF、Hackerrank、Codechef、POJ……）拉题组一场虚拟赛
如果你在虚拟赛中不能切掉这些题，而且没有想出解决方案，就应该去谷歌查题解（举个例子，如果你想找Codeforces Round #556 (Div. 1)的题解，就去谷歌搜“Codeforces Round #556 editorial”）
在CF上分还有一件重要的事。为了更快的手速，你应该准备一些板子。例如，认为线段树板子、懒标记线段树板子、CRT的板子、FFT的板子、计算几何板子等等都是很有效的
rating 2200~2400这是本博客关于训练技巧的最后一部分。事实上，卡在橙名很久了，就连在虚拟赛中平均表现也是橙名。这是因为之前的训练方法在橙名遇到了障碍
Rating 2200到2400事实上非常难——如果你平均表现2200，如果你练习赛打得更多，上粉（到2400）看上去也没那么难。但是平均表现2400比你想象的要难得多。如果你的rating正好是2400，那么在Div1的比赛上，你一般要打进前20%（例如，如果有525人参加，那么你应该最差在105名）才能上分
要达到2400，需要以下技巧：

Rating达到2200
在Div1比赛中切掉AC少于100人的难题

如果你想切难题和用ad-hoc临时方法的题，根据TozanSoutherPacks在上一篇博客下的评论（http://codeforces.com/blog/entry/53341?#comment-373965），“要达到2600分乃至更高，你应该切Boss题，所有这些都是临时问题或者步骤很多的问题。”觉得那是对的，但是对来说，觉得即使你只想达到2400分，切步骤很多的临时问题也是有必要的。
[[如何训练]]
达到2400分最安全的方法是“切4000道题”。就在TopCoder、AtCoder、CF等OJ上切了超过4000题
事实上，有一个传说（或者说是事实）是，最NB的选手tourist在他这辈子切了一万多题
但是可能很多人觉得自己没时间。所以会给你一些更高效的途径
首先，AtCoder上有很多教育题。推荐你做ARC尤其是ARC058到ARC090的E题和F题（尤其是AtCoder中700到900点的题目）。尽管以前的ARC在“思维”和“模板”之间是平衡的，但可悲的是，认为AGC和最近的ARC实际上太偏向思维了，所以如果你的目标是在CF上分，不推荐它们（尽管如果你想达到2600乃至更高，还是要刷AGC）
对来说，实际上，刷了ARC以后，在CF虚拟赛的平均表现从2100提高到了2300（I could not reach 2400 because start was early）
如果你切不动题，推荐你放弃思考并且看题解的时间如下：




AtCoder点值
CF难度
思考时间




600
R2000
40分钟


700
R2200
50分钟


800
R2400
60分钟


900
R2600
70分钟


1000
R2800
80分钟




如果你切了AtCoder上的教育题，你编程比赛的技能将会有所提高。但还有另一个问题，没有付诸实践，你没办法上分
所以，你应该至少在CF上打50场虚拟赛（尤其是Div1）。在虚拟赛中，你可以学到，紫名、橙名应该如何打比赛（比如比赛策略），以及如何在CF比赛中利用在AtCoder学到的技巧。强烈推荐在虚拟赛后看看所有题的题解，除了太难的题（比如在比赛中AC人数少于30的题）。还建议，在打完比赛看完题解后在笔记本上写一些对于比赛策略、教训和可以改进的地方的反思
此外，建议你每周一次，花点时间思考一些难题（比如CF上R2800的题）。如果你想了很久也想不出来，建议你去读题解，因为那样你可以学到很多。解决难题可能会给你一场上分100+的机会，也会给你更快解决简单题的机会
最后，猜这个方法对于超过30%的人奏效，因为用这个方法在CF上粉，square1001用这个方法在TopCoder上红。希望的方法可以产生新的粉名
训练心理心理问题是选手中最常见的问题之一。即使对，直到最近两个月前，出于对一场掉分100+的恐惧，超过9个月没打过CF上rated的比赛。另外，还有几场比赛甚至都做不到看下一个题，因为做不出来更简单的题，心态崩了
最近发现一种锻炼心态的办法

制定一个比赛前的常规程序。这能让们在比赛期间集中注意力
事实上，就而言，的常规程序是在比赛快开始时看着倒计时减少到0。黑红大佬yutaka1999实际上在IOI开始前就在修禅


如果你比赛中没发挥好（比如20分钟内切不掉B题），不去看榜也是个好主意
还有一件重要的事：“比赛过程中不要管rating”
觉得，即使这场要掉分，下一场上分的可能性也提高了。这就是为什么在比赛过程中不管rating


不要过于在意之前犯过的错误。错误也是一次好的学习机会，每个人都会犯错。即使是tourist也曾经在AtCoder World Tour Finals上翻车
觉得吧，“rating”和“你犯过多少错、做过多少反思”之间存在关联



以上这些方法不仅在正式比赛中适用，还在虚拟赛中适用。注意：比赛中不要有太大的压力，开心就好

来源于2909上级篇是针对想成为AtCoder黄名（2000+，对应CF2200+），以及橙名（2400，对应CF2522+）阶段的选手的进步指南

右边的评价来自于AtCoder的老版chokudai的博客

成为黄名选手的6个要求为了在AtCoder里成为黄名，你需要达到2000分（CF2200分）

在AtCoder Beginner Contest里稳定切掉5题
在AtCoder Beginner Conetst里半数情况切掉6题
简单的问题（500分内）尽快解决
根据相关数据，A题1分内，B题2分内，C题5分内，D题10分内，E题20分内比较合理
理论上你最好在40分钟内切掉5题
AGC之类对数学要求比较高的比赛里，最好能切掉2题

这是在竞赛里黄名选手的平均表现。为了保持这个表现，你需要做到以下6点。当然水色选手要做到的4点你也要做到（中级篇内容）
条件1挑战程序设计竞赛（AKA蚁书）上面记载的大部分算法和数据结构都要理解。具体来说，需要了解以下23个算法和5个数据结构
中级篇2-1节里的12个算法和3个数据结构
枚举	二分搜索	深度优先搜索	广度优先搜索动态规划	Dijkstra	Floyd	Kruskal线性筛	快速幂	逆元	前缀和·差分图论	树	并查集	
中级篇没有提到但是挑战里写过的11个算法
离散化	分治	矩阵乘	博弈论(原文是Grundy数)	字符串哈希 分块	最小割	二分图判定 二分图匹配	
中级篇没有提到但是挑战里写过的2个数据结构
树状数组 线段树与懒标记
条件2
条件1介绍的算法和数据结构，在各种比赛里学会使用，同时将本文介绍的算法和数据结构熟练掌握，变成自己的东西
条件3有一定的数学能力
在AtCoder里，不仅仅考验你能否灵活使用各种算法的能力，也频繁出现了大量的数学问题（和中级篇2-3里95-100的问题一样），问题也越来越难和多样。因此，为了成为黄名选手，要多多做一些数学题
条件4
25行左右的程序，基本Bug Free写出来
60行左右的程序，基本很快地写出来，出了BUG也能在10分钟内解决
实际上，60行左右的程序，能够30分钟内写完并且de完bug，是大概率能AK掉ABC的
条件5
打字速度要快！经验来讲，1分钟要350个字符才够用
实际上，一些高排名选手里也有打字很慢的人（200个字符左右），但是想在ABC里拿到好成绩，打字速度实在太重要了
比如说AtCoder 148里，30分钟AK和40分钟AK，差距250以上的表现分
条件6
一般来说，AtCoder的过去的题目要做1000题以上
补充
以上的6个条件满足了的话，ABC的E问题基本难不倒你。F问题的话，如果是超过250人做出来的场次，你应该也能做出来才对
顺便一提，最近15场ABC（141~155），F问题做出来的超过250人的场次有7场。因此AK掉ABC的概率应该是3-5成
满足了6个条件，再练练数学能力，AGC的问题解决出来的概率应该会慢慢增加
总结
掌握11个全新的算法
学会2个新的数据结构
去解决TopCoder SRM的问题，锻炼数学能力
去解决JOI（日本信奥）的题目，锻炼能力
解决以前Contest的题目
多多VP找感觉
练打字速度


references:
https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-1-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-10001400
https://www.acwing.com/blog/content/15042/
https://juejin.cn/post/7186915748395270201
https://www.luogu.com.cn/article/yx1u034q
https://blog.csdn.net/m0_45699242/article/details/123741377
https://github.com/azl397985856/cf
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>荔枝橙味拱腰觅马糕守</title>
    <url>/2024/09/11/%E8%8D%94%E6%9E%9D%E6%A9%99%E5%91%B3%E6%8B%B1%E8%85%B0%E8%A7%85%E9%A9%AC%E7%B3%95%E5%AE%88/</url>
    <content><![CDATA[本篇文章旨在记录笔者阅读《公钥密码方案构造及安全证明的知识要点和方法论》的学习总结和收获


Introduction
归纳总结了构造可证明安全的公钥密码方案所需掌握的知识要点

基本概念

数学基础

简单问题和困难问题

算法

安全规约证明

-&gt; 学习方案构造以及安全证明不可或缺的基础部分 需要最先掌握



学习构造可证明安全的公钥密码方案的方法

方案构造学习（如何学习方案构造）

算法定义和安全模型定义

经典方案推荐

尝试发现方案构造错误

-&gt; 使读者具备构造方案的基本能力

-&gt; 方案的构造与方案的安全证明相互影响，在缺乏安全证明的学习下，读者尚无能力构造可证明安全的方案



安全证明学习（如何学习安全证明，规约相关）

概念学习

证明训练

经典方案推荐

尝试发现证明错误



构造可证明安全密码方案（对构造可证明安全密码的方案方法的建议）

文献阅读

尝试方案构造和安全证明





30个经典方案及其证明用于该阶段的练习


知识要点两本书籍《Modern Cryptography: Theory and Practice》，《INTRODUCTION TO  MODERN CRYPTOGRAPHY》
基本概念
复杂性理论

时间复杂度

L-notation(Landau Notation)：也成为渐进符号，主要用于描述算法的时间和空间复杂度的增长趋势；包括 $O()\ \Omega()\ \Theta()$，分别表示算法在 最坏、最好和平均情况下的时间或空间复杂度；$\Omega()$ 表示算法的 下界，$\Theta()$ 表示算法的 精确界。
Probabilistic Polynomial Time (PPT)：指可以在多项式时间内通过概率算法解决的问题。概率算法在某些情况下可能会给出错误的答案，但运行时间是多项式级别的。如：蒙特卡洛算法。
Sub-exponential Time：亚指数时间，指的是算法的运行时间比指数增长慢但比多项式时间快，通常表示为 $2^{o(n)}$，是介于多项式时间和指数时间之间的复杂度。如：$n^{log\ n}$是亚指数时间，但 $2^n$ 是指数时间。
Exponential Time：指数时间，指算法的运行时间随着输入规模 $n$ 的增加呈指数增长，常用形式如 $O(2^n)$ 或 $O(c^n)$ （其中$ c&gt;1$）。这类算法运行时间增长非常快。如：旅行商问题 $O(n!)$。


计算复杂性

P (Polynomial Time)：多项式时间类。所有能够在多项式时间内解决的问题的集合。如：快速排序和归并排序。

NP (Nondeterministic Polynomial Time)：非确定性多项式时间类。可以容易验证解是否正确，但难以找解。如：子集和问题，如果给定一个可能的解，可以快速验证它是否正确，但找到该解的过程可能非常耗时。如：起点到终点是否有至少一条小于100个单位长度的路线。（所有P类问题都是NP问题）

NPC (NP-Complete)：NP 完全问题。这是一类最难的 NP 问题，所有 NP 问题都可以通过多项式时间归约到这类问题。如：旅行商问题（判定版本）、3-SAT 问题

NP-Hard ：NP难问题至少和NP问题一样难，可能更难；NP难问题不一定是NP问题，也就是说，它们的解不一定能够在多项式时间内验证。如：旅行商问题、停止问题（Halting Problem）（给定一个程序和输入，判断程序在这个输入上是否会停止）



计算模型相关术语

Computation Model (计算模型)：这是定义如何进行计算的理论框架，用于定义什么可以被计算和如何计算。如“”模型包括图灵机、随机存取机（RAM）和有限状态自动机等。
Turing Machine (图灵机)：由计算理论之父艾伦·图灵提出的抽象计算模型。由一个无限长的纸带（表示内存）和一个读写头组成。图灵机的每一步计算由状态和符号决定，能够通过改变符号和移动读写头来执行计算。图灵机是复杂性理论中用于定义可计算性和时间复杂度的基础模型。




攻击

Birthday Attack（生日攻击）

攻击对象：哈希函数
攻击目标：找到两个不同的输入具有相同的哈希值（哈希碰撞）。
例子：对 MD5 哈希函数进行生日攻击，攻击者可能找到两个不同的消息产生相同的哈希值，从而进行数字签名伪造或文件篡改。


Man-in-the-middle Attack (中间人攻击)

攻击对象：通信协议（特别是缺乏认证的加密协议）
攻击目标：拦截并篡改双方之间的通信，而通信双方并不察觉。
例子：攻击者在 Alice 和 Bob 之间建立两个独立的加密会话，拦截并解密他们发送的消息，然后篡改内容再发送给对方。


Brute-force Attack (暴力破解攻击)

攻击对象：密码或加密密钥
攻击目标：通过穷举所有可能的组合找到密码或密钥。
例子：对使用短位数密码（如 4 位数字 PIN）的系统，攻击者可以尝试所有 10000 种可能的组合，直到找到正确的密码。


Eavesdropping Attack (窃听攻击)

攻击对象：未加密或不安全的通信
攻击目标：窃听通信内容，获得敏感信息。
例子：攻击者在未加密的 Wi-Fi 网络上捕获用户发送的明文密码或信用卡号。


Meet-in-the-middle Attack

攻击对象：双重加密系统（如 2DES）
攻击目标：通过分别攻击加密的前半部分和后半部分，减少破解加密所需的时间。
例子：攻击 2DES，攻击者使用一个中间状态同时攻击加密的前半部分（第一轮加密）和后半部分（第二轮加密），从而减少暴力破解的时间复杂度。


Collusion Attack (共谋攻击)

攻击对象：多方协议或共享资源的系统
攻击目标：多个恶意方合作以欺骗系统或窃取信息。
例子：在分布式投票系统中，多方共谋可以合谋修改投票结果或操纵选举。


Side-channel Attack (旁道攻击)

攻击对象：硬件实现的加密算法
攻击目标：通过观察硬件泄露的信息（如电磁辐射、功耗、运行时间）来推测密钥或加密数据。
例子：攻击者通过测量加密设备的功耗，推测出设备运行不同指令时的耗电差异，从而推测出加密密钥。


Statistical Attack (统计攻击)

攻击对象：加密算法或协议
攻击目标：通过分析加密文本或通信中不同部分的统计特性来破译密文或找到加密弱点。
例子：攻击者通过分析加密文本中字符的频率，破译简单替换密码，因为某些字母（如英文中的 “e”）出现频率较高。


Replay Attack (重放攻击)

攻击对象：认证协议或通信协议
攻击目标：通过截获和重放有效的数据包来伪装合法用户。
例子：攻击者截获并重放用户登录系统时发送的认证请求，从而在不知晓密码的情况下再次登录。


Rainbow Attack (彩虹表攻击)

攻击对象：加密的密码或哈希值
攻击目标：通过使用预先计算的哈希表（彩虹表）来反向查找密码。
例子：攻击者使用彩虹表匹配存储的 MD5 哈希值，找到对应的明文密码，从而绕过系统的哈希加密机制。




基本工具

单向函数 (One-way Function)
输入：任意大小的输入值（通常是整数或比特串）。

输出：固定长度或与输入长度相关的输出值。

输入输出关系：单向函数易于从输入计算输出，但从输出反推出输入非常困难（计算上不可行）。

应用场景：单向函数是许多密码学协议（如哈希函数、数字签名、密码算法）的基础。常见应用包括：

密码散列
认证机制中的口令验证


零知识证明中的承诺方案




陷门单向函数 (Trapdoor One-way Function)

输入：任意大小的输入值和一个“陷门”信息（通常是密钥）。

输出： 固定长度或与输入相关的输出值。

输入输出关系：在没有陷门信息的情况下，从输出推回输入非常困难；而有陷门信息时，可以有效地反推出输入。

应用场景：陷门单向函数广泛应用于公钥加密和数字签名。例如：

RSA加密：只有拥有私钥的用户能够轻松解密用公钥加密的消息。
数字签名：签名者使用私钥进行签名，验证者使用公钥验证签名。




伪随机函数 (Pseudo-random Function, PRF)

输入：一个密钥和一个输入值（通常是比特串）。
输出：一个伪随机的输出值，类似于随机数生成器的输出。


输入输出关系：PRF 生成的输出看起来像随机的，但它是确定的，即对于同一个密钥和输入，输出总是相同的。只有拥有密钥的用户能够区分伪随机输出和真实随机输出。
应用场景：PRF 被广泛用于对称密钥加密、消息验证码 (MAC)、伪随机数生成、以及密钥派生函数 (KDF) 中。




哈希函数 (Hash Function)

输入：任意长度的输入数据。

输出： 固定长度的哈希值。

输入输出关系：哈希函数将任意长度的输入映射到固定长度的输出。理想的哈希函数具有抗碰撞性，即找到两个不同输入映射到同一输出的概率应该非常低。

应用场景：

数据完整性：用于校验数据是否被篡改（如SHA-256用于数字签名）。


密码存储：存储用户密码的哈希值，而不是明文密码。
区块链：用来确保区块内容的不可篡改性。




硬核谓词 (Hard-core Predicates)

输入：单向函数的输入值和输出值。
输出： 比特值（0或1）。


输入输出关系：对于给定的单向函数 $f$ 和输入 $x$，计算 $f(x)$ 很容易，但对于某些特殊比特（称为硬核谓词），即使知道$f(x)$，要猜出该比特的值也非常困难。

应用场景：硬核谓词用于设计更加安全的加密协议，如流密码生成器中的位选择机制。常见的硬核谓词包括 Blum-Micali 伪随机生成器中的二次剩余判定。


熵函数 (Entropy Function)

输入：概率分布或随机变量。


输出：熵值（衡量随机变量的不确定性或信息量，通常以比特为单位）。

输入输出关系：熵函数给出输入随机变量的不确定性度量，熵越大，信息越难预测；熵越小，信息越确定。

应用场景：

密码安全性评估：用于评估随机数生成器的质量。


信息论：熵函数用于分析通信系统中传递信息的有效性。
数据压缩：根据数据的熵来决定最佳的压缩算法，如Huffman编码。






认证

加密

模型

Random Oracle Model（随机预言机模型）

概念：将哈希函数视为一个理想化的随机预言机，即每次查询哈希函数时都会返回一个随机值，不考虑实际哈希函数的实现细节。
应用场景：这个模型通常用于证明密码方案的安全性，尤其是在设计签名算法、加密方案或零知识证明时，随机预言机模型简化了安全分析。例如，很多实际使用的加密方案，如RSA-OAEP和HMAC，在这个模型下被证明是安全的。
优点：可以简化安全性证明并提供很强的安全性保证。
局限性：实际中的哈希函数并不是理想的随机预言机，因此在现实中可能存在攻击漏洞。


Standard Model（标准模型）

概念：不依赖随机预言机等理想化的假设，而是依赖于基于已知的数学问题（如离散对数、因数分解等）的假设进行安全性证明。
应用场景：标准模型下的安全性证明更接近现实，通常用于密码学协议的严格安全性分析。例如，基于困难数学问题（如RSA、Diffie-Hellman）的加密和签名方案，通常在标准模型下证明其安全性。
优点：提供更为现实的安全性保证，避免使用理想化的假设。
局限性：安全性证明往往更复杂，并且可能导致效率低下的方案。


Common Reference String Model（公共参考字符串模型）

概念：在这种模型中，所有参与方在协议开始之前都会共享一个公共的随机字符串，该字符串由一个可信方生成。
应用场景：该模型经常用于零知识证明系统和多方安全计算（MPC）中。公共参考字符串用于保证协议的正确性和安全性。例如，Groth-Sahai证明系统就依赖于这个模型。
优点：简化了复杂密码协议的设计，并提供强大的安全性。
局限性：公共参考字符串需要由一个可信第三方生成，如果其生成过程不安全，整个系统的安全性将受到威胁。


Security Model（安全模型）

概念：安全模型是用来定义密码协议在特定攻击场景下的安全性。常见的安全模型包括选择密文攻击（CCA）安全模型、选择明文攻击（CPA）安全模型、完全前向安全模型等。
应用场景：不同的安全模型适用于不同类型的密码协议。例如，针对加密协议的选择密文攻击（CCA）安全模型广泛应用于分析公共密钥加密方案的安全性，如RSA、ElGamal等。选择明文攻击（CPA）模型则用于较弱的攻击假设下的分析。
优点：通过不同的攻击模型，研究者可以更精细地评估协议在不同攻击情境下的安全性。
局限性：模型之间的安全性可能不一致，需要针对特定的威胁模型进行全面分析。


Generic Group Model（通用群模型）

概念：假设在这个模型中，攻击者不能直接操作群元素，只能通过一个黑盒进行群运算。这种模型假设攻击者无法利用群的具体结构信息，而只能使用通用的群操作。
应用场景：通用群模型通常用于证明基于群的密码协议（如椭圆曲线密码学、Diffie-Hellman等）的安全性。这个模型对分析与离散对数问题相关的加密方案（如Diffie-Hellman协议）特别有用。
优点：简化了分析过程，并能提供对基于群的方案的广泛适用性。
局限性：在现实中，攻击者可能能够利用群结构的具体性质，从而使得通用群模型中的安全性证明无法完全反映实际的安全性。




第三方实体

Key Distribution Center (KDC) — 密钥分发中心

功能：KDC 负责在网络中的各方之间分发对称密钥。它生成并安全地传输会话密钥，确保各方能够使用对称加密进行安全通信。KDC 通常是可信的中心实体，负责管理密钥的分发和更新。
应用场景：主要用于对称密钥加密系统中，尤其是在需要多个用户之间进行安全通信的环境下，如：
Kerberos 协议：KDC 在 Kerberos 协议中生成会话密钥并分发给通信双方，以便实现身份验证和加密通信。
企业内部网络安全：KDC 用于集中管理员工设备之间的加密通信。


优势：减少了各方之间建立安全通信时需要直接共享密钥的风险。
局限性：KDC 成为单点故障，如果被破坏或泄露，整个网络的安全将受到威胁。


Key Generation Center (KGC) — 密钥生成中心

功能：KGC 是负责生成公钥和私钥对的中心实体，通常用于基于身份的加密（Identity-Based Encryption, IBE）系统中。KGC 基于用户的身份信息（如电子邮件地址）生成私钥，并分发给用户。
应用场景：主要用于基于身份的加密系统，特别是在分布式和多用户环境中，如：
电子邮件加密：用户通过其电子邮件地址作为公钥进行加密，KGC 提供私钥解密信息。
无需证书的加密系统：KGC 的存在消除了使用传统公钥基础设施（PKI）系统中对证书的需求。


优势：无需管理公钥证书，简化了加密系统的管理。
局限性：KGC 必须完全可信，因为它能生成所有用户的私钥，可能导致潜在的隐私和安全问题。


Private-Key Generator (PKG) — 私钥生成器

功能：PKG 是类似于 KGC 的实体，负责生成用户的私钥。它主要用于基于身份的加密系统中，用户的私钥是由 PKG 根据用户的身份信息生成的。PKG 通常也会生成公钥，但这些公钥是基于用户的身份生成的，而不需要显式地存储或分发。
应用场景：用于身份加密系统和签名方案，如：
Shamir 的身份加密系统：PKG 为用户生成私钥，用户身份作为公钥。
Pairing-based Cryptography：在基于双线性对的密码学系统中，PKG 负责生成和管理密钥。


优势：消除传统 PKI 系统对证书管理的需求，简化了密钥管理过程。
局限性：与 KGC 相同，PKG 必须是完全可信的，否则会导致整个系统的安全性崩溃。


Certificate Authority (CA) — 证书颁发机构

功能：CA 是公钥基础设施（PKI）中的核心实体，负责验证用户的身份并颁发数字证书。数字证书包含用户的公钥及其身份信息，并由 CA 签名，以证明该公钥确实属于该用户。CA 还负责吊销证书、更新证书和维护证书的有效性。
应用场景：CA 广泛应用于互联网安全、身份验证和加密通信场景中，如：
HTTPS/TLS 协议：CA 颁发 SSL/TLS 证书，确保用户访问的网站是可信的。
电子邮件加密（如 S/MIME）：CA 颁发数字证书用于电子邮件加密和签名，确保通信的真实性和机密性。


优势：通过数字证书验证公钥的真实性，确保用户之间可以安全通信。
局限性：如果 CA 被攻击或误发不安全的证书，整个系统的信任链条会被打破。此外，CA 通常是高度集中化的，这可能导致管理和成本问题。


Trust Third Party (TTP) — 可信第三方

功能：TTP 是一种在通信双方之间建立信任的第三方实体，通常负责验证双方身份并促进安全通信。TTP 可以用于密钥分发、身份验证、数字签名认证等场景。
应用场景：TTP 常用于分布式系统、电子商务、合同签署等场景中，如：
电子合同签名：TTP 验证各方签署的数字签名，并确保合同的真实性和有效性。
在线身份验证：TTP 在用户和服务器之间充当中介，帮助进行身份验证。


优势：通过引入一个可信的第三方，简化了安全通信的流程，减少了直接信任的需求。
局限性：TTP 是一个集中化的实体，如果它被破坏或失去信任，整个系统的安全性都会受到影响。




协议

Key Exchange Protocol — 密钥交换协议

应用场景：当 Alice 和 Bob 需要安全通信时，他们需要协商出一个共享密钥，其他第三方无法得知此密钥。典型的例子包括 Diffie-Hellman 密钥交换和 ECDH（椭圆曲线 Diffie-Hellman）。
解决的问题：
安全共享密钥：协议确保参与方协商出一个共享密钥，用于后续加密通信。
防止中间人攻击：通过认证机制（如公钥基础设施）防止恶意第三方伪装成通信参与者。


示例：Alice 和 Bob 在一个不安全的网络上协商生成共同的密钥，双方使用密钥进行后续加密通信，避免第三方窃听。


Fair Exchange Protocol — 公平交换协议

应用场景：公平交换用于确保两方在协议中公平交换某种数字资产或信息，比如数字签名、加密货币、合同等。典型的应用场景包括电子商务中的支付协议和数字签名的公平交换。
解决的问题：
确保交易公平：如果 Alice 提供了她的签名或信息，Bob 也必须在相同条件下提供他的。
防止单方违约：保证交易的一方无法单方面获得他人的资产或信息而不履行自己的部分。


示例：在数字合同签署中，Alice 和 Bob 可以使用公平交换协议确保签署过程公平，即 Alice 和 Bob 都签署合同或都不能签署。


Secret Sharing Protocol — 秘密共享协议

应用场景：当一个秘密需要在多个参与方之间分配并保密时使用，通常应用于分布式系统、银行加密、文件恢复等场景。Shamir’s Secret Sharing 是其中的经典协议。
解决的问题：
安全存储秘密：允许将秘密分成多个部分，每个参与者只拥有一部分，只有足够多的参与者联合才能恢复秘密。
容错性：即使部分参与者失去密钥，秘密仍然可以恢复。


示例：一个公司董事会需要投票决策，他们可以使用秘密共享协议将密钥分发给多名董事，只有达成多数票数后才能解密决策结果。


Oblivious Transfer Protocol — 遗忘传输协议

应用场景：当一方希望从另一方获取部分信息，但不希望让另一方知道他选择了哪部分信息时使用。常见于隐私保护机制、密码学应用和安全多方计算中。
解决的问题：
隐私保护：在 Alice 从 Bob 获取信息的过程中，Bob 无法知道 Alice 选择了哪些信息。
防止过多泄露：确保 Alice 只获取了她请求的部分信息，而不是 Bob 所有的信息。


示例：Alice 想从 Bob 那里选择一本书的某一页内容，但 Bob 不知道 Alice 想要哪一页，Alice 也不会看到除她选择之外的其他页。


Commitment Protocol — 承诺协议

应用场景：承诺协议用于在信息未公开之前确保其不可更改，常用于加密签名、选举系统、博弈论等场景。
解决的问题：
防篡改：承诺的值在揭示之前不能更改。
保密性：承诺值在揭示之前是保密的，不被他人知道。


示例：在电子投票系统中，Alice 对她的投票进行承诺，在投票结束后再揭示，这样她无法在投票期间更改票选。


Multi-party Computation (MPC) — 多方计算协议

应用场景：MPC 允许多个参与方在不暴露其输入的情况下，联合计算某一函数的结果。常见应用包括隐私保护数据分析、分布式系统和财务分析。
解决的问题：
隐私计算：参与者可以合作完成计算而不暴露各自的输入数据。
公平性：即使有恶意参与者，也能保证计算结果正确。


示例：多家银行可以在不分享客户数据的情况下，通过 MPC 计算某个统计数据，例如总交易额。


Zero-Knowledge Proof (ZKP) — 零知识证明

应用场景：ZKP 允许一方（证明者）向另一方（验证者）证明她知道某个秘密信息，但不会泄露该信息本身。ZKP 常用于身份验证、加密货币、区块链技术中。
解决的问题：
安全验证：证明者可以证明她知道某个秘密或满足某个条件，而无需泄露秘密。
隐私保护：在身份验证或认证过程中，敏感信息不会泄露。


示例：Alice 可以通过 ZKP 向 Bob 证明她知道一个密码，而无需告诉 Bob 这个密码是什么。




技术方法

Accumulator

基本原理：Accumulator 是一种将多个元素“累积”成一个单一值的数据结构，并允许验证某个元素是否包含在该累积值中的过程。Accumulator 的一个重要特性是它可以在不存储所有元素的情况下进行验证。
应用场景：
数字签名和零知识证明：Accumulator 常用于密码学协议中，如零知识证明和数字签名中，用于高效的集合成员身份验证。
区块链：Accumulator 可以用于验证某个交易或数据是否存在于一个更大的数据集（如区块链中的交易集）。




Bloom Filter

基本原理：Bloom Filter 是一种空间高效的数据结构，用于测试一个元素是否在一个集合中。它允许有一定的错误率（假阳性），但不会出现假阴性。这意味着某个元素可能被错误地判断为在集合中，但如果 Bloom Filter 判断某个元素不在集合中，那么该判断一定是正确的。
应用场景：
数据库查询：在大规模数据查询系统中用于加速查询过程，快速判断某个元素是否在数据库中。
网络缓存：在内容分发网络（CDN）中，Bloom Filter 用于高效判断是否需要缓存某些内容。




Hash Chain

基本原理：Hash Chain 是通过反复对一个初始值进行哈希运算生成的一系列哈希值链。每个链中的值通过对前一个值进行哈希运算获得。其性质是前面的哈希值很容易计算，但无法从后面的哈希值推断前面的哈希值。
应用场景：
一次性密码：在身份验证系统中使用 Hash Chain 生成一次性密码（OTP），每个密码只能使用一次，增强安全性。
区块链：Hash Chain 用于区块链中数据的不可篡改性，通过链式的哈希保证数据的完整性和安全性。




Hash Tree (Merkle Tree, Binary Hash Tree)

基本原理：Hash Tree（哈希树）是一种树形结构，其中每个叶节点是数据的哈希值，非叶节点是其子节点的哈希值。Merkle Tree 是一种常见的哈希树，用于验证大规模数据集的完整性。通过树的结构，可以快速验证某个特定数据是否在大集合中。
应用场景：
区块链：Merkle Tree 被广泛应用于区块链中，用于验证块中交易的完整性，允许节点高效验证交易是否包含在区块中。
文件系统：用于大文件或分布式文件系统中，通过 Hash Tree 验证文件的完整性，确保数据没有被篡改。




Chameleon Hash Function

基本原理：Chameleon Hash 是一种特殊的哈希函数，它具有碰撞可控的特性。即在给定某个初始值的情况下，攻击者可以找到另一个值使得两者哈希结果相同。Chameleon Hash 的这一特性允许某些场景下的灵活性，同时仍保持数据的不可篡改性。
应用场景：
可撤回的数字签名：在某些数字签名应用中，可以使用 Chameleon Hash 允许签名者撤回签名或改变内容，但这种修改是可控且可验证的。
区块链：Chameleon Hash 可以用于区块链的隐私保护或可修改的智能合约，允许在一定条件下对某些数据进行修改而不破坏系统的整体完整性。







数学基础需要专门阅读书目去学习，此章节待更新
简单问题和困难问题简单问题能在多项式时间内解决的计算问题
存在一个概率算法，将简单问题的一个例子作为算法的输入，改算法可以在多项式时间内以一个不可忽略的优势输出该例子的正确答案。例如：

给定 $(g,g^a)\in \mathbb{G}$，计算 $(g^s,g^{\frac{1}{a+s}})$，其中 $s\in\mathbb{Z}_p$ 任意值

困难问题不能在多项式时间内解决的计算问题
不存在这样一个概率算法，将困难问题的一个例子作为输入，该算法可以在多项式时间内以一个不可忽略的优势输出正确的答案

给定 $(g,g^a)\in \mathbb{G}$，计算 $(s,g^{\frac{1}{a+s}})$，其中 $s\in\mathbb{Z}_p$ 任意值

128个困难问题《Final Report on Main Computational Assumption in Cryptography》[9]
内容
优势用于评估攻击者相对于随机猜测或最坏情况下的表现有多大提升，描述攻击者的成功概率与基准成功概率之间的差异。
定义：攻击者的优势通常被定义为攻击者成功概率与随机猜测或标准概率之间的差。
$Advantage=P_{attack\ success}−P_{baseline(random\ guess)}$
例子：如果一个密码算法的密钥长度为 $128$ 位，攻击者随机猜中密钥的概率是 $\frac{1}{2^{128}}$。假设攻击者利用某种方法攻击，成功的概率为 $\frac{1}{2^{120}}$，那么攻击者的优势就是：
$\text{Advantage} = \frac{1}{2^{120}} - \frac{1}{2^{128}} \approx \frac{1}{2^{120}}$
返回
算法算法指用给定的输入以某种计算方式产生对应的输出
算法包括具体的输入参数、输出参数和计算过程，而算法定义只描述了输入和输出的参数对象
数字签名的算法定义$SysGen$，目的是生成系统公共参数，由权威机构运行；$KeyGen$，目的是生成公私钥对，由签名者运行；$Sign$，目的是对消息签名，由签名者运行；$Verify$，目的是验证签名，由验证者运行。

$SysGen:(1^\lambda)\rightarrow SP$，其中，$\lambda$ 表示系统安全参数，$SP$ 表示系统公共参数
$KeyGen:(SP)\rightarrow(pk,sk)$，其中，$pk$ 是签名者的公钥，$sk$是签名者的私钥
$Sign:(SP,sk,M)\rightarrow\sigma_M$，其中，$M$ 是消息，$\sigma_M$ 是签名者对消息 $M$ 的签名
$Verify:(SP,pk,M,\sigma_M)\rightarrow1/0$，其中，$1$ 代表 $\sigma_M$ 是 $M$ 的合法签名，$0$ 表示签名错误

公钥加密的算法定义$SysGen$，目的是生成系统公共参数，由权威机构运行；$KeyGen$，目的是生成公私钥对，由解密者运行；$Encrypt$，目的是对消息加密，由加密者运行；$Decrypt$，目的是解密密文，由解密者运行。

$SysGen:(1^\lambda)\rightarrow SP$，其中，$\lambda$ 表示系统安全参数，$SP$ 表示系统公共参数
$KeyGen:(SP)\rightarrow(pk,sk)$，其中，$pk$ 是签名者的公钥，$sk$是签名者的私钥
$Encrypt:(SP,sk,M)\rightarrow CT$，其中，$M$ 是消息，$CT$ 是加密者对 $M$ 加密后的密文
$Decrypt:(SP,pk,M,CT)\rightarrow M/\perp$，其中，$\perp$ 代表解密失败

安全模型安全模型里只涉及到算法的输入参数和输出参数
一个密码概念可能有多个不同的安全需求, 而每一个安全需求对应一个安全模型

初始化
询问
攻击
优势

常见安全模型中的组成部分

数字签名
公钥加密

安全规约证明
模拟
解决困难问题
分析

方案构造学习算法定义和安全模型定义密码概念安全模型概念
安全模型 (Security Model)

安全模型是用于定义和分析密码系统安全性的框架。在安全模型中，我们规定了攻击者的能力、目标、以及系统的反应，以便评估系统在各种攻击情景下的表现。
 形式化分析：安全模型通常基于数学模型，通过明确攻击者的能力（比如能够访问某些信息、对系统某部分做出操作等）来分析系统的安全性。 目标：设计一个安全模型是为了证明加密方案在某些假设下是安全的（或不安全的）。
常见的安全模型有 随机预言模型、标准模型 等。

挑战者 (Challenger)

挑战者是在安全模型中负责与攻击者互动的一方，通常代表加密方案或协议的实例。在安全性分析过程中，挑战者模拟加密方案的行为，并根据攻击者的查询作出响应。
 角色：挑战者充当系统的实现者，负责加密、解密、响应查询等。 目的：攻击者通过与挑战者互动，试图破坏协议的安全性。

攻击者/对手 (Adversary)

攻击者（Adversary） 是安全模型中的对立方，其目标是试图破坏系统的安全性。攻击者拥有一定的能力，如访问密文、发送查询请求，甚至可能控制系统部分资源。
 角色：攻击者通过利用安全模型中允许的能力和资源，试图破译密文、伪造签名或进行其他形式的攻击。 目标：获取未经授权的信息，或使协议失效。

查询 (Query)

查询是攻击者与挑战者互动的手段。攻击者向挑战者提出请求（查询），以尝试获取信息或影响加密方案的行为。
 常见类型的查询：   密文查询：攻击者请求挑战者提供某个消息的密文。   解密查询：攻击者请求对某个密文进行解密。   签名查询：攻击者请求某个消息的签名。

响应 (Response)

响应是挑战者对攻击者查询的回复。根据攻击者的查询，挑战者会返回相应的结果，如密文、解密后的消息或签名。
 目的是：使攻击者能够根据这些响应试图破坏系统的安全性。

获胜 (Win)

获胜（Win）指的是攻击者在安全模型中成功破坏了系统的安全性。成功的标准由安全模型定义，比如攻击者能够区分密文、伪造签名等。
 具体例子：   在 不可区分加密 模型中，攻击者能够通过与挑战者交互，成功区分出不同的密文，表明系统不安全。   在 不可伪造性 的签名方案中，攻击者能够伪造一个有效的签名。

自适应攻击 (Adaptive Attack)

自适应攻击是一类攻击，其中攻击者根据之前与挑战者交互过程中获得的信息来调整其后续查询或攻击策略。换句话说，攻击者的行为可以随着与系统互动的结果动态变化。
 自适应性增强了攻击的有效性，因为攻击者能够根据已有信息做出更有针对性的查询和攻击。 例子：攻击者可以先进行一系列查询，从这些查询的响应中学习有用的信息，然后发起一个更具针对性的攻击。

平凡攻击 (Trivial Attack)

平凡攻击是指那些无需任何复杂分析或特殊技巧就能够轻易破坏系统安全的攻击。通常是由于设计中的明显漏洞造成的，属于显而易见的攻击方式。
 示例：假如加密方案没有密钥保护，攻击者直接读取密钥即可解密密文，这就属于平凡攻击。

优势 (Advantage)

优势（Advantage）是量化攻击者成功率的一个指标。它衡量了攻击者比随机猜测更有多少机会成功攻击系统。
 定义：在密码学中，攻击者的优势通常定义为攻击者成功破坏系统的概率与随机猜测成功概率的差值。 形式化表示：如果攻击者能以 ( p ) 的概率破坏系统，而随机猜测的成功概率是 $\frac{1}{2}$，则攻击者的优势是  $\text{Adv}=p-\frac{1}{2}$。

强安全模型 (Strong Security Model)

强安全模型是在攻击者能力或资源非常强大的情况下定义的安全模型。加密方案在强安全模型下证明安全，意味着即使攻击者能力极大，方案依旧能够抵御攻击。
 例子：在强安全模型中，攻击者可能有能力进行自适应查询或对抗密钥泄露等场景。

弱安全模型 (Weak Security Model)

弱安全模型是一种对攻击者能力作出较多限制的安全模型。在这种模型下，攻击者的能力较弱，方案只在特定条件下能抵御攻击。
 例子：攻击者只能进行固定的查询，不能根据结果调整策略。

标准安全模型 (Standard Security Model)

标准安全模型是基于现实中的假设（如计算困难性）和不依赖额外理想假设的安全模型。与随机预言模型不同，标准安全模型只依赖广泛接受的数学假设。
 现实性：标准安全模型更贴近实际应用环境，不依赖于不切实际的假设（如理想哈希函数）。
经典方案推荐&amp;尝试发现方案构造错误篇幅过多，详见文章 公钥密码学经典方案30篇 学习笔记
安全证明学习归约相关概念学习证明训练文献阅读]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>常驻</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>记录_一定要打好基础</title>
    <url>/2025/05/23/%E8%AE%B0%E5%BD%95-%E4%B8%80%E5%AE%9A%E8%A6%81%E6%89%93%E5%A5%BD%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de76ab04d32e749f01d35ab7ebdd5c2d808c2f40622a3888966f86dd811afea936dc27699529deacbe36adc04875c300c1c3f47dabdfeeaf933095654d24260b732f4cc8d32b361bcc99c18a343783f0bc8efe428615c230ccd67cd5d5b91c6813e1474a024e0375ea1af4a62bb335df23a2e661c91627266b0d02d6c21be114bdd423af57c960abfcb4057a0a02f727cca17282b3071c47a3f21684dc1252bcb2597d3ec6b836ce262dc6bec1dc81abbe6de11c9456667dd964773a941460fe7b17389f05482a2bd20d471bf58449f48d4a362651a6cd7cd2bb4d2b71d5b57f994eb284068c94b5d2b619c3b52fae3f7b257f4a2cd211dce992bf450c211c1bb0ff4ee1e2daab480cd86af265d784229ac01fac35df3348d97ec5b09db934ca795fc61a3e4f2939609dc800957724f7098e70be2425daa77b2642a9838b713d180b3b727337c3b6516d96bc65739629308e5589221b6f4fb90fb6795a1c2d5f045242f62dd8fb4ad9bfea58070ecb3a96c196aa5bbbda5d24283063f72017939dbf6046999f7045625aed9c513bdfcd3602352643507a4d78484f9b4d2d240cb91d868063e793e14f68b7847e04fdb5ddbdcfacdeddcb913a9ad1a0454b562dc4c229fc4603c36fbd325b6c6c69561aa5e681adafa97a9c025f92101b1ed09339978b6b90e004e08cd65a2203b8d1d5436060708df08cee1b88dae1ddb280aad429eb478f52116ddc3185eb94d38f7cb99cdd5e9b9087d8ca94433b6770932e0ccbfe85a126a338fb926de70dff334848ca043d2b201cfdbb9aa45c657f1822e3b160197f7136929efa0e45a1705ee6db
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络有手就行诶我手呢</title>
    <url>/2025/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%E8%AF%B6%E6%88%91%E6%89%8B%E5%91%A2/</url>
    <content><![CDATA[计算机网络刷题记录



考虑电路交换的三个阶段
建立连接：$s$（题干给出）
数据传输：$\frac{x}{b}$（报文长度除以数据率就是所有报文都传输过去所需要的时间）
连接释放：$kd$（连接释放的报文直接发送，从发送端到接收端所需要的时间为链路段数乘以每段的传播时延）
分组交换
报文如果直接传输，需要的代价是 $\frac{x}{b}$
但是第一个报文未接收完成，后面的节点都是不在工作的，所以这里的代价为空闲的链路数乘以分组除以数据率 $(k-1)\frac{p}b$
加上个倾斜，也就是加上 $kd$

要使分组交换比电路交换快，则：

s+\frac{x}b+kd>\frac{x}b+(k-1)\frac{p}b+kd即 $s&gt;(k-1)\frac{p}b$


考虑原始的状态 $\frac{x}b+(k-1)\frac{p}b+kd$
没有传播时延，再考虑分组控制信息固定长度，则 $\frac{x}p\cdot\frac{p+h}b+(k-1)\frac{p+h}b$
整理得 $\frac{k-1}b p+\frac{xh}bp^{-1}+\frac{x+(k-1)h}b$
函数值最大，则 $\frac{k-1}b p=\frac{xh}bp^{-1}$
解得 $p=\sqrt{\frac{xh}{k-1}}$

发送时延=数据长度/数据发送速率
传播时延=距离/物理传播速率
(1) 发送时延=$\frac{10^7bit}{10010^3b/s}=110^2s$ ，传播时延=$\frac{100010^3m}{210^8m/s}=5*10^{-3}s$
(2) 发送时延=$\frac{10^3bit}{110^9b/s}=110^{-6}s$ ，传播时延=$\frac{100010^3m}{210^8m/s}=5*10^{-3}s$

正在传输的比特数=传播时延*数据率
传播时延=媒体长度/传播速度
(1) 传输时延=$\frac{110^{-1}m}{210^8m/s}=5*10^{-10}s$
$1Mb/s:\quad 510^{-10}s110^6b/s=510^{-4}bit$
$1Gb/s:\quad 510^{-10}s110^9b/s=510^{-1}bit$
(2) 传输时延=$\frac{100m}{210^8m/s}=510^{-7}s$
$1Mb/s:\quad 510^{-7}s110^6b/s=510^{-1}bit$
$1Gb/s:\quad 510^{-7}s110^9b/s=510^{2}bit$
(3) 传输时延=$\frac{10010^3m}{210^8m/s}=5*10^{-4}s$
$1Mb/s:\quad 510^{-4}s110^6b/s=510^{2}bit$
$1Gb/s:\quad 510^{-4}s110^9b/s=510^{5}bit$
(4) 传输时延=$\frac{500010^3m}{210^8m/s}=2.5*10^{-2}s$
$1Mb/s:\quad 2.510^{-2}s110^6b/s=2.510^{4}bit$
$1Gb/s:\quad 2.510^{-2}s110^9b/s=2.510^{7}bit$

由题意 $2W=20000$
码元变为16，则数据率$=2W\log_216=80000bit/s$
+
最长工作距离$=\frac{20dB}{0.7dB/km}=\frac{200}7km$
衰减$=\frac{20dB}{100km}=0.2dB/km$

$\frac{210^8}{120010^{-9}}=\frac53*10^{14}Hz$

这种题，直接逐项相加即可
$S\cdot A=\frac18\sum_{i=1}^8S_iA_i=\frac{1-1+3+1-1+3+1+1}8=1$
$S\cdot B=\frac18\sum_{i=1}^8S_iB_i=\frac{1-1-3-1-1-3+1-1}8=-1$
$S\cdot C=\frac18\sum_{i=1}^8S_iC_i=\frac{1+1+3+1-1-3-1-1}8=0$
$S\cdot D=\frac18\sum_{i=1}^8S_iD_i=\frac{1+1+3-1+1+3+1-1}8=1$
故AD发送了数据1，B发送了数据0，C未发送数据

需要发送的数据 1101011011，补齐位数为 11010110110000
校验多项式 10011
做模2减法（逐位异或），得到余数 0111

需要发送的数据 101110，补齐位数为 101110000
校验多项式 1001
做模2减法（逐位异或），得到余数 011

PPP协议中 0x7D 是转义字符

0x7D本身表示转义字符
如果数据中有0x7E（帧的边界字符），则它也会被转义成0x7D 0x5E
如果数据中有0x7D，则它会被转义成0x7D 0x5D



原文：0110111111111100
填充后：011011111011111000
填充后：0001110111110111110110
原文：00011101111111111110

单程传播时延 $\tau=\frac{110^3m}{210^8m/s}=5*10^{-6}s$
往返传播时延 $2\tau=10*10^{-6}s$
$2\tau$ 即为争用期。为了能够按照CSMA/CD 工作，最小帧的发送时间即为争用期$10\mu s$发送的数据量
$110^9b/s1010^{-6}s=110^4b=1250B$

等待时间=$2\tau*r$
10Mb/s的以太网争用期为$51.2\mu s$，则等待时间=5.12ms
100Mb/s的以太网争用期为$5.12\mu s$，则等待时间=0.512ms

第三章还剩下一些，暂时丢掉了~

01000101 0000000000000000 0001110000000000 0000000100000000 0000000000000100 0001000100000000 0000000000001010 0000110000001110 0000010100001100 0000011000000111 00001001$\rightarrow$01003532 0002341401110100 01001110$\rightarrow$取反码10001011 10110001

45 0000 1C00 0100 0004 1100 000A 0C0E 050C 0607 09$\rightarrow$74 4E
十六进制太难算了

第二个局域网所能传送的最长数据帧中的数据部分只有1200bit，即每个IP数据片的数据部分不超过1200-160(bit)，由于片偏移是以8字节即64bit为单位，所以IP数据片的数据部分不超过1024bit
故3200bit的报文要分4个数据片，所以第二个局域网向上传送的比特数等于(3200+4*160)=3840bit

128.96.39.10属于子网128.96.39.0~128.96.39.127，故下一跳接口为m0
128.96.30.12属于子网128.96.39.0~128.96.39.127，故下一跳接口为R2
128.96.40.151不在子网128.96.40.0~128.96.40.127，故使用默认路由R4
192.4.153.17属于子网192.4.153.0~192.4.153.127，故下一跳接口为R3
192.4.153.90不在子网192.4.153.0~192.4.153.63，故使用默认路由R4

IP数据包固定首部长度即为20字节，剩下总共3980字节
分成最大数据长度为1500字节，去掉首部长度为1480字节
3980/1480&gt;2，故划分为三个数据报片
第一片：数据字段长度为1480，片偏移为0，MF为1
第二片：数据字段长度为1480，片偏移为185，MF为1
第三片：数据字段长度为1020，片偏移为370，MF为0

132:10000100133:10000101134:10000110135:10000111
故共同前缀为 10000100(132)，总共22位
最大可能聚合为 212.56.132.0/22

后者包含于前者，因为前面的序列都相同

一眼是(1)哇

地址0/4与任意IPv4地址前四位为0000的地址都匹配

只有前11位相同（截止到第二位的16，即第12位）

2 4 11 30

20=8+8+4
84写成二进制是01010100，取前四位为0101xxxx
最小01010000，即为80；最大01011111，即为95
最小地址为 140.120.80.00，最大地址为 140.120.95.255
地址掩码为 255.255.240.0
地址块中共有地址 $2^{32-20}=2^{12}=4096$ 个
相当于C类地址 $2^{12}/2^{8}=2^4=16$ 个

第一步：下一跳全部改为C，距离+1
第二步：和原有的进行对比，选择相对较少的那个


29:0001110132:00100000
地址数为 256*4=1024
虽然这两个地址是连续的地址块，但无法写成前缀的形式。

网络掩码：255.255.255.224
网络前缀长度：27
网络后缀长度：32-27=5

地址数：$2^5=32$ 个
首地址：167.199.170.64
末地址：167.199.170.95

子网N1：14.24.74.0/25子网N2：14.24.74.128/26子网N3：14.24.74.196/28

都匹配，根据最长前缀匹配原则，选择路由3

11001000 00111000 10101000 00000000/21
$\frac{2^{32-21}}{2^8}=2^3=8$

::F53:6382:AB00:67DB:BB27:7332::4D:ABCD::AF36:7328:0000:87AA:03982819:00AF::35:0CB2:B271

0000:0000:0000:0000:0000:0000:0000:00000000:00AA:0000:0000:0000:0000:0000:00000000:1234 :0000:0000:0000:0000:0000:00030123:0000:0000:0000:0000:0000:0001:0002

UDP的首部有8字节，故总共8200字节
IP数据包的最大长度为1500字节，首部20字节，故应当分为六片
前五段数据字段的长度为1480字节，第六片为800字节
片偏移为0,185,370,555,740,925

UDP首部分别是 源端口 目的端口 长度 校验和
因此源端口是 $6256+316+2=1586$
目的端口是 $4*16+5=69$
用户数据总长度为 $16+12=28$
目的端口号 69&lt;1023，是熟知端口，为服务器端使用的端口
使用的服务程序是TFTP


TCP报文段首部序号字段占4字节，共$2^{32}$个序号
TCP是面向字节流的，每个序号对应一个数据字节，因此在序号不重复使用的条件下，一次性能发送$2^{32}$个字节，因此L的最大值为4GB
10Mbit/s=1.25MB/s
所需时间=$\frac{L+\lceil\frac{L}{1460}\rceil*66}{1.25MB/s}$

(1) 第一个报文段是70-99的数据，携带总共30个字节的数据
(2) 发回的确认号应当是100，代表100之前的序号皆被正确收到并且期待第100号
(3) 80个字节
(4) 70

最大吞吐量=$\frac{65535B*8b/B}{20ms}=26.214Mb/s$

发送65535字节所需要的时间$T=T_D+RTT=\frac{65536B8b/B}{110^9bit/s}+10ms*2=20.52428ms$
最大吞吐量$\frac{L}T=\frac{L}{\frac{L}C+RTT}=\frac{65536B*8b/B}{20.52428ms}=25.544Mb/s$
信道利用率=吞吐量/信道带宽=传播时延/总时延=2.5544%


初始化参数

- 初始的EstimatedRTT和DevRTT可以根据系统预设值或初始采样值来设定。
- 常见的初始值：
  - EstimatedRTT = 初始 RTT 样本值
  - DevRTT = 初始 RTT 样本值 / 2（或其他合理假设值）

更新 EstimatedRTT

当采集到新的RTT样本值SampleRTT时，更新EstimatedRTT：
$\text{EstimatedRTT} = (1 - \alpha) \times \text{EstimatedRTT} + \alpha \times \text{SampleRTT}$
- 这是一个加权平均公式，用于平滑RTT的估计值。
- 参数$\alpha$的典型值是0.125（即1/8）。

更新 DevRTT

基于SampleRTT与EstimatedRTT的差异，更新DevRTT（估算RTT的平均偏差）：
$\text{DevRTT} = (1 - \beta) \times \text{DevRTT} + \beta \times |\text{SampleRTT} - \text{EstimatedRTT}|$
- 这里使用的是绝对偏差来衡量RTT的波动程度。
- 参数$\beta$的典型值是0.25（即1/4）。

计算 RTO

根据更新后的EstimatedRTT和DevRTT计算RTO：
$\text{RTO} = \text{EstimatedRTT} + 4 \times \text{DevRTT}$
- 加权偏差部分（$4 \times \text{DevRTT}$）用于增加容忍度，防止因RTT波动引发过早重传。

动态调整

- RTO的上下限限制：在实际实现中，RTO通常会被限制在一个范围内。例如：
  - 最小值：1秒
  - 最大值：60秒
  这样可以避免计算结果极端化导致性能问题。
(1) RTO=4.5s
(2) RTTs=$\frac78$旧的RTT+$\frac18$新的RTT=1.625s
​     RTTd=$\frac34$旧的RTTd+$\frac14$|RTTs-新的RTT样本|=0.78125s
​     RTO= 4.75s

RTT0=30ms
RTT1=0.9RTT0+0.1RTT=29.6ms
RTT2=0.9RTT1+0.1RTT=29.84ms
RTT3=0.9RTT2+0.1RTT=29.256ms
$\alpha$取值较小，RTTs受RTT样本值的影响较小

ssthresh=上次拥塞值/2



(2) 慢开始时间间隔：[1,6]和[23,26]
(3) 拥塞避免时间间隔：[6,16]和[17,22]
(4) 第16轮是收到了重复帧，第22抡是超时检测
(5) 1-&gt;32, 18-&gt;21, 24-&gt;13
(6) 第七轮
(7) 4
半期考相关考点

集线器平分带宽，交换机都能使用最大带宽
集线器不能隔离广播域和冲突域，交换机可以隔离冲突域但是不能隔离广播域
已知网络利用率求网络延迟是最小值的多少倍，$(1-利用率)^{-1}$
最小单位：物理层：比特/位；数据链路层：帧；网络层：分组；传输层：数据报；应用层：数据
CSMA/CD是在介质访问控制（MAC层）实现的
传统以太网最短有效帧长位64字节，争用期为 $51.2\mu s$
以太网的物理地址的长度为48位，IPv4地址的长度为32位
IP首部定长部分为20字节

]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>记录butterfly+waline单文章访客统计正常但全局不显示解决方案</title>
    <url>/2025/07/11/%E8%AE%B0%E5%BD%95butterfly-waline%E5%8D%95%E6%96%87%E7%AB%A0%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%AD%A3%E5%B8%B8%E4%BD%86%E5%85%A8%E5%B1%80%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[前两天配置了butterfly主题博客，昨天想配置访客数统计，但是busuanzi一直出问题，索性配置了waline评论区，因为它附带访客统计功能
今天打开一看，发现全局统计出问题了（昨天还好好的）

仔细debug了许久，发现别的地方没问题，正打算翻源码，突然意识到有可能是浏览器的问题
解决方案：把这玩意关了

然后现在好了

如果有相关的防广告插件，也可以一起关闭试一试

问了下群友，说是可能因为Brave浏览器当隐私保护屏蔽了访客统计，不过这个功能事实上也确实是跟踪器

250715UPDATE
又崩了，不知道怎么肥四（哭
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>记录typora+hexo+next使用圆圈数字和多行latex</title>
    <url>/2024/09/16/%E8%AE%B0%E5%BD%95typora-hexo-next%E4%BD%BF%E7%94%A8%E5%9C%86%E5%9C%88%E6%95%B0%E5%AD%97%E5%92%8C%E5%A4%9A%E8%A1%8Clatex/</url>
    <content><![CDATA[在编辑 这篇博客，遇到了两个问题


如何展示圆圈里面数字

看了一下网上教程，一般是更改平台导入宏包或者使用\textcircled语法，但是前者可能出现更多的问题 后者我这边本地不凑效
然后看了 这篇博客 学习到了一个切实可行的写法
$$\enclose&#123;circle&#125;&#123;1&#125; \\\enclose&#123;circle&#125;[mathcolor=&quot;red&quot;]&#123;2&#125; \\\enclose&#123;box&#125;&#123;3&#125; \\\enclose&#123;circle,box&#125;&#123;4&#125; \\\enclose&#123;circle&#125;&#123;\enclose&#123;box&#125;&#123;5&#125;&#125; \\\enclose&#123;box&#125;&#123;\enclose&#123;circle&#125;&#123;6&#125;&#125; \\\enclose&#123;circle&#125;&#123;\enclose&#123;circle&#125;&#123;7&#125;&#125; \\\enclose&#123;box&#125;&#123;\enclose&#123;box&#125;&#123;8&#125;&#125;$$
效果：

\enclose{circle}{1} \\
\enclose{circle}[mathcolor="red"]{2} \\
\enclose{box}{3} \\
\enclose{circle,box}{4} \\
\enclose{circle}{\enclose{box}{5}} \\
\enclose{box}{\enclose{circle}{6}} \\
\enclose{circle}{\enclose{circle}{7}} \\
\enclose{box}{\enclose{box}{8}}补充：我安装了的包
$ npm list --depth=0hexo-site@0.0.0 C:\Users\coper\Desktop\myblog├── hexo-asset-image@0.0.5├── hexo-asset-img@1.1.0├── hexo-blog-encrypt@3.1.9├── hexo-deployer-git@4.0.0├── hexo-filter-mathjax@0.9.0├── hexo-generator-archive@2.0.0├── hexo-generator-category@2.0.0├── hexo-generator-index@4.0.0├── hexo-generator-searchdb@1.4.1├── hexo-generator-tag@2.0.0├── hexo-math@5.0.0├── hexo-renderer-ejs@2.0.0├── hexo-renderer-kramed@0.1.4├── hexo-renderer-pandoc@0.4.0├── hexo-renderer-stylus@3.0.1├── hexo-server@3.0.0├── hexo-theme-landscape@1.0.0├── hexo-wordcount@6.0.1└── hexo@7.3.0

多行latex中，会出现多出来一对 $$$$
举个例子：
原文：
实际：

经过F12调试发现，格式和正常的也不太对
然后一通摸索之后发现，把这个去掉就可以了

然后恢复正常

（一开始还以为是直接使用字符的数字圆圈导致的显示不正常，才去搞基于latex的数字圆圈，后来才知道是因为我多打换行了）
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下之后的小plan</title>
    <url>/2025/08/03/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E4%B9%8B%E5%90%8E%E7%9A%84%E5%B0%8Fplan/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88dea01838496b73bda4144fb2a3443994ed2d01f0f6f8672897208acfa890d7db5a8c6466401f12ad21eba7193b39cecb34c3a406f227534f71ff08b4ebca31d7688cec0a92cb481c752a96b04383a0b6a00b9176f06f8f77cc6493010b6f001eb5e2256eabd9e5c2c410b3623645e253a46e99b32f8a3a3483f3cd81dc35febe409ee1ecacd0c31b5c9961f75dfc184b5fec5d42c7b21a6bace545d3bfac065326d4b956f82eaeeffbc664e9a24cc4a2a3385c279513be3ecb2205137494583eec71666f4237758af16f8297645358a38c82b254daf0fd43a47de2428a2f9c243a0f927e4d19275bdc075a1d21460b5c6e30d01fc38bf4004b6a7767c37ab1f7d7a860039fc6fc6fce9440b565f8cb87864c96e1f98309848145bb3d9c7aac69b8acee23758f51a6c065557747641c65c9235cba588a8e56fb48b2641866ec22d1218b903695bd81871088f063ed6f225355cb2c210b33dc4195f7ddf4af720c9ab3e512242c26473cb4ae7e8e4125d37b0f13befba7ddc7f1982e3843b2e2a7363185ae41218e5e3363ac63cb2e926fd02a3ce6b839eff903d18462d33c17b89e573a7f22a04e6132cc17d93904d08d0f3f645a0eea41c54b6abcf6b4160ff62d736420262d6e06140dd94cf7f53a8db53128ce6027d0b307bfb4c8669cf04fbc790bc029f4fa2a4a7dcb8f921f6724015596164789fe3171dda8f6deee00a8a07201e0e52ca50634b64c84f15fdcb55895a592ed82b790926bb896c4424563118de5fe436f1e712bf79c58fa6acea03fe3fb25c9a86b9da713897fc25d532321de077f1866539231edaa965573518504c778ae37b06504fb6eb13b72e49b049385f7b092fa021ea0201384d2e6be6469bc3295bc582dc0dc63cdea04b2477388e349dc628f8f7c0fb282313d07632c1f0797bb635770189e8e5c6afc97175b02091d2dad7003f05d3c30f9389f659bce3ac5ea50867c61b1ea5937984860feee1509e257f2e6ce265706284c6ecd74b6a9afb1e7125cca89d7ce269f6a8c7e77be8ccd23009170b9545db7f48c29f5a46f25f62057cab5fe487a04d678fc30bc796e51de0b5bd5edd0b80b0fd86293db3036c0933ae839e6ece1fedb88a7256afa9de2716c95db0b87b98c43e75041592e7ef8ad9d324774482ee17dc668b32668c09cec158943e6e100d2d9b37c6ce81e80f91cfd19589787c906f069cac260d07973f908b235839504cddaffbc65c50dca2a185db963d1ad77848a1e2f42f3deec4fbc236ae9b44af4d05d79f40af1ba8779696eb1893b52b2f92ab31ccc4f335cbae746f8c3d072263c6abaf46cc08dc1ac0a8039a33ea360651cf3b6be5bc7c40dc1535132944e1e8130999f2138c058f4f3418ebe2ff99afd3e19d5084062a76d498be5a90e0889f6d912387e40f0cf49b23147750e5fe808763b68f44fbd4dbb5b52b40926146f57134c1769d23e281754bc8d7829749724f9ed0f439fe27231d052e3265c2345c3ca1bfbdaa9acd0d97086768015e8a5aad7e7addc5bdd9b2c5ab2294a0c65a81925b5072006976d2dd1467ef3b2219ed0c02f9be6daaa3a5a111ddd6b816a428ccaf595f6452f9ea091d7746f9151328deeabbe0ffdbbc24f1f5d012a4ba2ab241dd4f7b562ae821d59aee24c0b97e5c6b065d2c396f94fe2d9bd5301b55495d1b8079c564d908760ac3f959ab99b3198a620d6dbb5afb1f777ffa9fe08da68e1e8027b91b4724d57750a6c5528aa475b63310184575662bcd75a44a8dc8a1a347277f10a6f4343c09845433a52be071fae8cc0648e5feefd05a4131e23d2c55e519bd3e1a0cb0abe6cf477f3b5d175c8d668eca88b8582580bbdd9f6fa879aefba1a81b5508c1895dfe7eb1bb6200db3c964780558cd63209fff1061350848366e0c78fb55fa668487f193aa3262ca72f6488bca666404648ade936f1bd596420f548638b0ee68a8ab76fbf41edefc46b4db6e7b64e946ecf8f9d8c96229f599fe3d185ec37e29732f8a139ab10ecaf49e9258161da98cbd154cf6a247bb0def73d5a1c8596cf8a971d23aa96a6f6625620ba1ea48f39cc34bf0b0f081b04b2c3c822991cdde02fcd0427d93ddbaa6f7f6602998f2e784722220daa229207e483c9e7c088db8d7e3e509167efb31dd7b29925d428c029e697b5d5956dfb8ec98dcf9f1df54fd645f6f5d16eecaae880a986ee3cd695430d21aee93644ef377dbac1fea9c02adc924776b25146fc4f346b01b024177fd4b157867537a238f3d79e36218be7f10647a29994796bfd78d32d6f5b5e74b77954a6013a9c0c8cda402cdb208b4a8a3436a7b9da899ff4d1a908739ecfe6bc48f5bcd2ee336eb2ac52ff35aa6bda144fda2951f366a63e7b042d45d031ec9ca72210dead01cf30c3ef6600f9843396fd9c24dd9d4af18175d54852d7fec46d91a17a16231021e969d399073c0cf33548578bac816f7a3037d85d90cb6339d1f66cb5f90412dbb0f22f8bea0e0c14af906ea4685ff159d3e9a4d51b5e5219df1e0ce568fc11e1a4b0495cb62a36a2d37bc8dcbb32a013d1ad857257a14f636c70157979f018105e331b74d0b82011ff30c923b3cd17ddf7e83917922f10b680eaaeab57a459f79ac60d4f64cd5c0fcea3f145c5b1cda7aa144d99724f99eb9892f06001860a3b4d8a45392097ca89eb61eae93a5006093719e45aad5e92f44de8010b985fccaf689c8b3eccae6cc605b5acc0be6fb95511166e152ac685323f50be86e0f144e0013520ba514547207132a4e2ba8891bcfa60fccb9a4b7af6efb1f30b07007396f21da6733b2eaa34011ee6b30c23405b53a05f3727000eebb8c96166271a26f347bfc3b49bb42b54cc66b4543000183deabada5e6d191da568ab232dcb38d36002f908b5632a36b093f188e69a17777ed18779e2d3047600c787226cf2714dc4f2227b54f7c86ff5a50204df056fbe3e880a7363814def86fa10da003c1d15b7661fffa8b019618ea1f03cedc9a41e2ba94e62cbebb0737eebcadbc49a765d38ecbf41b33d74008503e48301a4e221c54259a30eaf72226da4d48eb912d1b866914c802251e30e78d010ed213cd6c2fcb289cfece64346116c9cf10ad85ca31aa8cdac1ac1f42c949d680ef25ceda2c0e5b6e31f2aa360c35d0123e4f62abd52758609966d6ab2b0db49e7885eaed5ba26cb2186a1dbb0f7b6afc6498211c59c480dec07b52391ae56070a94bff587379f484a5fb65be117e3ddb68a9ea56e6f6495bf4fe146d8732e44b4aef4f776a97b8802c3fbc08757d066a451105b3d2bd4d1ccc7ebf8721eb6bcf750e8e683f910e43b572779449672d7dbcf713db729b7c905faec56f9c8c8ac2ed7679fd18e60bf9ae76cdc96e7536fb8a8bd7cd855f34bc7a9e2bd9d026d2ee8aa02a02a6482789b6087bb28b9779713757f73790c349346cc0aee476e781dbf4da1d13c4cde74110e5c52c725ba73586e4dd86231b33cb18869344b09b1d0a66b5961382ed4b8f447ac79948852a3857626cfb2cadb198569638626c32540e8cd368185ac260c9becedf464bba2455979f98bdfd92de3d3ea1fd1c159479af82249e6989f5fcd74b259be76b619ac139710b40d7a9fbf377de2a70a8498f3a3c68428a288276156d01be7649501ba8618f207f9aeb0c5e6879f28e1955c9a2e89fc9200c2108f9940b090c181fdbae41b5c110eca4b3ee0128e92e006b09bb360c8c981f47c99da9cb12110df9970b18272dd6b246403b614d36825cd3c4a25e6e88ecbddf347493b7d880e5a142e5d1de4d80d85755d11745a1a0dca6c5dafd96f02056d99d2197c7d09c67232c035baa9d1ad8940d03ac98cc13b7a36e88ff5f1904830557ad32647ebe27df72b8e17eb51a26274256b38bc648bf0e2d6d3980f888bb042f2708b2d240a38138c34191c560177584d228da84e24ef579352adc6d136e5d50bf42950de8e7894130c0dbf4569a6bde52fafc9e06710445174d7e25795e9e49809b11047cbd82b7aaccd1283e60b3be2adfb5ca111c151cdf9a2c051087364b8d030ec9b61574459fd5881e184b0bc2e3c3dbae8dbddae7af276b7fa6e1be7a85a61215e8f7d44762ad44230da5d085cf1f271311f753dce492d21ac777b8062a163f38e9d4c3c2407aa46f5ee5c3ed37ad59dd21d1ad5acfc9788b64d8c68156a5c1cc476cfa7de4d32e6b391ff7596a2e99aa23f70a63e51b1ed935aa6a310911316e38f3629dbaa353849422933baedf1ed50c9df6e2683534c6bae9849564bbf4bca236390111e85a19b5d422f908f4c3d5144136052198d63e1b86685e28df33804f696a9f6709676415512daaaac80682e4ba3baa72c5f1f58502e8a283ecc250ed72b5175092c2afaf5f7b2a2d3be1390f0235bc6ab309a7d52cbf225bb5052e8cb802e7bd9d165432e24db4e58b98ab7bdf850d0dc3f4e7693e2e54501de97b1603612f24353711746c45318c97ac665f4dcad0bc3fea2acd9fc3d916160bfd4ee58e22850b227b282b36cd6551960019dd3c0a2177a97fd5cfbf921dbe1902eb819a17506b2bb0ab43554a2a7b8e97f4c662bd509528bf09ef6caf6f46366334ffec4eae3f6e13b6822633c2e71f3c0d39cc4f9d8081ebb83b586d3aa2474d56da599e53742812ad0cb784dd14f7b0908ccaeb2063c4992af31c501e7ac99e7c68cac5fd4157e63781cfb734405609f8c7c217f61d0338ae20ba4488c13a8e43d43ba5538a8bd16a5f15a27024023ebce1743d949936e232a3c4f6e6a266be4c20a8158028d3e31131446015574a309a68050479226fde9754708ad86d0823915c982e8c897f0d07913f9e9149de46ac42cac7ae8ee36b8414a8e3ae2d8ce3a0b6090020f8d8cb3d435eca5852685d77a3ed9099794aae4719a67b652c866da499d5a82cbe926575aef29063c01680705e2ee7d2b2e412fc99f07dcf5cf4425ccc5f426f7557380b39ea6d3df5faeb6ac2198a36da1e3e966f1094212c42a6346405d8d9510e1bb62796fcd9f2d521be8a79f7ffc7c3b211d9480951251a8f3bcd74410c5b1ea7bd7f069f85891729aaa29d42426526eb3e1af2150ac03e80e3cdc905f887f17df25212e1aede8b6350bca4a82305f273542f6d76ced7ffe22cf53633512023f878bc21e3be869a8b964f47e234552a5eb9a8a1d8eb7466915fdb69476eae48bb9715d4593f7beb28a16615632e0c5485033313b91afc1afa4532ad70d4bd46a2db720b1189a28c4f50cfd70e04e5f31f539e6fc0a46ec99e516abc083eb605ddffcc824e123e861206fd938471a430f9d85d5151763753d4898736357ff3d7575004c16561e2e0e9dd0ec63683ab59fcc91bb3b91e96315cfd05a8cf1343e03aa1c95597be9bd3be9b394f68c4aeef0021c6630cc336b9e401d60e8a3fdc2be8beb7fdf759ccbde36a02d1705cdfa60ecdbcb155de9f81eff0d0bbe9d05c3445727e58a83a33b24de6c5db35f976d7929226d32ffdbd5499e4d4e7d37132ed50dc37350bfa1bf379c3492d29406cea436246d122adfcee14dfa7480920f731310d908bd45385ac2a56cfc503412fafdb9118a92eaefdfd4abb0860eb69f8aa0dd796326610b0efa79a94e20fe895f239db7077f3113d06a6205236a42f055a2a96f4e8a4baf43a3e408b2f4d4c540f6047d6c40df23b62af46f9e586fafafb3f2691c2321a7d3d162e752b840210d068373169ff631dc93431639bae96f8b8bebab2913fa379b49c37cf495ef294f3c6820f4a090eca14e93f55fa5fa7f839b69440a19266362e9a5ddf206c1dd89d99967f5b7d74732ff4c9b4c42c040f65c010c78ac96094db517b5a6d608eb06faeda4f1e4a575e2cd804c2122496e04a9b199db5c37cd8cec8dda48f32183f68535fc92ea31891923ff7786f280075657c806c58fc56e5cc9c271a21f292036d5eaef3f71133ca5dd018fb634c46b12c99b553fbba2a9b5786b8dc245ea5c0c80b418feb54447806bc7e9e2d152a2296c0022ad08c07fffb062b24291ed481f9961328f24f10fcd9d5145a731a195f53fafd4cbeae2f3e65444cc9e7cca151d3460484bfb49392f3ca2db4b0a66493a69f1f15a3f162f57c11ea4e14955386545f6d4d51663a0868dadd8635b511f09d534b9f4cd8d2a6cc8f5a39cb0639d86105c9e57272753bb4092083ff8f81a30138fd39e4bfc7a718f8e31e186cabd18819956fb596f824a053686ce53b903960fdaab6f6c29df15e11e7410dd1b771721b050d4c93ce7e7ca0d7ab1c635b3747f3dab24ef6dbc162598ce041b18f87984745d82c9d46d25278904c83192967bffd40f9bfb7faf5eba259eaa6f2072caa3d618a3856a1432bc86adf648ac0332c7f0874d0661ca24fa235d5767ea4889d26df9d94a426988a615f39d65ae9dd037107bb7b32b3591e97be4d301b68e4be84c6e6831215b830bc481ebb811962d5eaaaf0574379cff65f2f4f74578fae456996132e962159ed771e962cc3a9b70035eaa0ac2cd3699d18d9ad5de7664ea2a72ae7e2d11853215142a43f593550f64d2ec4e4826e89e9e3711c60c4016ec288b858c8c6c7da7f62f53db63262d3367984c0e31d482fc9bb7ec709d41ffcb53a020b31eebb44e4879790cb7d135a7f5045c18ee5a67c70e9b9a2a1e4d0cb97d62e036c4eb3d98e1af91281b17a322266721f24d876ae081aaff3a7b47d769260270205059e7b951445cc84a7d4ba3d49212871c43d270f0f22fa87e321b87589ff6c166bebc6c6274f0c73cbc761a6453b9be639020f45dea09b4edef66a2b689bb85217172a18c1c272a1f0a949e418a161c6b695cd5d3b386f8bea06446d61b6d248b1e200ad21570495ad8ab16e13cd02a80c67390d13f9b481ae889f9b3a79f5fbd2cf599deffe6de47218bd633952c36e61e4af9ea3c148efa3bd455561814ab14e374f890cebd0fd43b999ee94bf2cc0d8eacdbe116338272cac6a18b0df968d54de9120959af4b7a6fa44af64dca0dfa9fd4d6c1458433cdcd71911c7c4815303a5be9bea427fd3c5c66f7d9b4a6ba711793f62d201c413da979b5659cd90fafcc5dbbffe7ef0c6fae04f95a400ee59dd6b4a65a49cf97c1f3f41585238c4787327f9d9ab9240aa7a0fadf9ec445275f63024b8e877544a2872a238238664ffb80a39c829eb6cb2aaed6b1b03b26f2089c2c55d288882fc8e40e5d8ab6d840e0ed553a96f0f2b0ab7f0c171e8efb56cf53afad80fd87005d2641808c3b0dc9bcef414ce00a4c484bd7af27d82f5c13866ebe7b405e46acfc515bd1f3f013e7e5503a1ad7226fa60966bed1d383782d27ad9e58d4f6325d753a8d7dde70ebe80d91a2c71f8a4b3d5ec69221614cb8d0759566a9ff499d8ff659d4a9b417763a19dfd73dd5dd19b1c74a2da43e4d41ba8bdfd1f3ab12ab1d2abe69ccaa796fd5215b1bc340d3289e61208fbb172e2464905f701dd1b0355ce42e682742ca7054c1d6d86eab3dc4b29cd40b7d4142aa1059e35d3e1a42a774699c6831e34a86f788503c3676db6193a0bf0dcd2ef5393677a6b329b3ab3039f6fd63eba6bfc1b1dff564a2efdf29b7ca88aeb9b8b5224319cb5568a7ab0db5cda61c0b692b3ef6b10a8cd25e1d2cfc6cdadb5c76c6dcd8fa437cc27001b98d6a2909889197ff080acb2e9b43aabd7ada75328a4d480654892c6d96e15b852710db3bbac865f7affdfe939cc9a23b3dd9cd5158b7f5020e88278188f754de8f55a9f83f1e5193fad3ed3ae1de4048226c7600983f50ef2485ab0a378f36f34182725aa4f952ae5f2e8c69650c3205a8385ef280d15b98416c519066195782e3c1f85f8c7794de7214498f75bf7f4d47c5d92af2cd470fd7d08bd32838129b48aab305f212063b8fcd1cab9c43ae48908ba9aa102d376e7dbb1e17e3c573b057c4ab446d0bb8b49e5f25067ec35137d7005b7dfccfa7ba8cffe8ee185ed1f78f5811f3555a0d6bcf34670185e203633bab05eef892d802ea1f761c6ad945f67bfc1b548e41099a5b38347fb3f4eaa575ed5db70e8133f01a2a33329fcc2a959724a959bbb20228551936f92051433fd67da166d445c5a8883e534883c6a1de1eb2a640edbfc4d345d763f060629ea34f07ac28d1dd435ab429c1dee34b4da5f42ea41e5430817137d7b8115f9bcec189c7f1c4ba42352c33a5ffbda58fc7db7c69fd8f66db31642091611f2896680d79628901bf7de64421149f4c747199380fb361fa671441cff0371ee87762c0f668278618c1c72a125a491b1a8ec3da5519efe900ffcd673915f4fc6b2bc380e4a46ae5a9008b3b34e9b4d7ce2ed99ec38e96fe6870b701fecefc85a8c5691c9ac2a5bafed0baff70f5e4142ac5a4738b25af1578991763a09f0d6c2df358e9b97ba62e44bbe37beecefb070ba91b915155c4c9705d9ae9698728a4cf2931b317fa7fc670dcdf45e4329267c73b59159f5bce3ee7a99e3854d42af8182464dc41e40a44666cb86148aff52128accd7f1237d050c718bef9222d5de4fa1d5b5b62e9da064745b11fe9baee36d8827163b4c4db96317a8e8a4c6a50bde5b8815e2df61e5619adef621826eb1c4c06420142a1d061759b78009b0454c907a9b1c0a9b5636b143a1c00a6021a3fecd2c2337587aa37d724570d9ee5d9698e2299a4b9d642a264ae6081f38581fc702a012ffb346505cf265064c52ddb939d57784ef6d9003c58bc0555af88a051a39713b2503f14068a5a2a2efe5ac5116ad9ce401ed24d7192404756e4f6ea64ccec527fea92b0416fee55e3a580850e1ecd274f532aca1260596a32a1aa1604d913586b17b5a82660b8e9e6975facf1cedd039a3427c70424113c94baa758839fe6ec2c18a2764de096dd01325fb133f2d5777f9044105cb162f889d7e3e5b6b731ad71aef21dd1d132cbd789d065c9d7aae9ac2c3e0b82576670047335c8cd196d415cd7212fca238ac80d694d691d43504959ea20b8e1fa89d357eef0fe152338089c09ec7f9663fe57a13151f5ae71178f419363451767b039b410c89039b8ef80ccf785681749501c154558fa43b266ab222cd1c510ce90005a19ee533f04c65e23b7b85da34ff8c7092acacdc71f4197faa714738589b6ea0a956501fb61da7f1e4b1cc7997cd5b6b4609b861e5cd64c6c47a5abb69d0731dcfa66ecee3e33c9ce0fb53cdec787ca2cc674e7914614a828ca42fa04336d8b7720f4faa1ee6da347cbb1f017fbf245b20aad3691ad3747ae9d9f809e34a396524ec3289cf5d11eeb61e97620474e4e82f3fe4492aa67cf1a1d620efbaa366069ee8357b36a77cdbf4149447a8530d994c6d1ca4b5737d43cd1827ff8b28ed664604499337c67ade83e963db34ba981d6d3bdcddd0c8a99191eaf7683905c29f15b317a587732714e2511be6af5b9d60e9a9e21c8a2e3149e17d6a44fdb751d17633252fd13785c43d1acc1c432d74a807b896d375fe57f5c95ed83738efa376ae71a8adac400c92846d06fb099fd25c850d87f7638778aaca0e5538836178d136fe6adef1ea347e509bd467e38bcfe6d7b1d9408c941a75c99b13e98cb1436108b2a596d3a0362950143fca71fb7b61d7a84cccd89cb9fc8c9be78a7a0e19c0b6e9380e2dfbfc82e0dcb6a811012acb497721c59499218ad1e8bc09ad9fb152296feb4f38b5ee23bbc85b16646ac1912e07dd0c80808a4a4d4fcfb3d05ecb626ff9247c1b938fafb3a42ab39d1a4f9df492ec272cfd8d7a02406d2325fd352a36b75d3cd5b959bdd0f095657f6d977f1b3923f6fb771ccce097a1aac5aeaf9c9663f3064d897adf514792e32391bc162d83a6854693b2678bbef8ad99f6effda56aa579871f625d8f3b3d514f50907e14c7054c602d2ac612e9220a17c6ed5510b219fe8fc6677d12d9dafb242ad8247aed6b5e07b3c169ddbc00f37e85f93a43b5394115e7926d91ea92820bbac98ec1162b8ec5e4ffa681ac2895038e4d72b37e4fddec58b989c58db18f4d628543452e59ecd042860b08d9da7084b521d10c96628a2e202e5cb7a86cd3a0e816e6e5843b33c35c5a03102d61ea373a2621e5db26dcf7d9752c307b5608e8df2958487c2850168dfdd8af0e012fd6391c4d043a989533bd81882f4572d072fb6720faa26bb8d524be58a21f6b60cb1a5aba8aace045e90fff97f5006c278afd8d0f97ba6d26fe0de785dabe6939313666e83d2c0bbeab07a20458378284c623bd65282a132e317f890b117383c00527c2f55280d61c40e47c5e680e1b7287391cae1e2a2b8245f65bca062473585328a2473e817ced6696c15bcd14b8c4f7743dcd3da2fb6a994e9bfc162ef6df5da55827d66f1e844e23892773aab102e442f5de6f4e011dd760053b0a7432fb3f9a721534e3fe53625a725b9fb71f33d2d2178e0dde5d4f44d09c8c23965e2499b9b10926e05fdfdd7ce15211ea8c20c388384af1cc2de145d381b9b26769fca7a67241511db9967da79e7ed08efbbda1b445961208e62ef952444f69e84fd192448839d7865a735ca53e7e1869365c2c1eb6970afdf72ec2a3ed7c0fb63faef840e3bf1289d4cdc0fc8ab22e97c1421e1c51a5dbe9225952caa88ce92bc05f8fd7b83e47a3c27530a3e2f68cc9180896cc47d8f69934b0d3869e649f7f54235c279f20545d63636d81a0b800b6a2467b5a2588a42bfea96768d05ddd8e7a1e88f97276e30ae34899dbf60b900b38f054d4b2ed7ce3e7dc5f1cd4b2c356bbac59633d377124bfc3b4d29b9f582f19e707694b513be23c4311f4e3882addd02f1cbaaa14db9abbe2b08aaf65b741e8c97233cacf89f05924e349b0ce7b16d31ca2176f684be714e8f3077c6196d613e51454930d5040412f35192ce41e9f9384927e832f43ca636a781fce2aa8846e4ea9bca267be9a52834ac3d8fcdc39a3315cd2649801f4d1ad50123337ffcfe24ef0bc49119ef09a2fc196643723349b3745337ecbf326ccdb33ad3162183f825c962fe33015b414c6cf2326b0a96da509e5b56881b171e38c9f8643e224d0d1b91bcf80a9ec469f6c3ba2e3adc5bc85c829540ac9161cf9263a2622f413c313cedf91781000749314ee833d6b1bdf94783f126d61371102d19efc118dba610a067a9bec3749efafe1dbc7b0cc4abe4ad7c74d72c9af63bcd2018d446c99ca64fb2a5b4fb211294a86f289af9c39933c1c224a263bb7867be5102550558acee7ca70e4ff781cd2de4085a10ec6487661d9eb2d147899de2e699615e96b28f253365b5d326eb83d873aa9fdf5f64710b6216f1530f30bfe77b9930ebabf2b3352117bfb84098fe7467508df40d2af4e78aa164890945099efb9595646645e38bf895925b2ca99c34ffbc20585ef03fdad64b5192a18d03adecfa5d74e279b6b0a0a89ef722d7ca39ff3f75f8696315ef3ef18ed85e604725ccac169632f0a34765c1b0d4c307f9c7dfd3538fd58634c2fd2aceab8064f45bca349e4cd8290fb1e7114ca88a53e66fd9f652cc6ce813169a36fbe73d196046cc1b0a886f8b2016254db85a0bc43cb9a8175ffcd881b24051b59647ff8ba94bd62a7f29c6436053afd93f47ca9e28375a4c3b3eca665b9ac7d35c1f0b26c2483fb142756b5c82766c0e13647d8ae24f6468ffbf6ad73e586d601a4d75085518b7c2fb84ee3b1098fd4a9188ee52a932bf307d2a6f2e3da58673428d9550335c16b5c8267fc2357b117c0b2d5326c0407c61c99a06a3a37f363e49c7fccad089ac6cd0cd9025656edb5241bff1244e2df3086ff58a208749635bc52c5b666d2ff96c408c97644600860fd042038f46c0baaca40215460baa8f023551c8b3a8c466ec12bfd9cb74f1969e009fa4592d953f8836b491b4f6f673159a901b6f0ed68c0e4ff631ad028a7451161c28ba3291f98223235e0ab32ac29f42e0f3a1ec4935e7c3fc13d02729498d86960f2f243a64df66d322c96a50381b6c386c370866bd8137ec90bb95160727611320dcfcd328448f38cfeb08a2f30f5cf88c8e3f41794da9d1db7aa56dcfff4dd08f91beb382aa4834fc5b1caf71b4df2125a8cb033c9ff00c955a54aa4a26c1fc8e18deae8310cceb9e5effb9e7dadac5de7b161c9098a1a860d4ddb898ede998701f98bd3785764015b20f6cbd9c82792552f803fa085a79467b165a74a37708c06167cd9113179050502aba08b4d99170153fd0b1240dda22bc749fbaab579586280d05ade87bba3755818c9571daddbd99e7098ee54ab3a82909d8016d34f6a1a9ae53067a7b4f99e9542b8cc7543d87414183c8a33478a01bb24b446d78c47b907b618345abe3d131edf879033380fcdfe98bd2f9ba03c6af4a9ed64a08b788c9b415f29220e5353b50aeae7925f4073f79e0d508e4198b9c645a071161e6d04d38f0a38e580b8b147bbd7a082210350e34b0b870ef3cb3b19640d988d4c677405ec1e6673d16dc2b03967c82df04f8c42e11b27784bc06f38729a43dc11d85d2236e704bf590feedb120969e5eb3420a315443fb46859d039f332232ca73541f4f6e775ca43f3b3cdc1691e5b5a0b5de3903dd35e746b2a39c61bd62e5bf77dab3473f13d1c5a06e1b25713b166566565cee45d70768c0adf195dd3e3d7936a5017c35355293df8427cb572d8e87a55c4975522a9683800272f0c882ca5f13f9ccf27eee48859478422a14c5ade57e0e38fa57f26ef31635b901d40125b135dff01c95a0cc27adbdf832f204a477c24e7f8046d39c07357d6aea6
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>生活与杂谈</category>
      </categories>
      <tags>
        <tag>unfixed</tag>
        <tag>None</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次关于hexo+next图片显示部分出错的debug过程</title>
    <url>/2024/08/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8Ehexo-next%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E5%87%BA%E9%94%99%E7%9A%84debug%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[今天看自己的博客，发现有的图片显示正常，有些不正常


有的内容多一层路径，有的图片就正常显示
经过多次对比发现是把\打成/
二者在typora中是都可以显示的，但是在生成博客时，如果没有使用反斜就会出错
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一道很有意思的简单考研数学题（奇偶性相关）</title>
    <url>/2025/10/23/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%80%E5%8D%95%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E9%A2%98%EF%BC%88%E5%A5%87%E5%81%B6%E6%80%A7%E7%9B%B8%E5%85%B3%EF%BC%89/</url>
    <content><![CDATA[题目描述：设 $f(x)=\frac{1}{2^x+1},x\in \mathbb{R},$ 则$f^{(100)}(0)=?$（即100阶导数）
学长听说我学完张宇第一章了，便给了我这道题检验学习成果
第一章全是极限相关的，但对于这道题，我翻来覆去也没看出哪里和极限相关的
于是乎只能硬导，企图寻找规律；奈何本人计算能力一般，算了三遍三阶导，每一遍都不一样
于是乎我去请教学长，得知和奇偶性相关，于是记录一下做法
简单地：$f(x)=\frac{1}{a^x+1}-\frac12$ 是奇函数，故而求导后是偶函数并且 $-\frac12$ 没了，这
第一步：化简函数
写成以 $e$ 为底：$f(x) = \frac{1}{e^{x \ln 2} + 1}$
第二步：中心对称性
$f(-x) = \frac{1}{2^{-x} + 1} = \frac{1}{\frac{1}{2^x} + 1} = \frac{2^x}{1 + 2^x}$
注意到：$f(x) + f(-x) = \frac{1}{1+2^x} + \frac{2^x}{1+2^x} = 1$
因此：$f(-x) = 1 - f(x)$
第三步：推导对称性条件对导数的影响
两边对 (x) 求导：

一阶导：$f’(-x) \cdot (-1) = -f’(x) \implies f’(-x) = f’(x)$所以 (f’(x)) 是偶函数。
二阶导：对上式再求导：$f’’(-x) \cdot (-1) = f’’(x) \implies f’’(-x) = -f’’(x)$所以 (f’’(x)) 是奇函数。

由此可以推得一般规律：$f^{(n)}(-x) = (-1)^{n+1} f^{(n)}(x)$
第四步：代入 (x=0)
令 (x=0)，得到：$f^{(n)}(0) = (-1)^{n+1} f^{(n)}(0)$
若要使该等式成立：

当 $(-1)^{n+1} = 1$，即 (n) 为奇数时，方程恒成立；
当 $(-1)^{n+1} = -1$，即 (n) 为偶数时，必须 $f^{(n)}(0)=0$。

第五步：结论
因为 (100) 是偶数：

\boxed{f^{(100)}(0) = 0}
如果我想直接求导呢？好像确实可以，要用到双曲正切~
下面的GPT给出的解法，我还没看懂：
用一点恒等变换就能把“死算导数”变成有规律的公式，既能解释为什么偶数阶导数在 $0$ 为 $0$，也能写出任意奇阶导数的闭式表达（含伯努利数）。步骤和结论如下。
先把 $2^x$ 写成指数形式并作代换：

f(x)=\frac{1}{1+2^x}=\frac{1}{1+e^{ax}},\qquad a=\ln 2.利用双曲正切的恒等式

\frac{1}{1+e^{y}}=\frac{1-\tanh\frac{y}{2}}{2},令 $y=ax$ 得

f(x)=\frac{1}{2}-\frac{1}{2}\tanh\!\left(\frac{a}{2}x\right).记 $b=\frac{a}{2}=\frac{\ln 2}{2}$。于是

f(x)=\frac{1}{2}-\frac{1}{2}\tanh(bx).由此得到两个直接结论：

$\tanh(z)$ 是奇函数，故其泰勒展开只含奇次幂，说明所有偶阶导数在 $0$ 处为 $0$。因此对原函数：

f^{(2m)}(0)=0\quad(m\ge1).这直接解释了为什么 $f^{(100)}(0)=0$。

对奇阶导数，利用链式法则

\frac{d^n}{dx^n}\tanh(bx)\bigg|_{x=0}=b^n\cdot \tanh^{(n)}(0),以及 $f^{(n)}(0)=-\frac{1}{2}$ 倍该值，可得奇阶的通项公式。



奇阶导数的闭式（含伯努利数）已知泰勒展开（关于 $x$）：

\tanh x=\sum_{k=1}^{\infty}\frac{2^{2k}(2^{2k}-1)B_{2k}}{(2k)!}\,x^{2k-1},其中 $B_{2k}$ 是伯努利数。由此得到对 $n=2k-1$（奇数）

\tanh^{(2k-1)}(0)= (2k-1)!\cdot\frac{2^{2k}(2^{2k}-1)B_{2k}}{(2k)!}
=\frac{2^{2k}(2^{2k}-1)B_{2k}}{2k}.因此对 $f$：

\boxed{f^{(2k-1)}(0)=-\frac{1}{2}\,b^{2k-1}\,\tanh^{(2k-1)}(0)
=-\frac{1}{2}\,b^{2k-1}\cdot\frac{2^{2k}(2^{2k}-1)B_{2k}}{2k},}稍整理可写成

\boxed{f^{(2k-1)}(0)=-\frac{2^{2k-1}(2^{2k}-1)B_{2k}}{2k}\;b^{2k-1},}
\quad\text{其中 }b=\frac{\ln2}{2}.
验证前几项（直观感受规律）从已知的 $\tanh$ 展开：$\tanh x= x-\frac{x^3}{3}+\frac{2x^5}{15}-\frac{17x^7}{315}+\cdots$。

$k=1$（一阶导）：$\tanh’(0)=1$，

f'(0)=-\tfrac{1}{2} b\cdot 1=-\frac{b}{2}=-\frac{\ln2}{4}.
$k=2$（三阶导）：$\tanh^{(3)}(0)=-2$（因为系数 $-1/3$ 对应 $3!(-1/3)=-2$），

f^{(3)}(0)=-\tfrac{1}{2} b^{3}(-2)=b^{3}=\left(\frac{\ln 2}{2}\right)^3.
$k=3$（五阶导）：系数 $2/15$ 对应 $\tanh^{(5)}(0)=16$，

f^{(5)}(0)=-\tfrac{1}{2} b^5\cdot 16=-8\,b^5.


总结
偶数阶导数在 $0$ 都为 $0$（所以 $f^{(100)}(0)=0$）。

奇数阶导数有明确闭式，且可用伯努利数写出通项：

f^{(2k-1)}(0)=-\frac{2^{2k-1}(2^{2k}-1)B_{2k}}{2k}\left(\frac{\ln2}{2}\right)^{2k-1}.

]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研数学</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一道2024.11.17做法南辕北辙的简单算法题</title>
    <url>/2024/11/21/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%932024-11-17%E5%81%9A%E6%B3%95%E5%8D%97%E8%BE%95%E5%8C%97%E8%BE%99%E7%9A%84%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[Codeforces Round 988 (Div. 3)因为当天有点头疼，飞速过了ABC，D卡住了，就去睡觉了
后来发现做法南辕北辙了
题目链接：D. Sharky Surfing

我的思路：
大致是从后往前扫，每次都要排序一次，然后选最优的
#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int N = 2e5;int n , m , L;int l[N+10] , r[N+10];int x[N+10] , v[N+10];int tempque[N+10] , top = 0;signed main()&#123;    // ios::sync_with_stdio( false );    int t;cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; l[i] &gt;&gt; r[i];        &#125;        for(int i = 1;i &lt;= m;i ++)&#123;            cin &gt;&gt; x[i] &gt;&gt; v[i];        &#125;        int jump_max = 0;        for(int i = 1;i &lt;= m;i ++)&#123;            if( x[i] &lt; l[n] ) jump_max += v[i];        &#125;        int ans = 0;bool flag = 1;        for(int i = n,j = m;j &gt;= 1;i --)&#123;            if( jump_max &gt; r[i] - l[i] + 1 )&#123;                top = 0;                while( x[j] &gt; l[i] )&#123;                    j --;                &#125;                while( x[j] &gt; l[i-1] )&#123;                    tempque[++top] = v[j--];                 &#125;                if( top == 0 ) continue;                sort( tempque + 1 , tempque + top + 1 );                int k = 1;                cout &lt;&lt; &quot;jp: &quot; &lt;&lt; jump_max &lt;&lt; endl;                while( jump_max - tempque[k] &gt; r[i] - l[i] + 1 )&#123;                    cout &lt;&lt; &quot;del: &quot; &lt;&lt; jump_max &lt;&lt; &quot; &quot; &lt;&lt; tempque[k] &lt;&lt; endl;                    cout &lt;&lt; &quot;de2: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; r[i] - l[i] + 1 &lt;&lt; endl;                    jump_max -= tempque[k++];                    ans ++;                    if( k == top ) break;                &#125;cout &lt;&lt; &quot;K1: &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; top &lt;&lt; endl;                while( k &lt;= top ) jump_max -= tempque[k++];                for(int kk = 1;kk &lt;= top;kk ++) tempque[kk] = 0;            &#125;else&#123;                cout &lt;&lt; -1 &lt;&lt; endl;                flag = 0;                break;            &#125;        &#125;if( flag ) cout &lt;&lt; ans &lt;&lt; endl;        // for(int j = 1;j &lt;= m;j ++) tempque[j] = 0;    &#125;    return 0;&#125;
后来第二个测试点的第一百多行wa了，我意识到做法假了，去看题解了
正解：正着扫，直接用堆存，贪心最大
#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;priority_queue&lt; int , vector&lt; int &gt; , less &lt; int &gt; &gt; q;const int N = 2e5;int n , m , L;int l[N+10] , r[N+10];int x[N+10] , v[N+10];signed main()&#123;    ios::sync_with_stdio( false );    int t;cin &gt;&gt; t;    while( t -- )&#123;        cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;        for(int i = 1;i &lt;= n;i ++)&#123;            cin &gt;&gt; l[i] &gt;&gt; r[i];        &#125;        for(int i = 1;i &lt;= m;i ++)&#123;            cin &gt;&gt; x[i] &gt;&gt; v[i];        &#125;        int ans = 0 , jump_range = 0;        int tool_top = 1;        for(int i = 1;i &lt;= n;i ++)&#123;            while( l[i] &gt; x[tool_top] &amp;&amp; tool_top &lt;= m )&#123;                q.push(v[tool_top++]);            &#125;            while( r[i] - l[i] + 1 &gt; jump_range )&#123;                if( q.empty() ) &#123;                    ans = -1;break;                &#125;                jump_range += q.top();                q.pop();ans ++;            &#125;if( ans == -1 ) break;        &#125;while( !q.empty() ) q.pop();        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;
总结：
不要钻牛角尖；简单题想复杂了，可以先吃点东西~
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>论文泛读学习</title>
    <url>/2025/07/17/%E8%AE%BA%E6%96%87%E6%B3%9B%E8%AF%BB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>说点老师的好话</title>
    <url>/2025/05/20/%E8%AF%B4%E7%82%B9%E8%80%81%E5%B8%88%E7%9A%84%E5%A5%BD%E8%AF%9D/</url>
    <content><![CDATA[
  7b22b1899bb4d215751e07a80f0d88de167c3831bec5fceb0b99f39a47bfc4bf51a8a314e161abf1769a061228078b2336178ee30d078682bcef33fb649d3f11c30f4b31f5bbdeb8da1012b181b013fba2484a8984ec5627dcfb89686a804bc09e033748077e0494492e35dd37863d0e0a4daa4e44e43c4c6cf59d15156c903c320242139b5fdc218eda881738501ba0322942f663027ea093444592708254ee0717367576e1861936029638f38f2cae777a8580f42288bb1265459fb0435a0da38fbc866b20e5a7f79771e207037d7b2214393a1db81cc683381c20883cff35d35fde6170133f03939f20ea58c1f672c29ce2c4710fbc9ef1cff9d5b48739ff585d685948df22c5d898293ba4579613dd119ebc822c463d58f50195c947d8c852a0af94634ec484552223a8773835d2c7a349961976e71f47793cc5930e06fd6b30b8a63e40b1fcc995352a0658566b252afc80fc1a1d4a52333a474ffd8f8dcc1809e29a5f77d783a7cffe07ea8f1e078c11eef78dd0e43ef13572f6ad32bb95c184c3db00278debe5dd684798ab49f497523032ccf756a0281ed4ac9aa8d8b4aac95d2d104a93f75b29e2a8f605900a26db25e4298dd7ec02412af3a80fe148116742e020b4bb5901374e23449e3db2ec5992bcf809d52252be55789b90cd82a3838298e8b2d67ee29298ee1a1b1091740e0303865862258e391bc990c9366204282a5ab6d17b16984c679c132627923105911f8c9267a83fc3a4c54d4d9db7753b6eea853d4d7a72a39522ed94cb4e9c9a5917044906fc427fde3aa7196e5243d8006404a74c70dc94a5384cd15b6c9a55f4880c17a027b37a4e2d993fc87e2450a4b53ddad6e4c6f19c788967ca5fd1d7a172b9c4567afebdfb579886901240882543715d759a9641309299d08d03485663ac8770671128b2b793780a132c457e0f95dc6df7551402109e1e83106f8653f58f82195134499d72e43203263d2f821e85ea74a761c5be08190ac2efba8f86c32e38de6449eb7b229b624695cfab48076ef1f2c8b221a3fda86e12a06a954275b9e485200d7334fa320bc990fa1768941d8dcbfa516bcdde5dd48ef62ba799966b6239751479d58c3ef88d168deb2ce850a3c840dcd76637fed6225b8d3151b1a4884d7f9bb7db26acb4890e42a38b5dca8c11a45cb8c8e9a471c7c8c1cbfcdd93d829186756f3df394b70a7dd74c954ebf5ce1ebf11bcf8354d9c74b163ecfc987fc2193cb49ee72870e863f646847c01898e4b9b58188da3abf6bc791694aff34efcae6d6e5a70e126e79a546a166a4841e65fcbb0d045292e9f0f5363b1acdf5a9688a08b9b7894d7b61b02dbc9aa197aabb83f13b7217e6580efded3ea836dd482592cd41f684cb2b637f0581e28cf25215f31632eec98210d1a00c7940d0e4c99fb9509931b1e1bda3948f592abab9bbf8f5f053371f310233f746854534aff0dcf1d0c15071f93cbc7c104a7db5fd01338180dd2a6fd8081ab316b383ac3371b1881574c185735f8fd44d7834890482bfd16f7e8ebba9fdbdfb4c53cc85ea68d71195c2115914fa91dd74a59855d376d6e3a91c70ed2d3ef2676014900031429ef6ed4850de1dd23654a63bb9c9bd33b0025bebf5bf36b19dd927c8116590b417967067007ba775e0c1fe111985024790e582f121f7696ca3d6b7c7cb8b3395b8469c512e40eb0082a353b4beff442e3646e38f3dfa564b3e1d364d326c9d5712d0b42f8675bfa11fc9659fd9101dc3594691f559a842a27819eeeb1feb515b759cc49ac40d4e2b91aa513095e91e48a37521f74dceb9b17e44ec65e28ea1738bae1e2e8414c893507a526970441357973ab82aadf97b69cc9846f2b31c2018ae2869c1214b481543a40984707c0e1ebd74ac7425d875aa39da46b163f31bca19a4269dd215e2ea227961fdc738911b297abe57f8230a79b22347663c0a8ea1cbdf795f2d7f9463d8b5fbea34655bbbcf7986772e9c5338acec88df9157cdd0cb60823d591294f997a6f4b70035a1234ddbcf728bb21170c7ba5193ca286ebe41f77446be2a834e57b96585a437e4475bdab4d11bef5f62ea576df855cc20b2ad46a87d3f0d8145068bc63c0a66aa7e758d095830191586af9890d8fbe41e829de146c71a39ee895d04a929465985411da1127dc5a8c2d404791d70df697e78614269dc4f3b48eeb55835ddc324a6b487cb2a8c5b91a8babfb17d4ff5dc8468a3a9b8239f138d6ba1d1e6b7970cbf14f37cba9cba020730e8fbf2be1a0ba2d3797f19d65d6caaa8da828ba32ad6beceae54ad3b7357a6909575f5faf9df37784dc5de8e8feb8cc4f6ad70067bed4ac6213105375897b498baae0865b7421409071a46561a3d53327a0cdeedc5e3ec0a2c2037a1417fd9a45ed7c90eb70dcc15fd34e01f45a8d4310225c07c3a7ddc1e52065f783c51bfe072158cb0d37f6c85f273db17761e70fd802100caa2707309f92b12e243cae30c0830939bc963e6abc3a908e98da99df05ae057908504a0f4e69b0694c4d3b5ccfb5d31a5376b123bf028f6aa4929d170f6448a01dbd583022273ef397b8c0c4429f22a0e18415483f1e88803a87a92fe4884c58bcaf45e2127e091298e998c48187ac7168cef5706bc30a264d226aef48a99093ede1b110a920c86f259ad6ab48d3789651c64c46c6966ea1db83e068511037ad8ee222735394e1296bdbfe1a2fe696f5b131b0dec63572a378b2f57badca05356ea6f72d671d02b5faf2cdd743307448cbcb627c94f1a6addd5833cfa51b0992a3ff3fd473d344fb82007699666e5453a3d7d8741383f1f663d8b0c0d4ee1ce395034da9274b7a001e4eb319f80e8bb165af658b424189c5d61e74fdbe436e8ca7ff3dbfafa58df7eb65984335158fca11ce204724ee06cc1659effdbcc3b0e4e8f86174e1238de237dd7ff1f50364cf02030daba80d887bb984ec059c36962ec9f6deef3c17be83c87906e37a768833316d20325c399f853d49630100dab59345131b913a0c5400176f128f4604696cc780c2a64ff6d13969ab846cde6f22f2e81005190bd7470a7bd9c2cdc1776e2a4dedc16f3dd0c2689d1df78e00ac63aa946910efdd350a06261114d16bcd7ec6865bb7c8f5c8476ad2ea911a91d0dc55eefa7f621f88d6005a0baee791a4efd0dd8938b85fed3fb554060510e33fcc9180c0933e8952884183f5694e8bb73b8a3bd2a0a5e75f154bdf215b728733c78c9f87fd31ec79d0206c361e2e2fcea802a4100a6f47e88e94673ba700d1b2e60e1aa228206da3149aa9e1e5970acca198695981552e6328f6c2edb0dff484fea927c573d94e0d3feaa96725783efa2ece7c5406313fa537c1428772c0a6f5c6867791ebf92726efea1623f3fa4c999ce694f4994226fd41b56e1f1669628e53583de68daf2e1dcb68dbdc615f94f78751b0bb77e6f4b051b07426f840c1e7e35ef66b2cba4dd764d9462aa7e6c1b079b9049ae84b5ef09f05d165ca9f05be2e6f5465ae9f4a991098a638b971b6c8ee2c066d9d9f7d86b0d6464a39883026c6ddc3c52c61290f4426e11ff46457fad15818178410a57dba175d6a6cb81a7ed88f54cd96aa97b712d2f4cf6de42933d17a91aebe031edaef7c4659b0c46bbabfc99660778589a0864c45eb5389448a486f3545a859ad68955a7f5f2d855bb789303f1493ea19ac94e481f2e048249f7ca75472b9f59c0a3a48edb51740955bb6804599637c517865c8bc08ada0faba1df83e379dc3565746019360a8141612e271d8f8d9abea7a74ef9f6c7c99b01e54830a4a2f086500ceb6b9027557b1ac2c348977c28daf682c3b0844b2949955d2dcadae7d79b7d32b8351d350e80956dbc3ed01dc3fdc85fdd2847452d695155c9ab736f67f1ad2f293257e10645150f4acf4c88f4d93bb1eb2459cbd9f080fa09653b03511c827f5eafb8c1a4a44f698692f59bd6ddb3d811bb5a78f3d7851d1a297e16cdb7884c0b32bff415e77ae090450cd0907bb7a4f3a4fa70dada732ad5014e7fc4bad46526029a7ee5743271ee529b74aa4c73170017c3cfabc95c6407e71e4f1547df83571ce863932ceea1c54a433050f0d105dcdfdd5f494a9d98840300bde652dfdbb02b44c661d36d3774b332adab9a8bb9d67563df8beb341a293d9a96de95947b5e9259502ad617b2efbc092b142b557b700a7c831a56350686fa7a8921dfd031b0211951b0c4f8a2b980333bc6a11342f2c5853edd80ea30adac3da3fa7e5a811a3b978be708f6a02f6a569aad9f86a0cc9f2b6ec8d7c640b6bcc41b09bddda3c95d25d101ae4c5830372a0918de23a4f454dc7dc2ddb7e4bd8ac8545a5a6052f72d24935d1308fcd84171135a1ce04860d2c9c1517f512c509c122f6ce226c6319e015a94a2d55488f5fe702cab9a265f7b04229e3ef53e1a39595d68709b0d9fc2f9eee2b226227c232a8bb39b3d32f052c6c70a4d72c090702d79bab7105aca16e292f8db46368ed32bf01de2d9cf4dcdc0025ccffc0292167b67972092f41f1704dc4e3215bf7e84d6c423d4e7d75fca74ffb293197e9013e1a486fd19a54b54568689efc45b71936bf4a3b629a82dda2771fe0560468003e5bbe898eb2156ea96b4bdd2e08c4db5794ee1f9c5c8c09bb8ee273f76763cca7845edcde2848374f96a0e92fbba1e56cdb4e268afb1d7ec04f5ce8b77528de21c6fbcf5b7b068998c0df27e0b1f8e8f423564059a23de46807dc680b59e491f61615cd8361f9aa948a09fc2b1a5c7b76000045f648201ea8e8a1b8f8fbb40d07e8785d6ebc96eb307dd6682cc4f33a4414e9047925ff52a3562340b468d676b18d1da33efc35c70257bcd509710387ecd47cea8955c12a2dc06e36febae98280e8d571ed438d21cb562ce24b1075ee3dadf5921df68da13d2fa996aaf4e0e1b5ab7cfb3cdb610e8c20c7537751ad621f14812517149da8bef5bae0cd928247fbc6fa57074e9f3b31cdb7661261
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>一点小思考</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>配置一键博客备份并上传</title>
    <url>/2025/04/26/%E9%85%8D%E7%BD%AE%E4%B8%80%E9%94%AE%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%B9%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[本文介绍了hexo博客，如何一键备份到仓库并上传


hexo是只把生成好的页面上传，这就导致了不可逆。也就是说原文没有，就恢复不了了，所以配置了一下git保存。这样算下来就一共六条指令了，很费劲，然后写了个一键运行
原理上挺简单的，不过真正实践起来有些bug，好在最终优雅的实现了
由于我的博客有些是需要加锁的，所以不能上传到同一博客的不同分支，索性直接创建一个新的私有仓库来保存源文件
然后把新仓库的git文件，放在原来的博客里

然后进行测试，发现hexo g出现报错，经查验是因为themes里面也有一个.git文件；这个文件对咱们用途不大（应该说是基本用不到），所以可以直接删掉
然后测试一下git和hexo，不出意外可以正常运行了
下面写一个一键运行脚本，拓展名是.sh，具体代码如下：
#!/bin/bashhexo cleangit add .git commit -m &quot;Update blog content&quot;git pushhexo generate #最后generate可以节约流量hexo deployif [ $? -eq 0 ]; then  echo &quot;Blog deployed successfully!&quot;else  echo &quot;Hexo deploy failed!&quot;fi
每次想生成博客的时候，打开bash然后输入 ./文件名.sh就可以一键运行了
可以起一个可以用Tab键一键补齐的文件名

嗯？怎么就这么点东西
我居然改bug改了一个下午（悲
]]></content>
      <categories>
        <category>工具与技术使用</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一道泰勒公式相关的考研数学题</title>
    <url>/2024/09/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
    <content><![CDATA[今天，有个学长（烤盐糕守）发给了我一道树穴题（据说是刚出锅的热乎题）
问题：极限 $lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{x^2-sin^2xcosx}=?$

方法一：洛！
计算量巨大，不做展开
方法二：泰勒
先放答案：

\begin{align*}
      &\ \ \ \ \ lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{x^2-sin^2xcosx}\enclose{circle}{1}\\
    &= lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{x^2-(x-\frac{1}{6}x^3)^2(1-\frac{x^2}{2})}\enclose{circle}{2}\\
    &= lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{\frac{5}{6}x^4}\enclose{circle}{3}\\
    &= lim_{x\rightarrow 0}\dfrac{(x-(x-\frac{x^2}{2}))\frac{x^2}{2}}{\frac{5}{6}x^4}\enclose{circle}{4}\\
    &= \frac{3}{10}\enclose{circle}{5}
\end{align*}
分母（式①到式②）怎么来的？

因为无穷小的运算法则：$o(x^n)+o(x^m)=o(x^{min(n,m)})$，低阶（无穷小）相应的更大，而分母的泰勒展开是直接要最小项的（无穷小的运算法则让它展开为最小项），所以要用更大的那个无穷小去算
对于分母 ${x^2-sin^2xcosx}$，cos的阶数是 平方，所以取 $x^4$ 作为实质的最小项（$x^2$ 消掉了）

\begin{align*}
      &\ \ \ \ \ lim_{x\rightarrow 0}\ {x^2-sin^2xcosx}\\
    &= lim_{x\rightarrow 0}\ x^2-(x-\frac{1}{6}x^3)^2(1-\frac{x^2}{2})\\
    &= lim_{x\rightarrow 0}\ x^2-(x^2-\frac{1}{3}x^4+\frac{1}{36}x^6)(1-\frac{x^2}{2})\\
    &容易观察到，x^2项全消了，所以最小项就是x^4\\
    &= lim_{x\rightarrow 0}\ \frac{1}{3}x^4 * 1 + x^2 * \frac{x^2}{2} \\
    &= lim_{x\rightarrow 0} \frac{5}{6}x^4
\end{align*} \\如果只取sin的第一项：

(错误示范)\\
\begin{align*}
      &\ \ \ \ \ lim_{x\rightarrow 0}\ {x^2-sin^2xcosx}\\
    &= lim_{x\rightarrow 0}\ x^2-x^2(1-\frac{x^2}{2})\\
    &= lim_{x\rightarrow 0}\ \frac{x^4}{2}
\end{align*} \\显然是不完整的，有一部分的 $x^4$ 未考虑
综上所述：分母的泰勒展开是直接要最小项的，但是不是只取最终项，要完整的求出最小项（如本题中，是 $x^4$ ），根据如何得到最小项来判断泰勒展开需要多少项（其实展开多了也没事，反正不会是最小项）

分子（式③到式④）怎么来的？

分子泰勒展开，展开到和分母一样的阶数即可⑤
式子 $lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{\frac{5}{6}x^4}$ 中，分母是四次方，所以分子也要展开到四次方（见后文，删除线中的内容和因果关系是错误的，但是本题中确实是展开到四次方）

\begin{align*}
      &\ \ \ \ \ lim_{x\rightarrow 0}\ (x-ln(1+x))(1-cosx) \\
    &= lim_{x\rightarrow 0}\ (x-(x-\frac{1}{2}x^2))\frac{x^2}{2} \\
    &= lim_{x\rightarrow 0}\ \frac{x^4}{4}
\end{align*}相关例题：
试计算 $lim_{x\rightarrow 0}\ \frac{x-sinx}{x^3}$
解：

\begin{align*}
      &\ \ \ \ \ lim_{x\rightarrow 0}\ \frac{x-sinx}{x^3}\\
      &\ \ \ \ \ 因为分母的最高项是三次方，故这里sinx也展开到三次方(这句话也是错误的，见下文 \\
    &= lim_{x\rightarrow 0}\ \frac{x-(x-\frac{1}{6}x^3)}{x^3}\\
    &= lim_{x\rightarrow 0}\ \frac{x-(x-\frac{1}{6}x^3)}{x^3}\\
    &= lim_{x\rightarrow 0}\ \frac{\frac{1}{6}x^3}{x^3}\\
    &= \frac{1}{6}
\end{align*} \\
为什么分子分母要等阶（⑤）？

高阶无穷小+低阶无穷小=低阶无穷小
所以无论展开几项都是一样的，都会只有最低阶（即展开后较靠前的部分）对于极限的计算有影响
故 无论分子分母，只需要展开到最低阶（即最终式子剩下的最低阶）
无需证明是否在极限值附近有界，只需要分子分母分别展开即可（这也是上文中删除线中句子错误的原因）

总结

计算此类题目（无法使用等价无穷小），只需要将分子分母中可以展开的项分别展开（目的是为了消项），展开到保留（最终结果的）最小项，再进行运算比较即可
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研数学</tag>
      </tags>
  </entry>
  <entry>
    <title>量子安全的概念</title>
    <url>/2025/02/20/%E9%87%8F%E5%AD%90%E5%AE%89%E5%85%A8%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[昨天组会，导师跟我说量子安全和后量子安全不是同一个东西，我此前一直将他们混为一谈，故今日作以区分

量子安全：指加密方法在量子计算机下仍保持安全。
反量子安全：通过增强现有算法对抗量子计算机的能力，通常是过渡性措施。
后量子安全：指完全为抵抗量子计算机的攻击而设计的新的加密算法。

UPD250910
上述内容并非完全正确，今天看了一个构造，通过量子计算机去优化一个ai算法，于是我想到
后量子密码学是用传统计算机加密，量子计算机无法解密，但是效率低下；有没有用量子计算机加密的密码学
后面得到答案
首先，反量子这个词并不正式，故而很少见

量子密码学 (Quantum Cryptography)


定义：利用量子物理规律（如叠加态、测不准原理、不可克隆定理）来实现安全通信。
代表：量子密钥分发（QKD, BB84 协议）。
特点：
安全性基于物理定律，而不是数学难题。
窃听会留下“痕迹”，因此可以检测。
需要量子信道（光纤或自由空间），成本和距离受限。




后量子密码学 (Post-Quantum Cryptography, PQC)


定义：运行在 传统计算机 上的加密方法，但能抵御量子计算机的攻击。
代表：格密码、哈希签名、多变量多项式密码、基于编码的密码。
特点：
数学难题仍是安全性基础（例如格上最短向量问题）。
可在现有网络和硬件上直接部署。
已进入国际标准化（如 NIST PQC 标准）。



📊 对比总结



名称
基础
依赖设备
代表技术
安全性来源
部署难度




量子密码学
量子物理
量子信道、量子设备
QKD (BB84)
物理不可克隆/测不准原理
高


后量子密码学
数学难题
普通计算机、网络
格密码、哈希签名
抗量子算法
中




✅ 所以你可以简单理解：

量子密码学：用量子去加密。
后量子密码学：用经典计算机去防量子。
反量子密码学：泛称，通常指“抵御量子威胁的密码”，多半就是指 后量子密码学。

]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>零知识证明学习</title>
    <url>/2024/12/19/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[241219阅读《Chameleon-Hashes with Ephemeral Trapdoors And Applications to Invisible Sanitizable Signatures》遇到了NIZKPoK，故学习一下


NIZKPoKNon-Interactive Zero-Knowledge Proof 非交互零知识证明
论文中的体现
\begin{align}
&Generate\ \pi\leftarrow NIZKPoK\{(x):h=g^x\}\\
&if\ \pi\ is\ not\ valid, return\perp
\end{align}解释证明着想要证明自己知道某个值$x$，而不透露$x$本身
Fiat-Shamir变换（简化的非交互证明）
初始化：$g$和$h$是公开的参数，$x$是秘密（证明者知道它）
生成证明：随机选择一个随机值$r$，计算承诺值$t=h*g^r$
计算挑战：生成一个挑战$c$（通常通过哈希函数生成）
计算响应：计算 $z=r+c*x$
发送证明：发送三元组$(t,c,z)$
验证：验证者检查是否满足$g^z=t*h^c$

实验代码#这份是手搓的，放进代码复现成功def gen_NIZK( g , x , p ):    h = pow( g , x , p )    r = random.randint( 1 , p )    t = pow( g , r , p )    c = SM3(&quot;窝丝一个挑战&quot;)    z = r+c*x    return (t,c,z),(g,p,h)def verf_NIZK( pi ):    ( t , c , z ) , ( g , p , h ) = pi    if pow( g , z , p ) == t * pow( h , c , p ) % p:        return True    return False
完整代码
#这份是gpto1写的，不过是基于椭圆曲线的from ecdsa import SECP256k1, SigningKey, VerifyingKeyimport hashlib# 曲线参数curve = SECP256k1G = curve.generator  # 基点 gn = curve.order      # 阶# 私钥 x（随机生成）x_sk = SigningKey.generate(curve=curve)x = x_sk.privkey.secret_multiplier  # x 的数值# 公钥 h = g^xh_vk = x_sk.verifying_keyh = h_vk.pubkey.pointdef nizkpok_prove(x):    # 证明者生成随机数 r    r_sk = SigningKey.generate(curve=curve)    r = r_sk.privkey.secret_multiplier    # 计算承诺 t = g^r    t = r * G    # 计算挑战 e = Hash(g || h || t)    e = hashlib.sha256()    e.update(int(G.x()).to_bytes(32, &#x27;big&#x27;) + int(G.y()).to_bytes(32, &#x27;big&#x27;))    e.update(int(h.x()).to_bytes(32, &#x27;big&#x27;) + int(h.y()).to_bytes(32, &#x27;big&#x27;))    e.update(int(t.x()).to_bytes(32, &#x27;big&#x27;) + int(t.y()).to_bytes(32, &#x27;big&#x27;))    e_int = int(e.hexdigest(), 16) % n    # 计算响应 s = r + e * x mod n    s = (r + e_int * x) % n    return (e_int, s)def nizkpok_verify(h, proof):    e_int, s = proof    # 计算 t&#x27; = g^s + (-h^e)    sG = s * G    eH = e_int * h    # 获取 eH 的负元    neg_eH = (n - 1) * eH    # 计算 t&#x27; = sG + (-eH)    t_prime = sG + neg_eH    # 重新计算挑战 e&#x27; = Hash(g || h || t&#x27;)    e_prime = hashlib.sha256()    e_prime.update(int(G.x()).to_bytes(32, &#x27;big&#x27;) + int(G.y()).to_bytes(32, &#x27;big&#x27;))    e_prime.update(int(h.x()).to_bytes(32, &#x27;big&#x27;) + int(h.y()).to_bytes(32, &#x27;big&#x27;))    e_prime.update(int(t_prime.x()).to_bytes(32, &#x27;big&#x27;) + int(t_prime.y()).to_bytes(32, &#x27;big&#x27;))    e_prime_int = int(e_prime.hexdigest(), 16) % n    # 验证 e 是否等于 e&#x27;    return e_int == e_prime_int# 生成证明proof = nizkpok_prove(x)# 验证证明is_valid = nizkpok_verify(h, proof)print(&quot;证明是否有效：&quot;, is_valid)
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一道考研数学-关于三角函数的极限</title>
    <url>/2024/09/21/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6-%E5%85%B3%E4%BA%8E%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90/</url>
    <content><![CDATA[题目：$lim_{n\rightarrow \infty}n\pi sin(n\pi)=?$

因为是填空题，所以一眼能看出来得 $0$ 
为什么是零呢？因为感觉不是正数也不是负数（对偶性），所以只能是 $0$
学长的讲解：
当 $n \to \infty$ 时，可以把问题理解为一个数列的极限，也就是趋于正无穷的实数。但是，直接看 $n \pi \sin(n \pi)$ 的极限是行不通的，因为这个表达式相当于 $0 \times \infty$ 的形式。在这种情况下，你可能想把 $0$ 单独拿出来处理，但根据乘法运算的规则，只有当两个乘数都存在时，才能进行这样的操作。
所以我们先不要直接看极限，而是先看表达式 $n \pi \sin(n \pi)$ 本身。在 $n$ 为实数的情况下，$\sin(n \pi)$ 总是 $0$，因此这个表达式无论 $n$ 是多少，都是 $0$。即使把极限带入，结果也是 $0$。尽管你可能会觉得这种形式是“无穷小乘无穷大”，不一定是 $0$，但实际上这是 $0$ 乘以任何数，结果必然是 $0$。
无穷小和 $0$ 是不同的，$0$ 是无穷小的一种特殊情况。虽然无穷小乘无穷大的结果并不总是 $0$，但在这里，表达式的极限确实是 $0$。

但是我的问题在于，随着 $n$ 的增大（只考虑趋向于正无穷大），函数值高速震荡，感觉不像是有界的

之后发现它确实是有界的，因为：
在判别函数的有界性时，我们需要先知道以下两个重要结论，即： 如果f（x）在闭区间［a，b］上连续，那么f（x）在闭区间［a，b］上有界。 如果f（x）在开区间（a，b）上连续且函数的极限存在于其端点处，则f（x）在开区间（a，b）上有界。
这个函数包连续的，所以理所当然的有界
既然都有界了，那么极限存在

后记：
结合网上的说法和gpt4o给出的答案，$\lim_{n \to \infty} n \pi \sin(n \pi)$ 不存在
当且仅当 $n\in N^*$ 时，$\lim_{n \to \infty} n \pi \sin(n \pi)=0$
如果 $n$ 是非整数实数，$\sin(n \pi)$ 会在 $[-1, 1]$ 之间振荡。而由于 $n \pi$ 趋向无穷大，乘积 $n \pi \sin(n \pi)$ 是一个无穷大乘以振荡的值，无法直接确定这个极限。
因此，严格来说，$\lim_{n \to \infty} n \pi \sin(n \pi)$ 是发散的，并不存在一个简单的极限值。如果我们只考虑 $n$ 为整数的情况，则结果为 $0$，否则该极限无法求出。
 $\lim_{n \to \infty} n \pi \sin(n \pi)$ 存在，当且仅当 $\lim_{x \to \infty} \sin(x)$ 存在；众所周知的，$f(x)=\sin(x)$ 既不收敛也不发散（在讨论整个序列时，极限存在与收敛实际上是等价的），故极限不存在
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研数学</tag>
      </tags>
  </entry>
  <entry>
    <title>飞行器空气动力学学习笔记（低速翼型）</title>
    <url>/2024/08/10/%E9%A3%9E%E8%A1%8C%E5%99%A8%E7%A9%BA%E6%B0%94%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BD%8E%E9%80%9F%E7%BF%BC%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[2024.11.06二次编辑
理论的话学这些已经足够了，基础知识不需要太多，该着手于上手实操和控制系统的调试了
故不再更新


机翼定义：平行于机翼的对称面截得的机翼截面称为翼剖面，通常称为翼型
飞机设计中，在确定了平面形状、机翼形状后，首先要做的工作就是翼型设计。翼型的气动特性，直接影响到机翼及整个飞行器的气动特性
翼型设计：确定机翼的几何形状

圆头尖尾用于低速、亚音速和跨音速飞行的飞机机翼，以及低超音速飞行的超音过飞机机翼
尖头尖尾用于较高超音速飞行的超音速飞机机翼和导弹的弹翼
翼型的几何参数前缘点、后缘点、翼弦弯度、厚度前缘半径、后缘尖锐度
前缘点指的是最前面，后缘点指的是最后面，连接前缘和后缘的直线,称为翼型的弦线,其长称为几何弦长,简称弦长（一般用字母b表示）。
描述翼型经常使用体轴坐标系（相对应的是“风轴坐标系”）

无量纲坐标可以写为

经过这样的处理之后，翼型的长度是1
中弧线：每个x值对应的两个y值的平均值，中弧线的无量纲坐标$\bar{y}_f(\bar{x})$称为弯度分布函数，最大值称为相对弯度$\bar{f}$，对应的弦向位置记为$\bar{x}_f$

\bar{y}_f(\bar{x})=\frac{\bar{y}_上+\bar{y}_下}{2}\\
\bar{f}=\frac{f}{b}=[\bar{y}_f(\bar{x})]_{max}\\
\bar{x}_f=\frac{x_f}{b}
$\bar{c}&lt;=12%$ 的翼型统称 薄翼型（薄翼型理论）

前缘顿度：对圆头翼型，用前缘的内切圆半径 $r_L$ 表示前缘钝度，该内切圆的圆心在中弧线前缘点的切线上，圆的半径 $r_L$ 称为前缘半径
相对值定义 $\bar{r}_L=\frac{r_L}{b}$
后缘尖锐度：后缘处上下翼面切线的夹角，称为后缘角 $\tau$，表示后缘的尖锐度

低速翼型编号
翼型的迎角在翼型平面上，来流和翼弦之间的夹角，称之为迎角(攻角)

一定程度内，迎角越大，升力越大
对弦线而言，来流上偏升力为正，来流下偏升力为负
飞机的迎角：来流和机身轴线间的夹角
滑跑：三轮着地，速度方向平行于地面
拉起：前轮离地，速度方向平行于地面
起飞：三轮离地，速度方向偏向于轴线方向

对于一个无限翼展展长的机翼，展向取于一个单位展长的翼段，那么这个翼段上的绕流及气动力就是翼型的绕流和气动力
翼型表面上每个点都作用有压强和摩擦应力，它们产生一个合力品，将R分解为垂直于来流和平行于来流方向的两个分量

垂直于来流方向的力称之为升力平行于来流方向的力称之为阻力
法向力垂直于翼弦方向的力轴向力平行于翼弦方向的力

（$\alpha$ 表示来流迎角）

低速翼型指的是马赫数小于0.3的流动对于一个给定的翼型，在不同的迎角情况下他的绕流特征是不一样的
0°迎角绕流，流过相对平滑
 
10°迎角绕流，尾部少许分流

30°迎角绕流，整个背风区都出现了分离流动

合适迎角——稳流
临界失速迎角——气流分离
失速迎角——湍流

库塔-儒可夫斯基后缘条件小迎角下，翼型绕流的压力分布及升力，与绕翼型的无粘位流的压力分布及升力无本质差别；因此，不计粘性作用，用绕翼型的无粘位流求解翼型压力分布及升力,是合理的近似绕翼型无粘位流的升力问题，遵循儒可夫斯基升力定理，直均流流过任意截面形状翼型的升力:  
$Y=\rho V_{\infty} \Gamma$ （升力=密度*来流速度*环量）确定速度环量是关键
 只有后驻点在后缘点上，才能有唯一的速度环量值与之对应

 
圆弧形后缘翼型：$V_{S上}=V_{S下}$ ，后缘点没有载荷（库塔-儒可夫斯基后缘条件）
薄翼型理论低速位流的控制方程$\Phi$速度位，$\phi _{\infty}$来流速度位，$\vec{n}$翼面外法线单位矢
速度位：即“速度势”（velocity potential），标量，用于描述无旋流动（即涡度为零的流动）和处理理想流体（无粘性且不可压缩的流体）的流动问题。
设流场中的速度矢量为 ($\mathbf{v}$)，如果流体的流动是无旋的（即涡度 ($\nabla \times \mathbf{v} = 0$)），那么存在一个标量函数 ($\Phi$)（速度势），使得流场中的速度可以表示为该函数的梯度：($\mathbf{v} = \nabla \Phi$)。
由于流体是无旋的，可以保证存在这样一个标量函数，且该函数满足拉普拉斯方程 ($\nabla^2 \Phi = 0$)，这就是所谓的速度势方程。
速度位与速度的关系：$\nabla\Phi = \left(\frac{\partial \Phi}{\partial x}, \frac{\partial \Phi}{\partial y}\right)=(v_x,v_y)$
单位外法矢分量 $\vec{n}=(n_x,n_y)$

翼型低速无粘位流

小扰动线性化近似的解析解法
扰动速度位的线性方程翼型绕流速度位 $\Phi$ 满足拉普拉斯方程，因此它可分解为直均来流速度位 $\phi _{\infty}$ 和翼型存在引起的扰动速度位 $\phi$ ，即
因有 $\Phi=\phi _{\infty}+\phi\ \Delta \Phi=0\ \Delta\phi _{\infty}=0$（满足拉普拉斯方程）
所以扰动速度位也满足拉普拉斯方程（翼型的存在引起的扰动速度位）
翼面边界条件线化近似翼面上 $x,y$ 方向的流速分量记为 $v_{xw},v_{yw}$
问题：绕过一个翼型，来流迎角为$\alpha$，来流速度为$V_\infty$的无粘位流的流动情况


$\alpha$表示来流迎角，$cos\alpha$ 趋向于0，$sin\alpha$趋向于$\alpha$
x方向速度 ≈ 来流速度 + 由于翼型的存在引起的扰动的x方向速度
带入得到


最终可以得到翼面边界条件的线性化近似表达式：

边界条件=来流速度（弯度±厚度-来流迎角）
压强系数的线化近似根据伯努利方程，流场中任一点的压强系数为

$v$表示当地速度，$V_\infty$表示来流速度
略去二阶小量，只保留一阶小量，则有

其中 $C_P$是物面的压强系数
进一步近似，得到

分别为：来流迎角引起的部分+翼型弯度引起的部分+翼型厚度引起的部分
小结：扰动速度位的线性叠加
再将问题分解，即可分为迎角问题，弯板问题和厚度问题

分为三个分方程，每个方程都对应一种流动

弯度问题 对应 0攻角情况下中弧线弯板扰流，$y_{f(x)}$就是这个翼型的中弧线
厚度问题 对应 没有迎角的厚度对称问题
迎角问题 对应 有迎角的平板扰流
]]></content>
      <categories>
        <category>电控</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>高数下学习笔记</title>
    <url>/2025/06/22/%E9%AB%98%E6%95%B0%E4%B8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[






]]></content>
      <categories>
        <category>课程与考试重点</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
</search>
