<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于分布式TEE的一点头脑风暴</title>
      <link href="/2025/07/02/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FTEE%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4/"/>
      <url>/2025/07/02/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FTEE%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> unfixed </tag>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数下学习笔记</title>
      <link href="/2025/06/22/%E9%AB%98%E6%95%B0%E4%B8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/22/%E9%AB%98%E6%95%B0%E4%B8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20250622154357083.png" alt></p><span id="more"></span><hr><p><img src="dan.png" alt></p><p><img src="dan5.png" alt></p><p><img src="tian.png" alt></p><p><img src="3.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库2025期末考试重点</title>
      <link href="/2025/06/17/%E6%95%B0%E6%8D%AE%E5%BA%932025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/"/>
      <url>/2025/06/17/%E6%95%B0%E6%8D%AE%E5%BA%932025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>本来想敲一遍的但是看我的字貌似能看懂就直接发上来啦~</p><span id="more"></span><p><img src="91be497a2a2d30452943bff6a98b77b3.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统2025期末考试重点</title>
      <link href="/2025/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/"/>
      <url>/2025/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>本文记录了老师讲的操作系统期末考试重点</p><p><img src="1.jpg" alt></p><span id="more"></span><hr><p><img src="2.jpg" alt></p><p>一、处理机</p><ul><li><p>进程：特征 和线程区别 程序段数据段</p><p>PCB：是什么 有什么 进程索引</p></li><li><p>状态转化 <strong>转化图</strong></p><p>同步互斥 同步-前后 互斥-同时</p><p>调度算法 <strong>优先算法 时间计算</strong>，<strong>信号量</strong>，作业调度 进程调度 内存调度</p><p>死锁算法 必要条件（4个） 处理办法（大题：银行家算法）</p></li></ul><p>二、存储器</p><ul><li>层次结构 寄存器 内存 硬盘</li><li>分配方式 连续分配（单一，固定，<strong>动态</strong>/可重分配）动态分区分配的四个算法  内部外部碎片（利用率）； 离散分配 <ul><li>页式存储（访问两次，通过PCB） <strong>给逻辑地址求物理地址</strong> ， <strong>计算逻辑地址分成几个页</strong>，倒排页表</li><li>段式存储（访问两次）根据逻辑模块存储，每个段大小不一致</li><li>区别：页表里存一个数（起始），段表存两个数（起始和终止）</li><li>段页式：访问三次</li><li>虚拟存储器：基于请求的（不要求进程的全部内容进入内容）1.请求调入 2.页面置换</li></ul></li><li>置换算法<ul><li>先进先出，最长最短时间 追加算法 时钟算法…</li><li>执行后发生几次置换，几次中断，缺页次数</li></ul></li><li>地址转换</li></ul><p>三、设备管理</p><ul><li>层次结构<ul><li>从上到下：共性 个性 交互方式</li><li>设备独立性，中断</li></ul></li><li>控制方法<ul><li>四种方式</li><li>通道程序</li></ul></li><li>缓冲管理<ul><li><strong>单/双缓冲</strong></li></ul></li><li>设备分配<ul><li>sdt dct coct 概念</li><li>独占改为共享</li></ul></li></ul><p>四、文件管理</p><ul><li>物理结构<ul><li><strong>文件最大数</strong></li><li>文件在磁盘上如何分配空间，正犹如进程在内存上分配空间（前面内容）</li><li>链接（隐式，显式）FAT32 刻画内存空间</li><li>进程：页表；文件：索引。链接，多层索引（计算文件最大多大）</li><li>混合索引（结构求最大，已知大小求索引等级）</li></ul></li><li>逻辑结构<ul><li>概念理解，不容易出计算题<ul><li>顺序文件等（哪个支持随机访问，哪个可以拓展）</li></ul></li></ul></li><li>目录结构<ul><li>结构（几级，树形）各自实现功能</li></ul></li><li>共享保护</li></ul><p>五、磁盘</p><ul><li>物理构造</li><li><p>访问时间</p><ul><li>人为优化：寻道时间（大题</li></ul></li><li><p>扫描算法</p><ul><li>多个算法</li></ul></li><li><p>优化方式</p><ul><li>交替···</li></ul></li><li><p>空间管理</p><ul><li>卫视图法（计算）</li></ul></li></ul><p><img src="IMG_20250617_151448-175014564106810.jpg" alt></p><p><img src="IMG_20250617_151653-17501456410678.jpg" alt></p><p><img src="IMG_20250617_152030-175014564106811.jpg" alt></p><p><img src="IMG_20250617_152520-17501456410689.jpg" alt></p><p><img src="IMG_20250617_152943-175014564106812.jpg" alt></p><p><img src="IMG_20250617_153049-175014564106813.jpg" alt></p><p><img src="IMG_20250617_153235-175014564106814.jpg" alt></p><p><img src="IMG_20250617_153412.jpg" alt></p><p><img src="IMG_20250617_153532.jpg" alt></p><p><img src="IMG_20250617_161342.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学2025期末考试重点</title>
      <link href="/2025/06/17/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A62025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/"/>
      <url>/2025/06/17/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A62025%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b3022949a75fe1a20bc0c96e0b196cfa2c8091139ca4a1284c79100ffb0b908b">3b3cf79b0eabd6299e13c545e84d581a4bb8710e65c6619349a83cfd227685b97a6107da1ad0f52bf08d7b8c61049ae54d977abbcf364552a436627e53f8eac76cac039044f4a7ae3f61c95a1ff4081063fd8ffee958d81eded31db25fa4bba17ccf01448743a3cf5e9f93b23bb609dece00531e887f77022fa56574599e0a9ede3217a4072fc6e5004a1394c58c9b0f87c5874c0f85ca14b7ac171122ef70faccb242f3a7699b1835185c35990b576b6d963d5eec9daebcb6ee0802dd224e407f81329f28e45f872802cae99dd3037c5e7d7c318e0110122178b757834d9b1854bde00b27c8bcbcd3efd838ba278cf4b8e279f21eeac3af64d6e5d2dfe31dbb423cbfe06cd4798b2be548901cbc03b680fcb7ee525a6d39a7b8cb1a39ccb4612e80b95079cd8f1550e1ed42a636643b5d8138b481006a8c1f335ddb692a742258e738c5ce0cdc641dd8ec4d6fac483c4fa9e0f11b15f6581402ab4861658b3730a36b0eadd534c52895a4a54dea5b409862bc560481ab05fabcaf8e2cfd123f7418a4faa7af690147a97aae6299abc85a519d7f07c7f501db3d43189b218f7f58855c30d168eed1e24dc9369c855f7d435ffbd024069b585d38fe55e92630fda13b4defb6fa68577799fa0f91b6725c1171eae161e5182c15fe3b3d4d2d80d93c25400a43e04a717714e62bfdae2f8d8848a2d1a7a22d3e3d7f8c0369fbf5f64473434a99c379ba9ca8075d4203376598a5a871bae9b1b9e1531f7cd3c249da870060841ce91b0a4f465c90c3a82d1631ab61d0a516394d6e1c31a4d73f566ed4c5953e52c007a082fc0662f925b5a78efda965d98462992c9bcc8de3b0651cee3df023028f68373433162561cd6b6503351c951b0fd352ab91d2825a32b199e9198ca4422a160c21b883bb137c2dc3d3f5584707a5ec1431251f6e87015d46115762a9b25fd20220b9ac563d5dcd91cb90075789a819ba40fdcc75399f23d2e1efb6d7d25cb05efd95f4c5e92620e48b03c1938cf6275c976d5510b2d5527056dbce69a1b78b300a267c700bded3e58e80f93ad47f0b138412e0c3f5ebd961bccf01a9c670c5c557cc17ccd26e243c073022842bfb7dd7577c5f595e9c353a58bb93cbae480b1d909d3aa62a676d1f9d114ad678e149cf06b1996dabad25a91eb41f7de71be6a342572d4e42a2cbb89a43ff90f68ad5158797c4cd4f42bf5f65119527946cde9cf1ae4983e5c5b227a0a94fd0872e9c836c65bb1826345484c60dab4e8857e52018d53baad06efc3bf30f7a70781ef03622c9024872d4e8e9bd6c5556bea46ae39776c481b8768b930cdb0e7be9e2cfb637d6450830fbbb60e8be8838fb0adb70cc1f4c4ce538c30e016e9f2e85a028164b7c239b2c02eaee636f66d26c8c795596ff21939cc2cc891efc481160380ccb3e67bf5d1a57bc7ccac1e27fd612412ab8dccc734f627960eddb71069a67ab808b066b75954f73a48270d6a7a5a26f7bb5c82fe55b319a06ab004239f5c7614eda6a70e06737f7a9be929d906eb9aee52df217efc92ad824725bf3bfe4c839bc38166306c93c5123316191662eb59a4cf40cabba3aa5f0472d7a545a07998cf5883cfe5526e3cc9ff951ec33df398a7004348e384307a1c81a852a9e11a7c0b706e9ca13522a891713381b0cc6ac78c357e8bf24278cd6f1dc2506d8422fecc1bd54c675e33ea4ff15330f8dc6d9c1d30a7482c70cc96885ce1d8fb2f06b329116bb2d2e419dc156af55e75a69a3fc07162ec8d755dca5b6a57222e4d5784f81c6e48f3d1e87e95e76649498d152ef38f8e2ecf60f24a15a66dfbadc4428eb73b07fcc9c3720bdcae79398fc6abd9eb2f0058e8b7daf42c364c78e9e76c87d053ba644cb021a488e99c0e2399d2513229e2c454182675134bc2a71bbe66da3d4901cbc761eddbbae4102349fc442e4b767effaccd064deb0280505bdf186e273e59a7c9cca6333bb46bc4796c140af482a8663e778b6d90577291e6f9a6312015a8a90d9c7d4547a8f1d463c964787e5983cce820bda1c82bd1230c8217c63ccb05a9a88c5130e3415897aea2c96e65f7347d8f9feec934fd06c32362fc9a2a68b6e7fde0bed740ac4d1c35bfa858220034ee22e845b364af24598f0eba3f30d8e030127cbc731db3a75dd522638b7c6855a44095d0e122c9ccc1c7cccc4efead66f074d166943059a25a34a8e23133812d44f38ac6a9b4accfe2618c75387b082549be474672549a0aad22340dc78c281c4fcaa351b49cd4f49df31f1898871977f7e89d3de3829dd52163aa417fb019f5218e369dea3fd85117afff7985bf9ec73b08ebd09c3b2e632fdab786a74f58b077529a0d601727f052fd57dcc821cee905808dcfa186009bf6c330f4ddc5d5161520ac5f002d0c6ea3aa50c1d1650d2fc18eeb590a1f492c8cef77e3cf4c8ba23ea5a8809df27b40cf5c6b9dc6cc059ab15ff9c009de6e3af13a9d300b3e534f5930e8ec4ba30583de9cb7947e1ee5481f9b80a0e9c344815a5d4f543a2bea9e69378440d499ea30963c5fa99ae3fafb26f7ff3fc6cbc44445ec658206ae83f30b86ce1f5b50a137ecbf21cb68739d535b35cb552d9faa4f4a5985885453c256d78b588e72e15</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子信息争鸣讲坛第七期-学习笔记</title>
      <link href="/2025/06/14/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E4%BA%89%E9%B8%A3%E8%AE%B2%E5%9D%9B%E7%AC%AC%E4%B8%83%E6%9C%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/14/%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E4%BA%89%E9%B8%A3%E8%AE%B2%E5%9D%9B%E7%AC%AC%E4%B8%83%E6%9C%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>今天导师突然发了个<a href="https://www.bilibili.com/video/BV1tg4y1k7Y4">链接</a>，说可以学习这里的文章写法</p><p>第一遍我粗略的看了一下，感觉不是密码学相关的，又时代久远（2023年年底），故而简略看了看就去干别的了</p><p>今天导师问有没有人学习这个，并且总结汇报，然后我意识到这个视频的重要性。故而在学习的同时写篇博文总结一下，旨在橙味写文章糕守~</p><span id="more"></span><hr><p><img src="image-20250614155527490.png" alt></p><p>密态计算技术：最难也是最重要</p><p>本讲座的主要内容针对机密计算（也就是第一个）</p><p>机密计算：提供硬件级别的系统隔离以保证数据安全</p><p>~</p><p>看了半天，感觉确实不是密码学的，确实完全是关于机密计算的，偏硬件，值得学习的应当在于其<strong>逻辑</strong></p><p>机密计算我真看不懂它是干啥的，我是硬件低手，下面我尽量带入密码学的角度来讲解一下如何做PPT</p><hr><p><img src="image-20250614170943380.png" alt></p><p>报告分为三个部分：机密计算是什么，现在怎么样，将来怎么样</p><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><img src="image-20250614193310405.png" alt></p><p>先介绍，机密计算很重要。符合国家战略和法律法规需求等等等等，很像写可修订区块链，讲GDPR云云</p><p><img src="image-20250614193502071.png" alt></p><p>然后是三大主流方向，顺着研究背景的内容，把数据安全这个问题进行拆解，分成传输存储使用三个部分，这三者缺一不可</p><p><img src="image-20250614193811150.png" alt></p><p>然后讲三个部分中，数据使用是最薄弱的，而这次分享的核心——机密计算，就是数据应用部分的。也是为了引入主题做铺垫（有一说一，第一遍看的时候真没看出来）</p><p><img src="image-20250614193952976.png" alt></p><p>很顺利的引到了机密计算，并对比了其它方向（其它几个好多老熟人哇）</p><p>模仿着的，写同态和MPC都可以用前面几张PPT类似的思维，就在这张PPT把想写的移动到第一位</p><p><img src="image-20250614194232066.png" alt></p><p>这一页正式介绍了机密计算的定义，但是不是直接说定义是什么（这样的话很枯燥，这一页的东西也会少很多），而是对比了各个机构对机密计算的定义，最后介绍笔者怎么想的</p><p>这种写法的普适性很强，感觉无论写什么都可以套用</p><p><img src="image-20250614194443828.png" alt></p><p>上一页是下定义，那么这一页是介绍了机密加密的特征</p><p>这个“墙壁”很好的标明了机密计算做了什么，加上旁边的注解，还有芯片的logo，让大家都知道是基于硬件的安全保证，构成这样一个TEE</p><p>这个构图值得学习，如果写同态的话，可以把图片替换成密态计算的流程，右下方改成同态的特点</p><p><img src="image-20250614194939960.png" alt></p><p>对比了类似的概念，直接上了表格</p><p>先区分概念，后文交代三者的联系</p><p><img src="image-20250614195057043.png" alt></p><p>这么好看的PPT我这辈子都做不出来（哭</p><p>这一页是对上一页的进一步说明，前面说区别，这页说关联，是层层递进的，里面还有举了很多具体的算法的概念，最终共同服务于数据安全（这几个大小配色也搭配的很好）</p><p>大同行基本上能知道机密计算是个什么东西了，定位是在隐私计算和可信计算中间</p><p><img src="image-20250614195446522.png" alt></p><p>又一页进一步补充说明关联，院士讲这一页的时候没有过多赘述，点了一下硬件基础（第一个）和隐私性（最后一个）就下一页了</p><p><img src="image-20250614195618312.png" alt></p><p><img src="image-20250614195639041.png" alt></p><p><img src="image-20250614195651366.png" alt></p><p>画了一个时间轴，将发展历程，这种写法在可修订区块链和同态加密都可以用哇</p><p>上面的时间轴不变，下面讲不同阶段</p><h3 id="现在怎么样？（发展现状）"><a href="#现在怎么样？（发展现状）" class="headerlink" title="现在怎么样？（发展现状）"></a>现在怎么样？（发展现状）</h3><p><img src="image-20250614195836709.png" alt></p><p>直接上一张大图，介绍了各个架构部署机密计算的技术路线</p><p>这种图基本没人会去细看，其目的旨在说明自己的对比结论是翔实可靠的</p><p><img src="image-20250614200424931.png" alt></p><p><img src="image-20250614200641450.png" alt></p><p>直接蹦出来这张图，告诉观众结论</p><p>效仿的话，直接列一张对比的大表然后给观众结论即可，感觉其它方向都可以学</p><p>不过这个配色草率了点，不是很现代化~</p><p><img src="image-20250614200705970.png" alt></p><p>体系结构，左侧是目标，右侧是指标，中间从下到上是从底层到应用</p><p>我完全想不到怎么做出这么好看的PPT~</p><p><img src="image-20250614200811674.png" alt></p><p>交互过程，密码学里很常见</p><p><img src="image-20250614201412033.png" alt></p><p><img src="image-20250614200914604.png" alt></p><p>也是同一页，和上次那个把表格一样的弄法，先给观众看图，然后再给看字</p><p>这种弄法，基本上多数密码学算法交互流程都可以套用（科普向很强）</p><p><img src="image-20250614201432743.png" alt></p><p>主要研究方向和内容，感觉基本上也是让观众看大字内容，小字不是很重要的</p><p>感觉可以改进，小字里也有很多关键部分，可以加黑</p><p><img src="image-20250614201621896.png" alt></p><p>攻击手段，也是一分多的画法</p><p><img src="image-20250614201638313.png" alt></p><p><img src="image-20250614201654593.png" alt></p><p>然后这里介绍了一些架构，写法大致相同，可以模仿</p><p>都是多个点，一个点后面带出来具体介绍</p><p><img src="image-20250614201714050.png" alt></p><p><img src="image-20250614201732476.png" alt></p><p>好好看的图~</p><p>和上面很像，都是左侧一列右侧一列，中间是一大列多层级技术构成</p><p><img src="image-20250614201829159.png" alt></p><p><img src="image-20250614201844330.png" alt></p><p><img src="image-20250614201852313.png" alt></p><h3 id="将来怎么样？（发展趋势）"><a href="#将来怎么样？（发展趋势）" class="headerlink" title="将来怎么样？（发展趋势）"></a>将来怎么样？（发展趋势）</h3><p><img src="image-20250614202407308.png" alt></p><p><img src="image-20250614202423915.png" alt></p><p><img src="image-20250614202449757.png" alt></p><p><img src="image-20250614202507341.png" alt></p><p>四大页PPT，虽然不是很华丽，但基本介绍了发展趋势</p><p>后面很长一段提问时间，不少也是围绕前景进行提问了</p><p>询问环节的专业性比较强（翻译：我听不懂），这里就不再赘述了</p><p>不过看起来这一块前景还不错嘞~感觉有点太硬了就是了</p><hr><p>最后还有一点令我比较泪目：院士的电脑居然还是传统的win7，用我叫不上来名字的Office版本</p><p><img src="image-20250614202717048.png" alt></p><p>天黑了，回宿舍睡觉了，早睡早起，明天蓝桥杯加油~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窝补药贵贵洗衣服</title>
      <link href="/2025/06/11/%E7%AA%9D%E8%A1%A5%E8%8D%AF%E8%B4%B5%E8%B4%B5%E6%B4%97%E8%A1%A3%E6%9C%8D/"/>
      <url>/2025/06/11/%E7%AA%9D%E8%A1%A5%E8%8D%AF%E8%B4%B5%E8%B4%B5%E6%B4%97%E8%A1%A3%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<p>前段时间有个朋友（不是我）出于学习目的研究了某品牌洗衣机（首先排除小依）的串口通信，发现可以重放攻击</p><p>本文章仅供学习目的，请勿用于非法用途</p><p><img src="小熊猫.gif" alt></p><span id="more"></span><hr><p>成本：一套三舅妈不用了的螺丝刀（拆掉外壳），一个大舅姥爷扔掉的硬纸板（用于临时工作台），还有一个情人节对象送的蓝牙模块（不到十块钱），再找前女友要<strong>四根公对母</strong>的杜邦线</p><p>蓝牙模块需要支持波特率2400的，可以问商家能不能帮你调，或者自己买个CH340自己调（本文不做讲解）</p><p>商家没给广告费，就自己用识图搜吧</p><p><img src="蓝牙模块.jpg" alt></p><p>然后拿螺丝刀给小依拆喽，如果没断电的话记得先给自己买个保险</p><p>找这一部分，给他拔喽</p><p>然后右上角这边是<strong>控制洗衣机的模块</strong>，左下角是<strong>原本的通信模块</strong></p><p><img src="八楼.jpg" alt></p><p>然后我们要把蓝牙模块接到右上角这边</p><p>下面我们来看走线</p><p>这是蓝牙模块</p><p><img src="模块背面.png" alt></p><p>这一半是洗衣机的</p><p><img src="接线特写.jpg" alt></p><p>下面很重要，接错了轻则没反应，重则烧掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">蓝牙模块的RXD 接 洗衣机的TXD</span><br><span class="line">蓝牙模块的TXD 接 洗衣机的RXD</span><br><span class="line">蓝牙模块的5V  接 洗衣机的5V</span><br><span class="line">蓝牙模块的GND 接 洗衣机的GND</span><br></pre></td></tr></table></figure><p>其他未提及的不用接</p><p>然后找个串口调试助手，找到蓝牙名称（不知道是什么可以问商家），发送hex:</p><p><code>AA 01 9A 01 02 A9 16 55</code></p><p>这就是 强力洗 水位中</p><p>其他的自己研究吧，我要去继续摸鱼了~</p><p><img src="画草.gif" alt></p><hr><p>有什么问题欢迎评论区留言，还好我这个博客没做评论区~</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学现代密码学v4</title>
      <link href="/2025/05/25/%E9%87%8D%E5%AD%A6%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6v4/"/>
      <url>/2025/05/25/%E9%87%8D%E5%AD%A6%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6v4/</url>
      
        <content type="html"><![CDATA[<p>本文重学《现代密码学（第四版）》（杨波编著，清华大学出版社），旨在巩固基础，同时为后人带来便利</p><p>你问我都5202了，最新的是第六版，为什么还要用第四版？</p><p>因为我只有第四版的电子书（悲</p><span id="more"></span><hr><h2 id="第1章-引言"><a href="#第1章-引言" class="headerlink" title="第1章 引言"></a>第1章 引言</h2><h3 id="1-1-1-3"><a href="#1-1-1-3" class="headerlink" title="1.1-1.3"></a>1.1-1.3</h3><p><img src="image-20250525183908152.png" alt> </p><p>安全业务：保密业务（防止被动攻击），认证业务（通信真实性），完整性业务，不可否认业务，访问控制</p><p><img src="image-20250525185554234.png" alt></p><div class="table-container"><table><thead><tr><th>攻击模型</th><th>攻击者能力描述</th><th>攻击强度</th><th>示例场景</th></tr></thead><tbody><tr><td>唯密文攻击（Ciphertext Only Attack, COA）</td><td>只能获取加密后的密文</td><td>最弱</td><td>截获通信数据</td></tr><tr><td>已知明文攻击（Known Plaintext Attack, KPA）</td><td>拥有部分明文及其对应的密文</td><td>较弱</td><td>知道邮件模板内容</td></tr><tr><td>选择明文攻击（Chosen Plaintext Attack, CPA）</td><td>可以选择明文并获取其密文</td><td>较强</td><td>与加密系统交互，获得加密结果</td></tr><tr><td>选择密文攻击（Chosen Ciphertext Attack, CCA）</td><td>可以选择密文并获取其解密结果（不包括目标）</td><td>最强</td><td>与解密系统交互，如解密Oracle攻击</td></tr></tbody></table></div><h3 id="1-4-古典密码"><a href="#1-4-古典密码" class="headerlink" title="1.4 古典密码"></a>1.4 古典密码</h3><p>凯撒密码：<img src="Users\coper\Desktop\myblog\source\_posts\重学现代密码学v4\image-20250525190342019.png" alt>（位移三位)</p><p>位移密码：<img src="Users\coper\Desktop\myblog\source\_posts\重学现代密码学v4\image-20250525190417738.png" alt>（位移指定位)</p><p>仿射密码：<img src="Users\coper\Desktop\myblog\source\_posts\重学现代密码学v4\image-20250525190509244.png" alt></p><p>多表代换密码：<img src="Users\coper\Desktop\myblog\source\_posts\重学现代密码学v4\image-20250525190708921.png" alt>（仿射密码，换为矩阵的形式)</p><h2 id="第2章-流密码"><a href="#第2章-流密码" class="headerlink" title="第2章 流密码"></a>第2章 流密码</h2><p><strong>流密码是一种对称加密</strong></p><p>基本思想：利用密钥k产生一个密钥流 $z=z_0z_1…$</p><p>加密：<img src="Users\coper\Desktop\myblog\source\_posts\重学现代密码学v4\image-20250526190323786.png" alt></p><h3 id="2-1-流密码的基本概念"><a href="#2-1-流密码的基本概念" class="headerlink" title="2.1 流密码的基本概念"></a>2.1 流密码的基本概念</h3><h4 id="2-1-1-同步流密码"><a href="#2-1-1-同步流密码" class="headerlink" title="2.1.1 同步流密码"></a>2.1.1 同步流密码</h4><h4 id="2-1-2-有限状态自动机"><a href="#2-1-2-有限状态自动机" class="headerlink" title="2.1.2 有限状态自动机"></a>2.1.2 有限状态自动机</h4><h4 id="2-1-3-密钥流产生器"><a href="#2-1-3-密钥流产生器" class="headerlink" title="2.1.3 密钥流产生器"></a>2.1.3 密钥流产生器</h4><h3 id="2-2-线性反馈移位寄存器"><a href="#2-2-线性反馈移位寄存器" class="headerlink" title="2.2 线性反馈移位寄存器"></a>2.2 线性反馈移位寄存器</h3><h3 id="2-3-线性移位寄存器的一元多项式表示"><a href="#2-3-线性移位寄存器的一元多项式表示" class="headerlink" title="2.3 线性移位寄存器的一元多项式表示"></a>2.3 线性移位寄存器的一元多项式表示</h3><h3 id="2-4-m序列的伪随机性"><a href="#2-4-m序列的伪随机性" class="headerlink" title="2.4 m序列的伪随机性"></a>2.4 m序列的伪随机性</h3><h3 id="2-5-m序列密码的破译"><a href="#2-5-m序列密码的破译" class="headerlink" title="2.5 m序列密码的破译"></a>2.5 m序列密码的破译</h3><h3 id="2-6-非线性序列"><a href="#2-6-非线性序列" class="headerlink" title="2.6 非线性序列"></a>2.6 非线性序列</h3><h4 id="2-6-1-Geffe序列生成器"><a href="#2-6-1-Geffe序列生成器" class="headerlink" title="2.6.1 Geffe序列生成器"></a>2.6.1 Geffe序列生成器</h4><h4 id="2-6-2-JK触发器"><a href="#2-6-2-JK触发器" class="headerlink" title="2.6.2 JK触发器"></a>2.6.2 JK触发器</h4><h4 id="2-6-3-Pless-生成器"><a href="#2-6-3-Pless-生成器" class="headerlink" title="2.6.3 Pless 生成器"></a>2.6.3 Pless 生成器</h4><h4 id="2-6-4-钟控序列生成器"><a href="#2-6-4-钟控序列生成器" class="headerlink" title="2.6.4 钟控序列生成器"></a>2.6.4 钟控序列生成器</h4><p>习题</p><h2 id="第3章-分组密码体制"><a href="#第3章-分组密码体制" class="headerlink" title="第3章 分组密码体制"></a>第3章 分组密码体制</h2><h3 id="3-1-分组密码概述"><a href="#3-1-分组密码概述" class="headerlink" title="3.1 分组密码概述"></a>3.1 分组密码概述</h3><h4 id="3-1-1-代换"><a href="#3-1-1-代换" class="headerlink" title="3.1.1 代换"></a>3.1.1 代换</h4><h4 id="3-1-2-扩散和混淆"><a href="#3-1-2-扩散和混淆" class="headerlink" title="3.1.2 扩散和混淆"></a>3.1.2 扩散和混淆</h4><h4 id="3-1-3-Feistel-密码结构"><a href="#3-1-3-Feistel-密码结构" class="headerlink" title="3.1.3 Feistel 密码结构"></a>3.1.3 Feistel 密码结构</h4><h3 id="3-2-数据加密标准…"><a href="#3-2-数据加密标准…" class="headerlink" title="3.2 数据加密标准…"></a>3.2 数据加密标准…</h3><h4 id="3-2-1-DES-描述"><a href="#3-2-1-DES-描述" class="headerlink" title="3.2.1 DES 描述"></a>3.2.1 DES 描述</h4><h4 id="3-2-2-二重-DES"><a href="#3-2-2-二重-DES" class="headerlink" title="3.2.2 二重 DES"></a>3.2.2 二重 DES</h4><h4 id="3-2-3-两个密钥的三重DES"><a href="#3-2-3-两个密钥的三重DES" class="headerlink" title="3.2.3 两个密钥的三重DES"></a>3.2.3 两个密钥的三重DES</h4><h4 id="3-2-4-3个密钥的三重-DES"><a href="#3-2-4-3个密钥的三重-DES" class="headerlink" title="3.2.4 3个密钥的三重 DES"></a>3.2.4 3个密钥的三重 DES</h4><h3 id="3-3-差分密码分析与线性密码分析"><a href="#3-3-差分密码分析与线性密码分析" class="headerlink" title="3.3 差分密码分析与线性密码分析"></a>3.3 差分密码分析与线性密码分析</h3><h4 id="3-3-1-差分密码分析"><a href="#3-3-1-差分密码分析" class="headerlink" title="3.3.1 差分密码分析"></a>3.3.1 差分密码分析</h4><h4 id="3-3-2-线性密码分析"><a href="#3-3-2-线性密码分析" class="headerlink" title="3.3.2 线性密码分析"></a>3.3.2 线性密码分析</h4><h3 id="3-4-分组密码的运行模式"><a href="#3-4-分组密码的运行模式" class="headerlink" title="3.4 分组密码的运行模式"></a>3.4 分组密码的运行模式</h3><h4 id="3-4-1-电码本模式"><a href="#3-4-1-电码本模式" class="headerlink" title="3.4.1 电码本模式"></a>3.4.1 电码本模式</h4><h4 id="3-4-2-密码分组链接模式"><a href="#3-4-2-密码分组链接模式" class="headerlink" title="3.4.2 密码分组链接模式"></a>3.4.2 密码分组链接模式</h4><h4 id="3-4-3-密码反馈模式"><a href="#3-4-3-密码反馈模式" class="headerlink" title="3.4.3 密码反馈模式"></a>3.4.3 密码反馈模式</h4><h4 id="3-4-4-输出反馈模式"><a href="#3-4-4-输出反馈模式" class="headerlink" title="3.4.4 输出反馈模式"></a>3.4.4 输出反馈模式</h4><h3 id="3-5-IDEA"><a href="#3-5-IDEA" class="headerlink" title="3.5 IDEA"></a>3.5 IDEA</h3><h4 id="3-5-1-设计原理"><a href="#3-5-1-设计原理" class="headerlink" title="3.5.1 设计原理"></a>3.5.1 设计原理</h4><h4 id="3-5-2-加密过程"><a href="#3-5-2-加密过程" class="headerlink" title="3.5.2 加密过程"></a>3.5.2 加密过程</h4><h3 id="3-6-AES-算法-Rijndael"><a href="#3-6-AES-算法-Rijndael" class="headerlink" title="3.6 AES 算法 Rijndael"></a>3.6 AES 算法 Rijndael</h3><h4 id="3-6-1-Rijndael-的数学基础和设计思想"><a href="#3-6-1-Rijndael-的数学基础和设计思想" class="headerlink" title="3.6.1 Rijndael 的数学基础和设计思想"></a>3.6.1 Rijndael 的数学基础和设计思想</h4><h4 id="3-6-2-算法说明"><a href="#3-6-2-算法说明" class="headerlink" title="3.6.2 算法说明"></a>3.6.2 算法说明</h4><h3 id="3-7-中国商用密码算法-SM4"><a href="#3-7-中国商用密码算法-SM4" class="headerlink" title="3.7 中国商用密码算法 SM4"></a>3.7 中国商用密码算法 SM4</h3><h3 id="3-8-祖冲之密码…"><a href="#3-8-祖冲之密码…" class="headerlink" title="3.8 祖冲之密码…"></a>3.8 祖冲之密码…</h3><h4 id="3-8-1-算法中的符号及含义"><a href="#3-8-1-算法中的符号及含义" class="headerlink" title="3.8.1 算法中的符号及含义"></a>3.8.1 算法中的符号及含义</h4><h4 id="3-8-2-祖冲之密码的算法结构"><a href="#3-8-2-祖冲之密码的算法结构" class="headerlink" title="3.8.2 祖冲之密码的算法结构"></a>3.8.2 祖冲之密码的算法结构</h4><h4 id="3-8-3-祖冲之密码的运行"><a href="#3-8-3-祖冲之密码的运行" class="headerlink" title="3.8.3 祖冲之密码的运行"></a>3.8.3 祖冲之密码的运行</h4><h4 id="3-8-4-基于祖冲之密码的机密性算法-128-EEA3"><a href="#3-8-4-基于祖冲之密码的机密性算法-128-EEA3" class="headerlink" title="3.8.4 基于祖冲之密码的机密性算法 128-EEA3"></a>3.8.4 基于祖冲之密码的机密性算法 128-EEA3</h4><h2 id="第4章-公钥密码"><a href="#第4章-公钥密码" class="headerlink" title="第4章 公钥密码"></a>第4章 公钥密码</h2><h3 id="4-1-密码学中一些常用的数学知识"><a href="#4-1-密码学中一些常用的数学知识" class="headerlink" title="4.1 密码学中一些常用的数学知识"></a>4.1 密码学中一些常用的数学知识</h3><h4 id="4-1-1-群、环、域"><a href="#4-1-1-群、环、域" class="headerlink" title="4.1.1 群、环、域"></a>4.1.1 群、环、域</h4><h4 id="4-1-2-素数和互素数"><a href="#4-1-2-素数和互素数" class="headerlink" title="4.1.2 素数和互素数"></a>4.1.2 素数和互素数</h4><h4 id="4-1-3-模运算"><a href="#4-1-3-模运算" class="headerlink" title="4.1.3 模运算"></a>4.1.3 模运算</h4><h4 id="4-1-4-模指数运算"><a href="#4-1-4-模指数运算" class="headerlink" title="4.1.4 模指数运算"></a>4.1.4 模指数运算</h4><h4 id="4-1-5-费尔马定理、欧拉定理、卡米歇尔定理"><a href="#4-1-5-费尔马定理、欧拉定理、卡米歇尔定理" class="headerlink" title="4.1.5 费尔马定理、欧拉定理、卡米歇尔定理"></a>4.1.5 费尔马定理、欧拉定理、卡米歇尔定理</h4><h4 id="4-1-6-素性检验"><a href="#4-1-6-素性检验" class="headerlink" title="4.1.6 素性检验"></a>4.1.6 素性检验</h4><h4 id="4-1-7-欧几里得算法"><a href="#4-1-7-欧几里得算法" class="headerlink" title="4.1.7 欧几里得算法"></a>4.1.7 欧几里得算法</h4><h4 id="4-1-8-中国剩余定理"><a href="#4-1-8-中国剩余定理" class="headerlink" title="4.1.8 中国剩余定理"></a>4.1.8 中国剩余定理</h4><h4 id="4-1-9-离散对数"><a href="#4-1-9-离散对数" class="headerlink" title="4.1.9 离散对数"></a>4.1.9 离散对数</h4><h4 id="4-1-10-平方剩余"><a href="#4-1-10-平方剩余" class="headerlink" title="4.1.10 平方剩余"></a>4.1.10 平方剩余</h4><h4 id="4-1-11-循环群"><a href="#4-1-11-循环群" class="headerlink" title="4.1.11 循环群"></a>4.1.11 循环群</h4><h4 id="4-1-12-循环群的选取"><a href="#4-1-12-循环群的选取" class="headerlink" title="4.1.12 循环群的选取"></a>4.1.12 循环群的选取</h4><h4 id="4-1-13-双线性映射"><a href="#4-1-13-双线性映射" class="headerlink" title="4.1.13 双线性映射"></a>4.1.13 双线性映射</h4><h4 id="4-1-14-计算复杂性"><a href="#4-1-14-计算复杂性" class="headerlink" title="4.1.14 计算复杂性"></a>4.1.14 计算复杂性</h4><h3 id="4-2-公钥密码体制的基本概念"><a href="#4-2-公钥密码体制的基本概念" class="headerlink" title="4.2 公钥密码体制的基本概念"></a>4.2 公钥密码体制的基本概念</h3><h4 id="4-2-1-公钥密码体制的原理"><a href="#4-2-1-公钥密码体制的原理" class="headerlink" title="4.2.1 公钥密码体制的原理"></a>4.2.1 公钥密码体制的原理</h4><h4 id="4-2-2-公钥密码算法应满足的要求"><a href="#4-2-2-公钥密码算法应满足的要求" class="headerlink" title="4.2.2 公钥密码算法应满足的要求"></a>4.2.2 公钥密码算法应满足的要求</h4><h4 id="4-2-3-对公钥密码体制的攻击"><a href="#4-2-3-对公钥密码体制的攻击" class="headerlink" title="4.2.3 对公钥密码体制的攻击"></a>4.2.3 对公钥密码体制的攻击</h4><h3 id="4-3-RSA算法"><a href="#4-3-RSA算法" class="headerlink" title="4.3 RSA算法"></a>4.3 RSA算法</h3><h4 id="4-3-1-算法描述"><a href="#4-3-1-算法描述" class="headerlink" title="4.3.1 算法描述"></a>4.3.1 算法描述</h4><h4 id="4-3-2-RSA算法中的计算问题"><a href="#4-3-2-RSA算法中的计算问题" class="headerlink" title="4.3.2 RSA算法中的计算问题"></a>4.3.2 RSA算法中的计算问题</h4><h4 id="4-3-3-一种改进的RSA实现方法"><a href="#4-3-3-一种改进的RSA实现方法" class="headerlink" title="4.3.3 一种改进的RSA实现方法"></a>4.3.3 一种改进的RSA实现方法</h4><h4 id="4-3-4-RSA的安全性"><a href="#4-3-4-RSA的安全性" class="headerlink" title="4.3.4 RSA的安全性"></a>4.3.4 RSA的安全性</h4><h4 id="4-3-5-对RSA的攻击"><a href="#4-3-5-对RSA的攻击" class="headerlink" title="4.3.5 对RSA的攻击"></a>4.3.5 对RSA的攻击</h4><h3 id="4-4-背包密码体制"><a href="#4-4-背包密码体制" class="headerlink" title="4.4 背包密码体制"></a>4.4 背包密码体制</h3><h3 id="4-5-Rabin-密码体制"><a href="#4-5-Rabin-密码体制" class="headerlink" title="4.5 Rabin 密码体制"></a>4.5 Rabin 密码体制</h3><h3 id="4-6-NTRU公钥密码系统"><a href="#4-6-NTRU公钥密码系统" class="headerlink" title="4.6 NTRU公钥密码系统"></a>4.6 NTRU公钥密码系统</h3><h3 id="4-7-椭圆曲线密码体制"><a href="#4-7-椭圆曲线密码体制" class="headerlink" title="4.7 椭圆曲线密码体制"></a>4.7 椭圆曲线密码体制</h3><h4 id="4-7-1-椭圆曲线"><a href="#4-7-1-椭圆曲线" class="headerlink" title="4.7.1 椭圆曲线"></a>4.7.1 椭圆曲线</h4><h4 id="4-7-2-有限域上的椭圆曲线"><a href="#4-7-2-有限域上的椭圆曲线" class="headerlink" title="4.7.2 有限域上的椭圆曲线"></a>4.7.2 有限域上的椭圆曲线</h4><h4 id="4-7-3-椭圆曲线上的点数"><a href="#4-7-3-椭圆曲线上的点数" class="headerlink" title="4.7.3 椭圆曲线上的点数"></a>4.7.3 椭圆曲线上的点数</h4><h4 id="4-7-4-明文消息到椭圆曲线上的嵌入"><a href="#4-7-4-明文消息到椭圆曲线上的嵌入" class="headerlink" title="4.7.4 明文消息到椭圆曲线上的嵌入"></a>4.7.4 明文消息到椭圆曲线上的嵌入</h4><h4 id="4-7-5-椭圆曲线上的密码"><a href="#4-7-5-椭圆曲线上的密码" class="headerlink" title="4.7.5 椭圆曲线上的密码"></a>4.7.5 椭圆曲线上的密码</h4><h3 id="4-8-SM2椭圆曲线公钥密码加密算法"><a href="#4-8-SM2椭圆曲线公钥密码加密算法" class="headerlink" title="4.8 SM2椭圆曲线公钥密码加密算法"></a>4.8 SM2椭圆曲线公钥密码加密算法</h3><h2 id="第5章-密钥分配与密钥管理"><a href="#第5章-密钥分配与密钥管理" class="headerlink" title="第5章 密钥分配与密钥管理"></a>第5章 密钥分配与密钥管理</h2><h3 id="5-1-单钥加密体制的密钥分配"><a href="#5-1-单钥加密体制的密钥分配" class="headerlink" title="5.1 单钥加密体制的密钥分配"></a>5.1 单钥加密体制的密钥分配</h3><h4 id="5-1-1-密钥分配的基本方法"><a href="#5-1-1-密钥分配的基本方法" class="headerlink" title="5.1.1 密钥分配的基本方法"></a>5.1.1 密钥分配的基本方法</h4><h4 id="5-1-2-一个实例"><a href="#5-1-2-一个实例" class="headerlink" title="5.1.2 一个实例"></a>5.1.2 一个实例</h4><h4 id="5-1-3-密钥的分层控制"><a href="#5-1-3-密钥的分层控制" class="headerlink" title="5.1.3 密钥的分层控制"></a>5.1.3 密钥的分层控制</h4><h4 id="5-1-4-会话密钥的有效期"><a href="#5-1-4-会话密钥的有效期" class="headerlink" title="5.1.4 会话密钥的有效期"></a>5.1.4 会话密钥的有效期</h4><h4 id="5-1-5-无中心的密钥控制"><a href="#5-1-5-无中心的密钥控制" class="headerlink" title="5.1.5 无中心的密钥控制"></a>5.1.5 无中心的密钥控制</h4><h4 id="5-1-6-密钥的控制使用"><a href="#5-1-6-密钥的控制使用" class="headerlink" title="5.1.6 密钥的控制使用"></a>5.1.6 密钥的控制使用</h4><h3 id="5-2-公钥加密体制的密钥管理"><a href="#5-2-公钥加密体制的密钥管理" class="headerlink" title="5.2 公钥加密体制的密钥管理"></a>5.2 公钥加密体制的密钥管理</h3><h4 id="5-2-1-公钥的分配"><a href="#5-2-1-公钥的分配" class="headerlink" title="5.2.1 公钥的分配"></a>5.2.1 公钥的分配</h4><h4 id="5-2-2-用公钥加密分配单钥密码体制的密钥"><a href="#5-2-2-用公钥加密分配单钥密码体制的密钥" class="headerlink" title="5.2.2 用公钥加密分配单钥密码体制的密钥"></a>5.2.2 用公钥加密分配单钥密码体制的密钥</h4><h4 id="5-2-3-Diffie-Hellman-密钥交换"><a href="#5-2-3-Diffie-Hellman-密钥交换" class="headerlink" title="5.2.3 Diffie-Hellman 密钥交换"></a>5.2.3 Diffie-Hellman 密钥交换</h4><h3 id="5-3-随机数的产生"><a href="#5-3-随机数的产生" class="headerlink" title="5.3 随机数的产生"></a>5.3 随机数的产生</h3><h4 id="5-3-1-随机数的使用"><a href="#5-3-1-随机数的使用" class="headerlink" title="5.3.1 随机数的使用"></a>5.3.1 随机数的使用</h4><h4 id="5-3-2-随机数源"><a href="#5-3-2-随机数源" class="headerlink" title="5.3.2 随机数源"></a>5.3.2 随机数源</h4><h4 id="5-3-3-伪随机数产生器"><a href="#5-3-3-伪随机数产生器" class="headerlink" title="5.3.3 伪随机数产生器"></a>5.3.3 伪随机数产生器</h4><h4 id="5-3-4-基于密码算法的随机数产生器"><a href="#5-3-4-基于密码算法的随机数产生器" class="headerlink" title="5.3.4 基于密码算法的随机数产生器"></a>5.3.4 基于密码算法的随机数产生器</h4><h4 id="5-3-5-随机比特产生器"><a href="#5-3-5-随机比特产生器" class="headerlink" title="5.3.5 随机比特产生器"></a>5.3.5 随机比特产生器</h4><h3 id="5-4-秘密分割"><a href="#5-4-秘密分割" class="headerlink" title="5.4 秘密分割"></a>5.4 秘密分割</h3><h4 id="5-4-1-秘密分割门限方案"><a href="#5-4-1-秘密分割门限方案" class="headerlink" title="5.4.1 秘密分割门限方案"></a>5.4.1 秘密分割门限方案</h4><h4 id="5-4-2-Shamir-门限方案"><a href="#5-4-2-Shamir-门限方案" class="headerlink" title="5.4.2 Shamir 门限方案"></a>5.4.2 Shamir 门限方案</h4><h4 id="5-4-3-基于中国剩余定理的门限方案"><a href="#5-4-3-基于中国剩余定理的门限方案" class="headerlink" title="5.4.3 基于中国剩余定理的门限方案"></a>5.4.3 基于中国剩余定理的门限方案</h4><h2 id="第6章-消息认证和哈希函数"><a href="#第6章-消息认证和哈希函数" class="headerlink" title="第6章 消息认证和哈希函数"></a>第6章 消息认证和哈希函数</h2><h3 id="6-1-消息认证码"><a href="#6-1-消息认证码" class="headerlink" title="6.1 消息认证码"></a>6.1 消息认证码</h3><h4 id="6-1-1-消息认证码的定义及使用方式"><a href="#6-1-1-消息认证码的定义及使用方式" class="headerlink" title="6.1.1 消息认证码的定义及使用方式"></a>6.1.1 消息认证码的定义及使用方式</h4><h4 id="6-1-2-产生MAC的函数应满足的要求"><a href="#6-1-2-产生MAC的函数应满足的要求" class="headerlink" title="6.1.2 产生MAC的函数应满足的要求"></a>6.1.2 产生MAC的函数应满足的要求</h4><h4 id="6-1-3-数据认证算法"><a href="#6-1-3-数据认证算法" class="headerlink" title="6.1.3 数据认证算法"></a>6.1.3 数据认证算法</h4><h4 id="6-1-4-基于祖冲之密码的完整性算法128-ΕΙΑ3"><a href="#6-1-4-基于祖冲之密码的完整性算法128-ΕΙΑ3" class="headerlink" title="6.1.4 基于祖冲之密码的完整性算法128-ΕΙΑ3"></a>6.1.4 基于祖冲之密码的完整性算法128-ΕΙΑ3</h4><h3 id="6-2-哈希函数"><a href="#6-2-哈希函数" class="headerlink" title="6.2 哈希函数"></a>6.2 哈希函数</h3><h4 id="6-2-1-哈希函数的定义及使用方式"><a href="#6-2-1-哈希函数的定义及使用方式" class="headerlink" title="6.2.1 哈希函数的定义及使用方式"></a>6.2.1 哈希函数的定义及使用方式</h4><h4 id="6-2-2-哈希函数应满足的条件"><a href="#6-2-2-哈希函数应满足的条件" class="headerlink" title="6.2.2 哈希函数应满足的条件"></a>6.2.2 哈希函数应满足的条件</h4><h4 id="6-2-3-生日攻击"><a href="#6-2-3-生日攻击" class="headerlink" title="6.2.3 生日攻击"></a>6.2.3 生日攻击</h4><h4 id="6-2-4-迭代型哈希函数的一般结构"><a href="#6-2-4-迭代型哈希函数的一般结构" class="headerlink" title="6.2.4 迭代型哈希函数的一般结构"></a>6.2.4 迭代型哈希函数的一般结构</h4><h3 id="6-3-MD5哈希算法"><a href="#6-3-MD5哈希算法" class="headerlink" title="6.3 MD5哈希算法"></a>6.3 MD5哈希算法</h3><h4 id="6-3-1-算法描述"><a href="#6-3-1-算法描述" class="headerlink" title="6.3.1 算法描述"></a>6.3.1 算法描述</h4><h4 id="6-3-2-MD5的压缩函数"><a href="#6-3-2-MD5的压缩函数" class="headerlink" title="6.3.2 MD5的压缩函数"></a>6.3.2 MD5的压缩函数</h4><h4 id="6-3-3-MD5的安全性"><a href="#6-3-3-MD5的安全性" class="headerlink" title="6.3.3 MD5的安全性"></a>6.3.3 MD5的安全性</h4><h3 id="6-4-安全哈希算法"><a href="#6-4-安全哈希算法" class="headerlink" title="6.4 安全哈希算法"></a>6.4 安全哈希算法</h3><h4 id="6-4-1-算法描述"><a href="#6-4-1-算法描述" class="headerlink" title="6.4.1 算法描述"></a>6.4.1 算法描述</h4><h4 id="6-4-2-SHA的压缩函数"><a href="#6-4-2-SHA的压缩函数" class="headerlink" title="6.4.2 SHA的压缩函数"></a>6.4.2 SHA的压缩函数</h4><h4 id="6-4-3-SHA与MD5的比较"><a href="#6-4-3-SHA与MD5的比较" class="headerlink" title="6.4.3 SHA与MD5的比较"></a>6.4.3 SHA与MD5的比较</h4><h4 id="6-4-4-对SHA的攻击现状"><a href="#6-4-4-对SHA的攻击现状" class="headerlink" title="6.4.4 对SHA的攻击现状"></a>6.4.4 对SHA的攻击现状</h4><h3 id="6-5-HMAC"><a href="#6-5-HMAC" class="headerlink" title="6.5 HMAC"></a>6.5 HMAC</h3><h4 id="6-5-1-HMAC的设计目标"><a href="#6-5-1-HMAC的设计目标" class="headerlink" title="6.5.1 HMAC的设计目标"></a>6.5.1 HMAC的设计目标</h4><h4 id="6-5-2-算法描述"><a href="#6-5-2-算法描述" class="headerlink" title="6.5.2 算法描述"></a>6.5.2 算法描述</h4><h4 id="6-5-3-HMAC的安全性"><a href="#6-5-3-HMAC的安全性" class="headerlink" title="6.5.3 HMAC的安全性"></a>6.5.3 HMAC的安全性</h4><h3 id="6-6-SM3哈希算法"><a href="#6-6-SM3哈希算法" class="headerlink" title="6.6 SM3哈希算法"></a>6.6 SM3哈希算法</h3><h4 id="6-6-1-SM3-哈希算法的描述"><a href="#6-6-1-SM3-哈希算法的描述" class="headerlink" title="6.6.1 SM3 哈希算法的描述"></a>6.6.1 SM3 哈希算法的描述</h4><h4 id="6-6-2-SM3-哈希算法的安全性"><a href="#6-6-2-SM3-哈希算法的安全性" class="headerlink" title="6.6.2 SM3 哈希算法的安全性"></a>6.6.2 SM3 哈希算法的安全性</h4><p>习题</p><h2 id="第7章-数字签名和认证协议"><a href="#第7章-数字签名和认证协议" class="headerlink" title="第7章 数字签名和认证协议"></a>第7章 数字签名和认证协议</h2><h3 id="7-1-数字签名的基本概念"><a href="#7-1-数字签名的基本概念" class="headerlink" title="7.1 数字签名的基本概念"></a>7.1 数字签名的基本概念</h3><h4 id="7-1-1-数字签名应满足的要求"><a href="#7-1-1-数字签名应满足的要求" class="headerlink" title="7.1.1 数字签名应满足的要求"></a>7.1.1 数字签名应满足的要求</h4><h4 id="7-1-2-数字签名的产生方式"><a href="#7-1-2-数字签名的产生方式" class="headerlink" title="7.1.2 数字签名的产生方式"></a>7.1.2 数字签名的产生方式</h4><h4 id="7-1-3-数字签名的执行方式"><a href="#7-1-3-数字签名的执行方式" class="headerlink" title="7.1.3 数字签名的执行方式"></a>7.1.3 数字签名的执行方式</h4><h3 id="7-2-数字签名标准"><a href="#7-2-数字签名标准" class="headerlink" title="7.2 数字签名标准"></a>7.2 数字签名标准</h3><h4 id="7-2-1-DSS的基本方式"><a href="#7-2-1-DSS的基本方式" class="headerlink" title="7.2.1 DSS的基本方式"></a>7.2.1 DSS的基本方式</h4><h4 id="7-2-2-数字签名算法-DSA"><a href="#7-2-2-数字签名算法-DSA" class="headerlink" title="7.2.2 数字签名算法 DSA"></a>7.2.2 数字签名算法 DSA</h4><h3 id="7-3-其他签名方案"><a href="#7-3-其他签名方案" class="headerlink" title="7.3 其他签名方案"></a>7.3 其他签名方案</h3><h4 id="7-3-1-基于离散对数问题的数字签名体制"><a href="#7-3-1-基于离散对数问题的数字签名体制" class="headerlink" title="7.3.1 基于离散对数问题的数字签名体制"></a>7.3.1 基于离散对数问题的数字签名体制</h4><h4 id="7-3-2-基于大数分解问题的数字签名体制"><a href="#7-3-2-基于大数分解问题的数字签名体制" class="headerlink" title="7.3.2 基于大数分解问题的数字签名体制"></a>7.3.2 基于大数分解问题的数字签名体制</h4><h4 id="7-3-3-基于身份的数字签名体制"><a href="#7-3-3-基于身份的数字签名体制" class="headerlink" title="7.3.3 基于身份的数字签名体制"></a>7.3.3 基于身份的数字签名体制</h4><h3 id="7-4-SM2椭圆曲线公钥密码签名算法"><a href="#7-4-SM2椭圆曲线公钥密码签名算法" class="headerlink" title="7.4 SM2椭圆曲线公钥密码签名算法"></a>7.4 SM2椭圆曲线公钥密码签名算法</h3><h3 id="7-5-认证协议"><a href="#7-5-认证协议" class="headerlink" title="7.5 认证协议"></a>7.5 认证协议</h3><h4 id="7-5-1-相互认证"><a href="#7-5-1-相互认证" class="headerlink" title="7.5.1 相互认证"></a>7.5.1 相互认证</h4><h4 id="7-5-2-单向认证"><a href="#7-5-2-单向认证" class="headerlink" title="7.5.2 单向认证"></a>7.5.2 单向认证</h4><h2 id="第8章-密码协议"><a href="#第8章-密码协议" class="headerlink" title="第8章 密码协议"></a>第8章 密码协议</h2><h3 id="8-1-一些基本协议"><a href="#8-1-一些基本协议" class="headerlink" title="8.1 一些基本协议"></a>8.1 一些基本协议</h3><h4 id="8-1-1-智力扑克"><a href="#8-1-1-智力扑克" class="headerlink" title="8.1.1 智力扑克"></a>8.1.1 智力扑克</h4><h4 id="8-1-2-掷硬币协议"><a href="#8-1-2-掷硬币协议" class="headerlink" title="8.1.2 掷硬币协议"></a>8.1.2 掷硬币协议</h4><h4 id="8-1-3-数字承诺协议"><a href="#8-1-3-数字承诺协议" class="headerlink" title="8.1.3 数字承诺协议"></a>8.1.3 数字承诺协议</h4><h4 id="8-1-4-不经意传输协议"><a href="#8-1-4-不经意传输协议" class="headerlink" title="8.1.4 不经意传输协议"></a>8.1.4 不经意传输协议</h4><h3 id="8-2-零知识证明"><a href="#8-2-零知识证明" class="headerlink" title="8.2 零知识证明"></a>8.2 零知识证明</h3><h4 id="8-2-1-交互式证明系统"><a href="#8-2-1-交互式证明系统" class="headerlink" title="8.2.1 交互式证明系统"></a>8.2.1 交互式证明系统</h4><h4 id="8-2-2-交互式证明系统的定义"><a href="#8-2-2-交互式证明系统的定义" class="headerlink" title="8.2.2 交互式证明系统的定义"></a>8.2.2 交互式证明系统的定义</h4><h4 id="8-2-3-交互式证明系统的零知识性"><a href="#8-2-3-交互式证明系统的零知识性" class="headerlink" title="8.2.3 交互式证明系统的零知识性"></a>8.2.3 交互式证明系统的零知识性</h4><h4 id="8-2-4-非交互式证明系统"><a href="#8-2-4-非交互式证明系统" class="headerlink" title="8.2.4 非交互式证明系统"></a>8.2.4 非交互式证明系统</h4><h4 id="8-2-5-适应性安全的非交互式零知识证明"><a href="#8-2-5-适应性安全的非交互式零知识证明" class="headerlink" title="8.2.5 适应性安全的非交互式零知识证明"></a>8.2.5 适应性安全的非交互式零知识证明</h4><h4 id="8-2-6-零知识证明协议的组合"><a href="#8-2-6-零知识证明协议的组合" class="headerlink" title="8.2.6 零知识证明协议的组合"></a>8.2.6 零知识证明协议的组合</h4><h4 id="8-2-7-图的三色问题的零知识证明"><a href="#8-2-7-图的三色问题的零知识证明" class="headerlink" title="8.2.7 图的三色问题的零知识证明"></a>8.2.7 图的三色问题的零知识证明</h4><h4 id="8-2-8-知识证明"><a href="#8-2-8-知识证明" class="headerlink" title="8.2.8 知识证明"></a>8.2.8 知识证明</h4><h4 id="8-2-9-简化的Fiat-Shamir身份识别方案"><a href="#8-2-9-简化的Fiat-Shamir身份识别方案" class="headerlink" title="8.2.9 简化的Fiat-Shamir身份识别方案"></a>8.2.9 简化的Fiat-Shamir身份识别方案</h4><h4 id="8-2-10-Fiat-Shamir-身份识别方案"><a href="#8-2-10-Fiat-Shamir-身份识别方案" class="headerlink" title="8.2.10 Fiat-Shamir 身份识别方案"></a>8.2.10 Fiat-Shamir 身份识别方案</h4><h3 id="8-3-安全多方计算协议"><a href="#8-3-安全多方计算协议" class="headerlink" title="8.3 安全多方计算协议"></a>8.3 安全多方计算协议</h3><h4 id="8-3-1-安全多方计算问题"><a href="#8-3-1-安全多方计算问题" class="headerlink" title="8.3.1 安全多方计算问题"></a>8.3.1 安全多方计算问题</h4><h4 id="8-3-2-半诚实敌手模型"><a href="#8-3-2-半诚实敌手模型" class="headerlink" title="8.3.2 半诚实敌手模型"></a>8.3.2 半诚实敌手模型</h4><h4 id="8-3-3-恶意敌手模型"><a href="#8-3-3-恶意敌手模型" class="headerlink" title="8.3.3 恶意敌手模型"></a>8.3.3 恶意敌手模型</h4><p>习题</p><h2 id="第9章-可证明安全"><a href="#第9章-可证明安全" class="headerlink" title="第9章 可证明安全"></a>第9章 可证明安全</h2><h3 id="9-1-语义安全的公钥密码体制的定义"><a href="#9-1-语义安全的公钥密码体制的定义" class="headerlink" title="9.1 语义安全的公钥密码体制的定义"></a>9.1 语义安全的公钥密码体制的定义</h3><h4 id="9-1-1-选择明文攻击下的不可区分性"><a href="#9-1-1-选择明文攻击下的不可区分性" class="headerlink" title="9.1.1 选择明文攻击下的不可区分性"></a>9.1.1 选择明文攻击下的不可区分性</h4><h4 id="9-1-2-公钥加密方案在选择密文攻击下的不可区分性"><a href="#9-1-2-公钥加密方案在选择密文攻击下的不可区分性" class="headerlink" title="9.1.2 公钥加密方案在选择密文攻击下的不可区分性"></a>9.1.2 公钥加密方案在选择密文攻击下的不可区分性</h4><h4 id="9-1-3-公钥加密方案在适应性选择密文攻击下的不可区分性"><a href="#9-1-3-公钥加密方案在适应性选择密文攻击下的不可区分性" class="headerlink" title="9.1.3 公钥加密方案在适应性选择密文攻击下的不可区分性"></a>9.1.3 公钥加密方案在适应性选择密文攻击下的不可区分性</h4><h4 id="9-1-4-归约"><a href="#9-1-4-归约" class="headerlink" title="9.1.4 归约"></a>9.1.4 归约</h4><h3 id="9-2-语义安全的RSA加密方案"><a href="#9-2-语义安全的RSA加密方案" class="headerlink" title="9.2 语义安全的RSA加密方案"></a>9.2 语义安全的RSA加密方案</h3><h4 id="9-2-1-RSA问题和RSA假设"><a href="#9-2-1-RSA问题和RSA假设" class="headerlink" title="9.2.1 RSA问题和RSA假设"></a>9.2.1 RSA问题和RSA假设</h4><h4 id="9-2-2-选择明文安全的RSA-加密"><a href="#9-2-2-选择明文安全的RSA-加密" class="headerlink" title="9.2.2 选择明文安全的RSA 加密"></a>9.2.2 选择明文安全的RSA 加密</h4><h4 id="9-2-3-选择密文安全的RSA-加密"><a href="#9-2-3-选择密文安全的RSA-加密" class="headerlink" title="9.2.3 选择密文安全的RSA 加密"></a>9.2.3 选择密文安全的RSA 加密</h4><h3 id="9-3-Paillier-公钥密码系统"><a href="#9-3-Paillier-公钥密码系统" class="headerlink" title="9.3 Paillier 公钥密码系统"></a>9.3 Paillier 公钥密码系统</h3><h4 id="9-3-1-合数幂剩余类的判定"><a href="#9-3-1-合数幂剩余类的判定" class="headerlink" title="9.3.1 合数幂剩余类的判定"></a>9.3.1 合数幂剩余类的判定</h4><h4 id="9-3-2-合数幂剩余类的计算"><a href="#9-3-2-合数幂剩余类的计算" class="headerlink" title="9.3.2 合数幂剩余类的计算"></a>9.3.2 合数幂剩余类的计算</h4><h4 id="9-3-3-基于合数幂剩余类问题的概率加密方案"><a href="#9-3-3-基于合数幂剩余类问题的概率加密方案" class="headerlink" title="9.3.3 基于合数幂剩余类问题的概率加密方案"></a>9.3.3 基于合数幂剩余类问题的概率加密方案</h4><h4 id="9-3-4-基于合数幂剩余类问题的单向陷门置换"><a href="#9-3-4-基于合数幂剩余类问题的单向陷门置换" class="headerlink" title="9.3.4 基于合数幂剩余类问题的单向陷门置换"></a>9.3.4 基于合数幂剩余类问题的单向陷门置换</h4><h4 id="9-3-5-Paillier-密码系统的性质"><a href="#9-3-5-Paillier-密码系统的性质" class="headerlink" title="9.3.5 Paillier 密码系统的性质"></a>9.3.5 Paillier 密码系统的性质</h4><h3 id="9-4-Cramer-Shoup-密码系统"><a href="#9-4-Cramer-Shoup-密码系统" class="headerlink" title="9.4 Cramer-Shoup 密码系统"></a>9.4 Cramer-Shoup 密码系统</h3><h4 id="9-4-1-Cramer-Shoup-密码系统的基本机制"><a href="#9-4-1-Cramer-Shoup-密码系统的基本机制" class="headerlink" title="9.4.1 Cramer-Shoup 密码系统的基本机制"></a>9.4.1 Cramer-Shoup 密码系统的基本机制</h4><h4 id="9-4-2-Cramer-Shoup-密码系统的安全性证明"><a href="#9-4-2-Cramer-Shoup-密码系统的安全性证明" class="headerlink" title="9.4.2 Cramer-Shoup 密码系统的安全性证明"></a>9.4.2 Cramer-Shoup 密码系统的安全性证明</h4><h3 id="9-5-RSA-FDH-签名方案"><a href="#9-5-RSA-FDH-签名方案" class="headerlink" title="9.5 RSA-FDH 签名方案"></a>9.5 RSA-FDH 签名方案</h3><h4 id="9-5-1-RSA签名方案"><a href="#9-5-1-RSA签名方案" class="headerlink" title="9.5.1 RSA签名方案"></a>9.5.1 RSA签名方案</h4><h4 id="9-5-2-RSA-FDH签名方案的描述"><a href="#9-5-2-RSA-FDH签名方案的描述" class="headerlink" title="9.5.2 RSA-FDH签名方案的描述"></a>9.5.2 RSA-FDH签名方案的描述</h4><h4 id="9-5-3-RSA-FDH签名方案的改进"><a href="#9-5-3-RSA-FDH签名方案的改进" class="headerlink" title="9.5.3 RSA-FDH签名方案的改进"></a>9.5.3 RSA-FDH签名方案的改进</h4><h3 id="9-6-BLS-短签名方案"><a href="#9-6-BLS-短签名方案" class="headerlink" title="9.6 BLS 短签名方案"></a>9.6 BLS 短签名方案</h3><h4 id="9-6-1-BLS短签名方案所基于的安全性假设"><a href="#9-6-1-BLS短签名方案所基于的安全性假设" class="headerlink" title="9.6.1 BLS短签名方案所基于的安全性假设"></a>9.6.1 BLS短签名方案所基于的安全性假设</h4><h4 id="9-6-2-BLS-短签名方案描述"><a href="#9-6-2-BLS-短签名方案描述" class="headerlink" title="9.6.2 BLS 短签名方案描述"></a>9.6.2 BLS 短签名方案描述</h4><h4 id="9-6-3-BLS-短签名方案的改进一"><a href="#9-6-3-BLS-短签名方案的改进一" class="headerlink" title="9.6.3 BLS 短签名方案的改进一"></a>9.6.3 BLS 短签名方案的改进一</h4><h4 id="9-6-4-BLS短签名方案的改进二"><a href="#9-6-4-BLS短签名方案的改进二" class="headerlink" title="9.6.4 BLS短签名方案的改进二"></a>9.6.4 BLS短签名方案的改进二</h4><h3 id="9-7-基于身份的密码体制"><a href="#9-7-基于身份的密码体制" class="headerlink" title="9.7 基于身份的密码体制"></a>9.7 基于身份的密码体制</h3><h4 id="9-7-1-基于身份的密码体制定义和安全模型"><a href="#9-7-1-基于身份的密码体制定义和安全模型" class="headerlink" title="9.7.1 基于身份的密码体制定义和安全模型"></a>9.7.1 基于身份的密码体制定义和安全模型</h4><h4 id="9-7-2-随机谕言机模型下的基于身份的密码体制"><a href="#9-7-2-随机谕言机模型下的基于身份的密码体制" class="headerlink" title="9.7.2 随机谕言机模型下的基于身份的密码体制"></a>9.7.2 随机谕言机模型下的基于身份的密码体制</h4><h3 id="9-8-分叉引理"><a href="#9-8-分叉引理" class="headerlink" title="9.8 分叉引理"></a>9.8 分叉引理</h3><p>习题</p><h2 id="第10章-网络加密与认证"><a href="#第10章-网络加密与认证" class="headerlink" title="第10章 网络加密与认证"></a>第10章 网络加密与认证</h2><h3 id="10-1-网络通信加密"><a href="#10-1-网络通信加密" class="headerlink" title="10.1 网络通信加密"></a>10.1 网络通信加密</h3><h4 id="10-1-1-开放系统互连和TCP-IP分层模型"><a href="#10-1-1-开放系统互连和TCP-IP分层模型" class="headerlink" title="10.1.1 开放系统互连和TCP/IP分层模型"></a>10.1.1 开放系统互连和TCP/IP分层模型</h4><h4 id="10-1-2-网络加密方式"><a href="#10-1-2-网络加密方式" class="headerlink" title="10.1.2 网络加密方式"></a>10.1.2 网络加密方式</h4><h3 id="10-2-Kerberos-认证系统"><a href="#10-2-Kerberos-认证系统" class="headerlink" title="10.2 Kerberos 认证系统"></a>10.2 Kerberos 认证系统</h3><h4 id="10-2-1-Kerberos-V4"><a href="#10-2-1-Kerberos-V4" class="headerlink" title="10.2.1 Kerberos V4"></a>10.2.1 Kerberos V4</h4><h4 id="10-2-2-Kerberos-区域与多区域的Kerberos"><a href="#10-2-2-Kerberos-区域与多区域的Kerberos" class="headerlink" title="10.2.2 Kerberos 区域与多区域的Kerberos"></a>10.2.2 Kerberos 区域与多区域的Kerberos</h4><h3 id="10-3-X-509认证业务"><a href="#10-3-X-509认证业务" class="headerlink" title="10.3 X.509认证业务"></a>10.3 X.509认证业务</h3><h4 id="10-3-1-证书"><a href="#10-3-1-证书" class="headerlink" title="10.3.1 证书"></a>10.3.1 证书</h4><h4 id="10-3-2-认证过程"><a href="#10-3-2-认证过程" class="headerlink" title="10.3.2 认证过程"></a>10.3.2 认证过程</h4><h3 id="10-4-PGP"><a href="#10-4-PGP" class="headerlink" title="10.4 PGP"></a>10.4 PGP</h3><h4 id="10-4-1-运行方式"><a href="#10-4-1-运行方式" class="headerlink" title="10.4.1 运行方式"></a>10.4.1 运行方式</h4><h4 id="10-4-2-密钥和密钥环"><a href="#10-4-2-密钥和密钥环" class="headerlink" title="10.4.2 密钥和密钥环"></a>10.4.2 密钥和密钥环</h4><h4 id="10-4-3-公钥管理"><a href="#10-4-3-公钥管理" class="headerlink" title="10.4.3 公钥管理"></a>10.4.3 公钥管理</h4><p>习题</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录_一定要打好基础</title>
      <link href="/2025/05/23/%E8%AE%B0%E5%BD%95-%E4%B8%80%E5%AE%9A%E8%A6%81%E6%89%93%E5%A5%BD%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/05/23/%E8%AE%B0%E5%BD%95-%E4%B8%80%E5%AE%9A%E8%A6%81%E6%89%93%E5%A5%BD%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="3aa86549a36cf4a55e961d6f2ebd73a4759117ffbed9b7356efb2c07136c2887">7b22b1899bb4d215751e07a80f0d88de76ab04d32e749f01d35ab7ebdd5c2d808c2f40622a3888966f86dd811afea936dc27699529deacbe36adc04875c300c1c3f47dabdfeeaf933095654d24260b732f4cc8d32b361bcc99c18a343783f0bc8efe428615c230ccd67cd5d5b91c6813e1474a024e0375ea1af4a62bb335df23a2e661c91627266b0d02d6c21be114bdd423af57c960abfcb4057a0a02f727cca17282b3071c47a3f21684dc1252bcb2597d3ec6b836ce262dc6bec1dc81abbe6de11c9456667dd964773a941460fe7b17389f05482a2bd20d471bf58449f48d4a362651a6cd7cd2bb4d2b71d5b57f994eb284068c94b5d2b619c3b52fae3f7b257f4a2cd211dce992bf450c211c1bb0ff4ee1e2daab480cd86af265d784229ac01fac35df3348d97ec5b09db934ca795fc61a3e4f2939609dc800957724f7098e70be2425daa77b2642a9838b713d180b3b727337c3b6516d96bc65739629308e5589221b6f4fb90fb6795a1c2d5f045242f62dd8fb4ad9bfea58070ecb3a96c196aa5bbbda5d24283063f72017939dbf6046999f7045625aed9c513bdfcd3602352643507a4d78484f9b4d2d240cb91d868063e793e14f68b7847e04fdb5ddbdcfacdeddcb913a9ad1a0454b562dc4c229fc4603c36fbd325b6c6c69561aa5e681adafa97a9c025f92101b1ed09339978b6b90e004e08cd65a2203b8d1d5436060708df08cee1b88dae1ddb280aad429eb478f52116ddc3185eb94d38f7cb99cdd5e9b9087d8ca94433b6770932e0ccbfe85a126a338fb926de70dff334848ca043d2b201cfdbb9aa45c657f1822e3b160197f7136929efa0e45a1705ee6db</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何背诵单词的思考</title>
      <link href="/2025/05/23/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%83%8C%E8%AF%B5%E5%8D%95%E8%AF%8D%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2025/05/23/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%83%8C%E8%AF%B5%E5%8D%95%E8%AF%8D%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>今天思考了一个问题——如何更有效，且更持久的进行背诵英语单词，并且如何检查背诵成果</p><span id="more"></span><hr><p>解决记忆问题：<strong>间隔重复，视听写读</strong></p><p>解决持久问题：<strong>固定时间，定时定量</strong></p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>第一步：首次输入（联想+朗读）</p><ol><li>看单词和中文释义</li><li>听录音+跟读三遍</li><li>遮住中文，回忆意思</li><li>在一旁默写一遍单词</li></ol><p>✅ 目的：建立听觉+视觉+动作联结</p><p>第二步：加强记忆（默写+复述）</p><ol><li>间隔半个小时，测试这组单词：<ul><li>中文提示 -&gt; 写出英文拼音</li><li>复述单词意思</li></ul></li><li>听录音不看书 -&gt; 跟读说中文释义</li></ol><p>✅ 目的：加深记忆路径，测试回忆能力</p><p>第三步：次日复习（检验记忆是否“过关”）</p><ol><li>拿出昨日的单词列表：<ul><li>中文提示 -&gt; 写出英文拼音</li><li>听录音判断自己是否还记得意思</li></ul></li><li>标记哪些记不清楚，重新加入今日学习计划</li></ol><p>✅ 目的：巩固+筛查遗忘点</p><h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><div class="table-container"><table><thead><tr><th>测试方法</th><th>要求</th><th>是否过关</th></tr></thead><tbody><tr><td>中文 → 英文拼写</td><td>90%以上正确</td><td>✅</td></tr><tr><td>听录音 → 说出中文</td><td>能快速反应出意思</td><td>✅</td></tr><tr><td>自己能用该词造句</td><td>能简单口头用出</td><td>✅（长期目标）</td></tr></tbody></table></div><h3 id="如何分组"><a href="#如何分组" class="headerlink" title="如何分组"></a>如何分组</h3><p>背的多了记不住，少了进度慢</p><p>单次20~30分钟（25分钟番茄钟）</p><div class="table-container"><table><thead><tr><th>英语水平</th><th>建议每天新词量</th><th>建议每日总学习时间</th></tr></thead><tbody><tr><td>初级</td><td>10～15 个</td><td>20～30 分钟</td></tr><tr><td>中级</td><td>15～25 个</td><td>30～40 分钟</td></tr><tr><td>高级</td><td>30～50 个</td><td>45～60 分钟</td></tr></tbody></table></div><p>💡<strong>注意</strong>：这个是“新词”的数量，不包含复习旧词的时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说点老师的好话</title>
      <link href="/2025/05/20/%E8%AF%B4%E7%82%B9%E8%80%81%E5%B8%88%E7%9A%84%E5%A5%BD%E8%AF%9D/"/>
      <url>/2025/05/20/%E8%AF%B4%E7%82%B9%E8%80%81%E5%B8%88%E7%9A%84%E5%A5%BD%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ccd6baca118e83f98e545789ea9b69d84ae84dedf4a9593e79f5f5216ccd067a">7b22b1899bb4d215751e07a80f0d88de167c3831bec5fceb0b99f39a47bfc4bf51a8a314e161abf1769a061228078b2336178ee30d078682bcef33fb649d3f11c30f4b31f5bbdeb8da1012b181b013fba2484a8984ec5627dcfb89686a804bc09e033748077e0494492e35dd37863d0e0a4daa4e44e43c4c6cf59d15156c903c320242139b5fdc218eda881738501ba0322942f663027ea093444592708254ee0717367576e1861936029638f38f2cae777a8580f42288bb1265459fb0435a0da38fbc866b20e5a7f79771e207037d7b2214393a1db81cc683381c20883cff35d35fde6170133f03939f20ea58c1f672c29ce2c4710fbc9ef1cff9d5b48739ff585d685948df22c5d898293ba4579613dd119ebc822c463d58f50195c947d8c852a0af94634ec484552223a8773835d2c7a349961976e71f47793cc5930e06fd6b30b8a63e40b1fcc995352a0658566b252afc80fc1a1d4a52333a474ffd8f8dcc1809e29a5f77d783a7cffe07ea8f1e078c11eef78dd0e43ef13572f6ad32bb95c184c3db00278debe5dd684798ab49f497523032ccf756a0281ed4ac9aa8d8b4aac95d2d104a93f75b29e2a8f605900a26db25e4298dd7ec02412af3a80fe148116742e020b4bb5901374e23449e3db2ec5992bcf809d52252be55789b90cd82a3838298e8b2d67ee29298ee1a1b1091740e0303865862258e391bc990c9366204282a5ab6d17b16984c679c132627923105911f8c9267a83fc3a4c54d4d9db7753b6eea853d4d7a72a39522ed94cb4e9c9a5917044906fc427fde3aa7196e5243d8006404a74c70dc94a5384cd15b6c9a55f4880c17a027b37a4e2d993fc87e2450a4b53ddad6e4c6f19c788967ca5fd1d7a172b9c4567afebdfb579886901240882543715d759a9641309299d08d03485663ac8770671128b2b793780a132c457e0f95dc6df7551402109e1e83106f8653f58f82195134499d72e43203263d2f821e85ea74a761c5be08190ac2efba8f86c32e38de6449eb7b229b624695cfab48076ef1f2c8b221a3fda86e12a06a954275b9e485200d7334fa320bc990fa1768941d8dcbfa516bcdde5dd48ef62ba799966b6239751479d58c3ef88d168deb2ce850a3c840dcd76637fed6225b8d3151b1a4884d7f9bb7db26acb4890e42a38b5dca8c11a45cb8c8e9a471c7c8c1cbfcdd93d829186756f3df394b70a7dd74c954ebf5ce1ebf11bcf8354d9c74b163ecfc987fc2193cb49ee72870e863f646847c01898e4b9b58188da3abf6bc791694aff34efcae6d6e5a70e126e79a546a166a4841e65fcbb0d045292e9f0f5363b1acdf5a9688a08b9b7894d7b61b02dbc9aa197aabb83f13b7217e6580efded3ea836dd482592cd41f684cb2b637f0581e28cf25215f31632eec98210d1a00c7940d0e4c99fb9509931b1e1bda3948f592abab9bbf8f5f053371f310233f746854534aff0dcf1d0c15071f93cbc7c104a7db5fd01338180dd2a6fd8081ab316b383ac3371b1881574c185735f8fd44d7834890482bfd16f7e8ebba9fdbdfb4c53cc85ea68d71195c2115914fa91dd74a59855d376d6e3a91c70ed2d3ef2676014900031429ef6ed4850de1dd23654a63bb9c9bd33b0025bebf5bf36b19dd927c8116590b417967067007ba775e0c1fe111985024790e582f121f7696ca3d6b7c7cb8b3395b8469c512e40eb0082a353b4beff442e3646e38f3dfa564b3e1d364d326c9d5712d0b42f8675bfa11fc9659fd9101dc3594691f559a842a27819eeeb1feb515b759cc49ac40d4e2b91aa513095e91e48a37521f74dceb9b17e44ec65e28ea1738bae1e2e8414c893507a526970441357973ab82aadf97b69cc9846f2b31c2018ae2869c1214b481543a40984707c0e1ebd74ac7425d875aa39da46b163f31bca19a4269dd215e2ea227961fdc738911b297abe57f8230a79b22347663c0a8ea1cbdf795f2d7f9463d8b5fbea34655bbbcf7986772e9c5338acec88df9157cdd0cb60823d591294f997a6f4b70035a1234ddbcf728bb21170c7ba5193ca286ebe41f77446be2a834e57b96585a437e4475bdab4d11bef5f62ea576df855cc20b2ad46a87d3f0d8145068bc63c0a66aa7e758d095830191586af9890d8fbe41e829de146c71a39ee895d04a929465985411da1127dc5a8c2d404791d70df697e78614269dc4f3b48eeb55835ddc324a6b487cb2a8c5b91a8babfb17d4ff5dc8468a3a9b8239f138d6ba1d1e6b7970cbf14f37cba9cba020730e8fbf2be1a0ba2d3797f19d65d6caaa8da828ba32ad6beceae54ad3b7357a6909575f5faf9df37784dc5de8e8feb8cc4f6ad70067bed4ac6213105375897b498baae0865b7421409071a46561a3d53327a0cdeedc5e3ec0a2c2037a1417fd9a45ed7c90eb70dcc15fd34e01f45a8d4310225c07c3a7ddc1e52065f783c51bfe072158cb0d37f6c85f273db17761e70fd802100caa2707309f92b12e243cae30c0830939bc963e6abc3a908e98da99df05ae057908504a0f4e69b0694c4d3b5ccfb5d31a5376b123bf028f6aa4929d170f6448a01dbd583022273ef397b8c0c4429f22a0e18415483f1e88803a87a92fe4884c58bcaf45e2127e091298e998c48187ac7168cef5706bc30a264d226aef48a99093ede1b110a920c86f259ad6ab48d3789651c64c46c6966ea1db83e068511037ad8ee222735394e1296bdbfe1a2fe696f5b131b0dec63572a378b2f57badca05356ea6f72d671d02b5faf2cdd743307448cbcb627c94f1a6addd5833cfa51b0992a3ff3fd473d344fb82007699666e5453a3d7d8741383f1f663d8b0c0d4ee1ce395034da9274b7a001e4eb319f80e8bb165af658b424189c5d61e74fdbe436e8ca7ff3dbfafa58df7eb65984335158fca11ce204724ee06cc1659effdbcc3b0e4e8f86174e1238de237dd7ff1f50364cf02030daba80d887bb984ec059c36962ec9f6deef3c17be83c87906e37a768833316d20325c399f853d49630100dab59345131b913a0c5400176f128f4604696cc780c2a64ff6d13969ab846cde6f22f2e81005190bd7470a7bd9c2cdc1776e2a4dedc16f3dd0c2689d1df78e00ac63aa946910efdd350a06261114d16bcd7ec6865bb7c8f5c8476ad2ea911a91d0dc55eefa7f621f88d6005a0baee791a4efd0dd8938b85fed3fb554060510e33fcc9180c0933e8952884183f5694e8bb73b8a3bd2a0a5e75f154bdf215b728733c78c9f87fd31ec79d0206c361e2e2fcea802a4100a6f47e88e94673ba700d1b2e60e1aa228206da3149aa9e1e5970acca198695981552e6328f6c2edb0dff484fea927c573d94e0d3feaa96725783efa2ece7c5406313fa537c1428772c0a6f5c6867791ebf92726efea1623f3fa4c999ce694f4994226fd41b56e1f1669628e53583de68daf2e1dcb68dbdc615f94f78751b0bb77e6f4b051b07426f840c1e7e35ef66b2cba4dd764d9462aa7e6c1b079b9049ae84b5ef09f05d165ca9f05be2e6f5465ae9f4a991098a638b971b6c8ee2c066d9d9f7d86b0d6464a39883026c6ddc3c52c61290f4426e11ff46457fad15818178410a57dba175d6a6cb81a7ed88f54cd96aa97b712d2f4cf6de42933d17a91aebe031edaef7c4659b0c46bbabfc99660778589a0864c45eb5389448a486f3545a859ad68955a7f5f2d855bb789303f1493ea19ac94e481f2e048249f7ca75472b9f59c0a3a48edb51740955bb6804599637c517865c8bc08ada0faba1df83e379dc3565746019360a8141612e271d8f8d9abea7a74ef9f6c7c99b01e54830a4a2f086500ceb6b9027557b1ac2c348977c28daf682c3b0844b2949955d2dcadae7d79b7d32b8351d350e80956dbc3ed01dc3fdc85fdd2847452d695155c9ab736f67f1ad2f293257e10645150f4acf4c88f4d93bb1eb2459cbd9f080fa09653b03511c827f5eafb8c1a4a44f698692f59bd6ddb3d811bb5a78f3d7851d1a297e16cdb7884c0b32bff415e77ae090450cd0907bb7a4f3a4fa70dada732ad5014e7fc4bad46526029a7ee5743271ee529b74aa4c73170017c3cfabc95c6407e71e4f1547df83571ce863932ceea1c54a433050f0d105dcdfdd5f494a9d98840300bde652dfdbb02b44c661d36d3774b332adab9a8bb9d67563df8beb341a293d9a96de95947b5e9259502ad617b2efbc092b142b557b700a7c831a56350686fa7a8921dfd031b0211951b0c4f8a2b980333bc6a11342f2c5853edd80ea30adac3da3fa7e5a811a3b978be708f6a02f6a569aad9f86a0cc9f2b6ec8d7c640b6bcc41b09bddda3c95d25d101ae4c5830372a0918de23a4f454dc7dc2ddb7e4bd8ac8545a5a6052f72d24935d1308fcd84171135a1ce04860d2c9c1517f512c509c122f6ce226c6319e015a94a2d55488f5fe702cab9a265f7b04229e3ef53e1a39595d68709b0d9fc2f9eee2b226227c232a8bb39b3d32f052c6c70a4d72c090702d79bab7105aca16e292f8db46368ed32bf01de2d9cf4dcdc0025ccffc0292167b67972092f41f1704dc4e3215bf7e84d6c423d4e7d75fca74ffb293197e9013e1a486fd19a54b54568689efc45b71936bf4a3b629a82dda2771fe0560468003e5bbe898eb2156ea96b4bdd2e08c4db5794ee1f9c5c8c09bb8ee273f76763cca7845edcde2848374f96a0e92fbba1e56cdb4e268afb1d7ec04f5ce8b77528de21c6fbcf5b7b068998c0df27e0b1f8e8f423564059a23de46807dc680b59e491f61615cd8361f9aa948a09fc2b1a5c7b76000045f648201ea8e8a1b8f8fbb40d07e8785d6ebc96eb307dd6682cc4f33a4414e9047925ff52a3562340b468d676b18d1da33efc35c70257bcd509710387ecd47cea8955c12a2dc06e36febae98280e8d571ed438d21cb562ce24b1075ee3dadf5921df68da13d2fa996aaf4e0e1b5ab7cfb3cdb610e8c20c7537751ad621f14812517149da8bef5bae0cd928247fbc6fa57074e9f3b31cdb7661261</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学术晚宴学到的需要注意的一些点</title>
      <link href="/2025/05/19/%E5%AD%A6%E6%9C%AF%E6%99%9A%E5%AE%B4%E5%AD%A6%E5%88%B0%E7%9A%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/"/>
      <url>/2025/05/19/%E5%AD%A6%E6%9C%AF%E6%99%9A%E5%AE%B4%E5%AD%A6%E5%88%B0%E7%9A%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="772a3b2a60ae33535a729f3f0dbfe479174f9c0dd11ff40d20aa3583dd1ac0e0">7b22b1899bb4d215751e07a80f0d88de7ac43174b2bb1ad06a11d61b739ea0078e3d8e8154af558c4f00c1f60c8beddbbc345755205c62db720a0ef1d8fa4bb7dfef30ae482e960c0519757f048c4f216b90e5a84f61cd1bc87de77a0f2f45aa0e58e67eb564f3bf3856573215f610d833ffb7e28dda5f0cf0b9f550604ba92ba5b498e2f1cd2ea91cdd288d1c90dcd3b0270df90ae75d27611c2ee09b0f3df5b2a4416627820085c20a7595cdce451012efe8ba3f9362534cdaa39a9829e7e5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS2025摘要小结</title>
      <link href="/2025/05/19/CS2025%E6%91%98%E8%A6%81%E5%B0%8F%E7%BB%93/"/>
      <url>/2025/05/19/CS2025%E6%91%98%E8%A6%81%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文对第九届网络空间安全国际研讨会的分享知识进行小结</p><p>相关链接：<a href="https://coperlm.github.io/2025/05/12/第九届网络空间安全国际研讨会-会前准备/">会前准备</a> <a href="https://coperlm.github.io/2025/05/17/CS2025参会游记/">会后游记</a> <a href="https://github.com/coperlm/CS2025">拍照备份</a></p><span id="more"></span><hr><h2 id="会议议程"><a href="#会议议程" class="headerlink" title="会议议程"></a>会议议程</h2><p><img src="311e2e26b315700abdbba615868bf1e.jpg" alt></p><h2 id="主要笔者学习内容"><a href="#主要笔者学习内容" class="headerlink" title="主要笔者学习内容"></a>主要笔者学习内容</h2><h3 id="图像篡改定位模型对抗"><a href="#图像篡改定位模型对抗" class="headerlink" title="图像篡改定位模型对抗"></a>图像篡改定位模型对抗</h3><p>Motivation：AI兴起，虚假图像合成的成本大幅降低。本报告旨在检测篡改部位</p><p>Solution：使用深度网络，训练模型。有效检测篡改</p><p>新的攻击方案：给照片加噪音，人眼看不出区别，但使用原有检测方案 难以检测篡改</p><p>总结：安全领域，对抗是永恒的；AI的产生增加了对抗，也增加了弱点；在研究中，应当攻击方白盒，防守方黑盒</p><h3 id="态势感知"><a href="#态势感知" class="headerlink" title="态势感知"></a>态势感知</h3><p>Motivation：国内网民众多，且信息多模态难以处理。传统处理算法的时间复杂度为指数级（响应速度为分钟级）</p><p>Solution：利用关联信息进行优化（例如分块，关注敏感话题等），时间复杂度变为多项式级别（响应速度达到秒级）</p><p>应用：检测并控制舆情，护网等</p><p>备注：该报告的PPT做得十分优异，有待借鉴学习</p><h3 id="安全云存储"><a href="#安全云存储" class="headerlink" title="安全云存储"></a>安全云存储</h3><p>Motivation：云数据库存在被服务提供商或攻击者窥探的可能性，查询语句和数据关系可能泄露敏感信息</p><p>Solution：</p><p><img src="image-20250519084908967.png" alt></p><p>面临挑战：数据关系隐私保护（如 JOIN 隐私）；功能性与隐私性的平衡难题；泄露抵抗机制优化（如访问模式隐藏）；差分隐私与SQL的融合应用；模糊搜索技术集成与拓展</p><p>备注：该老师用的是纯英文演讲，所以只能录屏后在学习，故而理解可能有不准确的地方</p><h3 id="大语言模型越狱"><a href="#大语言模型越狱" class="headerlink" title="大语言模型越狱"></a>大语言模型越狱</h3><p>Motivation：攻击者如何让AI回答例如如何毁灭人类，或者制造凝固汽油弹之类的问题；开发者如何让AI避免回答这些问题</p><p>三个发现：增加奇奇怪怪的后缀可能绕过；简单越狱方法叠加使用增加成功概率；就算没有敏感问题也有可能被拒绝回答</p><p>一些哲学思考：威胁AI会鲨掉他，或者给AI小费，可以增大越狱可能性。AI越来越像人了</p><h3 id="口令认证密钥协商"><a href="#口令认证密钥协商" class="headerlink" title="口令认证密钥协商"></a>口令认证密钥协商</h3><p>Motivation：传统使用PKI和证书进行认证，使用口令（便于记忆，无需存储）则不需要</p><p>一个令我拍手叫好的构造：使用一步对称加密，有效防止中间人攻击</p><p><img src="image-20250519090300209.png" alt></p><p>Contribution：构造了一个高效的后量子aPAKE协议（基于KEM）；基于同源构造了Strong aPAKE且UC安全（也是抗量子）；使用串并行构造了HPAKE</p><p><img src="image-20250519090846765.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS2025参会游记</title>
      <link href="/2025/05/17/CS2025%E5%8F%82%E4%BC%9A%E6%B8%B8%E8%AE%B0/"/>
      <url>/2025/05/17/CS2025%E5%8F%82%E4%BC%9A%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b98d5c6e36bf8f23dcc3f474fc0d29f3ee9857f8f6c30a513b508eef5b526fac">7b22b1899bb4d215751e07a80f0d88de542d676cb326d0c5d6a10c6353002e1c857d400123ac95c955b82c9a27c938fe6272a98c0e32cec6e393fe8f9eec356e2a6c241e30fb6422803d97d1c60f1d1b4f731c0251f3851cd9bb88bf8eccbc1704b16a372922f03402096fd78f2f7acfaf8f75ea22be1ef2fc20fee85ec69f949c74f6ec5848ecbd05cf228684901fe99f5f2cdeb3b0d1f2f3de79b3977b4df94e5794f825f949e67c26f7efe1061de9434d87d0e809c706396d2f6427e599ac648e41f8491141e2ea714fc3b06783b74b2ccc11f702039aa608aa360c5899871f935c452fed0adf199978ecc6cb799f4e64d3f1aefeb7123b72b44a56f937dc58a56d298060a8921010ccc5f624877541633246f68b87181ba0e4fedf6d05dba9ed585c440968067e83d22276e4ad10bd1f34c21678edb06e758a26560f8e03f2afb3637154d75050ceb8a2c267ff0bf51249c4b22a25761b4632d7e3b0426f6c18c50e6ab843c8aad0c977e8ed28c20f0f84499db0af6f8c4f834b83ffb8bc4d521cff5668e6248a7fd2dd59723191ab07b4712e2411a2822bc53e9bfdd6a4a51f753fdf15fb053ed24f8c70c249826c94f09e1105bb81a4708d6434ae6333515f3fcdd4c32d051a928101b1af16fdd12a3ea5f6a87fc42928a6638fe752fc6afe449da331e76e0b3d82eec070f4b4ea6f015543de15ca576b127d5fbc018cc899c97fbf02e4c6cb19d56091ed11081b579c351aabd7b58975dbd9da5c7e125101c516b5cedda6abd2c40390c863a3b6943091759be92c39f8207a3115729c468b9901b0e4132ac505dba949960504abe277447088d5e3dcb02706229afc09f0c6150f34f5e9fac329d060e229eb253f65527db35d3ec962e0b72a2ca53d8d8195d8b75b0fe957a7f0cd798b7b955669f6b10bdcede0e59b1710e3f71f8771062a5ee3b1ea1267506e91e3b448397ec381c6eae0aa6c6a8a3e92a53d10797c7fd2b1ac8ebbaa917a5606dabbbb6d9f489ab029154aea84619368c6d92f308fda94eede11649a547a68b2c7812b2f0cb98a15507fae2ad0e7706c5dfeb6afb6fd7beeca71bbf1a7e6ac9db79200b5b499e574be33dba5b930ef0ba7b84a7265733f4f196de49f0196e02f17f1add4c78cfcdd5a29504c0a949607ef8d98996b1e40215639497a4103621e44227439e6b19063b827ff2cd5dea33d94eb37a9127c18b6b9afd27ccae240974419f8b7d1703009fef854721ee86f9fdf47dc6a60b0ed935d1bbde4a16d0746b8b924367fb9a125b0b691deeb84509c201716b350e8e8d78bbf85d54fc7660be412ca619e3e658c1cee499bd48046850ff90353f7ca1b3844ebc6d55bacc3c5ed78314faf652d409ab2aaf8453850111679ac879b95069a9d1c72b7d4ee9e158e78b0382b65f8a6e5ad60f12a085162f11fd54fd8190d2b3eb3b383f25ed3839d99a29ac3d824428dc6d14b1a76a22445baabdb9cda5d93f305324dc35162e0a16614a81f67f4f4f9928cf0fbada33073edde8d737e44f997f8101905bb665c7617ea4084c3a22791f076420a3d4bd2d8344c1c687cf7a0349ff0461345eff76ac61180078f28d7d5f1adeea74eaf7fc6341124461785d53f8615880b2c424e63deb72e01012ff2ef840b17579980e9d2b6a769cd0969d0bc1faaa85671d02a32edc8eede6a0ae4d572d4b418b9bc50aa1864c2196babf19fa370615f84f99cf3f643187fb6b036873df906c0c45b4fd03e04d303c2001c552e05f7704187d26f004498d3f756a435c12c87214262eddb503d49162e7f5d376f963d9e95cea8cab55f860b2f39a6b27e068eef376adb1e856b9e7d4e1493aa8670fa045536121de103c7b570ab1f0735b9c1cc6f40aace50347e3df30c3b54804f5ea40680ed082a88747f7c0aeb656dfb50e464a0f5386bec6e1e64ddb7ba9456fc738c43aa02c9d73bee6728c6e8f5dfab8828c337d8408e4d7c09294879b3243763f70c4e3cf2c509116a5186d9d9540936a0fd8e17aca5d4bca6eab2843d11d361627d78f9160a905f5ec5d8355a1c1e69cec92a7ad07207ffe7d000accba77b5d781f2c90df53a03433df9fbe237830281114beb40752245361e1c8a8b6a61ad782c1e61c1959f60df34912e43f1a84e9532bf263e846f4b9bd56be3e688dc2c2bdb98e33067f74c8266072e51f79ba40d567e896fb7ac5ed97c1c55c538dcfa7336c2df5abd117f20e256e938f766dd012866f28ed6cf26140dbde556984cf0cc89f02e67eb666ab7609f3a799ed0e51dc05f61884d8cd5f80c017e4624fa0ce778c7d13d33f36f7c0b8ed1151e21a0d3b6ae9749a686905adb14ad1d4ae30a7290abaa8a1c6c648fc9b72582821a64f38abedffddfe089095f0c9ab091c0173b4f7448cd99ae6d01f6fa58acfe9bb78d10ae5805b14118b82536b6e9bc87b08a1f7ff78ce4acd1ec5a178f590b4604929907a4acc85fd62be5ee2b27b8caf875996e1a9f18da998a2e017c7888b63a298912ac91f7ad85523f6096d61ef4430c897b2dd2e0b1fc52b19e958013c24c8f9a80ae37b849895a89151a6b78ad7242d36db0045ec213d9e0bf945d2cac37a9013561f3dda9c07b76c7486e9d19ea18e08c905941d001a81490b72ab3803f049094031ee962eeb03e32185b088951a78153fc67ff5a41defb641ba4db2e8ff1d26275cf1c9878e98b54b251cbfd2006245e4cce71e6fae08f7536a22334aff3e9431095975f55f3dc18a05e7bc75dba5d395d7b4d35b6715822492cc14ca478eed0510079c26056f5c0a3a34a7396c1bcf8fa492796fc4aae7c5444ddf0265129091cccc466501c7cb1531579ae0184273d14d6e33a16626f6f26f88cea3f347fadbbe7fcb5e33bb4de2bd10f99a991b9044f823ddc8948cbc8898af1680d03cac325afedac8a4ed61ec8c78227a8af4d565f727cc46a1d94562c162cc82b50b1057bd05f18e9e9e93aad91e93b9834c8c37f1d7b055ebcc319c7a80fac256ee3172197fc09913c1bda1c132be59676560fc7273bcc1294a12f9cb961bd70552de074c7270098d03a0ea1c002c4f62c14e9c856cfd2266f59468b8ee06092219565f493698c336d6ed25ff14785fa13be693f6fcd08977b10e7efe7605ac61e5ffdabdc7a65add8d626dc72675a6c03a673063ad4514b5240b031345b854c4c385285ceb385b67</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> unfixed </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念：关于密码学的方向选择和导师的契合度思索</title>
      <link href="/2025/05/15/%E7%A2%8E%E7%A2%8E%E5%BF%B5%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9%E5%92%8C%E5%AF%BC%E5%B8%88%E7%9A%84%E5%A5%91%E5%90%88%E5%BA%A6%E6%80%9D%E7%B4%A2/"/>
      <url>/2025/05/15/%E7%A2%8E%E7%A2%8E%E5%BF%B5%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9%E5%92%8C%E5%AF%BC%E5%B8%88%E7%9A%84%E5%A5%91%E5%90%88%E5%BA%A6%E6%80%9D%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a5b0a4aa25210249ab27f6cb0faff4eba9de05c6e7240eb1af6e365991083d65">7b22b1899bb4d215751e07a80f0d88deca33120d4ad1342d09e59b6b63d4f5ae1b9d1b2dc7a377bc6e7b10a13b02c3dd61ae18302bca751537f5a1b1e7eb714f23347c887eb3d2c2b50c053d7e8f612697cecc5c64263653245fb63639312162122fa77742fa7ffec9a66106235fd219e0e0a0f1b25874b0bbcd23e6a97e0c5198ba4e3e4a19383fb26688cab55fceb3631ff63f4acc2e65c21743fad0f9b3c942b9528b63337b58fe5e03cfa22316c5991db4ed919a42ac621528a987a7e6fa906b8dfd36720517602f985dcbdb575090b8ee0c13757c6502c43fbc0733343f74cf764e1d96fb8f0b636f0b6de987a7c5524d793f1d5e52b67b4e6ec1ee59187d46f19f7d9b59bf7942dfc8e669dcf2a7046594aa02d3445cdbed7c41b25f6dc5b4aa296cd58f3f33486dd18e7cf4054f5b99ed787127361c7d5a8d695e16e679697daeb95ad8e071935f01fefcefc13431cfa45d59acddbb92860e8831b0f269de774015b2f0de1c015d7cfd39897079a9eff19ad9295712612316fe04d0f46eb0d4e43e8f3e8dfea784f2341f3b8ccfd9c00a8ab39235ce435f8fd1e3b86c2656bcee7106645c6ca04e38f66a23505252e7b796ae5fc9896246e87d4f1307ef9dcf2ff248caa60ae5ecacea202ad460b1c92330611a51bd588b16ad4dc3afcf0718830ee1cf701bc8604f9d49b09c3bca3a52833827b85258f9b67946b2d3a2fdc742a9ceffc48b750804481b433acf49c2921035b47c5d880c45622bc70e3dd3d40b58f83669c74941a94c7dae91eb1ac84f93e2c86cc2813ad6445327c2a6be0c1c11a5905a0b4202383afd9cf78a540527b38201c268ed2a897d423c61fdd78b5d23bebeb276a756145ddbdfa4333c4c928f82faec2f1cdeb5e63c87c3a10469eef4faabae85eb9cd7de7a0207cd16fff8aeeb01c185f889829e6d114aac5e888c621723bc32c6ff61236b26a496ddb52bc8735da8ae5862b7551f7ca9db7364352aca1854c4ed3fc37700fe6b02498a3b51a5c4192af7edab5db45015d92ee82429b54a524c95ca470dd294b92043a6b1a71225262f1e593302ecbc477fe6f46d8bb8eb5ef0c28c898e96c072a02717bb82894f11800237b0c9d15538159f4e1774ef143aff1993f7be5a413c878077c03e8187c42612fa1654f6d9a75e50ff4a80a3045e698fa8fd49574479b4af71681125f213a7015537423dc0e45eed5f2058aaa77bf97e387ce3ba77760213968164ef94b35e241552caa76193ffa7e5a1017a65f7fafd031f7a1b7891bc5d44ab4a72e9aae643bd1c3cdd3e4bf5cd77c35a3d3aeabb184caa5c2df6b709e9f4db906006a9528ff92174d7947ca3f4408e148cf820c9056a97d669880118e688d2b24febb16dd1ca9492a0cc41b0fcbd5c75bb68666dd03b3837ec7e2b0acc658c953b9922343eb9526e3562d145f56b30ebc43e4490e9f5fac79c065847f63df6529c4ed09318c682c694698de4589076520a087d4adabc66e261fd9eb513c29055f589a98cefa7728899148e8a3f77291dc95f2b7577ba8517bc84f04d51948adc00f572501ada6c8585817864c8c19d49c98d5ce6889bbff4c44d8e94d165c148a7d3f2b9c66ec3a378bcd860fb9c6fd76323e8013a4bbff4ed90e8fba49cce3c8832fb310fe8eba376f0663fed723e697284ff5eb5acaa8ef37f9f22ea7363050f11ee822157777461608757f847aa8a2e35c3d4eadcf0c6911b49bf842f48cc8bee8638b5bc189138b577a209ad1f28bc1b502280a3e8c338efc2b3b6117ad50a2cd57ddc606dacb3152cfe6614fcbbd63d582754ba8e210bfa0306c6ba488e9fe5f0cc84b57ffc8e1fcf36ae60c6eee079985f6c241f6793108d14a8eafd507df1ea70a4f9be0a67e4be0e90e6bdbfb86ff19d8dde52c240d73233723723eb43decc990876671b9124b3bf61f8fdea2bb96b36b1eb8a355c109aa71182ee4896f7487b10b33286e50b77afedc844c3329260d0cd3069a462485599b9c1421d1391b8d5934ed21aafd2f316900d2609ccca9f555f656c27da44d230c104113d61aaa0ba63e4c662471550a1c14a981b46ec995de801d8c99b1025</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九届网络空间安全国际研讨会 会前准备</title>
      <link href="/2025/05/12/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%9B%BD%E9%99%85%E7%A0%94%E8%AE%A8%E4%BC%9A-%E4%BC%9A%E5%89%8D%E5%87%86%E5%A4%87/"/>
      <url>/2025/05/12/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%9B%BD%E9%99%85%E7%A0%94%E8%AE%A8%E4%BC%9A-%E4%BC%9A%E5%89%8D%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="cfafede4ea27f5f79af7e19e7ce86539fa6aa7582cbcf96931a457566b58840c">7b22b1899bb4d215751e07a80f0d88de177c76d9dee5b490c134eefa0fe7d07a476035cfb172a5cd658b512e633b2373b760e0db778920237161c4e661333195c8702a6cb6d63a90cfe9fed3baeae097741a63602eb6d2228a95cf1e7588ee5138b389257f3b9259812167dba934401ade657168d7a2124a89a56f5814e4445acfbecdc0dfeeeafa1447347bf3ee56d062e4441b9c98dfe64100c28afe7f809f0aececb6d66994b9e9d6beaa3486acf4abbad8eff1d49775f8dfa9b62149bf2082b8110cdede1b4a174f21a02a11419c1f9186a3fde100bb582a82292b678f31af520d3141ab01092963b9cec4742d1299aceab279ca88b0a06c79c0483e67e788cc611c8f0e64f603c1794d482afabd10bd53ccbc6973719be43866f3af6cd8c04079ac2a2d74a2c1bb4db19ec39fe119dad34448a3630ea26649cdeac372706d74a8e5c3529c41b5d4da4c65833258ea66b6a1221179d5dbc2b548cbdbb6c386f81107f6c056cbc058a442dd0bcecef636a4b19f65249c881829f30d6b59a10ddadee1f2edcd6af2d9c94c94a2065e180ab1d0717ca20ed29a636cc7eef3c96c78b2459301aacdf5ce82778e58ae607d470e0a40f8763d8cf407cf7bc2bab483f961851943d6791ee1a8f6b8228a82b684b77d837a80962ad8ddce3237d79b3be21d4a65b2454e0908031d597c47cfab4948aa335283828be85ce861172871d7367e2a4f42596e9b99ad0079560bde1205ccde0cb6fd218d498704116f11daafab8cead41ede9e90eb7eb0e86261af2d0fc541e7e6133e7024e4133d67fe7a899e17b8021114a156b357343ecbb97f386eb2a3f3398772562d9269b7476c65c37ee9621d3bc04fb44dc685f7fe9251fc59e61dbb41a27b42158d86d697ab4cb487a51bd6aa5f725938b183b2236dbb5901b014a9f4905302e03b80870f85a92da66a0ba1b17f4ec28cb6556df6603cc8816a5cf89d01b6b3a4ead2a5bfd4864e96288843b24ed29d4c61b61b13ff1fc36ddbc6aeb711afe969873af7bf556b036cd7bd0d173ec1d1041e57659f9a9fec26e9df7653b3c1996098e419382fdf9fd7d75caa7b71ae5b4eae47e00fe07817156fb71962c051e6c685836483ad215cb9617442628d4851e0619c709d9399450b1ee408ed2db9aadaa332024a988364278eaa8fb2ddf0fcbeae315072cfaa4d56af8ecd09c653b84a803eae1152136aa75323f63719641bb098eaeb14664f982553540677fe7d047117611fffba59e116f780492b1e8a8885254c2d3621a4a52ec77f671fa7c645f4d849961f4a051e71f22f021b9d0f98ebfad63b0c3c1e0a479b6992784453d00c256c95457c07202c30e94e9670efe275bdb6c64c343d0bbb27feb30d08afc30425e548d52d45d1590c59af22a04ac95f92ed490d30b3d5f4b8737a6ed3f7eb42abc8fb3ee897786442220a940b6cd8435feabb7b2dd1018dd7903b9431ba2285940c1ed4d675366089462acc8af744111599a941b21eca9c8bcce8784c3b868c030f8a196cb7d78d50ffd0abf76ae56a5847553395b70f0d4bbd82a6b042f06bc4668f524672fc749df6f5747073c557139171506ee9f6be0a97cad159dccaac3d1c0c2da152e2dfd6817c9e7c4c29aded9efde22074da0c9a79abf5e2455170fe0c8a5ee570d64f997c52581d7ebd15efc29d3a3f2981aa0a837710e33b6172f044d13d5b84dc5b7c6801e9409d3e9932a053147b7cd44bee99a21f1f123506901e382ee6593459d1700804e7d0edff3278a0a2409c95f8a2cd747aa904e79d816de05f2b5767c087bf20fcffcea9fce7c2447d79bddc64282aa49eb290714c26501e1df9dbecbca992a47d9bcc76165969ae63a6e2f2bc1416914ed9bb3afcf65a92297b695cc69c7f8969a048cbe8efe43bb9491dea80299e1548e1a9393df4e051271ce33366dc89bad9c690a743855388638a7db30b581cbc697636f5089b365eedb59f1db8bc73853081ec07696face47f38a41604bc6017898338a4918bcf14b732907922946b91d1adc82a9d6035b14a5bb8234bc8a754664703bccfb4cb8b55d7c1c941d92f375eabfee7a89227b2f534f23aaf8e176d1b26eeb7408c91a50813a28f4846b9f66ab4e66e6f40a4029ffeca102ccf14045e43c8383e785545e66b4d0f52ffa1d85015ec2997787c4d7ee7f828e79dabb148d40098382eb95d4cfb04f8af64491cd5829899a973bf65d5e636ebea6dabc229743fabc68b48437a3d910aba99ff4b7cc4888f1ab1789aa7b33b347cc30b076c8eee9b4db1c8215679bc2102a87221a0df56a32048bdf7f3a9f80419b54d4e458cfbb625d4df15897db405b50ae47f51804f66a9c99a43bedec01b2c4281f880c1351b881fd70b75df44f1de0b09268955c4822f14d3acc735dcdd360cf0cd8699f47720049b2001ca276590ba15232abed2a6d3abc59afee2e40c152b83a353211bf4caa3f2fdde115430bac8244d9b381c453216ecf8dabbe5960870c4f60c60feeaa03fda410966ed8170efe319fdb982e13b42ca4bd76f4d7a5007f9d1f4afa246fec25278b7c652145e070daafd5180a920f4063d9ce5b0ec78cf68c60cad9fd62fcf38ca886cbf577fa6b9a1a7ffd23803fc318a93680e21886bd1cbdedd81c7971887c6f19709bf6fa65c0506b8f83a8004fd7a875e5e61a9fbd2a4dd05dd804c257790ddd6ccd6c65cc79733a51c22323782b50dd1c196adf47a0e89843842b86cdd48a39277b360d852c23c4680701b4969ca4ea9bb9480d7ec35033eb80d2c928e1b4773092b6a170b8a1caac943cdeec1ad83bbe29da0614422cec71284b3002fe95dd8b796271135d82a99987427976b3a1cd490506598e5d30d2ec3b115093febb20075066da8326f62317345e93b6bcfa53a8f594540e7a4e2291aa3b7c267c785e75e59d2e60bbbcd46c67c4a72bd487c561c68f41eef4a881cb544a05255e4f73fb4e48042a1559c8d8439fc86d3db084dace4049ff71bdfdb6b56e57cab4e6aaa988d694dd141439681cafa1a13bd545eceda8ff1014e073d786946d36272e78b1d74b21bba382c7e44a39c218659eea76b46822a0eb6544020e24a1927ca63a26b6fee0d5a6d2976654ceb58f5b77378e4cfec67898bd7655b78a22ec27c5e44dc8216d4d0261bde270be3b724f08c82943508417e378712747315f2e38e1e7ab7d6053273080690dadbe5b552e18ea21fba346a84a4d9210bc98a3438d816e0a689d036bb064bfc1e43637f0f3bdce3b80d4c1576a35e3f0b7382af7ab8ea26b9595029b8a0ebea1d3ee852cde38129e2bd356f6b3e6a0c3181ec579234b23eb5471c5115282d6f9bd677bb8cdb645bf1d8b4c11880b8aaf511a7422bc97806e056eb9f85c816acae2b126674215150c95ae453daaca962e57327f7e3c2e21975bf72b7f11d8eb8e028190d00e83d2bafd312ce5b6546ba8efd0e8d5cd83ddf2cc167f7aa5cad0980cb6f102e4d352ce260767215d85955d02c0fac4bd07238e1b24f83d306a207128b20d0206d79fee76c3e7241fd117ffb289cc9056e618191c686a0a23a12312e8f714def61d8ad4a98c65f15613029d5af271d61a426785f8a67d99adfcd23e34f2f56fe616c887d63c022ee5f473edd09ba736d996db577c891e8fb9705ce9e8b33b6dfe79669458092fc78a306628f88e71a1b1ba7177e7f7463c5e7cec9926b1aedc4534fb69db748006de0f1a88c3f8c4be5d4425e039131c3f9f3681bc95b57d467bccde87808919f3c2c33db5257902b32a281304970109965d9cdedf904662bb896ff4b9b736a7d8cdee5396dea9fa43436535f980b405aedf60dbc6404865151ec213caab083358ea87bf2539e031565861d4c2704c830f962998fc6347641d2f25693b5e78688dc6bf122e09a49fbdf24d3ecbf28016c7e651a94904919ac88d2e44cf4d5d92def34e10e00956563c8538042bb4a40a5a7534a69962c2555f88d25fb1b46d5a0ccf5d8f147dbaf9ae5533cf6e6f45f50fb7daf4c06197ded83849c09d0a0ff1e3a50c2fa81752b340da5398cd684c8da13322644fa4bfead4846b84e921c359449e702c2d0561c80236f4e7bf9783f18a26abd7d71c5caf4b24116a7297209d0d868ebd89094de4737131bbd3318014a713ead29ed7e6eb9fabb6eef15e05c12707d36f71d6cebe8fa775c38037f5844c3247f9472ad4d90b7d178e3f8fbd698f94aa9e9bf103ef201b6434800aa5029f46f46529d91d4cfba4cde772095989ffac458663dd50ad8061b7cbef6f66d503a24c0611369cc215340eeb22d77f7927d402aca54e4d490e88a3515845e7b9259cd3f084ee7ec9f61417429324ffa59fa4cfc7cd9e77c623018df061f9e49555462467e0ac4bc1ac76c1acb7929d52fcec653fcb3fd87f8b4f67d0de3941a778bdb275e4b1d857359d5b2f34b3ffaf79c2c0cf96eec33df0807fc720a109db0defda5b449664cd196552ab4b4518412838e01e51c6d08dfcf602b94d89d3390855303f9057f4559d4b99e59b34b29ceb6dea1d97ef1608b46aa8f39f95ddea5e1ba6559f3a164b265193a44d36e5b7901847f88405f67bef5e5fa816c90a3de07904a35b9faa35f2ac1c2bca69b494986cbbec36bb4560a376b42263967c3277ab177e7faccb72d74be459d50cc4c98d4864fc9e53c6e8e4c1105050a03469c6e49d420637ae0a68aab323e461ea320ea016c2743ffb599ba96cb5aeb1bced2ce997f1f0abf7fde7642eedd4b6481641c0add853771e588fafba57d5e7b4f056d8be1f77c61acc35ad9d820909258f7ceefd09643aa0c41daec70b0ee23b966cae79ffc25c6ac9ef31e5f67786e13c0e9cdec3a5e995c9847563ad430da7fb91e71d952b49d4df65179363d2a9289d5a027c8c021b6aaea36e205b11a95a2ed3432b3034b121374fc4cd8838edcd181f573b6d6884e7a520361df5255111c551fef9d5c7e4d72fc5ab23e4d9b1b4a894a84233d1b0f37c2ebae9eadab026eba44808f7c3fcd5a991710d22d1a81929ed8a7f5b36e96ae6a4cde9189facaa23b069479cdb86f58a3311d025070d614ae803eb94387db244b1c55f45276d179e81e29a5649c6ca94c2893c449e2bf60b786a76bb14afc1178855010a1a343ad70f7a44730882717f390b669f798d45dbac7ce2ebf0748dc224c0cb01a4fbe9d88c40a638212069cd563d030899575bec6acdcc7970a9e81ec9f19f6b1caafe8b7d8002c13525f63bc8f9ec2ddffb597b9884a9dddbc87b14a665b144613d1b335d245daf22c664632b56f33934aa26db65258125b091eee92cef4fba41159f0e6cc050b6306f76a41245f40e4ba236a206bf7796896ab74b406e23dc7d07a8ae154acbcc33b60c97a84215a6ce74a679f4d0dfebf67a9d222f31ca54c66ffc5a02a4cb392372c2328889c208aa6599af6e618beb3b53f9aa90ce8e26f61580208f277acf7d4f07ed63c1cea98022150418aca50185d60401eac898165cda174f6a547f22763eddc122ceaf8d1d0f5e12900f2bde95a32a41bb325bfadaa6d0ab27ceeb5550ea8a29530a34bccf0fafddb5c5bcf36482a08d713945afe8337181161a394e911db29d864d914de7f2cc71af09ee6d29a49afd42a44d63bfe1fb6e5c10f2ef8e82c2866ead1defa1b1606d059630ac6c88f14433716a5c193faca06a834c01212b0addbf56f262f9f57d0ff22fcfedbfa727767be81c39dd5fc4c86a921e1282a32b4a6372a72947c83e8c42fd0335b28634e96a19465e01dffe428a191b68760ab908660ffa41a951dfc48ba9b44d34d25f5c818d81d3377fa8baf6e03130377643b630fd5f3c4479cee84b563e76333ebe6ee4a4dcd010b9a79b24f41c654611c01dbb1d82069201c0cba716405258dfb0ef0080da95365bc987dd32216402385e000af2dc712711ef886a5857ac3c2147144a2e89498b74d0a9003962f551105169d9f893290e1ee018b8307dc3adc77ff11e7814cda32ba89ad7aa9cc4f1dfdb2a4f259af9826e90b00909a4d40da982718ecc1c21721c88965fc35eff9cd4eba86b6b2f992a145875841b2204a8ce4feaef751ca455e038a52a4374360e9ecadce8e4784ed606eb03fa84e6d2f6193f0bef116085700cd5a5d6a5422b65f1d84a43ec1f997f11c276e8271c09f0eaca1fbf1b913ae7aa1f3ad60e84840f13c9865c1bbda82a77c8c25e75f73509bbaf9d9e249d8f341506421d1dde064f0c561679f7191e00a52f3458e3c04b1cd6c4e5a1814b87de611fbcf20f0fa2a113298fb1fce366afd1f5feb9812d80c690f284b3d9ee864c6bf2afd59800c7ce0d0a0c50a327f61d9fc725e3e3fb349c5e46c65bba537bbd5c27c7461a9d9633b0aa210453c3f0de9af4281d0c3eb7528ac3023e1c89e7430f53ea3adb2e89bf89d1e0d4ed0561c7d03e26e7926149adf467935addb657d2b0d4e4331419723bbbf0a3ac22a467c1668ed1a41f22684e4986426af481d7f897981215b788376c5e38de592008d6aec75fd4921bec356909a4e4a87b13698802c1141024968c663fab070d37e862010d0c6a29eefbd2881b86f2171b06c422678603853c7501afcd60d41ba2b170d093eb904cc8b9a4304dddfe094431e57325b4c5865bad2f274a825bce7e79ae0bd3594c3e9fcafaeaf1cf0c44727824b8269e5c0554ae7b5930f9c945a7aafd202fedfe54e31900256b8c994097a1f5030899229d9604741fa4cd982a65b4233a099d3a15eb80e0e0f40acca078aa2890dab68ed5eb8a7f30796e8167b0017f2dc58eeafde95aa2b94466b306470bd355e238a35ee9dee3d853cf2f85aef109e469cc7f2080ed22f9b2f3eb4a3905ebf5a97eb1ed98fe1896b1e6a7424267e8eb1f3e542cf19cf246fdb0cddf756cab8887b1229c972e67b86c1a89fb5ed02ffe4a9430b3f706b49b41ff85590286b6c14760a9d7aeb495aa0f458fbf31d24ecd736014a6c69a747cbb5c875f31d04ce6e9c938df02fbfb99c9119d6a91810d21f76034f66afb4edc4ab363411594fe58892ac56ec257304370cc3cc7ac4f67d2c434d29fbd60d8daddd1a9710a0ad0a70f4210e8b5d1582bc06fbe1c1a3e4d92abe8acbe65da1a90749c91e92de70e6d02dddf039a176c25455a2ef1f2e5d0bbaf21c5caeb113d9c63869ee912326360c115594826812d9da0b66fbf3558cf6b38846faa20115dd83f220c885c90444a6ce9c63f8365fa27ad48eb3e2c9ee722ac8ec1cb47ca6c13b7123471f799d4beff955e5f16dbef9eb717a1b83a71ebdd1ea562b48a7a197b16b14ca2f8cd01cdf66a2aea9ef483b24c6c953f5a7b9eacc70f844d5640e9cdea2263b26718bd7b2c8449bad793d0a976a7511a90e60686eb925a669335dd1e253b4058c8ee7c2cf7c7530c745319e75a9770148cd67e0545275c4854e13e25a7865667e827b698d447678ef750e2d62608d145b9318b44ca0a733a1c95545c9f622c33b015ce4003c85fbf2c65e2efe9f0ddb6712009ae658e1c51c7546bdd3ccac43cacbe617e6c21717c2cb1fa0607e97aedef3ff3bee6bd1445e1e3e9355c2109142494b153e8f8c27ba711a2f2b65439a6e0e28706e85393a48baee59b04629daf9ef11ea0abfb1f033cd4751f46cfd95fbc5deb41c3ce61c22a55cce2c9dbe8beb437c543d0000e7a49eb924f5d7af088a171e05fe16e280e38cd8d5de63aa1efde515fc96ab6d4125475dda204a782aff06fa497a580481f419fed179344d3c2d3b66f1dcfd1a06ee6ea16b4aaefe0940a613bb1fbcad5fbe7bd6a5b6a803ee7f140a2463503d9eb38ec3e1e642a82ba497bcea4a51811fb7479992f6ab8bf805b3ceb8cff0bd47a9d3c376111ecabaec0d44505c090b107930e96286bba8ce0b2ae7859e6229289e714822646884e155a53120a08bf5ffe0173a71499e7a8e4677ebf21c4fc8885e00bc243121e72656cb65da8d1f64836936e43386eb0423c37f1671ee413f9acda7d1aae1a1791ff8fd6e50964d20dab8d9919bea6a1383d09bc69a524469356a6c7d393b2491e90bc47ad51a0ace19965e782e530057376da897c8e36bbcffb664389ce01250281eca28a2bb7d01f3e4fe76299d19ac12903bde89ab90e380f06ec1ca7ca50ca83762c839b8a7a324f3039c7ccf54717c21744f9bc8ebba83319ef0719a47b166788e87e8659d82aa1715984f0529c38cc10f4537aa38dbe333cb2d6b29dc58aa51d56b08b6a842745f4229a2ed736f5a1b1e2133baa5afadd130ade4abd206fbc26896e430e32765e13c0dd067d371a1a88a2756a0bb0cc8f58c82dbd4c04db03513da2967e44976488d635c8933b681f7d3542a72543636e960d09303a8c6c585ddf5bc27340fd823ca155f1b65a427249544c29474c53e63b5d9a0a8a269f47c8c619ab43e831ffdf6ccb1ee7cb825901e597caf791827c4356fcaca7657255a4d0abd4d77492512c4be25f470a3fd05474187ee172ed353f2703931edc0f2f154b4778322726a6f3e0469656329a7399211f1cbd3d19645a6d328c9dee06cd688f9c2679a206eafe597edcc986397cca520cea0c708ba690d00a22d32591b616c27eee82a06f593d43c8c4dd225a3e4decb7bc722e554e51da54a9933722e327e5e51a49b36c4d459dee6918c07f23864ceb4e7e35941a7ae49589a99e4c1e6523d7e6f9aa07fb8641f53c9b1d5c69eef24d8e8a844cc65e0d50283ea3522600eda97cfeec47f767fc99cb55f97fc563eaeedda16d31164455de5b3482e6df8b8a3ef146ba257d7f9e77af371f2546ec58b19e1a4d32656965cb7700100d8846c35543096c5b30082d7617c999d24edf6781d78f5beeff8cb9287037c2886592541e66c9b9cf80065c3bdd093e6ff02cd802164ecf521d0bf0bb865686adbef18909baf4db2b4e4b485663289b66f6fde681ba35f43cf6d8328232d4c39850e74bc3b059f59746da0a7660a76df026f558cfea38793015ed1cb21c56a0d86380305890d3397798e99fe4770fb572218633f2e24c571abfec3235b0f28ff15bf2afb24ed0de04b53145966780a118e2143b21885d2eef44d296ed8563b52f576b9d06ad3b6dde5271407013b8220ac73fa2698341f93f985f8e6ae9d851a09db244a4d532e4b0cec5b75a194e1adf0afa7a62f2b965c241afb9f29f13129df1e508e5d9125af0a7772c243d8a4cb72ccb9e04b848e9f7987ea3aab62e68583c718201da76cc3b96a6e3808fe4ff4c313cc608d33320f9a458e3125243b290680ce728e977b5145865b2935307fc6f9b2306b66ddff7553135a26a0d1e8372b4ad81a2b49344f561fa1819591f6c8ba3e81b067f6e2b6a317596f230e0bd65aefe3ddeceb86e43666ca6cbc9fb0d58c4375aedad6e4d6d4ecdc98bbe6304c23c2aa7d491f1d8f934a4dd15c946ceaff09c72bf9ad83300d001bcc652cc607f2d3e01c46ff0792b666d632125a2dca56f191630e9bb5f190d54a21a83132acd0d60e26a9493597b7226183c05fef863c52609d6b27b6b3acab2d86857cfd1327c4b29ea3783d1866342540c5db9b592233bad2c8b82c2c08613f296f5ce4fa522596cfda28af6daf1c2c992f39a13432a1088e73399b6d36d9278125db4ce3a30bf89e176622f84b59694f026660a5d089d0ea8ab09c15e0f60b72a4dff4700e6968d7a18c5433c6ca4b648ed5a2153222729075c9b9a4c425591425273dda6aeba6e76831bdabcbf860c6000a5db0eb7213e84ab16ec8bd576352f4e13cd50b8f9ef334ad1fc31f0bb95b44fdaf83a7fa64a54337b3b036a338e53966f8725597c95a95300b0971065db81b26ce5ac5b67c2eb26b97f193b51d15f31aa3ffa2366b9f96bc5a4546993a700972642c06cdebbefe950032e98caaf9dfa27d7388c55e8c6a42d0dd907636cef304403920a4fd32cf42c49b9b875c587045b4c8fab7d14ad4e15a0035de3606344f96ad9c0f59f83ce2a36efc98b047dc2bd598c84066fa7c60879fa12cd832e1a1a60ce01b91afc0800683ea0e66231b9813dbbef272982afd456921a9454b9791761b03b3290ee77afd1cdd1d04650ff3a6d5441f727f30ccff7c5d177f5f2455c82c26ae0b4329b33a68f1616453475f5c397d99821839e4b345e37f8cfc0531e15845b3f35d1179849dcedf701d08c5872774cac98f8d952e932c4c4f0bf0028b09aca08ff9f11cbf2b1057ac0194a5e2ea8504ec4c366e25650f6b36f0d7552f68c247d84169f0f8d618a50fd820758b4df8a4f8195edb2b35268952cd26466eb17353738fdec475d2dbac6c78d4c7716bcea2c1a7aa8f322476189743187efb985ccef3128e438d6a06c4c5d11e166b6d13da3c03b985f4f478278a7e4fb6f72768a9ab7ada7e80849b69bd276ddf7a765b09ab2f19f06441259e181a79061c767a79c7eed52ba16af6d4ef6167f045afb0b589c56f645b2b1546404b598425387f5fb5f06c8ab519300496716da4dbf8578b5f5c540c6678dab8c31911d3f38d2bf820665c8a12d2fa1aba50839c3298a6279310521217b5859c79c96bedcb1ff2d61386ffca3280637dc4035d23d52ea7be29682d4d22e23d03acb36b144595a712be6a1872b1f56e23964c47d349f9782a32c3ea7a6d07458d6860d1e6fde358ced106330a801cda124a5fa3d55e0a451d939038054544d7907d67073e1fe368d1917d90b11d513be94784904d1a163fbb94f86891ea3d4a593365bdca0c794912571f6232ac2019bd7d96ba0e98fbac143c7ee2a5afff75daf57e2671fd8ebbbe0724e67cb630cd495abed21bc9b67eff97445f1a7146f08fd0212592cfd849c621c990b78c0126c86a6c74dac7093097ae1c8c481832e5ca14a8b6363c8f882ceb412212f01d02a022f16dca95eca298d4e6e0e4dcda640ed5b7f88f44bd3d4ece768fe3f8db2f9a956ecbfe14f6052f30075134c5a5336a74ea35fc68c95c4f32b78ac915cbddb35e0ff143752a553f8329fdb163d20414967ada404d9668614ce9f7a239f6c1c969e179349dae0891a8df9172863e2d4ffbbbe53ab766e5cddde44ea74ec7a0ef47554df872a0dc5a5fc80fbc11946d094083f247e5d0ef1a39f1a05c7183761640544defe093ceff6b66cfcf32db3c77f54af97912ef52cae0c90cf410b9d50a69837329eecef1192b0f5b693e8cc593b819888cc6802037ecd7a173ba5ddd4e50a3a43aea886d807b0364aca88492dfb60b9a3ba9af122ef84a1dffafb25654a43981267aefdd64140ee9fa788c975bde9e513063c5772baa43b18b2236e99ae60fdbe1810434bd3ff490c24d29ff0417e6bc008c0d30b3b6867fff10d3f2f344097a2cf6790b5c82db1f4b4bc5cebf9723e798c6264319b56562ecd6e21640fdb821698712ebe2dadd1da0686ed7dd7936e4aa6573bc801cb2071bdd98bf734a59f3fdb0a175ba48fc1d2c9cd0371546f6bf65f51d8d1c8ddc9cb75cb46f0e990670b65767734159dc7f55bc76fdf8c584dce141da3b4445613db25df381bf91781a5b34baeb41fb2b3c761c05de2adf5bbf063449b5c7824dff2c10cda46834dc9e9e0c790d17e95956b4cd131e5ca999180cf6a3a7cb8b15da23e9131b32fb4745e3f9f4584423d610810d123c6162a6561fb201257805a151b49290192309f9d26aa960955160dc0b9ec41ae6318d0f368a08e56385875abef8528fd5714ad69e2abb0a8ab18410b21b00048be530ab6dfe947c75aac6454a1e2b27a7abf5b6eb6510c8e93e68669ef50792c490fe57a9ec223a41fb7590d4efdac4614980150f06c6753e3af68f4710252c43c371c4ccfc80cd17663483fd1406514f32ce781bf47f1e3f0ee5bf415950b729295aa07c35fba37d0a04808f04979fea8d63e3d521d6ba005b30e35285d1c80a087f9d5d542aa49ad01e1bd2686afdffc18e00d46d5f8d89fef8017bba7797be3a2ca630998720961000e30e077556a4e754653558379c49b4ca5b2524540ddc08b91c0fecfbafd2a35ab38207d9fde5e48163ab5c581ec33ca97cb5ed506671c1cc8f7baa71473f2b31fde3dd9df732c924c0c05667e0cf7b952b15db8b7b10d1779ed569be995816992ec6dccaa41697d09e8b9d80ff9c4b2d9450da560d56c7280ee294044cfccb753b3d0b73d9be8b03e08306cd9c42fddc3015616e03ead306e9a15fc3240efc25b931384eb3891aa95db830744e02292de91696f4870dc1de068246e31529ace0747ae04dfcafc62d1cf10e3210a9b4f326e9e8d9cda40b55db99250b1db34053fa2802d882cc9c6da9b3d6b0244206f09961b4e196a10f2f57611be69ac170702e64fda4eaa3c10885612eac1e10358b7992ed8f62555dc92efef0a79c074bbd318803da940577290567d2967d07853133ab834ba6477e980800fec4314a94a8ef3b83177969ccd402b85181248820e51199ef9b48e0842dc64849bd38055c8ef43645da9cb6fbce4bbb5a28884434306d4758b728b177594b956f1c41ef1197e51c48b6a5069cd3cb9be9b0f6cb513f9bf1652fad2cba358195c6112628418c80fb81abe1bcf745fd44e2925f5b52c6c3b8da56d5a07234bbc6584e4f10e49cf80d4a789f3a9f897fe07e16213940b7317eb18880c6c517c9ebf5bfde7ccf6486214fa12987894cff7a3fb9fa3ced06db3292f4c8ebcc032f807c5d7776b6e30bf737c67bba499ee1f22d1abaa47a7876072fb4059f0e002e256609e983c60c2c5254c5447af51614f2a3e6e3d2c6967aea61a9858e2d3283b4fe7811f61205f84b4233c30121aa415d9d47cc6ebc5e11c6208a67e933b7b2485390136f017fde8f14dbb9bb02bd6193f276b2e317b6abc08e8d486ab909f869364f0ba6aeae0859ed95fd9a64b10b93fbc33fe6e7fb64c24a3c056ff2f5b562227444505f806aa413e629553521df046450b5bd84ed7b44be7e16a68c4df610bd766c822dfc23c1802df7be7b31cd9f4f802108aeab5f0edcf90cd78c69762310ab01057f04485e4b12aa85566a512488a3fef83f389a26b2c8474e72dfe033d5a0031b371118136e3beda99ddcb270f29d14b18d9abd6559769cdb957e2c1670743d42fa6af182219bd483493e67347b9ac35b37c592678b5120d438ff32623091da94a4cb752b7aebe0882a9c43800faf5095b252f952fefab3f1e7e5b088622c9d2c1f40a6b1f6b54aa304278eb05625d37d9649ef794fa11d99692f1075bcf502cc058a527218983db4984dfcdb7673292a72be2e30bb060e427d89defb5448be42f83663a9eb8fb66246a7a427a1f3c7d17eb3cf4afd746a44f310192b21a524368e55234b24d74024df8663817c1924233a495a7bef55d8025d4cfcc056dd572dc47675c2867a81eb30fd79d92c4b95fca348738f713c58917258e5a880d6f312efa25c1a2b345cc3d2e04e0f9036c26d56b1829842404f591b58453f7b25b69b11ef89f768f93d59541cc9e6e283deca23bc8878e6a60139af0398254fe2aaac6fb8583389725d20a1b05165992351323c71e542f3f1c57833e6619aef463cd1f77674713a5eb0dfbdb9cc7b472b8464f0337662c20478c6ad2123f49e2116da4ff94df22bd709127def4912e6e801f64e24be66318a2b251e3b4080e4dfbb101cdc757edceaef8ebd50ea65d96e8f02d8e31e5004e6e725d7334d2827e5a00fc0774d2f4458ceabd6985a598b61d1553c0ee1aa85ab74b4a3d3b9db6a59dd1c09c14f73644b65c83ca9abc8cb989a3394455b34769b2ef3c881100803633ada8419608f32b3a9398b93fafaf8fcf9c4af0b4ba64f648d5315a2b0411162aa7e43c70af56e1d3acf7854ee759ea464fa54f71aa498b4ae7fd2329e4554078c729af8ee4e1f2b6c4e79b06232a30ad6f0aef69dd25841a1d11a35a0868e3b1080128898b906f2ffc08f36904a901a90684616931a898a3cadf3b31aaa3cc12426cc44e3c930b44a9a3399ab8295e6a120ee730364497faabf96508624be643c897d68bca1b671a9a6f2e4e5692300679d00468a9dee353d2494273e91a6ad64c9abaae6f7ffa562e4d595b738c9d7570d8f0349eabac234510ecfb2b19fca9d0a5bffd40b18dc59d603bbcdba5193bdc0760d7a3c17bb907a27d67b6a29ac06b633ac00cd7d30bda5e608ed1a196a1513d36c0dac6d033b253bfc6d572770e9a042d3c7600a1b7c561d5b5a125b65b44755f071ec15dc4b23bd85b09d64373d59faf8346a6204026a00ce50c1a0e11e8eab91708adccf4520e5081d7c3470f1f18551102b1cdbb6e88b13f92a26ebfa2dcb94f96a61cbf2b58a14b48bfde770641e23d7b4c920c0e735e7655774562870680d78258326204e1dee6c22c336f9b8d5ac65ad50b804903abd341894091cde57fc52e7b8ec59e3334bf3caf2c63829983a19cf7f9463d7973cea3effaba34b00f48487f1bafa2788782a0d881117f768360b085c7f21f0e3f4a96b212ca92f5cb69e801c72b83b39e38f40769177c74c78f0b2cfcb4712061d4ddba9056ad52be62689bba51d4ee7c6c40463a56119b123dfc0cbc686e8be076e5ce3594e33c84d07ea233a653853e584da532b18529a81742deda7365245b4bdb71fe835b57d5bee00e52be25decff25012edca65c672edec7eb2752d423cc7e54b69c37760529f61fb65253da6d938788a28693f003c8e4fe2f0e5c7b853ae5ab3545e78ff7fc868fa1897c3975bccfe20fcd87dc15d6a7260658f3974d51f78f9adb2252a359138c6e884f7ed28b85e20ad1aee8ace564fbce1aed0d218cb21acd60c10d139e29ab196d86770574ac37f8ba4f6f25ac7d4be597eb5face91092d4f34f440d041c3ffa36e2e23e2e9b9f91eef1ed572c03c8068ddeca2d3b0817433cd13346eca4bb93c250d4a7473bda1b351e1d9d7ba4fa7b95a51fb596ddb8b08b2bd039328f944cee2e972b174f9d4ed5d56b8ad6874add3de95c43b2b7e2db419fbc2454d4b6ac461429e748b74bb8a35053d71d21f10ae8f15aa8bd9b7b22113ef239b6da031cf54986813bc9b2530b61df53ef74a98332d494c9e34f3e3e886cf298b4d263ef2d90a2433f8d23c57c20ea2dc8bc33e831f0282f47fb69b9185be9afb1066680983106f15c3285dc70d80a78499d974ca6e35afd6442cfeff434a74f079ac1e6685adab0c4dd9c01093bfd2f19b2333c12bf6fccee9aa4f5ed7f541913483b7f82264c72f8f563739b57bfc0c42f0d53dedebcebec45fdb6b66b1afec6d719eac3312aaa52e7c9227214e5c8f7f9512888d9a6a3defcefe8a89d50f65fd7bd93f852e8319a6d62978640695e571ad442f00edaa8a09d369b800ea93e4a3842a0d62629aa0ab71f91b0b95274e926cfd495a5291875d440a7dfed4ae853834a1633a3c49c8f3e669ff2b4cf15ef8b3a9cbff8ed11f98089ceadf68867f68551d1c130bb550a4908cd5c356a7ccd446fa23b1c6e8712b96bb10ce40f4aeb5ec47078d2a2e77835d215fd3ebc2d49078c20dc7098ede7d0b18a6e2bd2a85a89be2c959f3df93e4e18d40d68b4f20a3ccf3be33251c66cde6b5a4ef74e4b677b110b8999bfcf9e9f598abc856a364eee0d2c9487f65f5d9be5fa6cf528f6d1e8c1c067929902b2ab961ecc106de1cdbb364b2fce1074427037234e2cadda8be7b080d8b2e23d3bbae1e491349deb14bed987a7ad1a55c23958d2c9ac78d38e9550c95a9cf22f2369f829a5f0e93ce054ffcf841f7c3710765deb911bdffe007b9e52cdc6f164ec0108310b056e0191fe251ae313289ef8f7fe8d57ee2c6432e3e50aa96275c2a5fb316adf47019ae8bcda6fb30d851bbdbf3eb31255928c5caddca182391918f30b0b6989ae45a38e0865eadd5870fad8185bfd01e311852a9971833e3d312769de112800b38e47fc511f25d2f69b93bdb466f3a08da0f7bfd4ba150e67d2d0f73b8145274a6e23fe18723daf17ceb4abd1ffe32fb8cef452a4553320afa78d8f2ab749b838f9babb9f7a0cb75eaf6d27f963759ba4bdb84c169106f3df8eb612f8b06b8b1f7d32a0a0461f195bdcb106ff485486ee6672f0f9b438ac9a2618483012028f04ee786d60c7f7bbcf1523a086c0ebcf009ee8ef481771fd06e161b87418431ff6aea933bdfabee46ec2b01316e0f8909fddb92a14307b8a5eb2f869866395510504ca5378192c6676be828340d9461e79fbd99695c5f01ce01d5f4cd294642e764898db38fd07ed67ff6c44c825155a984cfd2ad8cddbf54cd008622be3b606242eb5b44bdf41ab1fddf302e47ee9eca0f087299151f8df8d0346284e6f15ea489b4d169615e1cb73384e066c731338aee7e3b1191b792e224eb30eff6ee4feb294e20b60ff053bdb9fbf78ef1aeb54637adbb95faa49fd95de8ceec93c47fb496568981f72e0e4d90e2684296718d4dd6fef08dc42e8fa09f2618f8b09fecd69ece53f8ff7ece6dc4aad078dda86bdf68e6beb1d008a458aa89bc5a279a34746c6cf625a7b15665c9dd6a9f66712743c697f071e236700306b1a88d5eb324b691b70745cf831f755754429700453266e8e00d6c9e1f74d6f16683407ca4e4fc8a2dbabe378ccefb85ac6b602c3ba62084e9ddf13cbc2d61180ca687b2391366204eeae24334d6e5af6689d4b30c61a643a992b6d119594099ba5bdb2c2851bdc946c981ddf75b58c3b3d5b071e7dbd7441597b0b04893850e8e577b210545120b4f07b926e987d931359b7d45975b6f62d4e45f0880e044919925393a38540f8cc2e1e8ad9a5446f95cd41ee7a5c4d4d5cb3f667255be86a86f52bb815842303927ccf37abadecaaef24783d1fb09289682140dbf5ce763763d4b0444eaa3efa8652a41a6eda082181028a18915b89422467453f7b15c6b210c09c4f563a6812f868c037b897d5dca74df84f87add538874718a175f1e1c61ccfc0781376f77645fe7a96d3cc70eea596be9a6874b22b559d1ce3a872c8df57531c1e9c9e041ffdea21bafc7bcc36124bbb94d94a7dcbdaa9af143fa824813f152843ee2cf4fa5a0166c4674db612bf28a8f0a04e7d59947ea9d576eb4fd74c37a9c3418f18399f6cc9ac6c9fbd201c3ca9e016d93fd6c58ae7c8ce9df670383e2d54cd1cd79dd4bf07b6db7f89dafe37d14607a6ea612265e1d7a96b068098c979f7cf03c74b1be887cfd6566221a00bdf060b53ea87f98cee372ffce899c7f6e6dda573190117aea575c66296bb4c3e84c622f5d8bbf31264f3940384bf85b23da32df6ddca2372afc1a623dd0342488dfce9b0dc58c38a4e0710d03a82cc5ef6342d659a03e333cb7f62074ecf70a8be7ac40c6226305bca6624db0d44007b498ff1a1e30508fd5a9f35baa48762758e5d149e5493996a195b08230ddc8751f7d5b6c0d02c394b1180aa11729d2878c829bb98b2b796800f958b6f3a498d9160bb6bb17e4b19d9fce82579b8b56283567f1c5c82696ea94a23bf267156586172fedd736f92fcbed49b9297a4d768ec9f5b17c8be52293a5929149c00e64ae8d3526e4c74e61e5a316c790d27507323203dd255fca841d603ca340b0f05f067ed1ae94caf4c206eacd093ef8beb322170780d940efa04d683fda28ef3ad96b8f838c76b98b0ae5de02167b1b3fb3083352c7fd282c25827cde74167b5c80896e69792b843492b1f056c179746e6eb9ab99a3e2a2c26710240520d6b8f978f94e85636053807da100b3d5b053edef01a79b15dd5594e37bc1a7d36f9e55d8ed8caf431c879bed286faef280b2cb7b92875fc20558cb3efee92b891e6b15b8cbc4693a3bc10a5241e078de1a12864baad3b01869beeb611c13851566727145ef13a33f92ef9cfef46838eee19b8e8362407c816cc284d28c22bf133cc90d524293a7dd0f52c1603757d0fefeaf66eabe495a90c5aa3550a6b00ebcf95f8a557bb2bf97f2361cd4a6b16eee58c9e0d5ba787414e206fd4d36194a03303e32debc41571b131cd2df8edca8925238fe3378402417da540a446c76107eeb1a9595853059301c333a582b39712a47143b8f70c0ae9b4bb9ba5f84e1f010aa7c0a3d8daef8fc98022aa14f87295108af535d9a5846d4d4af989d712d5c43beecc3790fd0b62c35ee1b374014ae989741bbebb30469558ea1ea85812c9eb2e13ce19b73740d9e8c8f34549ba9372ad4f0c113d8b36a024b6e713752a6ac97b9656b331b89d12b13f4355e5d0f221eacf36ef7e6a13355c6dacba7b842bc6fcdbba049447769153b729f08ff48533b430847ef4c08798d43e7be7fcb638a3c3f6a88a1df1fbabf53b2de9dafb859d38effc9fc0a0aef0fce42117845641122db17f50362a645917bbc57eb58768e64071137d8674b10cdee28722ddd19f74c247c6e5b14d15a3f49f5f0f768b5407ec3e4575ac7cae171b535730e9b31c3f2a6f04951eb2f0cb9332620f9541f7ef7c9f71713d91e1e4bde5bebf30af13b4027762470eda5cdd82e710a90e7645ed106f4f91844e0c2a8fbda94cfbc7bd3cb4e12b0871862250ae9eb88eb2e4c0746e455de5a37e02b62e18cd69546a84b46d10a216e68df61f86756e60a3f0a3894ac2d04e198fb070bcaa7b22efef6543170d596cfff30c0af345d57e31312c4955d78e7344985dc2850ddc9c8bb48c60b398bb71cfd61f2a529ab1fcfdf991625ed177b9507cf80c78b53edb9345ad29b0d93b406b553c9278ae86422b838bd63f3f3713764800fe7102b5b7cf69e47627d73543a57dd50b9f2684d7bd1bc3d829811a9979bec999e05cd98965d3741c26d5440b21ad0deb1d0cda016ecc99ade8860da1f53d92248a54b578a547749c8564add86e34051ad5ce5c461f8198ed28b66f406afcc0f813bfd27f7e3ee6929593aa205843fe14930b75be7009bb01bde2d25c1eb7000b40d4504b3a4b310f199c08ecfefba5ccb0c9a2dff1cac02c2c55b99e5ccbeb1b45ee43d396df91ce9282f9b4ab16ea772b92640a713312150fe60530cafa5b5bac3bbaf3b91b08218b0bc88100263cdc145e1255fd29b03d572506c6302d479d10a215749170fa058474328baf2e4499d35cae5acfe79c49bd00c2b1c959687a85cc914f3003191a9af06d0bbc1cdb4616d87595c1594bdb6489c2e78875f770666103401f68b0d16a0c4043aca1a560c479777ff16583b1631e5abc5fd84efa66ef256ff54bf6a9b688be639196a52212c8632b0116b5fbf3c6798820a6d7b0d0d1a8bb55cdd03aea9b4d33e308997220ef82d5e9fa30dfa80309698ef1256aec820826985495559fc9eb69c4da37d87dbb14a36bd72076b48cafd4c6a3798958671856491f16501e26e30a60d3ec28da3ed066697ba3252f6f744a478b2a6174f39711b07bd97fdc4457410993a926f7b02c97c01680157911936fc0cb8166b66c19e5601bc370eb36883cff6190055f4570f665db70a5fb16f17874790dc5c381c76140c22f16c0af093c1057de3833d83994b2c5dc3717e83c0bbf496a954923629f43b02c8e90036898684d8fdbb4a30535c05ecbbd9e82fb5dbb0b037a85ae8ab2a177e5227a61537143b127b83d7d61a437f260fd0257b985a131166c6776df695f3007ed69910b5a28643572abc885572f28ce00460fd79f4f68f6fca14552737cd2338a9429d399525d3b7b7341cd5028b0a6e4b2db44d0a6288e9502a529bf4b0d49bc86dbfe2449ae7b3f28dcd7f5723d1f57a2dfbd229d8ee1642d481c1e4544c7fa2b036f55083988ba6ca1818a477917ab8f4b4425c68bdcbe46429df2661260c2368aa7d6a90752e4e6059e3d614f42ff73abf34bf9625f0d836c144e74004533fdd62985f998bccd7c1b9334b10ece9d878d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DCIC2025作品赛游记</title>
      <link href="/2025/05/06/DCIC2025%E4%BD%9C%E5%93%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
      <url>/2025/05/06/DCIC2025%E4%BD%9C%E5%93%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>数字中国2025也算告一段落了</p><p>感谢师兄们的无私帮助和师弟的不懈打杂（bushi），最终获取优胜奖（翻译：参与奖）</p><span id="more"></span><hr><p>比赛最一开始，导师问我要不要打这个比赛，用可修订区块链；我一听，诶又有师兄带飞了？那包要打的哇，然后答应了下来</p><p>后来线下讨论，才发现师兄们太忙了，这个次是我带队（哭哭</p><p>后来意识到，感觉我这队好像是来凑数的~ 毕竟是自己学校承办的比赛，所以参赛人数还是不能少的。不过毕竟是自己导师交给自己的任务，还是得好好干</p><p>好在老师给我找了个大一的学弟，帮我分担了些文档工作——写得还很不错</p><p>不过我头一次做PPT，做的一坨，狠狠改了一个星期，终于有点模样了~</p><p>给老师看了一下，老师没说什么——那就是可以（嘻嘻），提交~</p><p>然后把github仓库改成了只读</p><p>等出成绩那天，莫名其妙入围了。我头顶一个大大的问号~</p><hr><p>把喜报告诉了队友，取消仓库的只读状态，然后继续狂肝吧~</p><p>师兄指导了一下，又改了好久的PPT，然后交给老师，老师还给<a href="https://coperlm.github.io/2025/04/18/%E6%96%87%E4%B9%A6%E5%86%99%E4%BD%9C-PPT%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%B8%88%E7%BB%99%E7%9A%84%E6%8C%87%E5%AF%BC%E5%92%8C%E6%94%B9%E6%AD%A3%E6%B1%87%E6%80%BB/">指导了很多</a>（老师：你是怎么入围的。我：我也不知道哇（哭）），最后尽管差强人意，不过也差不太多了</p><p>最终展示的时候，PPT大致中规中矩的样子，答辩问了一些问题确实难住我了</p><ul><li>基于可修订区块链的网络和传统数据库有什么差异？我当时答的好像是分布式，Web3.0下的，感觉问题不大</li><li>有没有什么专利？我想了半天回答确实没有。后来师兄告诉我那个专家是企业的，论文比专利难，专利是横向，论文是纵向，学到了~</li><li>和传统区块链实现上有什么不同？我还没学区块链网络的体系结构呢~然后回答的是变色龙哈希的构造（嘻嘻那篇论文我还是看过的），这个勉强算是答上来了</li><li>区块链的优势在于不可修改，但是可修订区块链没有这一优势了岂不是。我当时确实没想好怎么回答，然后就和稀泥~说优势在于监管和隐私平衡。当天晚上老师说这个问题可以用19年一篇S&amp;P（基于投票的变色龙哈希）回答，也没有中心机构，我恍然大明白。后续读论文，又遇到了许可链的应用和其他可修订区块链的可行实现优势，感觉那时候确实阅历太狭隘了</li></ul><p>无论如何比赛结束了，还是混到了个奖~</p><p>下次好好多读论文，再也不做PPT了（哭哭），做PPT好累~</p><p>唉唉该做还是要做的，只不过中心放在科研上了该，那两个星期光肝PPT了，别的啥也没做</p><p>还有就是确实收获到很多师兄和老师给的指导，记下来了，以后没准还能用到</p><p>现在这个仓库正式改为已读了</p><p><img src="image-20250506103736212.png" alt></p><p>下次比赛再见~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置一键博客备份并上传</title>
      <link href="/2025/04/26/%E9%85%8D%E7%BD%AE%E4%B8%80%E9%94%AE%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%B9%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2025/04/26/%E9%85%8D%E7%BD%AE%E4%B8%80%E9%94%AE%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E5%B9%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了hexo博客，如何一键备份到仓库并上传</p><span id="more"></span><hr><p>hexo是只把生成好的页面上传，这就导致了不可逆。也就是说原文没有，就恢复不了了，所以配置了一下git保存。这样算下来就一共六条指令了，很费劲，然后写了个一键运行</p><p>原理上挺简单的，不过真正实践起来有些bug，好在最终优雅的实现了</p><p>由于我的博客有些是需要加锁的，所以不能上传到同一博客的不同分支，索性直接创建一个新的私有仓库来保存源文件</p><p>然后把新仓库的git文件，放在原来的博客里</p><p><img src="image-20250426175758939.png" alt></p><p>然后进行测试，发现<code>hexo g</code>出现报错，经查验是因为<code>themes</code>里面也有一个<code>.git</code>文件；这个文件对咱们用途不大（应该说是基本用不到），所以可以直接删掉</p><p>然后测试一下<code>git</code>和<code>hexo</code>，不出意外可以正常运行了</p><p>下面写一个一键运行脚本，拓展名是<code>.sh</code>，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Update blog content&quot;</span><br><span class="line">git push</span><br><span class="line">hexo generate #最后generate可以节约流量</span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">  echo &quot;Blog deployed successfully!&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;Hexo deploy failed!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>每次想生成博客的时候，打开bash然后输入 <code>./文件名.sh</code>就可以一键运行了</p><p>可以起一个可以用Tab键一键补齐的文件名</p><hr><p>嗯？怎么就这么点东西</p><p>我居然改bug改了一个下午（悲</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>katz密码学教材v3阅读笔记</title>
      <link href="/2025/04/24/katz%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%99%E6%9D%90v3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/04/24/katz%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%99%E6%9D%90v3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇笔记用于记录阅读 <a href="https://api.pageplace.de/preview/DT0400.9781351133029_A40791566/preview-9781351133029_A40791566.pdf">introduction to modern cryptography (3rd Edition)</a> 一书的阅读</p><p>重点在于公钥密码部分</p><p>本文尽量通俗讲解，但是不能代替阅读原著</p><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>第一章介绍了一些引入，包括公钥加密，历史和现代密码学设计原则</p><p>第二章介绍了一些完美加密，也算引入部分（还有信息论的香农定理，很前段时间读论文在[OB22]遇到了）</p><p>以上是第一部分，用于引入</p><p>第三章介绍了对称加密，然后我打算跳了~</p><p>第四章讲消息认证码MAC（等我有钱了也要买MAC（不是这个mac））</p><p>第五章讲CCA安全，CCA也就是选择明文攻击</p><p>第六章讲哈希函数，目录看起来是区块链的基础（有默克尔树之类的）</p><p>第七章讲流密码之类的~不懂，后面再看看</p><p>第八章是 好的我不懂，后面看了再来补目录</p><p>以上是第二部分，主要是对称加密</p><p><strong>后面开始是核心内容，我也会从这里开始看</strong></p><p>第九章讲数论和数学困难问题假设之类的，RSA啊什么的是基础，重中之重</p><p>第十章讲基于离散对数的加密，然后我突然想起导师发我了一篇相关论文我好像还没看（光速逃）</p><p>第十一章讲密钥管理分发，就是DH密钥交换那一类</p><p>第十二章开始上正菜了，标题的公钥密码加密，但是实际上里面有很多重要概念</p><p>第十三章讲数字签名，难度下降，但是更偏应用</p><p>第十四章讲后量子，加油加油加加油~</p><p>第十五章也就是最后一张，讲公钥密码的高级操作，嘻嘻后面再细看</p><p>以上是第三部分，是最重要的公钥密码</p><hr><p>好的，开始干活~</p><h2 id="第九章-数论和密码学困难问题"><a href="#第九章-数论和密码学困难问题" class="headerlink" title="第九章 数论和密码学困难问题"></a>第九章 数论和密码学困难问题</h2><p>本章可以学到的东西：密码学基础需要的数论，为后续学习奠定基础</p><h3 id="9-1-前置知识和基础数论"><a href="#9-1-前置知识和基础数论" class="headerlink" title="9.1 前置知识和基础数论"></a>9.1 前置知识和基础数论</h3><h4 id="9-1-1-素数和可除性"><a href="#9-1-1-素数和可除性" class="headerlink" title="9.1.1 素数和可除性"></a>9.1.1 素数和可除性</h4><p>整除：<code>a*c=b</code>，则称<code>a</code>能整除<code>b</code>，写作<code>a|b</code>，否则<code>a∤b</code></p><p>因子：<code>a|b</code>，则<code>a</code>是<code>b</code>的一个因子，若<code>a≠1</code>且<code>a≠b</code>，则<code>a</code>是<code>b</code>的一个非平凡因子</p><p>素数：没有非平凡因子的数（又称质数）</p><p>合数：有非平凡因子的数</p><p><strong>算数基本定理</strong>：任何大于<code>1</code>的整数都可以唯一的表示为质数的乘积 $N=p_1^{e_1}p_2^{e_2}…p_k^{e_k}$</p><p>带余除法：<code>a=bq+r</code>且<code>0≤r&lt;b</code></p><p><code>||N||</code>表示二进制长度，<code>||N||=⌊log N⌋+1</code> （⌊⌋表示向下取整）</p><p><code>gcd(a,b)</code>表示<code>a</code>和<code>b</code>的最大公约数</p><p><strong>欧几里得定理</strong>：存在整数<code>X</code>和<code>Y</code>，满足<code>Xa+Yb=gcd(a,b)</code>（证明在第308页开头，自己去看）</p><p><strong>欧几里得引理</strong>：若<code>c|ab</code>且<code>gcd(a,c)=1</code>，则<code>c|b</code></p><p>进一步的：若<code>p</code>是质数，且<code>p|ab</code>，则<code>p|a</code>或<code>p|b</code></p><h4 id="9-1-2-模运算"><a href="#9-1-2-模运算" class="headerlink" title="9.1.2 模运算"></a>9.1.2 模运算</h4><p>就是取余，自己看书吧（光速逃）</p><p>真正有意思的都在后面呢</p><h4 id="9-1-3-群"><a href="#9-1-3-群" class="headerlink" title="9.1.3 群"></a>9.1.3 群</h4><p>讲的是群运算，很多基础知识</p><p>具体的可以自己看书，我说下我的理解：就是一个自动取模的机器</p><p>举个例子，c语言最大是<code>2147483647</code>，再加一就爆内存了，变成<code>-2147483648</code>了，这就是个群，然后再从<code>-2147483648</code>加加加不断加 加到厌倦，然后再到<code>2147483647</code>，再加，又变回<code>-2147483648</code>了</p><p>群运算，我愿称之为自动取模机~</p><p>当然这只是一种加法群，后面还有乘法群啊啥的，不过本质一样，一样的哈</p><p><strong>阶</strong>：对于群$\mathbb{G}$，群的阶 $m$ 指的是对于任意$g\in\mathbb{G}$，都有 $g^m=1$，记为 $m=|\mathbb{G}|$</p><p>阶可以完成很多很厉害的运算（就行FFT，一种将乘法的时间复杂度从$O(n^2)$降低到$O(n\log n)$的算法，就是基于阶的），更多的应用可以问问AI，提示词：<code>我的研究方向是密码学，刚刚学习了群的阶的相关概念，你能不能为我通俗讲解：阶在密码学中还有什么应用。由于我是初学者，请一定要通俗，最好举例</code></p><p>后面还有一些推论和证明，请自行阅读；如若不懂可以跳过，不影响咱橙味觅马靴糕守~</p><h4 id="9-1-4-群-mathbb-Z-N"><a href="#9-1-4-群-mathbb-Z-N" class="headerlink" title="9.1.4 群 $\mathbb{Z}_N^*$"></a>9.1.4 群 $\mathbb{Z}_N^*$</h4><p>哎呦呦，鸡汤来喽~</p><p>这个群 $\mathbb{Z}_N^*$ 十分滴珍贵，应该让同志们先学</p><p>$N$ 指的是这个群的模数，$*$ 指的是乘法</p><p>也就是这盆鸡汤，是在 ${0,1,…,N-1}$ 中的乘法运算</p><p>但是里面有很多元素没有<strong>乘法逆元</strong>，所以只需要将他们剔除，剩下的就构成了这个乘法群。这个群在后面很常见，尤其是在密码学中种种构造中~</p><p>什么？你问我乘法逆元是什么？别问我，去问<a href="https://chatgpt.com/">AI</a>，它讲的比我讲的好</p><p>什么？你说打不开？那你去问问学长吧（别问为什么不去问学姐，我要想要学姐&gt;.&lt;）</p><hr><p>就是说，$\mathbb{Z}_N^*$ 里面有多少个元素，事实证明，有 $\phi(N)$ 个元素</p><p>\phi 也就是欧拉函数，怎么计算呢？来自己看吧：</p><p><img src="image-20250424194101624.png" alt></p><p>欧拉函数有很多很好玩的特征，就想满足对于任意 $a\in\mathbb{Z}_N^*$，都有 $a^{\phi(N)}\equiv1\mod N$</p><p>（在模运算中，等于号一般写作 $\equiv$，它和普通等于号的效果差不多，你可以给它俩画等号~所以该画哪种等号呢）</p><p>特别的，你看上面的式子，如果 $N$ 是质数，则可以算出来 $\phi(N)=N-1$，就有 $a^{p-1}\equiv1\mod p$</p><p>诶？这不是著名的费马小定理嘛，就这样被咱推出来了（傲娇</p><p>COROLLARY 9.22 是和 后面的RSA有关联的，可以看一下，也可以等后面会遇到的</p><h4 id="9-1-5-同构和中国剩余定理"><a href="#9-1-5-同构和中国剩余定理" class="headerlink" title="9.1.5 同构和中国剩余定理"></a>9.1.5 同构和中国剩余定理</h4><p>啊啊啊这一章不想写了，窝补药学基础数论，算了先跳一下，读者感兴趣可以继续往后读，中国剩余定理RCT就是求一元线性方程组的，没啥东西感觉，不过也挺重要的；感觉后面用到的不多？主要是RSA的共模攻击（来猜猜为什么没人用RSA进行同态加密），还有可能可以构造门限？不懂没用过</p><p>好的直接跳到RSA P322</p><h3 id="9-2-素数-分解-RSA"><a href="#9-2-素数-分解-RSA" class="headerlink" title="9.2 素数 分解 RSA"></a>9.2 素数 分解 RSA</h3><p>好帅的标题~</p><p>就，简单说下吧</p><p><code>p</code>和<code>q</code>都是大质数，然后<code>n=p*q</code>，已知<code>n</code>无法倒推<code>p</code>和<code>q</code></p><p>然后 $\phi(n)=(p-1)(q-1)$，没有<code>p</code>和<code>q</code>，也没法算<code>n</code>的欧拉函数</p><p>欧拉函数可以用来计算逆元，也就是使算法可逆的key</p><p>也就是基于大数分解数学困难问题的加密算法：加密是正向，谁都可以加密；解密是逆向，需要逆元，但是不能分解<code>n</code>就没有逆元，所以解密只能有私钥的人进行</p><p>然后看几个很常见的术语吧：</p><p><img src="image-20250424201545192.png" alt></p><p>按我的理解就是：算法 $\mathcal{A}$ 正确分解 $n$ 的概率，不高于一个可忽略的函数</p><p>$\Pr$表示概率，$\text{w-Factor}$ 指的是分解 $n$ , $1$ 表示成功分解，$\text{negl()}$ 指的是一个随着 $n$ 增大而急速减小的函数</p><h4 id="9-2-1-生成随机素数"><a href="#9-2-1-生成随机素数" class="headerlink" title="9.2.1 生成随机素数"></a>9.2.1 生成随机素数</h4><p>如何生成随机大素数 $p$ ？这一点很关键，如果大素数生成符合一些特定规则，会很容易进行分解（如：维纳攻击等）</p><p><img src="image-20250425085105876.png" alt></p><p>大致过程就是随机生成随机数然后再check</p><p>诶呀呀，我还以为是很优雅的生成方式</p><p>不过有一说一这个确实够用，只不过有点安全隐患罢了（尽管安全隐患很小，基本上是可忽略的）</p><p>下面证明：<strong>随机roll出来的数，很容易roll到素数</strong></p><p>结论 9.32 <code>n</code>位的数中，素数的占比不低于 $\frac{1}{3n}$</p><p>好的，下面我们进行一个很nb的操作，不妨设 $t=3n^2$，那么进行 $t$ 次操作后选不到素数的概率是</p><p><img src="image-20250425090408715.png" alt></p><p>误区：这里的 <code>n</code> 指的是位数，如果遍历（不随机）选择素数的话，时间复杂度是线性的（即$O(n)$），优化一下不会低于 $O(\sqrt{n})$；而使用随机选择，使用的是 $n$ 的二进制下的位数</p><p>即对于1024位的<code>n</code>：如果使用朴素算法（遍历），大概需要计算 $2^{1024}$ 次；而使用随机算法，只需要 $3*1024^2$ 次——完全不是一个量级的</p><p>额外说一点，对于具体实现，使用python，不推荐使用<code>random</code>库——因为它不安全，是可预测的。除非你进行其他额外的操作</p><hr><p>在离散对数中，需要两个素数（取模用的），可以直接 $p=2q+1$，这样生成出来的素数又大又安全（傲娇</p><p>但是在RSA里头，需要roll两个素数的，千万别用！因为：</p><script type="math/tex; mode=display">\left\{\begin{align}&\ n=p\cdot q\\&\ p=2q+1\end{align}\right.</script><p>这玩意不就一下被分解了吗（狂汗</p><hr><p>在知道了随机roll出来可以很快得到素数后，紧接着到来的是质数检测</p><h4 id="9-2-2-素数检测"><a href="#9-2-2-素数检测" class="headerlink" title="9.2.2 素数检测"></a>9.2.2 素数检测</h4><p>这一章讲一个叫做<strong>Miller–Rabin素数检测</strong>的算法，它不能绝对证明一个数是素数，但是可以<strong>极高概率地判断一个数是不是合数</strong>，快得飞起</p><p>传统算法：直接试除法？线性时间复杂度，炸缸了~</p><p>米勒罗宾：也是基于概率的，芜湖起飞</p><p>出发点——费马小定理：如果 $n$ 是素数，且 $a$ 是不整除 $n$ 的整数，则有 $a^{n-1}\equiv1(\mod n)$</p><p>也就是说，可以随机roll这个a，如果很多次都不符合费马小定理，那么就是合数，否则就是素数</p><p>初步算法如下：</p><p><img src="image-20250425093434596.png" alt></p><p>进一步的，我们再把这个算法变厉害变快一点：</p><p><strong>第一步：拆解 $n-1$</strong></p><p>$n-1=2^s\cdot d$</p><p>例如：$n=561$，那么 $n-1=560=2^4\cdot35$，即 $s=4,d=35$</p><p><strong>第二步：随机选择 $a\in[2,n-2]$</strong></p><p>用这个 $a$ 来“试探” $n$ 像不像素数</p><p><strong>第三步：检查条件是否成立</strong></p><p>计算： $x=a^d\mod n$</p><p>如果 $x=±1$，则说明没问题</p><p>否则就开始<strong>连续平方</strong>：把 $x$ 平方再取模（共做 $s-1$ 次），看看这些数里有没有变成 $n-1$ 的（也就是$-1$）</p><p>如果从头到尾都没有出现过 $n-1$ 的话，我们就抓到一个证据：<strong>这个 $n$ 肯定是合数！</strong></p><p>这里的 $a$ 就称之为 $\text{witness}$（见证者）</p><p><img src="image-20250425094826085.png" alt></p><p>通常运行20~40次，误判率即可忽略不计</p><p><img src="image-20250425094739802.png" alt></p><p>从第326页下半部分到第330页上半部分，看起来兜售对算法正确性的证明，这里不再赘述（实际上是我看不懂），感兴趣的读者可以自行阅读（学会后教我（伸手））</p><p>然后最终的米勒罗宾筛法如下（前面已经说过了，这里的是原文的内容）</p><p><img src="image-20250426150801361.png" alt></p><h4 id="9-2-3-分解假设"><a href="#9-2-3-分解假设" class="headerlink" title="9.2.3 分解假设"></a>9.2.3 分解假设</h4><p>引入了一个名叫 GenModulus 的算法，为了说明大数是难分解的（不能在多项式时间复杂度里进行分解）</p><p>感觉这一章没什么好讲的，这里就解释一下多项式时间复杂度是什么意思叭</p><p>就是$O(n^a)$，n是自变量（一般认为是大数的位数），a是常数</p><p>就像直接分解大数，枚举算法时间复杂度大概是 $O(2^\sqrt{n})$，这是指数级的算法，不是多项式时间复杂度</p><p>更广义的，多项式指的是 $f(x)=a_0x^0+a_1x^1+…+a_kx^k$，其中 $k$ 是确定的常数，这里直接取最大值 $O(x^k)$ 就好了（为什么？快去学时间复杂度计算，把主定理学了就好了（学会记得教我））</p><p><strong>值得注意</strong>的是：这里的指数级和多项式级是对于<strong>二进制下位数</strong>进行讨论的，如果是数字本身，需要集体降低一个量级</p><h4 id="9-2-4-RSA假设"><a href="#9-2-4-RSA假设" class="headerlink" title="9.2.4 RSA假设"></a>9.2.4 RSA假设</h4><p>RSA困难假设是基于大数分解数学困难问题的，所以本质和前面是一样的</p><p>这一块块就很偏理论计算了，群啊什么的，你们加油，我开始看下一章了~</p><p>这一章新东西不多，感觉就是把前面的整合起来</p><h3 id="9-3-循环群密码学假设"><a href="#9-3-循环群密码学假设" class="headerlink" title="9.3 循环群密码学假设"></a>9.3 循环群密码学假设</h3><p>这一章强度上来了哈，稍微一不留神就跟不上了哈</p><h4 id="9-3-1-循环群和生成元"><a href="#9-3-1-循环群和生成元" class="headerlink" title="9.3.1 循环群和生成元"></a>9.3.1 循环群和生成元</h4><p>前面已经讲过了生成元，这里正式介绍一下——</p><p>对于群 $\mathbb{G}$，其阶为 $m$，生成元满足阶是最小的群元素满足 $g^m=1$</p><p>这一章是大量的定理和证明练习，不再赘述（我有时间再回来补罢</p><p>（逃~</p><h4 id="9-3-2-离散对数-DH假设"><a href="#9-3-2-离散对数-DH假设" class="headerlink" title="9.3.2 离散对数/DH假设"></a>9.3.2 离散对数/DH假设</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文书写作/PPT制作 导师给的指导和改正汇总</title>
      <link href="/2025/04/18/%E6%96%87%E4%B9%A6%E5%86%99%E4%BD%9C-PPT%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%B8%88%E7%BB%99%E7%9A%84%E6%8C%87%E5%AF%BC%E5%92%8C%E6%94%B9%E6%AD%A3%E6%B1%87%E6%80%BB/"/>
      <url>/2025/04/18/%E6%96%87%E4%B9%A6%E5%86%99%E4%BD%9C-PPT%E5%88%B6%E4%BD%9C-%E5%AF%BC%E5%B8%88%E7%BB%99%E7%9A%84%E6%8C%87%E5%AF%BC%E5%92%8C%E6%94%B9%E6%AD%A3%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8fe822dc3ae0719ec7eac022e6225383cc2b9bfb9cfb3801a5814c98854db8d3">bc04ce3a4ec4a3c032d6e1a3db0cda04ac30e6ef4bc7af54a0ce34499a8a34a9c8f864e25b8edcb98f9b3677b2e687717bbfd2d41ff93773ee649efb77590cab0e0e6939d426ddff079d78ed5d7605452c3bd6c698dd18ef51214a09683a1e396aafbce5e5b27b2d0fb72e64c6255516076caf29e2000d9891b9c73a25261e8f440d30e72972ef679da1bdfbddde53878853b612fec231e0bf4114c303fa8a270e7ef6861ab9452cd159c490569ac63e274ec18dc9f1acf9467c2a4d1f50806507090ec962978ef29b403e9c32b065cd8386d4e11c1468708121d40b2cf7a127042dd4abae7342ee2514f27beedacdc2f3bb5bf86ebcb5c4b8e7cc96430f74fb1d65547371565f4e60b733d5a245b0e0ffad3961e8c820bd0d00ce37830817cb733f041d0db8bf4baebf01a2bb02f0e0bbdd44740cc9fffc70585bc481e37360d2adb8fa61dcca50b8f18fd5f9794d2e55d8bcf4a577bd4f3bf4db6cc22c37cf13496a94d986835944469c8bd8249b8835eed388ed42c3c296d15918933be0ee01de6a24b281f3f10b37be25cec8698afa45e9d994df1d1d3b5b06cc814dd05dd159b5682ab7d27830b591d041c9caebb08d54c1337ac43cae3a0c68d181dce77e7146b67e4555782d2ad6b37869f11392808e6e636e4ca5ef3730785e3ac32ccad76e9dd9bbca07a83007bb10abecdb4861814623d4767eefa305fbba7ea30cc7f984bd0f1ea5d95fcbd14f56d90d55e4b172cddae079e972949c4a953ba149f6553921f309147e11e9ec5d1242055bc7d6e688852a83080eda8b98b08af5826f7545bde8767ccae2106ecd5f4b428fa80fe0ec7f02e45e2311175754b807973bf4ab7f81708ab8caba4db385dff187bdd54c921abd90e33b18aa12a10589eaa3612052b2af300b2e98c86e87f9233637a44a13f9310c3881417f012772b34c38d67e9130c650b20b5863304b9cdfc711c21dea17a2640e64994441940cb2244310a5046f2d746ad13c1e1c107f336e1240f9d9b0cdb8ee14785955ea4af572df427c50e939e9d007a9c43d8ecc4f7a7b1f6053ef63de8adfb4b66e07a145a7d9eeb3f1a2397538e4bebac9946db0e870cd90cf3f72214853213c131b875a7f7bfb9822d3c10a9fd627f8a7a4ea2441f6f12f5d3adb7b2c4d173ec95fac6a3a813b5a99c95e20b993427201ac53279034e8156dbba030d2e25ee6f2d4ce79df7138fb1c1560e829773965ccda773cc90db14cf3a84adc36cbc5392950abadd832bbb670e357e9d1c4d7111c94d21647894f1fa2aac76d4ebfe5e464e873f91e5e6c39104d939909d3c5c8a09671b35cdec86b09d58b2b5eaa6f19a0c17039d7517fff0d4f66186decaa87ca0473a31f3919897568d8abdae3ef838e5ccaec62f3f837f3bd13803bf0094b3da831ef927b7ab6373f6743b63853e661deec2202db9c6b41e209a989c4636c973b59acab7230d86488d24130ee78b9cc64bd356715b82012ec21f4cd1bb88e11828f4b71f9da19c32d92a9c303aa9373218a1692758b0e59a516a5b2ec513e9db920d77a58ff136c1bf580505e99c632b2719a5bb2a3b2a57b08c972a178819aad32f84d6985c7fd10360a0d67264f822fdf485a48c897a4d5681b75446b4fca6a7cf9824a7e801d3ec10fdc16db4721f00df6ced7b359a9e0a82627eb53a3ffbab1f1879492cf60001a093f7c401b8257d2453ce4b2beede84d80b5fff0b2dffc3aa880d7a51414e6737f5f8c723a75bd8bdf96a8ba30634b63be77040c4a014fda05a16c8d977038712de327a8dfb7bb62ae3e0db6d92d1f93716f87369dba21aee2086e666a10e80e8ec94c2e99cc93e9f24e541a94dbebbb42b242779ec613295281ff96f78601c3deaff61f512154ab773233c8297a29bbc3e1f43b6108d04450e0d89949a1b687b09e7152fe623e7a7f3263f355ef851bc8d1310a60b781bec0a6e3ea6953cec1f8d49adfaf4918ab8acea5444a10501ce2fc6e97717db0a2915e38499f0fe8c3a6d026aade01240c83da60058beebc650a900ba223ee8b7a3d92e55b66f9f6955f574f1025ffa09af55f374807150b834451c3b4e592c19d521a41650342666a6740b110ec62007f386f40b633d8d10e6380eb309699ef02b06c7711669737b1fcc20f22b1f62a8e6a0ea5bc5391251fa74467a567077ef1723024597061e76f567ed49afeb16ebd0324463210d7381d6e00bb9047d79b1ad12e1182c428fe6a724259145ae593bbad3851076fb52ac74e469bf45f55a84efd4128c03143019d809cf3b48e93f0a55aa1e9b7ffe9a7836509292a84e5b63899b65ce4952282617a84679ee134f6bdd4940ae1ef25ff2d77cc580f7d18945557b14fd30a56a3713043ab65456311a0ea022e42daaf30426efd1087f6170a7ea7b9d77eaec1d6db481a00e01029ebe074a84a052b9a7cd56aac9da2c3c693a95351d7198fa37c5fb1462c87342cec61f44737999e185a24529601b32f3d23310ee97656152ce41697988578d1bd8d47c220df2ff7cade1dca4690517e41c83ac2ffb74505c57581386cd9c61307a2785a17e66b31ae50faa212473a87d24e85ecd73fdfbea91f0b14f5c7e112650fd98e510b1089f7bc5de64ff69669c75700d5b5788087674ccdba16d67515be7ef75cfd8600cc8b4516130156b3c2a11af53f3aa0786147334bdec7d11ce8912d020be5b2f71e45873ae3ede3ec77324a67742c634adfb86768794ddc34661ff60aba5cda78d28ef7226c6c0ab97b916c95f5910474e62f56661d97ff7a6adc50e20910f9be48a8b3eb28b2556c1f6042f9776b7500c32644cc628c2ccc96e1679bd389e2cfd326bfceb55433f24711084b2e26af37376fc4bc230d836cc2bd5a1fc99035ad05e1e8e998bf3c524290fbfdc28a152ca2cb3ccd1935d10f3fdb489de4ff6015babb5bcb3b8f9334b0b6164a5db824aa3969e11adadd139b7727bc0ba341cd10b958bdb7b4cf8a84aa1cf9cb09e4b36f40bbf419957fa239cdd1aa0a2f3f900026b5abd4f09c5d2474f1b6c04af72528cbe7976c24694cd059dea8c559e486fbb17673394ba6c2de2f532c29173ffc0990ee36efd269c5ad245bc90eed15ac1c03ae3188f1e49e02243da9ba9dcc7fb5c1c46f4a138af09ac406d810e0bb5bd023dce93dc36943e6e4967d7c295af187570da5c7967f1652bd8c9ca59bcfd9e9bf47ca303469c9dda654de75900123a08ddbaec4aeb59acff6ca0d7e1e9571e02d97d354da8db398c6d3f8cda34e97d88d2e3203fcd875bae263fb9503ace13fd79b3c0b2f931d3daa41d6ebc5c7399a2a40e7256db68604b0d7572e601f684a0211ce13df6a6dfd83bbe3fd4e2941cd3c840ce5f90d23f60248121dd634193b103e682242d941b4857010a123829d926b1150247533a10340475c646181cd3e363ad164ee6bf51a8981f73f9e6d953e1341ff5696fc4f5b6dccde3057fb1ec21b181ce3e6f8ddf7099835c5a35e8ffb282f828b86bec6bb8e03b5bc08eddb602b9b2d2efea137799d60b5b1655fa3ae5fc3adb8fd1adbfc3445af21d6fcc6c77cbe7a6730ea7f74917cd1aa2c30e610dfa2ef7d9c50ddb7dcbe2fa6a75e5c7516e7ca7c77ab4812ffe0766eca6ee0f1b0a8c3db742cc209d48ec8aef77130c8026acfc52f2ec76f661ed5575182e4fb8fa0d9626b36797e5e943f397eb4084ea87a3faf0d2c05bdfb54ee812deb3f5f04344ba5c99c04f083017ed4af9cca86d3b314a8b70c3306089abb65a37fcb2d3bbdf0a16d1f0ade1d2112c07009d809ed0ff298e3016ff1100bc06fd911d9f557f80da3acd0378b5820afe37a009ef41feb1e910268b4e1f7a97c8a2c14c754a8861646fc5685f0b9940bc446fb8cca57da61f735c99c3278a6883c8af445646564b4acf42e28188515df9a7f0c2a79b888c39f52244478660f667d891efc06645672a3b0a07fe15a20a7479482da5d3294aeda93fa2f10515812ad5e4cbe7d654a3568df294e193a9faabc3f34aba2e788a2f99bb0dd707b60256c8184fb6bb1ede2c6f0e482654e2f8f96607acb5c157579f1b2edae2465d822049c65966cfb1eb6d14965de20cf579fff9fba2c37185216c4cbea521d6bd67589436a9d2fd54eb897930466ac633c84db0bacee93678b47c849d92071be2da9b3b669a5b9c8da8ad448ff9251cf8dd8e5cb39643abfdcb506aa29a447347392e903cd814b270316c8575861087b7a4af84e29ab2df21a8cb5ce3bc6b259580b73ea3b57997bbc232cfd40e7e54873ca7a5ca31429fd47a2bca97d43b4c68325b1ed52c7324c6884df1dd09708212134383f4d277bf79bc4ec49e749a05c1b69f1b94aed684cff1cf5f2247f22ab99386f7b1001f1677c0d4b845b922f64b74bf2f7a4620fc9105f31410f87ed295596fa6774a6ec8022ef8c9cafd7f4d37883f681c1197402eb31cdc3e6cd7ff9de08a151890758d4ffa72e56875b393a06548ad50d6cf97cd9c97abd660fb3a6bbfab1251e422bf6306292773ee3a3bb6474423aff395987465ccefbf9b9673ba6a6d837bb7b70b0a20329c8c1a10646b6dc7b556a0921f99f078d2d1158e600d08eed0a0f299103fa6601ba266e2e81adc132d38629167fa5d62c17f9642a6ca596554d73b1b89f53a0cb9a6565bc23c8f99c4e8016a646475064079580e504c7e234925f42fcca59def6d660e5e65f33e80d61b704d6996280354b86eb1cc356651830b35a980acc19afc64aaad887b28371a36dd54e27183fe6af16cb3ad65e6c4c95aae974d423c16bbf58714ea93d9e59f8f664a67c1802bcf33e02935423a204195b7ee0304a468297fe4bd4ec57ff5ec9422a16998dccc3ac5cc1b89d3a672a3d592917d407f38d9b86c20c09648f934ac44e64f1ef13ab7de6b007dc45c765aef476154a0737a8c93a509b854e6fad4b2ff7e91cb54742bb24cccd05b22218c9faa9776c8acfe1d59110a62120b060eafcde2acfac079889d416d70f4715fcc9dd691c10dd82b0a8f28dc8b5b8f1dfc485285d7b25ec7b81f9f036c4edcfc6b68b7e34890eea989ddc77d7f14c955c3a8b960fc63edb39dacc06b016e8a3fd12ed15884d7a80cd7dd7426d1ddbe25f73c0a7588e187d01724d052df2566a1753c8284acb94294111347023672badd4b984e6b1989c1139c8377f3dba90b6626f8d0b2ba81ae1e8b0560673fcd4860c06af08f40f282d715204957e6e569edbbd9de9f5acc92f257dec64d3b0a9b1cef3d9f4ae7341a71558d7368447ff16b8036d2b418369efe0cb330d88f2185d87ed731696553094deee7355ee42ea3f8226943b778412cc71887473ff8bd7c141f9d78d79d4792dc95cdd53b96842351edae8d6a781aaaec2b0aa8e08fd0f041906c975b4362be4302be723003e3b5b007c69d7b1cedf21bc0e76dd61d664a87a637303bcef1f0ffd9890d78b31b43cf19d80d0f02aa04c0866ca0fe1d459646646811d456b8a1ea50cd635c97aee2cddb5a4c99c25453127ac2e22b0147898ac00c9d6460336d9548b11b22d64c908f6c66967ac23cdb88262b11a382d456461588df5c29ac77e37b91ff43b450b0012af9205dcd789a420dfe1da5e5c59ed8104b9f18ba583a657a88408261b3853694db4456ea9878ed79a449b06eb7702a4c016d357a369ec1ce76410b700327019173f4cc136d92908a929a7a67fc82dec35d3730246f568f8e47b2903cf02e4799b48c59543bdc5965408343d53bdb93e061bd11349c9b706928354155e012aa31a5fe66d22fb513d5805a557ca84101fb20726147d07e871bc960a7199ecb209f3a66259b092c28cbfc4793ba170e3b20e76f908958aa8554d4f9a6d6ead816404ebe99fe50ae85e8e41a4bfc6c0e40af44b21dfd99662a5ce6e9a7e75a9c8e7ce5938e35c9156961cd3b649c4ddb154ffbb9cbb7497eec6b7e588eaedfce768dfb7b847cf5210d806a156aa7a97fd343ed5fc3b461e59de3e96ae0c4cd36c9ded6c078aa9501ca3d9824b095e6c99132648ae962e4e7b52a319fe47411e9d9ed4129df588180b0e9735717063c244c33098f94e985f4f21d407645319813cd189720df459245b2ca67b6d8d3e1310bb83a471cbf7205ffd1de9e0cbe9720f452882c64cd0cba046956c86b7eae42e3b57f361f27b6a386a1c11ba079d4b3a78e303c2a3921bc91514d9a9360d77af89fa1731db20f8f714b75956481f60302775c0ecdbdbb8a42955b9202450dfd15c11d1b83f06164b652e20b00a247c0547d99f0baebd2ee7b37805f364caa27e562e87ed5d08ebbd1c48ccd096c5d8fef2fc779c6b2514ffdbb162cc7013e90cb83add3ed0925fab3d67312d8ed9e0163a6bbfaf79b69f0582438ea75b40ad145bca82ab890e04137ad04978a57e1819032e67f58f34dbf1150c9ef1b7052f7ed9cf8123119d3b75a63492a4a1960af7ab1d06fcc2f1e5b7aa0eca64b3f9fddcb10d1140283e4634fb70446638f6de61e105c23611ccdcbea87afbfbba2f159e29c8bb2a8635a72ec7a824a9f8f8778fe37306645c3c5983b1e6bf9387d02c7a473e7b29e00cad3b0f4662558840c42dbc6fa21023f739f1ac6f3b64cdfa6b744bd3865e9c75141eaba6fa51569a21b7217cf2c8b5a65e49dcae87cb5258a858f30fcf870f701f3a0bd4ef430dc35835409e74f359c9649ddeec374dd2ea24c38c0042ae2a9c795a25dd87a75731a1eddde823f932f8e3103dc32ce773f0837393d74ed42660132fab0b660326dc0a23f644e1b995cb35f068a5c90ed7523d81083ff7388ade98682cb079914c929a6ca982d49fd81371742ba3c0c2aed37bf0ba6ae4ebf22c4b713152c2bdea6425f71047f83df4dd3fa6b122f8d6438e4e7ceac33f1f7afbccc6f7948c7729da98c8ac068612826ba0d2e804d4401ce9de29138f755b1fe21bdaedd8b7b7ff231f6a250c9c27e8b210d653d77944d0719010e8667e2e60d81afbb9b65cc120000144d0d64393978af6c2e23e15cbb07799bb5c8b3a33d646fb691b064ff527c28fe5d1851bce97a1c4ac2f218da4c683ca7e91fbbb7bf690dc6e9b021f917480e528caccebd6adee9da7bd2df926bc9f5df8a157409df02418ca59d11dd28cef8fce19713d2579dc7d2cf2d9b881636c7e9e42271aca3ee6849380ede8bf51d94ba2fe9c9c3fde334f09cf7aeff30f7650da71231ed4d8a337232726307b55d04160fb0d153fd78d05192a90e876d0958534c8903db6b128df1db209e5216db0216dc995ad65aa75a18ecb14f66c62f344b28b5d5591c345462a3bf8e52f16cdbdb8a118b9c085df253519870fbd666a19ce9b62ac89ad26025a3470317499650763f7abb674c621b0f09da967c4fb559e217d515ed750fc2373fd4709771ba6a806ef1bf73cff8eb82bafc4d1572e7911746444b99faa793db4991aa020f0e2526e2331b335cad17f46fa02fb6f00699bd6bdd5610e58a3726238789a9708e0a040c5fc9ef43ecb6276a3d106c6d4edd10c8078894ebafe6491a1ccad05fc6f50fa13918f65cfd588515a2258f0d98fae577ff90662027d0c2f0c51da2e71ed66a80d88ece9757ee33668c25af3ad1c7695ce4717865d18c75e8be9b48341922a380f0fb41692ff8a3a0ffa911cda1671e9e20ca9976237ac3a2e318c903a1c605dd0d75784edae93cfca1240f71a343066576997a8815a39c32dc26673d0688b665d01b79374a38f401bbe9d7d741a230ff76a86c6c1ba5d4caf6c5808490f7e38f2bffa22e19d9e102ee26a252223abc6904ee2c489a966b0a894836b739ff58f9140d05b075c76e42631ad7c3da59d0d6006dea356defaa03ba387105b1b1d89d391a010d49186fe70b8a5a9f38b3254165bbe04be14b0df32b39e84bf7cd586b4adace1e9ecf936b64d182f40fd7aa03bc337b2a654268b13f31f265dd2353c0d619aed7962e7b19796e6eb220707244de50900ce33dcac63780f2cad0421c0646b7ab116fd6c2a9993beea3a8d55a8a368c0aa00d46f9665269cc0a249e785fac05f263dd7f0b2e003045dcb27fbbe733510225b8d3575dd90971f5ec05e2666d9bdb1a9d6574f1d21c63382addaa0a033c0a6816b39ba04081cdd83a05083a374d3a514296980bf8d5e12e048142c036adb1a86707926b270b3cf96d70480ce93aa06c6411ed04517a7228adfd2c042b9064a6a28c287ad035be363a2e37e7e5e6b28541d9070011748f8b483157a1fdbcc634fa02ac6ef124d2467a09191e6b4a80d94cd257ca85a15f041a827e0e60bdc1fe606938c6da672b583a228077866572f1ac84d6f0f81f009821fb23def6a11f09c809f5b61dae62ba936e2ba04acaf674321f9e33627c717bde6245f1f5662dbdf4770e834d83e6329ff5a4e0ca1453ee6cb856bd79c021d3960803d6fd2f6b59f3d24684518b59d3bdc530331ae1784bb3fbf64d2d75430a70f47db6823807efae37682171c8d74f3cf2b8e1bbfe135482622c79311a9dc53a5e06ce33553ce2f99c53bda4f22a0d0e116d28f68761634e5cf5eb79125ee5ba227cc2df0d01b64a7377a77d7d196bb8e4f628160c72f8542d05a5fe5f0d49d2f431d31e95ca0f766af9dc372daf68c2bf908a0da5bc9812951ecbd6e178cf2601f5484dcd3095ca0de4b59cb9ca00f611b94ba00d69ca2b30ccf1864182f582eaaa9b33cc291ad4a7a9cc38fd28b64a2f65a47143e6ae320793d7598acde5f0464c03d623bc972b69f09f146368e08de753b99b2e2170a81e109cf0056b314b014d5ba68724b1727568f81f5d10d1b5d69011b65732b224259beb19a6d0ac429a73ac6af1bed6c3e146461f1fd67fc34bd44de6002c004560d5331fcf6edec2e4374876be70e535eef635f3571364d20e96151eb8438442fc6c8775bd82ec86ae66e3be31023affed969fbefb899fba40b97b5fb5c09890444b61ff03c2048ad56646a78197fd67fa2e77212a2cdb186b9c3d368519e63f7ef0c329dfab2d0e28652c31c74e40d4ad870c80ca5b00406c52b8e752b247c6ac1fb8e480ed0b3596ccc04b4ffb75c1bec3c643c7372c7538b8d49f432975c4275e726a677f0ac314afd38795e70a8340ae52469563415917c19fb203077a2d79750be6409d286398291ac6345a943c1eec9b7f1806430aeda9bd5818d6f011451761b10c0d4561134d88a68420a348eb1600ee75940dfa1b618e578016656ca0d8326e78f25020390a94061d69f2ffcd050d1bbb7c63b38111a6eb4d018f56b705ec4e2fc482459f9d303479b1e1140b56eaf3d914864b8c4ede6e9550ac287acf40477b8fee41abd96d9115cf54404128685173795e1a4caeb8672aea36a6ea50418a36b0010a3ee5031319031e090fc62e3a02916980059d885be0981f6f281ba5cb9465014cccdb06be06a15d9982ce482e54d01ebd520f72588e407e845928e3a1ec0309c59bf4b98bf9db5aa1d617b9a359e54c718d6c868d3afabc3d958f1587943fd78fbed6fc450db463921ad8ee405bd6cecb8cddafd63a7a6e925fa7eebe3b7712ec7fde45e5020e96bcebb4586d3c8005a3dbe14b399f786acc212a99f2cb37013aeb892533b3860d959e75a2fe35ed5ceb822add0a91c1e160f8bc403b2a0ba894e2dea6089afb08da6b3a39e7b4bce8c2f107f3b65abb60501b4595c6bcacfed11d671114d14cc0a1e76868c20f4f8042b12e4649c0276d191daac5774e2314019e3de838e825e2c67703c88c1f5348066a47e7ebfef6c6e56f8c71242a83a5a9569ab9608b51010669d67c2c95bc76d6b60c802726f5bf71ee0df5054f9b2c69fa61553ac0d1cac0d2250f85df8380b206d5639b09adc2ccde6f48ba64b9b45608ef1b21659c2e4b5a15c63d5db052d27804813b82593b3b9b5bc05ff985513cb53f51d2e6b2953f6137c3eb72641ea2a77e31ca49708e7177b2bb33d8b5573319e969c33b7338b1c517aca0611109978575e0266cb24de5002b2c41a56bffae551ee927fba9f03049ff2543dd54a355d812addc6348d465a96e1fdb09519ef3fa3e0a65125f0e16dd15a56033e168c9c020b3ab77a2257a540e27c55cbc760cc83ec083b551e1bc917af9dfae734d8f54a2f4dc41eaa87b5142af2b524ce28a552e80252768683ac5bddada35d7640681e7d39d4d4f521006aaa0a293a9bde47b26a761faca43a1f47b6ef81efa0fca5c4f82e6820a1f6eee507aa3bfcf5b109323052ace1172186f84b5193b873a758bcf8c98323af1c64558cae3f0bc98598cfbfd71954a06b7db62d2620e2c46dbf3cde45999e6a5b797d4fe7322bb8478df0b3711e2ab0752759cfe7c2d64ca3063c33c9c6d99ed405b520a7cbaf461b2fafa4e50e8fd2068238e77e2a09dd97d57a652168507bdc575a317200aa59e8db7856bd895c8d92dc583976509d0f82648f9c2d41af9e07544c9485a0fbf63f5845aa2b9f6f0844c1e87d7a426f1baa2cb577c892c7aeff21c066d1bcd904e91579babfc0a45f8219e56edbc3fcb3d2a806717053175027e1468514b9d7cd4a93dd515affd1e1b1043080d54fa39c10e372366a5eb28da0077261eaff7b2067e03c5ab57774dc3b64fc0804edf65b8e386a898834d6755e77209b974510aed6b36f000d57e0483d0e30dcbfc6fd08123138fad8a76c17ffcaac006cd0489d2c1fdd7278ab543a9ea8b226b90975e286a9ba8876cadab64dc84d4e3e03751464b7cdc944cd3a754c0d6c99d6b17c895fd60392cc92c4301ed43e7573ba887f573c81f80cf1782cb8862a563864f011d83675f244dd1fa3a76e620668cacb16e2996d55ab0954b0042560ec6837589824974b3588f3934e45b1b9a2f95ce3b38add92dfd5782efe24b809bf1e9cd61af09e062d11d8e8e6d63920f6886608a2778afa52e8bd2f20eb353dcd753966fd1bece07aa64e6aeac1a74990954ceb2215894c896e4c2f9044908d539d674bccc70307758c238840cd5758715024aa953175657101f38881ec06d4acf51103240afcf17976ac8343e658d20ac59b22deff5684a5e7a11292d45a0639b4251a675ef03fd185c167a1a7013c923dc74644965318dbf0568feda012bdc55cf728cd372d82c314b444a23818e82d8f7d19f614c22dd259be7f8a7b5f4108c6ddcfef841a9cf0b39a3bbc477c069df2229a3a866f2b7313200bf2b1aff0090461efa2811df344bff3d37dde0d6adac1c945bc27879be1cf9b2d54837f2ce1eec5fb60da425e8e8386e1ba47284b5f8408570d20406d5a47dd7b4ebcdedcd73cad11114c3574b7aadb4a14e9a96950d3870a31ca78c2c7b9adf6be5065959a9a0fe1eb1e608216bc35e537a083f94217ec4e5f941bffa86cc698ed7251595a83839328690d67dacc9933ba334e85764aba4ceceff359691bafbc787921781c028e7c004a2994daa7e315bb93d4eec5395ad32e5ddfc3785c59460c0663dbe3661d64609276ff04b80066cfab4b31cd15d3723d7e312543859ecc264f24626a61cae59fec557ac975c67561abe94df82aac5bda7e92ba8919a285e579fe795e455a5e5c5af1aae9480d8e46c8041b2c40d0e7e4b0e914cab7647b46d9f8ead1df8364e6b59fe356556f1b6c926d15972dd1e1b32760b9e84413cbcfad494c7805760ad8866c0fd19ad9b12b71810270ff44d629082740fecca78f6d24fc3f8308238841519b4330b10bdcd2780ea84bf2e624d4fae19e59307847d89920b57563a84806ba2a746db468d4ed6cc66626378439883a2b7a0133887db56715cf60369a2733e50ef253b9cdc88f07d23c41456242b969e7a46e7ab3be8bfd3b99cfba0f7340cb2f93ea06bb50c24d9c1124f544dfc7faf833af2417cb5d93dbafd0c3f34bd6a8565ee50661be38ccede7ce443d21b7dc194536bd54d27423613b1aa33668bb5ae7f511c86192a0599b380fbfa74ccd82d065a36fccb31eb74eee3eee0a23559f62dfe17fc0af5362a68f3868aa2636b3e68e69358480bf5c50312d0d1a6e59c86f9ef811ba6f49a1aa5ef43707cf7defd0eadc72aed203614de29a899384989685d35b3101c956989868361df20747cf7c24dd4d4889225cbceefff7b584ae4514dfafd1e18a2996f3fd884d20db5cff6412a87f45b5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> unfixed </tag>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Beaver三元组用于乘法共享</title>
      <link href="/2025/04/10/Beaver%E4%B8%89%E5%85%83%E7%BB%84%E7%94%A8%E4%BA%8E%E4%B9%98%E6%B3%95%E5%85%B1%E4%BA%AB/"/>
      <url>/2025/04/10/Beaver%E4%B8%89%E5%85%83%E7%BB%84%E7%94%A8%E4%BA%8E%E4%B9%98%E6%B3%95%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>Beaver 三元组（Beaver triples）是安全多方计算（MPC）中一个超级聪明、实用的技巧，用来安全地做乘法</p><p>通俗类比：就好像你和朋友要乘两个私密数字，但你们提前准备了一个万能“乘法模板”，可以安全又正确地偷偷算出结果。</p><span id="more"></span><hr><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>在安全多方计算里：</p><ul><li><strong>加法</strong>很容易做：每个人把自己数据碎片加一下就行。</li><li>但<strong>乘法就麻烦了</strong>，因为：<ul><li>两个秘密数的乘积不能直接从碎片算</li><li>又不能暴露真实数值</li><li>所以需要巧妙地”绕过去“</li></ul></li></ul><p>Beaver 三元组应运而生</p><hr><h3 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h3><p>Beaver 三元组表示为：</p><script type="math/tex; mode=display">(a, b, c) \quad \text{where} \quad c = a \cdot b</script><ul><li>所有参与方各自拿到这些数的“碎片”，但不知道完整的值。</li><li>它跟我们真正要计算的 $x \cdot y$ 没有关系，只是一个通用的乘法工具。</li></ul><hr><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>假设两位参与方想计算：</p><script type="math/tex; mode=display">x \cdot y</script><p>但每人都只知道自己的秘密（$x$ 或 $y$），又不想泄露给别人。</p><hr><p>步骤如下：</p><ol><li><p>每人拿到 $x$ 和 $y$ 的秘密共享，还有一个 Beaver 三元组 $(a, b, c)$，满足 $c = ab$</p></li><li><p>本地计算（在共享上进行）：</p></li></ol><script type="math/tex; mode=display">\begin{align}&d = x - a\\&e = y - b\end{align}</script><ol><li><p>公布 $d$ 和 $e$（这不会泄露 $x$ 和 $y$，因为 $a$ 和 $b$ 是随机的）</p></li><li><p>使用下面的公式计算结果：</p></li></ol><script type="math/tex; mode=display">xy = c + d \cdot b + e \cdot a + d \cdot e</script><hr><p>安全性说明：</p><p>虽然你公开了 $d$ 和 $e$，但由于 $a$ 和 $b$ 是随机数，<strong>别人无法反推 $x$ 和 $y$</strong>，同时这个公式仍能计算出准确的乘积</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCS简要介绍</title>
      <link href="/2025/03/26/PCS%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/03/26/PCS%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>之前听师兄讲PCS（多项式承诺方案），听不懂一点，甚至有一次差点睡着（bushi</p><p>今天看Siniel，又遇到PCS了，故而通俗理解记录一下，也没时间看相关论文了~浅学一下，够用即可~~</p><span id="more"></span><hr><p><img src="image-20250326202011752.png" alt="图一"></p><p>Motivation：证明者有一个多项式 $p()$，验证者指定一个数 $z$ 来验证，<strong>通过承诺确保原多项式不会改变</strong></p><p><img src="pic2.png" alt="图二"></p><p>这里，我们介绍 KZG。更具体的：</p><p>KZG 方案是基于<strong>双线性对（bilinear pairing）</strong>和<strong>加法同态加密（homomorphic encryption）</strong>的密码学技术。它允许一个发送方<strong>承诺（commit）</strong>一个多项式，并稍后提供<strong>证明（proof）</strong>，以便验证者确认多项式在某个点的值是否正确。</p><p>前置知识：双线性映射</p><ul><li>设 $G_1,G_2$ 是两个循环群，阶为素数 $p$</li><li>设 $e:G_1\times G_2\rightarrow G_T$，满足 $e(g^a,h^b)=e(g,h)^{ab}$ 对所有 $a,b\in\mathbb{Z}_p$ 成立，其中 $g,h$ 是群 $G_1$ 和 $G_2$ 的生成元</li></ul><p>KGC的四个步骤：（对应图二）</p><ol><li><strong>Setup（设置）：</strong> 生成公钥参数。</li><li><strong>Commit（承诺）：</strong> 证明者使用私有多项式生成并公开该多项式的承诺。</li><li><strong>Open（打开）：</strong> 验证者指定在某个点，而后要求证明者公开该多项式的值并提供一个证明。</li><li><strong>Verify（验证）：</strong> 验证者检查提交的值和证明是否有效。</li></ol><hr><h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><p><strong>2.1 设定（Setup）</strong></p><p>由可信第三方（或 MPC ）选取一个私有值 $s$，并计算：${ g, g^s, g^{s^2}, \dots, g^{s^d} }$ 作为公共参数；这些值是椭圆曲线群上的元素并公开发布。</p><p><strong>2.2 承诺（Commit）</strong></p><p>证明者需验证多项式 $p(x) = a_0 + a_1 x + a_2 x^2 + \dots + a_d x^d$</p><p>计算并公开承诺 $C_p = g^{p(s)} = g^{a_0 + a_1 s + a_2 s^2 + \dots + a_d s^d}$</p><p><strong>2.3 证明（Open）</strong></p><p>验证者想知道证明者的多项式在 $x = \alpha$ 处的值 $y = p(\alpha)$</p><p>证明者计算<strong>商多项式</strong>：$q(x) = \frac{p(x) - p(\alpha)}{x - \alpha}$；因为 $p(x) - p(\alpha)$ 可被 $x - \alpha$ 整除，所以 $q(x)$ 是一个比 $p(x)$ 低 1 阶的多项式。</p><p>计算承诺 $C_q$：$C_q = g^{q(s)}$；并将其作为证明 $\pi = C_q$ 发送给验证者。</p><p><strong>2.4 验证（Verify）</strong></p><p>验证者通过以下等式检查证明是否有效：$e(C_p / g^y, g) = e(\pi, g^{\alpha})$</p><p>即：$e(g^{p(s) - y}, g) = e(g^{q(s)}, g^{\alpha})$</p><p>若等式成立，则说明证明者提供的 $y = p(\alpha)$ 是正确的。</p><hr><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>①设公共参数为：$g, g^s, g^{s^2}, g^{s^3}, \dots$</p><p>②证明者私有多项式：$p(x) = 3x^2 + 2x + 5$</p><p>计算承诺并将其公开：$C_p = g^{5 + 2s + 3s^2}$</p><p>③验证者指定一个点：$z=2$</p><p>证明者计算:$p(2) = 3(2)^2 + 2(2) + 5 = 17$</p><p>证明者计算商多项式:$q(x) = \frac{(3x^2 + 2x + 5) - 17}{x - 2} = 3x + 8$</p><p>证明者计算证明：$\pi = g^{q(s)} = g^{3s + 8}$</p><p>④验证者执行验证：$e(C_p / g^{17}, g) = e(g^{3s + 8}, g^2)$</p><p>如果等式成立，则证明 $ p(2) = 17 $ 是正确的。</p><hr><h4 id="进一步的，关于验证阶段"><a href="#进一步的，关于验证阶段" class="headerlink" title="进一步的，关于验证阶段"></a>进一步的，关于验证阶段</h4><p>验证者需要验证 $e(C_p / g^{17}, g) = e(g^{3s + 8}, g^2)$ 是否成立</p><script type="math/tex; mode=display">\begin{align}左式=&e(C_p / g^{17}, g)\\=&e(g^{(5 + 2s + 3s^2) - 17},g) \\=&e(g^{3s^2 + 2s - 12},g)\\=&e(g, g)^{(3s^2 + 2s - 12)}\end{align}</script><script type="math/tex; mode=display">\begin{align}右式=&e(g^{3s + 8}, g^2)\\=& e(g, g)^{6s + 16}\end{align}</script><p>故只需 $3s^2 + 2s - 12=6s + 16$ 成立，则验证通过</p><p>此时 $s=\frac{2 \pm \sqrt{88}}{3}$ （此过程为逆向过程）</p><p>即最一开始的公开参数 $s=\frac{2 \pm \sqrt{88}}{3}$ 时，则 $e(C_p / g^{17}, g) = e(g^{3s + 8}, g^2)$ 成立，证明通过</p><h4 id="后记：补充说明"><a href="#后记：补充说明" class="headerlink" title="后记：补充说明"></a>后记：补充说明</h4><p>和上面的算法相呼应，在论文的后半部分找到的具体算法，本质相同</p><p><img src="image-20250329163236108.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust study</title>
      <link href="/2025/03/01/rust-study/"/>
      <url>/2025/03/01/rust-study/</url>
      
        <content type="html"><![CDATA[<p>本文记录了rust的学习</p><span id="more"></span><hr><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>vscode配置rust环境</p><p>vscode内配置快速打开Terminal，绑定<code>openInIntegratedTerminal</code>即可</p><p><img src="image-20250301191522700.png" alt></p><p><img src="image-20250301191610383.png" alt></p><p>然后下载rust依赖</p><p>因为我们都是喜家家糕守（电脑里有cpp环境），所以可以管理员运行下载<a href="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe">这个东东</a>即可</p><p>（没有cpp的环境我就不管了（光速逃））</p><p>然后一路回车</p><p>安装好后，cmd里输入<code>rustup --version &amp; rustc --version &amp; cargo --version</code>测试安装成功</p><p><img src="image-20250301192417753.png" alt></p><p>然后打开vscode，下载相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rust</span><br><span class="line">Rust-analyzer</span><br><span class="line">CodeLLDB</span><br><span class="line">crates</span><br><span class="line">Rust Syntax</span><br><span class="line">Rust Test Lens</span><br><span class="line">Even Better TOML(Better TOML已弃用)</span><br></pre></td></tr></table></figure><p>后面就可以正常使用了</p><p>新建项目 <code>cargo new hellowrold</code></p><p>打开项目 <code>cd .\helloworld\</code>（TAB键补全）</p><p>运行项目 <code>cargo run</code></p><p><img src="image-20250301201157547.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窝补药橙味算法竞赛掉大分糕守</title>
      <link href="/2025/02/22/%E7%AA%9D%E8%A1%A5%E8%8D%AF%E6%A9%99%E5%91%B3%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%8E%89%E5%A4%A7%E5%88%86%E7%B3%95%E5%AE%88/"/>
      <url>/2025/02/22/%E7%AA%9D%E8%A1%A5%E8%8D%AF%E6%A9%99%E5%91%B3%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%8E%89%E5%A4%A7%E5%88%86%E7%B3%95%E5%AE%88/</url>
      
        <content type="html"><![CDATA[<p>2025年2月21日周五晚<a href="https://ac.nowcoder.com/acm/contest/101963">这场牛客</a>，掉大分了</p><span id="more"></span><hr><p>A题快速切出来，后面就开始坐牢了（还好记得开ll了）</p><p>B题憋了半天，感觉要开不止一对堆，然后一看榜C出的人多，就去看C了</p><p>然后C挂了两发，和21年csp-s差点ce的原因一样（</p><p>当时是数组开到N，但是i也遍历到N</p><p>这次学聪明了，数据开到N+10，然后扫到N；结果忘了后面用到i+1了</p><p>然后挂了两发才发现</p><p>B题就有意思了，开了四个堆最终，调了好半天过样例了，结果一直WA</p><p>赛后找评论区的hack数据也找不出一点问题</p><p>最终对拍了下下，记录最大值的初始值是0，但是最大值有可能是负数···</p><p>最终成绩</p><p><img src="image-20250222150529258.png" alt></p><p>虽然没掉大分，不过这场也打得挺抽象的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量子安全的概念</title>
      <link href="/2025/02/20/%E9%87%8F%E5%AD%90%E5%AE%89%E5%85%A8%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/02/20/%E9%87%8F%E5%AD%90%E5%AE%89%E5%85%A8%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>昨天组会，导师跟我说量子安全和后量子安全不是同一个东西，我此前一直将他们混为一谈，故今日作以区分</p><hr><p>量子安全：指加密方法在量子计算机下仍保持安全。</p><p>反量子安全：通过增强现有算法对抗量子计算机的能力，通常是过渡性措施。</p><p>后量子安全：指完全为抵抗量子计算机的攻击而设计的新的加密算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二元不等式串引发的思考</title>
      <link href="/2025/02/05/%E4%BA%8C%E5%85%83%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%B8%B2%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2025/02/05/%E4%BA%8C%E5%85%83%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%B8%B2%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>写了一下午，最后发现推导的结论是错的<br>蚌埠住了，布响丸辣</p><span id="more"></span><hr><p>我们早在高中就学过以下不等式串</p><script type="math/tex; mode=display">\sqrt\frac{x^{2}+y^{2}}{2}\geqslant\frac{x+y}{2}\geqslant\sqrt{xy}\geqslant\frac{2}{\frac{1}{x}+\frac{1}{y}}</script><p>今天刷张宇的时候，又遇到了这个问题；一般而言这个不等式串背过就行了，直接套用即可，但是我忘了，然后就不会了（大雾</p><p>这样死记硬背有利于短期记忆，所以我们进一步研究，<strong>本文致力于让读者深入理解和更好的记忆该不等式</strong></p><p>我的切入点是切入面（字面意思），也就是看截面；不妨写成$z=$的形式获得到四个式子</p><script type="math/tex; mode=display">\begin{align}&z=\sqrt\frac{x^{2}+y^{2}}{2}\\&z=\frac{x+y}{2}\\&z=\sqrt{xy}\\&z=\frac{2}{\frac{1}{x}+\frac{1}{y}}\end{align}</script><p>我们使用绘图软件画出这四个式子可以很直观的发现</p><p><img src="image-20250205155642726.png" alt></p><p>后面进行分析</p><p>第一个$z=\sqrt\frac{x^2+y^2}2$（青色图像），等价于$z^2=\frac{x^2+y^2}2$，一个很典型的圆锥</p><p>具体来说，设有圆形且圆的半径满足$r^2=x^2+y^2$，这时满足$z=\frac{\sqrt2}2r$</p><p>第二个$z=\frac{x+y}{2}$（紫色图像），这是个没有任何弯曲的平面</p><p>第三个$z=\sqrt{xy}$（蓝色图像），若不考虑$z$，则$x$和$y$的关系是反比例，图像如下</p><p><img src="image-20250205164344087.png" alt></p><p>切一个面，切出来是反比例函数，也就是双曲线</p><p><img src="image-20250205164612014.png" alt></p><p>第四个$z=\frac{2}{\frac{1}{x}+\frac{1}{y}}$（棕色图像），<strong>该图像如果使用z=k进行切割，将会切出双曲线</strong>，故我们使用$x+y=k$进行切割</p><p>容易计算这时$z=2x-\frac{2x^2}k$是个双曲线；图像如下</p><p><img src="image-20250205165529486.png" alt="image-20250205165529486"></p><p>这时候就有人要问了，为什么别的式子都是直接切$z=k$，偏偏最后一个要切$x+y=k$非要搞特殊</p><p>这时不得不拿出这张众人皆知的图了</p><p><img src="compare.png" alt></p><p>看蓝色部分，也就是抛物线部分，它是竖着切的</p><p>其他几个不完全是竖着切的，所以上述切法仅仅是投影，除了圆形，其他的不准确，但不影响判断图像性质（即分辨圆形、椭圆或双曲线抛物线），即<strong>离心率范围不会跨越</strong></p><p>回归正题，我们该如何记忆不等式呢？就记忆离心率即可</p><p>离心率越小，在不等式的位置越大</p><script type="math/tex; mode=display">\begin{align}&z=\sqrt\frac{x^{2}+y^{2}}{2}（椭圆）\\&z=\frac{x+y}{2}（圆形）\\&z=\sqrt{xy}（双曲线）\\&z=\frac{2}{\frac{1}{x}+\frac{1}{y}}（抛物线）\end{align}</script><p>诶好像不太对劲~</p>]]></content>
      
      
      
        <tags>
            
            <tag> mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客寒假2025题解</title>
      <link href="/2025/01/29/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%872025%E9%A2%98%E8%A7%A3/"/>
      <url>/2025/01/29/%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%872025%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文用于记录牛客寒假赛的六场比赛的赛时解题和赛后补题</p><p>笔者水平：CF绿上蓝下 </p><span id="more"></span><hr><h2 id="第一场"><a href="#第一场" class="headerlink" title="第一场"></a>第一场</h2><p><img src="image-20250122111748922.png" alt></p><p>打红温了，头一次连打五个小时~</p><p>题本身不难，就是实现上遇到比较多的障碍</p><p>A题签到题，如果没有<code>1</code>就输出<code>1e9+7</code>即可</p><p>D题也是直接模拟即可</p><p>G题排序后计算<code>a[i]-i</code>，就是每个点需要操作的次数了</p><p>B题一开始以为是有向图浪费了很多时间，树存在简单路径的充要条件是它是链</p><h3 id="M题"><a href="#M题" class="headerlink" title="M题"></a>M题</h3><p>也属于思路很简单但是<strong>写起来比较困难</strong>的题</p><p>就拓扑排序一下，然后逐步拓展，取最优解即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n , a[N+10];</span><br><span class="line">struct NUMBER&#123;</span><br><span class="line">    int num;</span><br><span class="line">    int id;</span><br><span class="line">&#125;b[N+10];</span><br><span class="line"></span><br><span class="line">bool cmp( NUMBER x , NUMBER y )&#123;</span><br><span class="line">    return x.num &lt; y.num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n;cin &gt;&gt; n;</span><br><span class="line">    int maxn , minn;maxn = 0 , minn = 2147483647;</span><br><span class="line">    int minp = 0;</span><br><span class="line">    int ans = 2147483647;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        b[i].id = i , b[i].num = a[i];</span><br><span class="line">        if( maxn &lt; a[i] ) maxn = a[i];</span><br><span class="line">        if( minn &gt; a[i] ) minn = a[i] , minp = i;</span><br><span class="line">    &#125;</span><br><span class="line">    if( n == 1 )&#123;</span><br><span class="line">        cout &lt;&lt; &quot;0\n&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int l , r;l = r = minp;</span><br><span class="line">    sort( b + 1 , b + n + 1 , cmp );</span><br><span class="line">    b[n+1].id = n+1 , b[n+1].num = 2147483647;</span><br><span class="line">    int down_minn = minn * 2;</span><br><span class="line">    if( maxn &lt; b[1].num * 2 ) maxn = b[1].num * 2;</span><br><span class="line">    minn = b[2].num , minp = b[2].id;</span><br><span class="line">    if( minn &gt; down_minn ) minn = down_minn;</span><br><span class="line">    ans = min( maxn - minn , ans );</span><br><span class="line">    for(int p = 2;p &lt;= n;p ++)&#123;</span><br><span class="line">        if( b[p].id &gt; r )&#123;</span><br><span class="line">            while( b[p].id &gt; r )&#123;</span><br><span class="line">                r ++;</span><br><span class="line">                if( maxn &lt; a[r] * 2 ) maxn = a[r] * 2;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = b[p+1].num , minp = b[p+1].id;</span><br><span class="line">            while( minp &lt;= r &amp;&amp; minp &gt;= l )&#123;</span><br><span class="line">                p ++;</span><br><span class="line">                minn = b[p+1].num , minp = b[p+1].id;</span><br><span class="line">            &#125;</span><br><span class="line">            if( minn &gt; down_minn ) minn = down_minn;</span><br><span class="line">            ans = min( maxn - minn , ans );</span><br><span class="line">        &#125; </span><br><span class="line">        if( b[p].id &lt; l )&#123;</span><br><span class="line">            while( b[p].id &lt; l )&#123;</span><br><span class="line">                l --;</span><br><span class="line">                if( maxn &lt; a[l] * 2 ) maxn = a[l] * 2;</span><br><span class="line">            &#125;</span><br><span class="line">            minn = b[p+1].num , minp = b[p+1].id;</span><br><span class="line">            while( minp &lt;= r &amp;&amp; minp &gt;= l )&#123;</span><br><span class="line">                p ++;</span><br><span class="line">                minn = b[p+1].num , minp = b[p+1].id;</span><br><span class="line">            &#125;</span><br><span class="line">            if( minn &gt; down_minn ) minn = down_minn;</span><br><span class="line">            ans = min( maxn - minn , ans );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="J题"><a href="#J题" class="headerlink" title="J题"></a>J题</h3><p>赛时还以为是什么糕级数论，结果降低时间复杂度$O(n^\frac32)$就能过</p><p>通过打表可知，符合条件只有两种情况，再判一下就可以了</p><p>要先<code>continue</code>掉奇数，不然亲测会T掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n , ans , a[N+10];</span><br><span class="line">map &lt; int , int &gt; m;</span><br><span class="line"></span><br><span class="line">int gcd_( int x , int y )&#123;</span><br><span class="line">    if( y == 0 ) return x;</span><br><span class="line">    return gcd_( y , x % y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) m[a[i]] ++;</span><br><span class="line">    for(int i = 1;i &lt;= N;i ++)&#123;</span><br><span class="line">        if( i % 2 ) continue;</span><br><span class="line">        for(int j = 1;j &lt;= sqrt(i);j ++)&#123;</span><br><span class="line">            if( i + j &lt;= N )&#123;</span><br><span class="line">                if((i ^ (i+j)) == j)</span><br><span class="line">                    if( gcd_( i , i+j ) == j )</span><br><span class="line">                        ans += m[i]*m[i+j];</span><br><span class="line">                if( (i ^ (i+i/j)) == i/j &amp;&amp; j*j!=i)</span><br><span class="line">                    if( gcd_( i , i+i/j ) == i/j )</span><br><span class="line">                        ans += m[i]*m[i+i/j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赛后补题"><a href="#赛后补题" class="headerlink" title="赛后补题"></a>赛后补题</h2><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p>看起来不难，以为半个小时就能写完</p><p>结果调了好久···</p><p>大致思路就是朴素开扫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e2;</span><br><span class="line">int n , t , a[N+10][N+10];</span><br><span class="line">int ans_list[1000000][5];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">signed main()&#123;int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            for(int j = 0;j &lt; n;j ++)&#123;</span><br><span class="line">                if( s[j] == &#x27;1&#x27; ) a[i][j+1] = 1;</span><br><span class="line">                else a[i][j+1] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 1;i &lt;= n/2;i ++)&#123;</span><br><span class="line">            for(int j = 1;j &lt;= n/2;j ++)&#123;</span><br><span class="line">                if( a[i][j] == 0 )&#123;</span><br><span class="line">                    for(int ii = 1;ii &lt;= n;ii ++)&#123;</span><br><span class="line">                        int jj , jjl;if( ii &lt; i ) jjl = n/2+1;</span><br><span class="line">                        else if( ii == i ) jjl = j;</span><br><span class="line">                        else jjl = 1;</span><br><span class="line">                        for(jj = n;jj &gt;= jjl;jj --)&#123;</span><br><span class="line">                            if( a[ii][jj] == 1 )&#123;</span><br><span class="line">                                // cout &lt;&lt; &quot;SWAPP: &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;</span><br><span class="line">                                while( !(i==ii&amp;&amp;j==jj) )&#123;</span><br><span class="line">                                    if( ii &gt; i &amp;&amp; a[ii-1][jj] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii-1][jj] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii-1;</span><br><span class="line">                                        ans_list[cnt][4] = jj;</span><br><span class="line">                                        ii --;</span><br><span class="line">                                    &#125;else if( ii &lt; i &amp;&amp; a[ii+1][jj] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii+1][jj] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii+1;</span><br><span class="line">                                        ans_list[cnt][4] = jj;</span><br><span class="line">                                        ii ++;</span><br><span class="line">                                    &#125;else if( jj &gt; j &amp;&amp; a[ii][jj-1] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii][jj-1] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii;</span><br><span class="line">                                        ans_list[cnt][4] = jj-1;</span><br><span class="line">                                        jj --;</span><br><span class="line">                                    &#125;else if( jj &lt; j &amp;&amp; a[ii][jj+1] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii][jj+1] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii;</span><br><span class="line">                                        ans_list[cnt][4] = jj+1;</span><br><span class="line">                                        jj ++;</span><br><span class="line">                                    &#125;else goto RECHOOSE;</span><br><span class="line">                                &#125;goto FIXED;</span><br><span class="line">                            &#125;RECHOOSE:;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;FIXED:;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        //     for(int j = 1;j &lt;= n;j ++)&#123;</span><br><span class="line">        //         cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        //     &#125;cout &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        for(int i = 1;i &lt;= cnt;i ++)&#123;</span><br><span class="line">            for(int j = 1;j &lt;= 4;j ++)&#123;</span><br><span class="line">                cout &lt;&lt; ans_list[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果WA了个测试点~</p><p><img src="image-20250122114911663.png" alt></p><p>看了题解，感觉思路真妙哇~</p><p><img src="image-20250122115049179.png" alt></p><p>按照题解敲了一下，发现实现起来的复杂程度和我的代码差不多···</p><p>最终千辛万苦，debug一整个下午，找到问题了</p><p><code>ii</code>和<code>jj</code>这个两个指针复用导致的，每次用完之后复位一下就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e2;</span><br><span class="line">int n , t , a[N+10][N+10];</span><br><span class="line">int ans_list[1000000][5];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">signed main()&#123;int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            for(int j = 0;j &lt; n;j ++)&#123;</span><br><span class="line">                if( s[j] == &#x27;1&#x27; ) a[i][j+1] = 1;</span><br><span class="line">                else a[i][j+1] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 1;i &lt;= n/2;i ++)&#123;</span><br><span class="line">            for(int j = 1;j &lt;= n/2;j ++)&#123;</span><br><span class="line">                if( a[i][j] == 0 )&#123;</span><br><span class="line">                    for(int ii = 1;ii &lt;= n;ii ++)&#123;</span><br><span class="line">                        int jj;if( ii &lt; i ) jj = n/2+1;</span><br><span class="line">                        else if( ii == i )&#123; jj = j+1;&#125;//cout &lt;&lt; &quot;???????????&quot; &lt;&lt; endl;&#125;</span><br><span class="line">                        else jj = 1;</span><br><span class="line">                        int oii , ojj;oii = ii;</span><br><span class="line">                        // cout &lt;&lt; &quot;disp?: &quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;</span><br><span class="line">                        while(jj &lt;= n)&#123;</span><br><span class="line">                            ojj = jj;</span><br><span class="line">                            // cout &lt;&lt; &quot;ij: &quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;</span><br><span class="line">                            if( a[ii][jj] == 1 )&#123;</span><br><span class="line">                                // cout &lt;&lt; &quot;SWAPP: &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;</span><br><span class="line">                                while( !(i==ii&amp;&amp;j==jj) )&#123;</span><br><span class="line">                                    // cout &lt;&lt; &quot;PASSED: &quot; &lt;&lt; ii &lt;&lt; &quot; &quot; &lt;&lt; jj &lt;&lt; endl;</span><br><span class="line">                                    if( ii &gt; i &amp;&amp; a[ii-1][jj] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii-1][jj] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii-1;</span><br><span class="line">                                        ans_list[cnt][4] = jj;</span><br><span class="line">                                        ii --;</span><br><span class="line">                                    &#125;else if( ii &lt; i &amp;&amp; a[ii+1][jj] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii+1][jj] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii+1;</span><br><span class="line">                                        ans_list[cnt][4] = jj;</span><br><span class="line">                                        ii ++;</span><br><span class="line">                                    &#125;else if( jj &gt; j &amp;&amp; a[ii][jj-1] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii][jj-1] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii;</span><br><span class="line">                                        ans_list[cnt][4] = jj-1;</span><br><span class="line">                                        jj --;</span><br><span class="line">                                    &#125;else if( jj &lt; j &amp;&amp; a[ii][jj+1] == 0 )&#123;</span><br><span class="line">                                        cnt ++;</span><br><span class="line">                                        swap( a[ii][jj] , a[ii][jj+1] );</span><br><span class="line">                                        ans_list[cnt][1] = ii;</span><br><span class="line">                                        ans_list[cnt][2] = jj;</span><br><span class="line">                                        ans_list[cnt][3] = ii;</span><br><span class="line">                                        ans_list[cnt][4] = jj+1;</span><br><span class="line">                                        jj ++;</span><br><span class="line">                                    &#125;else goto RECHOOSE;</span><br><span class="line">                                &#125;goto FIXED;</span><br><span class="line">                            &#125;RECHOOSE:;</span><br><span class="line">                            ii = oii , jj = ojj;</span><br><span class="line">                            jj ++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // cout &lt;&lt; &quot;unp: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">                    // for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">                    //     for(int j = 1;j &lt;= n;j ++)&#123;</span><br><span class="line">                    //         cout &lt;&lt; (a[i][j]==1?&quot;1&quot;:&quot;0&quot;) &lt;&lt; &quot; &quot;;</span><br><span class="line">                    //     &#125;cout &lt;&lt; endl;</span><br><span class="line">                    // &#125;</span><br><span class="line">                &#125;FIXED:;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        //     for(int j = 1;j &lt;= n;j ++)&#123;</span><br><span class="line">        //         cout &lt;&lt; (a[i][j]==1?&quot;1&quot;:&quot;0&quot;) &lt;&lt; &quot; &quot;;</span><br><span class="line">        //     &#125;cout &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        for(int i = 1;i &lt;= cnt;i ++)&#123;</span><br><span class="line">            for(int j = 1;j &lt;= 4;j ++)&#123;</span><br><span class="line">                cout &lt;&lt; ans_list[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;cout &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h3><p>概率论没学好（悲</p><p><img src="image-20250123095350739.png" alt></p><p>知道了这一点，将会是签到题的难度（悲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n , t , a[N+10];</span><br><span class="line"></span><br><span class="line">signed main()&#123;int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort( a + 1 , a + n + 1 );</span><br><span class="line">        int goal , goal1;</span><br><span class="line">        goal1 = a[(n/2+1)/2];</span><br><span class="line">        goal  = a[n/2+(n/2+1)/2];</span><br><span class="line">        for(int i = 1;i &lt;= n/2;i ++)&#123;</span><br><span class="line">            ans += abs( a[i] - goal1 );</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = n/2+1;i &lt;= n;i ++)&#123;</span><br><span class="line">            ans += abs( a[i] - goal );</span><br><span class="line">        &#125;</span><br><span class="line">        if( goal1 == goal )&#123;</span><br><span class="line">            int add , add_temp;add_temp = 0;</span><br><span class="line">            for(int i = 1;i &lt;= n/2;i ++)&#123;</span><br><span class="line">                if( a[i] == goal1 ) add_temp ++;</span><br><span class="line">                else add_temp --;</span><br><span class="line">            &#125;add = add_temp;</span><br><span class="line">            add_temp = 0;</span><br><span class="line">            for(int i = n/2+1;i &lt;= n;i ++)&#123;</span><br><span class="line">                if( a[i] == goal ) add_temp ++;</span><br><span class="line">                else add_temp --;</span><br><span class="line">            &#125;add = min(add_temp,add);</span><br><span class="line">            ans += add;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H题"><a href="#H题" class="headerlink" title="H题"></a>H题</h3><p>思维题</p><p>考虑贪心，为了最大化排的开，我们需要<strong>按左节点排序，当$i=l_i$时加入备选，备选里面按右节点排序</strong></p><p>如果不够了，就说明不存在</p><p>记得判非空</p><p>顺便学习了一下如何结构体根堆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int l , r;</span><br><span class="line">    int id;</span><br><span class="line">&#125;a[N+10];</span><br><span class="line">bool cmp( NODE x , NODE y )&#123;</span><br><span class="line">    return x.l &lt; y.l;</span><br><span class="line">&#125;</span><br><span class="line">struct Comp&#123;</span><br><span class="line">    bool operator()(const NODE&amp; x , const NODE&amp; y)&#123;</span><br><span class="line">        // if( x.r == y.r )</span><br><span class="line">        return x.r &gt; y.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt; NODE , vector &lt; NODE &gt; , Comp &gt; pq;</span><br><span class="line">int ans[N+10];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;a[i].id = i;</span><br><span class="line">    &#125;sort( a + 1 , a + n + 1 , cmp );</span><br><span class="line">    int top = 1 , topi = 1;</span><br><span class="line">    while( top &lt;= n )&#123;</span><br><span class="line">        while( a[topi].l == top ) pq.push( &#123;a[topi].l,a[topi].r,a[topi].id&#125; ) , topi ++;</span><br><span class="line">        if( pq.empty() )&#123;</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if( pq.top().r &gt;= top )&#123;</span><br><span class="line">            ans[pq.top().id] = top;</span><br><span class="line">            pq.pop();top ++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就此，100人以上的题目都补完了</p><p><img src="image-20250128160459794.png" alt></p><h2 id="第二场"><a href="#第二场" class="headerlink" title="第二场"></a>第二场</h2><p><img src="image-20250128160849232.png" alt></p><p>这场被打爆了，D结论题没做出来（根本想不到）</p><p>不过好在H题一个钝角三角形就秒了，没掉太大分</p><p>A题签到</p><p>B题直接排序然后输出<code>a[n/2+1]-1</code>即可</p><p>F题打表找到规律<code>r-l+1</code></p><p>G题直接模拟</p><p>J题也是大模拟（但是没有想象中的毒瘤）</p><h3 id="K题"><a href="#K题" class="headerlink" title="K题"></a>K题</h3><p>直接搜索即可，但是需要一些优化技巧不然会T掉~</p><p>就涂色就可以了，代码还是听清楚的</p><p>感觉难在优化（挂五发的悲哀）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 5e2;</span><br><span class="line">int n , m;</span><br><span class="line">int a[N+10][N+10];</span><br><span class="line">int blue[N+10][N+10];</span><br><span class="line">int rem[N+10][N+10];</span><br><span class="line">string s;</span><br><span class="line">int ans , ans_now;</span><br><span class="line">int most_low;</span><br><span class="line"></span><br><span class="line">void dfs( int i , int j )&#123;</span><br><span class="line">    most_low = max( most_low , i + 1 );</span><br><span class="line">    if( i+1&lt;=n &amp;&amp; a[i+1][j] == 1 &amp;&amp; blue[i+1][j] == 0 ) blue[i+1][j] = 1 , dfs(i+1,j);</span><br><span class="line">    else if( i+1&lt;=n &amp;&amp; blue[i+1][j] == 0 ) blue[i+1][j] = 2 , ans_now ++;</span><br><span class="line">    if( i-1&gt;=1 &amp;&amp; a[i-1][j] == 1 &amp;&amp; blue[i-1][j] == 0 ) blue[i-1][j] = 1 , dfs(i-1,j);</span><br><span class="line">    else if( i-1&gt;=1 &amp;&amp; blue[i-1][j] == 0 ) blue[i-1][j] = 2 , ans_now ++;</span><br><span class="line">    if( j+1&lt;=m &amp;&amp; a[i][j+1] == 1 &amp;&amp; blue[i][j+1] == 0 ) blue[i][j+1] = 1 , dfs(i,j+1);</span><br><span class="line">    else if( j+1&lt;=m &amp;&amp; blue[i][j+1] == 0 ) blue[i][j+1] = 2 , ans_now ++;</span><br><span class="line">    if( j-1&gt;=1 &amp;&amp; a[i][j-1] == 1 &amp;&amp; blue[i][j-1] == 0 ) blue[i][j-1] = 1 , dfs(i,j-1);</span><br><span class="line">    else if( j-1&gt;=1 &amp;&amp; blue[i][j-1] == 0 ) blue[i][j-1] = 2 , ans_now ++;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        for(int j = 0;j &lt; m;j ++)&#123;</span><br><span class="line">            a[i][j+1] = s[j] - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = 2147483647;</span><br><span class="line">    int ii , jj;ii = 1;</span><br><span class="line">    while( 1 )&#123;</span><br><span class="line">        ans_now = 0;</span><br><span class="line">        most_low = 1;</span><br><span class="line">        for(;ii &lt;= n;ii ++)&#123;</span><br><span class="line">            for(jj = 1;jj &lt;= m;jj ++)&#123;</span><br><span class="line">                if( a[ii][jj] )&#123;</span><br><span class="line">                    blue[ii][jj] = 1;</span><br><span class="line">                    dfs( ii , jj );</span><br><span class="line">                    goto OUT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        OUT:;</span><br><span class="line">        ans = min( ans , ans_now );</span><br><span class="line">        for(int i = ii;i &lt;= most_low;i ++)&#123;</span><br><span class="line">            for(int j = 1;j &lt;= m;j ++)&#123;</span><br><span class="line">                if( blue[i][j] )&#123;//1和2都涂为灰色</span><br><span class="line">                    blue[i][j] = 0;</span><br><span class="line">                    a[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H题-1"><a href="#H题-1" class="headerlink" title="H题"></a>H题</h3><p>没想到这题这么简单，答案是钝角（即答</p><p>直接试图构造最钝角的钝角三角形即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a , b , c , d;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int t;cin &gt;&gt; t;while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        if( b - a &gt; d - c )&#123;</span><br><span class="line">            cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; b-1 &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; d-1 &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; c+1 &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; a+1 &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赛后补题-1"><a href="#赛后补题-1" class="headerlink" title="赛后补题"></a>赛后补题</h2><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p>大结论题，完全没想到的一款</p><p>结论：连续子串和不连续子串，最长情况下，只有最后一个（或者第一个）字母不同</p><p>学长给的证明，感觉很清晰易懂</p><p><img src="2ZJTTZLS5UCBN$E]BZQD[JH_tmb.jpg" alt></p><p>赛后多了新数据，特判一下1的时候输出0就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n;</span><br><span class="line">string s;</span><br><span class="line">int a[N+10] , lst[30];</span><br><span class="line">map &lt; int , int &gt; mp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        a[i] = s[i-1] - &#x27;a&#x27; + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxn = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        if( mp[a[i]] ) maxn = max( maxn , lst[a[i]] );</span><br><span class="line">        mp[a[i]] ++ , lst[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= 26;i ++) mp[i] = 0;</span><br><span class="line">    for(int i = n;i &gt;= 1;i --)&#123;</span><br><span class="line">        if( mp[a[i]] ) maxn = max( maxn , n - lst[a[i]] + 1 );</span><br><span class="line">        mp[a[i]] ++ , lst[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    if( maxn == 1 ) maxn = 0;</span><br><span class="line">    cout &lt;&lt; maxn &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题-1"><a href="#C题-1" class="headerlink" title="C题"></a>C题</h3><p>构造题，需要建立在D的结论之上</p><p>不妨先只考虑一个方向（从前往后）</p><p>构造一个串，答案为<strong>最后一个倒数第二个字母</strong>（最大的）</p><p>就，前面半截是<code>abcde...</code>，只要末尾最后俩是对<code>a</code>，就是<code>m=n-1</code></p><p>例如，<code>n=11,m=10</code>，则构造的序列为<code>abcdefghiaa</code>，这时符合条件（只考虑从前往后扫）</p><p>那，还要从后往前扫怎么办~</p><p>对称一下不就好了，即<code>abcdefghiaihgfedcba</code>，这时<code>m=10</code>（虽然<code>n</code>变了）</p><p><code>n=2m+1</code>的时候可以这样子构造，，，那其他情况呢？<code>n&gt;2*m</code>的时候，往中间填充任意字符就可以了（需要是两侧出现过的哦）</p><p>如果<code>n&lt;=2*m</code>，也就是<strong>回文区间大于前缀/后缀</strong>，可以发现我们可以从前缀结束之后直接继续数，例如</p><p><code>abcde fgh edcba</code>这样子，反正这样就可以达到延长子串的作用（不信你试试，答案刚好是前两段的内容（第一种情况下答案只包含第一段+1））</p><p>最后别忘了特判<code>n==m</code>和字母不够（<code>n-m&gt;26</code>）的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n , m;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int t;cin &gt;&gt; t;while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        if( n == m || n - m &gt; 26 )&#123;</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        if( n &gt; m * 2 )&#123;</span><br><span class="line">            for(int i = 1;i &lt;= m;i ++)&#123;</span><br><span class="line">                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = m+1;i &lt;= n-m;i ++)&#123;</span><br><span class="line">                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = m;i &gt;= 1;i --)&#123;</span><br><span class="line">                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i = 1;i &lt;= n-m;i ++)&#123;</span><br><span class="line">                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = 1;i &lt;= 2*m-n;i ++)&#123;</span><br><span class="line">                cout &lt;&lt; (char)(1+&#x27;a&#x27;-1);</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = n-m;i &gt;= 1;i --)&#123;</span><br><span class="line">                cout &lt;&lt; (char)(i+&#x27;a&#x27;-1);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E题-1"><a href="#E题-1" class="headerlink" title="E题"></a>E题</h3><p>哦原来是RMQ算法哇怪不得我不会做原来是因为我不会</p><p>先记下来，明儿个学了再补~</p><h2 id="第三场"><a href="#第三场" class="headerlink" title="第三场"></a>第三场</h2><p><img src="image-20250129202306326.png" alt></p><p>这场发挥比较好，骑马进前10%了（也有可能是题目难度梯度大，恰巧E调出来了）</p><p>A题猜结论按奇偶性分类，随机数最优策略都只拿一个故偶数必败</p><p>M题一个桶结束</p><p>F题模拟一下极端情况，可以发现<code>sum&#123;a,b,c&#125;</code>在<code>n</code>和<code>2n</code>之间是合法的，否则不合法</p><h3 id="C题-2"><a href="#C题-2" class="headerlink" title="C题"></a>C题</h3><p>正解为按字典序排序然后贪心，当然trie树也可以做</p><p>由于最后一步不需要复原，故把最后一个弄成最长的那个即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n , m;</span><br><span class="line">string s[N+10];</span><br><span class="line"></span><br><span class="line">bool cmp( string x , string y )&#123;</span><br><span class="line">    for(int i = 0;i &lt; min(x.length(),y.length());i ++)</span><br><span class="line">        if( x[i] != y[i] ) return (int)(x[i]) &lt; (int)(y[i]);</span><br><span class="line">    return x.length() &lt; y.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    &#125;cin &gt;&gt; m &gt;&gt; m;</span><br><span class="line">    sort( s + 1 , s + n + 1 , cmp );</span><br><span class="line">    string now_str = &quot;&quot;;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        while( now_str != s[i] )&#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for(;j &lt; min(now_str.length(),s[i].length());j ++)</span><br><span class="line">                if( now_str[j] != s[i][j] ) break;</span><br><span class="line">            ans += ( s[i].length() + now_str.length() - j*2 );</span><br><span class="line">            now_str = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int long_max = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        long_max = max( long_max , (int)s[i].length() );</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + (int)now_str.length() - long_max &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="L题"><a href="#L题" class="headerlink" title="L题"></a>L题</h3><p>算是个构造+小模拟</p><p>我的策略如下</p><p>初始下，不妨设酱紫</p><p><img src="3L1.jpg" alt></p><p>构造，先把右上角这条线，从上到右下画了</p><p><img src="3L2.jpg" alt></p><p>然后通过以下规则进行填充</p><p><img src="3L3.jpg" alt></p><p>按照紫色的规则，填充到最左侧，然后往上两个（见红色）</p><p><img src="3L4.jpg" alt></p><p>再按如图的规则填充到最右侧</p><p><img src="3L5.jpg" alt></p><p>现在就回到了最右侧，之后按照之前的步骤，就可以填充所有的节点</p><p><img src="3L6.jpg" alt></p><p>通过代码实现上述内容即可，数据范围比较小，调试通过了大概率就能过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[10][10];</span><br><span class="line"></span><br><span class="line">void out( int i , int j )&#123;</span><br><span class="line">    cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">    // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n;cin &gt;&gt; n;n ++;cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        for(int j = 1;j &lt;= n;j ++)&#123;</span><br><span class="line">            if( i &gt;= j )&#123;</span><br><span class="line">                cnt ++;a[i][j] = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">    //     for(int j = 1;j &lt;= n;j ++)&#123;</span><br><span class="line">    //         cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">    //     &#125;cout &lt;&lt; endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        out(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = n;i &gt;= 1;i --)&#123;</span><br><span class="line">        for(int j = i-1;j &gt;= 1;j --)&#123;</span><br><span class="line">            // cout &lt;&lt; &quot;start: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            if( j == 1 )&#123;</span><br><span class="line">                out(i,j);</span><br><span class="line">                i--;out(i,j);</span><br><span class="line">                if( i &gt; 1 ) &#123;i--;out(i,j);&#125;</span><br><span class="line">                while( j &lt; i )&#123;</span><br><span class="line">                    i++,j++;out(i,j);</span><br><span class="line">                    i--;out(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                out(i,j);</span><br><span class="line">                i--;out(i,j);</span><br><span class="line">                j--;out(i,j);</span><br><span class="line">                j++,i++;out(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">            // cout &lt;&lt; &quot;round: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E题-2"><a href="#E题-2" class="headerlink" title="E题"></a>E题</h3><p>因为是弹性碰撞，所以我们可以认为<strong>两个球碰撞等价于两个球相互穿过</strong>（后面的讨论都基于此）</p><p>只考虑向右和向左的球，故如果知道了时间 $t$，我们只需要确定是否存在大于 $k$ 个球的间距不小于 $2t$ 且左侧的球是向右走，右侧的球向左走</p><p>故我们将两侧的球分别记录，然后二分时间即可</p><p>值得注意的是，向右走的球与其左侧的向左走的球永远不可能相撞，故记录一下进行减法运算即可</p><p>从后往前扫，累计加入答案，这样可以让一次check的时间复杂度降到$O(n)$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n , k;</span><br><span class="line">struct BOLL</span><br><span class="line">&#123;</span><br><span class="line">    int p , v;</span><br><span class="line">&#125;b[N+10];</span><br><span class="line">int distl[N+10] , distr[N+10] , uselessp[N+10];</span><br><span class="line">int ltop , rtop;</span><br><span class="line"></span><br><span class="line">bool cmp( BOLL x , BOLL y )&#123;</span><br><span class="line">    return x.p &lt; y.p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int check( long double dist )&#123;</span><br><span class="line">    // cout &lt;&lt; &quot;dist: &quot; &lt;&lt; dist &lt;&lt; endl;</span><br><span class="line">    int ans = 0 , i , j;i = j = 1;</span><br><span class="line">    while( i &lt;= ltop &amp;&amp; j &lt;= rtop + 1 )&#123;</span><br><span class="line">        if( distr[j] - distl[i] &lt;= dist &amp;&amp; j != rtop+1 )&#123;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ans += ( j-1 - uselessp[i] );</span><br><span class="line">            // cout &lt;&lt; &quot;ans: &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // cout &lt;&lt; &quot;dist k: &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long double ef( long double l , long double r )&#123;</span><br><span class="line">    if( r - l &lt;= 1e-8 ) return l;</span><br><span class="line">    long double mid = (l+r)/2;</span><br><span class="line">    if( check( mid ) &gt;= k ) return ef(l,mid);</span><br><span class="line">    else return ef(mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; b[i].p &gt;&gt; b[i].v;</span><br><span class="line">    &#125;sort( b + 1 , b + n + 1 , cmp );</span><br><span class="line">    int useless = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        if( b[i].v == 1 ) distl[++ltop] = b[i].p , uselessp[ltop] = useless;</span><br><span class="line">        else distr[++rtop] = b[i].p , useless ++;</span><br><span class="line">    &#125;</span><br><span class="line">    // for(int i = 1;i &lt;= ltop;i ++) cout &lt;&lt; distl[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;</span><br><span class="line">    // for(int i = 1;i &lt;= ltop;i ++) cout &lt;&lt; uselessp[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;</span><br><span class="line">    // for(int i = 1;i &lt;= rtop;i ++) cout &lt;&lt; distr[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    int reference = 0;</span><br><span class="line">    for(int i = 1;i &lt;= ltop;i ++) reference += (rtop-uselessp[i]);</span><br><span class="line">    // cout &lt;&lt; reference &lt;&lt; endl;</span><br><span class="line">    if( k &gt; reference )&#123;</span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        long double ans = ef( 0 , 1e9 );</span><br><span class="line">        printf(&quot;Yes\n%0.8Lf\n&quot;,ans/2);</span><br><span class="line">    &#125;</span><br><span class="line">    // cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赛后补题-2"><a href="#赛后补题-2" class="headerlink" title="赛后补题"></a>赛后补题</h2><h3 id="G题"><a href="#G题" class="headerlink" title="G题"></a>G题</h3><p>打个表先~</p><p><img src="image-20250201120517119.png" alt></p><p>从后往前看，发现是等差数列</p><p>先是公差为1，然后公差为2，之后3…</p><p>故可以分块，公差相同的一组分到一个块</p><p>然后二分符合条件的数值（第前k项对应的数值）；对于每个块，知道了首项和公差，所以可以$O(1)$计算有多少个符合条件的；总共有$\sqrt{n}$个块。故此算法的时间复杂度为$O(\sqrt{n}\log n)$</p><p>值得注意的是，二分的写法有点不太传统~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n , k;</span><br><span class="line">int vtot , val;</span><br><span class="line"></span><br><span class="line">int cnt( int num )&#123;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for(int l = 1,r;l &lt;= n;l = r + 1)&#123;</span><br><span class="line">        r = n / ( n / l );</span><br><span class="line">        int a = n - n / l * l;</span><br><span class="line">        int b = n / l;</span><br><span class="line">        if( a &lt; num ) continue;</span><br><span class="line">        tot += min( (a-num)/b+1 , r - l + 1 );</span><br><span class="line">    &#125;return tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ef( int l , int r )&#123;</span><br><span class="line">    if( l &gt; r ) return ;</span><br><span class="line">    int mid = (l+r)/2;</span><br><span class="line">    int tot = cnt(mid);</span><br><span class="line">    if( tot &lt; k )&#123;</span><br><span class="line">        vtot = tot , val = mid;</span><br><span class="line">        ef( l , mid - 1 );</span><br><span class="line">    &#125;</span><br><span class="line">    else ef( mid + 1 ,  r );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// void ef( int l , int r )&#123;</span><br><span class="line">//     if( l &lt;= r ) return ;</span><br><span class="line">//     int mid = (l+r)/2;</span><br><span class="line">//     int tot = cnt(mid);</span><br><span class="line">//     if( tot &lt; k )&#123;</span><br><span class="line">//         vtot = tot , val = mid;</span><br><span class="line">//         ef( l , mid );</span><br><span class="line">//     &#125;</span><br><span class="line">//     else ef( mid + 1 ,  r );</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ef( 1ll , n );</span><br><span class="line">    // cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; vtot &lt;&lt; endl;</span><br><span class="line">    int ans = ( k - vtot ) * ( val - 1 );</span><br><span class="line">    // cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    for(int l = 1,r;l &lt;= n;l = r + 1)&#123;</span><br><span class="line">        r = n / ( n / l );</span><br><span class="line">        int a = n - n / l * l;</span><br><span class="line">        int b = n / l;</span><br><span class="line">        if( a &lt; val ) continue;</span><br><span class="line">        int len = min((a - val) / b + 1, r - l + 1);</span><br><span class="line">        ans += (a * 2 - b * (len - 1)) * len / 2;</span><br><span class="line">        // cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四场"><a href="#第四场" class="headerlink" title="第四场"></a>第四场</h2><p><img src="image-20250206185947578.png" alt></p><p>这场代码量太大了（悲</p><p>K题签到题，直接取最大值即可</p><p>I题直接扫一遍即可</p><p>B题直接枚举即可，C就不会了（悲</p><p>E题直接开扫，我写的依托~</p><h3 id="D题-1"><a href="#D题-1" class="headerlink" title="D题"></a>D题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int t , n , m;</span><br><span class="line">string a , b;</span><br><span class="line"></span><br><span class="line">map &lt; char , int &gt; mp;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mp.clear();</span><br><span class="line">        if( n &lt; m )&#123;</span><br><span class="line">            string c = a;</span><br><span class="line">            a = b , b = c;</span><br><span class="line">            swap( n , m );</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; a.length();i ++)&#123;</span><br><span class="line">            mp[a[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; b.length();i ++)&#123;</span><br><span class="line">            mp[b[i]] --;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 0;i &lt;= 26;i ++)&#123;</span><br><span class="line">            if( mp[i+&#x27;a&#x27;] &lt; 0) ans -= mp[i+&#x27;a&#x27;] , mp[i+&#x27;a&#x27;] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp_del = 0 , rel = 0;</span><br><span class="line">        for(int i = 0;i &lt;= 26;i ++)&#123;</span><br><span class="line">            if( mp[i+&#x27;a&#x27;] &gt;= 2 ) temp_del += mp[i+&#x27;a&#x27;] / 2;</span><br><span class="line">            rel += mp[i+&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += rel-min( temp_del * 2 , n - m );</span><br><span class="line">        cout &lt;&lt; ans/2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赛后补题-3"><a href="#赛后补题-3" class="headerlink" title="赛后补题"></a>赛后补题</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF补题小合集</title>
      <link href="/2025/01/19/CF%E8%A1%A5%E9%A2%98%E5%B0%8F%E5%90%88%E9%9B%86/"/>
      <url>/2025/01/19/CF%E8%A1%A5%E9%A2%98%E5%B0%8F%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>由于后续CF比赛基本只参加VP，故特此记录一下</p><span id="more"></span><hr><h3 id="2025-01-17"><a href="#2025-01-17" class="headerlink" title="2025.01.17"></a>2025.01.17</h3><p><a href="https://codeforces.com/contest/2055">Codeforces Round 996 (Div. 2)</a></p><p>这把打爽了，表现分差点上紫，D题最后一分钟调出来过样例 结果WA2了</p><p><img src="1.png" alt></p><h4 id="C题"><a href="#C题" class="headerlink" title="C题"></a><a href="https://codeforces.com/contest/2055/problem/C">C题</a></h4><p>构造题</p><p>我们从<code>(1,1)</code>开始思考，假设场景是这样的</p><p><img src="1.jpg" alt="1"></p><p>设每行每列的和都为$S$，故<code>(1,1)</code>的数值和$S$的大小成线性关系</p><p>也就是说，知道$S$就能通过这一行的数求出<code>(1,1)</code>的数值（如蓝色所示）</p><p><img src="2.jpg" alt></p><p>同理，知道$S$就能求出第二行的数值（如紫色所示）</p><p><img src="3.jpg" alt></p><p>按顺序（沿路径）向下递推，就必然可以计算出下一个方格的数据（如红色所示）</p><p><img src="4.jpg" alt></p><p>故得出结论：<strong>如果该位置的下一个是R，则通过列计算；否则通过行计算</strong></p><p>但是$S$还不知道哇~</p><p>梅瓜吸，$S$是多少都可以，我直接让它是0（更正式的，由$x+1$个未知数的$x$个方程构成的方程组中，存在一个自由量，<strong>这个自由量可以是S</strong>；其中$x=n+m-2$）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e3;</span><br><span class="line">int n , m;int a[N+10][N+10];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            for(int j = 1;j &lt;= m;j ++)&#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int x , y;x = y = 1;</span><br><span class="line">        for(int p = 0,i,j;p &lt; s.length();p ++)&#123;</span><br><span class="line">            if( s[p] == &#x27;D&#x27; )&#123;</span><br><span class="line">                for(j = 1;j &lt;= m;j ++)&#123;</span><br><span class="line">                    if( j == y ) continue;</span><br><span class="line">                    a[x][y] += a[x][j];</span><br><span class="line">                &#125;a[x][y] = -a[x][y];</span><br><span class="line">                x ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if( s[p] == &#x27;R&#x27; )&#123;</span><br><span class="line">                for(i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">                    if( i == x ) continue;</span><br><span class="line">                    a[x][y] += a[i][y];</span><br><span class="line">                &#125;a[x][y] = -a[x][y];</span><br><span class="line">                y ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 1;j &lt; m;j ++) a[n][m] += a[n][j];</span><br><span class="line">        a[n][m] = -a[n][m];</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            for(int j = 1;j &lt;= m;j ++)&#123;</span><br><span class="line">                cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D题"><a href="#D题" class="headerlink" title="D题"></a><a href="https://codeforces.com/contest/2055/problem/D">D题</a></h4><p>不容易的思维题，不过只要逻辑理清楚了，都很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">考虑以下策略</span><br><span class="line">仅考虑两个相邻的点</span><br><span class="line">如果二者的距离小于k，则可以直接越过去，a[i]的值尽可能的大</span><br><span class="line">如果二者的距离大于k但是小于k+已过去的时间，则右侧点有能力移动到a[i-1]+k，也不需要额外消耗时间</span><br><span class="line">如果二者的距离大于k+已过去的时间，则右侧点应当从一开始就开始全力左移，并二者相向而行，代价是相向而行的时间</span><br></pre></td></tr></table></figure><p>值得注意的是，long double最后要转成long long不然输出的可能是科学计数法（WA6）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n , k , l;</span><br><span class="line">long double ans , time_now;</span><br><span class="line">long double a[N+10];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;ans = 0;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k &gt;&gt; l;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];</span><br><span class="line">        ans += a[1]*2;</span><br><span class="line">        time_now = a[1];</span><br><span class="line">        a[1] = 0;</span><br><span class="line">        for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">            if( a[i] - a[i-1] &gt; k )&#123;</span><br><span class="line">                if( a[i] - a[i-1] &gt; k + time_now )&#123;</span><br><span class="line">                    a[i] -= time_now;</span><br><span class="line">                    ans += (a[i] - a[i-1] - k);</span><br><span class="line">                    time_now += (a[i] - a[i-1] - k)/2;</span><br><span class="line">                    a[i] -= (a[i] - a[i-1] - k) / 2;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    a[i] = a[i-1] + k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                a[i] = min( a[i-1] + k , a[i] + time_now );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += max( (l - a[n] - k )*2 , (long double)0 );</span><br><span class="line">        cout &lt;&lt; (long long)ans &lt;&lt; endl;</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT制作总结</title>
      <link href="/2025/01/11/PPT%E5%88%B6%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2025/01/11/PPT%E5%88%B6%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结各种情况下的PPT如何制作</p><span id="more"></span><hr><h3 id="1-组会汇报"><a href="#1-组会汇报" class="headerlink" title="1. 组会汇报"></a>1. 组会汇报</h3><p>面向导师和同学，强调科研进展汇报和交流</p><ul><li><p>格式要求：</p><ul><li>中文字体：微软雅黑；英文字体：Times New Roman</li><li>字体大小：最小不得低于18号，推荐20号及以上</li><li>排版设计：背景简洁，切忌使用动画</li></ul></li><li><p>内容呈现：</p><ul><li>注重清晰性：多用图表，少用文字描述</li><li>重点突出：用颜色标注关键结果或问题</li></ul></li><li><p>汇报技巧：</p><ul><li>简明扼要：不必深入每个细节，重点汇报进展和结果</li></ul></li><li><p>时间分配</p><p>汇报主体（30-40分钟）</p><ul><li><p>研究背景（5-10分钟）：</p><ul><li>简述问题来源和研究意义，回顾之前的研究进展</li><li>提供上下文，使组内成员对你的工作方向和目标有清晰认知</li></ul></li><li><p>研究方法与设计（10-15分钟）：</p><ul><li>展示研究方法、算法设计或实验过程</li><li>强调你的创新点及其理论依据</li></ul></li><li><p>研究结果与分析（10-15分钟）：</p><ul><li>使用清晰的图表或数据展示结果</li><li>对结果进行定量和定性分析，回答“为什么会出现这些结果”</li></ul></li><li><p>未解问题与计划（5分钟）：</p><ul><li>列出当前面临的技术问题或挑战</li><li>说明下一步计划，寻求导师或同事建议</li></ul></li></ul><p>讨论与反馈（20-30分钟）</p><ul><li>预留充足时间与导师及组内成员交流</li><li>主动提问，展示你对未解问题的思考和希望获得的反馈</li></ul></li></ul><h3 id="2-学术会议汇报"><a href="#2-学术会议汇报" class="headerlink" title="2. 学术会议汇报"></a>2. 学术会议汇报</h3><p>面向领域内专家学者，突出科研成果和创新点</p><ul><li>PPT设计：<ul><li>简洁专业：每页聚焦一个主题，内容适量，每页文字不超过6行</li><li>色彩搭配：背景与字体对比鲜明，常用白底黑字或深色底白字</li><li>数据可视化：使用高质量图表展示数据，标明单位和轴标签</li></ul></li><li>内容结构：<ul><li>开头：研究背景、意义和问题</li><li>中间：研究方法、实验设计、结果和分析</li><li>结尾：关键结论与未来展望</li></ul></li><li>表达要点：<ul><li>语言清晰：用学术语言简洁表达，避免过多术语</li><li>逻辑分明：按逻辑线索推进（背景→问题→方法→结果→结论）</li><li>时间把控：提前排练，遵守会议规定的时间限制</li></ul></li></ul><h3 id="3-宣讲和授课"><a href="#3-宣讲和授课" class="headerlink" title="3. 宣讲和授课"></a>3. 宣讲和授课</h3><p>以传播知识为目的，强调互动和易懂性</p><ul><li>视觉设计：<ul><li>突出重点：大标题、分点呈现，字体建议30号及以上，图文结合</li><li>多媒体辅助：适量使用图片、视频或动画吸引注意力，但避免复杂特效</li></ul></li><li>内容设计：<ul><li>突出逻辑：每部分开头设置提纲或总结，引导听众理解</li><li>提供实例：结合案例或实验结果说明抽象概念</li><li>控制节奏：通过提问、互动或练习激发参与感</li></ul></li><li>汇报技巧：<ul><li>语速适中，注重语气和肢体语言</li><li>注意听众反应，适时调整节奏和内容深度</li></ul></li></ul><h3 id="4-挑战杯竞赛"><a href="#4-挑战杯竞赛" class="headerlink" title="4. 挑战杯竞赛"></a>4. 挑战杯竞赛</h3><p>我没学会（大哭</p><h3 id="通用注意事项"><a href="#通用注意事项" class="headerlink" title="通用注意事项"></a>通用注意事项</h3><ul><li><p>排版与设计：</p><ul><li>每页内容不要过多，控制在1-2分钟内讲完</li><li>避免花哨背景，确保简洁和专业</li></ul></li><li><p>时间管理：</p><ul><li>提前排练并计时，预留答疑时间</li></ul></li><li><p>表达技巧：</p><ul><li>语速适中，语言清晰，确保观众能跟上节奏</li></ul></li><li>保持自信，避免频繁低头看稿</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安数基复习笔记</title>
      <link href="/2025/01/08/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%9F%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/08/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%9F%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="27446199_6cdb64b4-3ac0-4581-a465-b43263aa54a3.png" alt></p><span id="more"></span><h3 id="往年期末考试题目"><a href="#往年期末考试题目" class="headerlink" title="往年期末考试题目"></a>往年期末考试题目</h3><p><img src="image-20250107164952728.png" alt></p><p>$(x,y)=(3y+4z,y)=(4z,y)$</p><p>故A正确</p><p><img src="image-20250107165514398.png" alt></p><p>简化剩余系：与模数互素且不同余</p><p>与15不互素：$1,3,5,6,9,10,12,15$</p><p>故一个简化剩余系为 ${2,4,7,8,11,13,14}$</p><p>也可以写作 ${7,8,11,13,14,17,19}$</p><p>故C正确</p><p><img src="image-20250107170442079.png" alt></p><p>B. 整数模素数剩余类环都是域，故B正确</p><p>C. 整环的定义是没有零因子，3*4=12是0，故C错误</p><p><img src="image-20250107171324523.png" alt></p><p>原根存在的充要条件 $m=p^k$ 或 $2p^k$，其中 $p$ 为素数，$k\ge1$</p><p>故选D</p><p><img src="image-20250107171926343.png" alt></p><p>A. pa=0，错误</p><p>B. 费马小定理是 $a^{p-1}=1$，错误</p><p>C. 正确</p><p><img src="image-20250107172433174.png" alt></p><p>$7x$</p><p><img src="image-20250107172457957.png" alt></p><p>$x$的原根数为$\phi(\phi(x))$</p><p>22</p><p><img src="image-20250107172810022.png" alt></p><p>85=5*17</p><p>$x^2\equiv1\mod5$ 和 $x^2\equiv1\mod17$ 的解数之和</p><p>分别有两个解（分别是$(1,2)$和$(1,4)$）</p><p>故总共有四个解</p><p><img src="image-20250107173659148.png" alt></p><p>$|G/H|=\frac{|G|}{|H|}=3$</p><p><img src="image-20250107173851083.png" alt></p><p>$GF(16)$是一个阶为16的有限域，则$GF(16)^*$是一个阶为$15$的循环群</p><p>在一个循环群中，任意元素的阶是$15$的正约数。也就是说，$GF(16)$中非零元素的可能乘法阶是$15$的正约数</p><p>故可能取值为${3,5,15}$</p><p><img src="image-20250107174825860.png" alt></p><script type="math/tex; mode=display">\begin{align}&4^{173}\\=&16^{86}*4\\=&43^{43}*4\\=&3^{21}*43*4\\=&9^{10}*3*43*4\\=&10^5*3*43*4\\=&29^2*10*3*43*4\\=&40\end{align}</script><p><img src="image-20250107180648221.png" alt></p><p>第一步，计算所有模数的乘积$M$</p><p>$M=m_1<em>m_2</em>m_3=140$</p><p>第二步，计算每个模数对应部分的乘积$M_i$</p><p>$M_1=35, M_2=28, M_3=20$</p><p>第三步，计算$M_i$在$m_i$下的逆元</p><p>$inv_1=3, inv_2=2, inv_3=6$</p><p>第四步，计算新的$x$</p><p>$x=\sum(a_i<em>M_i</em>inv_i)\%M=17$</p><p>通式：余数乘以模余乘以其逆</p><p><img src="image-20250107194431327.png" alt></p><p>(1) $(\frac{40}{71})=(\frac{40\%71}{71})=(\frac{40}{71})=40^\frac{71-1}2\mod71=40^{35}\mod71$</p><script type="math/tex; mode=display">\begin{align}&40^{35}\\=&40*38^{17}\\=&40*38*25^8\\=&40*38*8^4\\=&40*38*4096\\=&40*38*49\\=&1\end{align}</script><p>$p=71$ 满足 $p=4k+3$</p><p>故 $x=\pm a^\frac{p+1}4=\pm40^{18}\mod71=18$或$53$</p><p>(2) $(\frac3{119})=(\frac37)(\frac3{17})$</p><p>$(\frac37)=3^\frac{7-1}2\mod7=1$</p><p>$(\frac3{17})=3^\frac{17-1}2\mod17=-1$</p><p>故 $(\frac3{119})=-1$，$x^2≡3\mod119$ 无解</p><p><img src="image-20250107203358255.png" alt></p><p>(1) 封闭性：如果$A,B\in GL(3,Q)$，则$AB\in GL(3,Q)$；由于$det(AB)=det(A)det(B)\neq0$，且$AB$元素皆为有理数，因此$AB\in GL(3,Q)$</p><p>结合律：矩阵乘法满足结合律，即 $(AB)C=A(BC)$</p><p>单位元存在：单位矩阵$I_3\in GL(3,Q)$，且对任意$A\in GL(3,Q)$，有$AI_3=I_3A=A$</p><p>逆元存在：对于$A\in GL(3,Q)$，其逆矩阵$A^{-1}\in GL(3,Q)$，因为$det(A^{-1})=\frac1{det(A)}\neq0$</p><p>证明$GL(3,Q)$是非交换群，找到反例即可</p><p><img src="image-20250107204718561.png" alt></p><p>显然$AB\neq BA$，故$GL(3,Q)$是非交换群</p><p>(2) 定义$SL(3,Q)={A\in GL(3,Q)|det(A)=1}$，正规子群需要验证两点</p><p>$SL(3,Q)$是子群</p><p>封闭性：如果$A,B\in SL(3,Q)$，则$AB\in SL(3,Q)$；由于$det(AB)=det(A)det(B)=1$，因此$AB\in SL(3,Q)$</p><p>结合律：矩阵乘法满足结合律，即 $(AB)C=A(BC)$</p><p>单位元：单位矩阵$I_3\in SL(3,Q)$，因为$det(I_3)=1$</p><p>逆元：对于$A\in SL(3,Q)$，其逆矩阵$A^{-1}\in SL(3,Q)$，因为$det(A^{-1})=\frac1{det(A)}=1$</p><p>因此$SL(3,Q)$是子群</p><p>$SL(3,Q)$是正规子群</p><p>对任意$A\in GL(3,Q),B\in SL(3,Q)$</p><p>$det(ABA^{-1})=det(A)<em>1</em>\frac1{det(A)}=1$</p><p>因此 $AB^A{-1}\in SL(3,Q)$</p><p>故$SL(3,Q)$是$GL(3,Q)$的正规子群</p><p>(3)markdown学不会了（恼</p><p><img src="image-20250107205742872.png" alt></p><p><img src="image-20250107205811614.png" alt></p><p>(1) 多项式 $m(x)\in GF(2)[x]$是不可约的，当前仅当它不可分解为两个低阶非常数多项式的积</p><p><img src="image-20250107211228913.png" alt></p><p><img src="image-20250107211326507.png" alt></p><h3 id="拓欧算法"><a href="#拓欧算法" class="headerlink" title="拓欧算法"></a>拓欧算法</h3><p>(a,b)=(b,a%b)</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><h3 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h3><h3 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h3><h3 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h3><p>求原根：</p><ol><li>确定是否存在原根</li><li>计算$\phi(n)$</li><li>计算$\phi(n)$的所有素因子</li><li>检验原根，当前仅当对$\phi(n)$的每个素因子都满足 $g^\frac{\phi(n)}p\neq1\mod n$</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IND-CCA2下的CP-ABE安全</title>
      <link href="/2025/01/07/IND-CCA2%E4%B8%8B%E7%9A%84CP-ABE%E5%AE%89%E5%85%A8/"/>
      <url>/2025/01/07/IND-CCA2%E4%B8%8B%E7%9A%84CP-ABE%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>今天阅读前置知识，搞了半天终于明白了IND-CCA2下的CP-ABE安全，记录一下</p><span id="more"></span><hr><p>论文名称：Fine-Grained and Controlled Rewriting in Blockchains: Chameleon-Hashing Gone Attribute-Based</p><p>相关内容：</p><p><img src="image-20250107152801165.png" alt></p><p><img src="image-20250107152841979.png" alt></p><p>我们只看核心部分</p><p><img src="image-20250107152931245.png" alt></p><p>我们大致划分为三个部分</p><p>第一部分，初始化，不再赘述</p><p>第二部分，攻击者交互阶段，攻击者$\mathcal{A}$选择任意属性集合$\mathbb{S}$进行请求，模拟器会这些请求的属性集合加入全局集合$S$，并生成与属性集合$\mathbb{S}$相对应的私钥$ssk$，将请求编号及生成的密钥记录到$Q$中</p><p>第三部分，挑战阶段，攻击者$\mathcal{A}$提供属性集合$A^<em>$（$A^</em>\cap S=\emptyset$），模拟器随机选择$b\in{0,1}$，使用属性集合$A^*$对应的私钥加密$m_b$，将密文$c_b$提供给$\mathcal{A}$ </p><p>如果攻击者$\mathcal{A}$能够通过交互获得的信息区分密文中加密的是$m_0$还是$m_1$，且成功的概率显著大于$\frac12$，则认为攻击者成功，算法被攻破，否则认为该加密方案满足IND-CCA2安全性</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构不是有手就行（陈述句</title>
      <link href="/2025/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E6%98%AF%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%88%E9%99%88%E8%BF%B0%E5%8F%A5/"/>
      <url>/2025/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E6%98%AF%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%88%E9%99%88%E8%BF%B0%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>数据结构没有很多题目，所以只能通过知识点为索引进行复习</p><p>知识点来源是学长给的文档和期中考试题目</p><span id="more"></span><hr><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>前序遍历 根-&gt;左子树-&gt;右子树<br>中序遍历 左子树-&gt;根-&gt;右子树<br>后序遍历 左子树-&gt;右子树-&gt;根</p><p>差异：访问到根节点的条件</p><h4 id="已知先序序列和中序序列求树"><a href="#已知先序序列和中序序列求树" class="headerlink" title="已知先序序列和中序序列求树"></a>已知先序序列和中序序列求树</h4><p><img src="image-20250106142613576.png" alt></p><p>解题步骤：</p><ol><li>从前序遍历的第一个节点找到根节点</li><li>在中序遍历中找到这个根节点，根节点左侧的部分是左子树，右侧的部分是右子树</li><li>根据分割出的左右子树，在前序遍历中找到相应的部分（保持顺序），递归重复前两个步骤直到完成树的构造</li></ol><h4 id="已知中序序列和后序序列求树"><a href="#已知中序序列和后序序列求树" class="headerlink" title="已知中序序列和后序序列求树"></a>已知中序序列和后序序列求树</h4><p>解题步骤：</p><ol><li>从后序遍历的最后一个节点找到根节点</li><li>在中序遍历中找到这个根节点，根节点左侧是左子树，右侧部分是右子树</li><li>根据分割出的左右子树，在后序遍历中找到相应的部分（保持顺序），递归重复前两个步骤直到完成树的构造</li></ol><h4 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h4><p>后序线索二叉树是一种特殊的二叉树，它在普通二叉树的基-础上，通过为二叉树的结点增加“线索指针”来优化树的遍历效率<br>这种线索指针的引入，使得二叉树的后序遍历可以在不使用递归或栈的情况下完成</p><p>简单的来说，线索化就是把X序序列转成双向链表的形式（如果已有一条边，则无需返程）</p><p><img src="image-20250106150044907.png" alt></p><h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><p>哈夫曼树是一种带权路径长度最短的二叉树，构造基于贪心算法</p><p>其中，权值为节点的频率（或权重），路径长度为根节点到某个节点的路径中边的数量，带权路径长度为路径长度乘以节点的权值</p><p>哈夫曼树的目标是让带权路径长度（WPL）的总和最小</p><p>特定：没有任何一个权值小的节点比权值大的节点更靠近根的位置</p><h4 id="树的构造"><a href="#树的构造" class="headerlink" title="树的构造"></a>树的构造</h4><ol><li>初始化：将每个权值看作一个独立的节点，每个节点都是一棵单结点树</li><li>选择最小的两个权值：从当且森林中找到两个权值最小的树作为左右子树构造一个新树，新树的根节点权值为这两棵树权值之和，删除旧树</li><li>重复步骤，直到森林中只剩下一棵树</li></ol><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>是一种可变长度的编码方案，基于哈夫曼树生成</p><ol><li>无前缀性：没有一个编码是另一个编码的前缀，确保了解码的唯一性</li><li>长度与频率相关：频率高的字符使用较短的编码，频率低的字符使用较长的编码</li><li>权重分配：从根节点开始，左子树路径赋值为0，右子树路径赋值为1；到达叶子结点时，记录从根到该节点的编码</li></ol><p>例题：某通讯系统只使用8种字符a、b、c、d、e、f、g、h，其使用频率分别为0.05, 0.29, 0.07, 0.08, 0.14, 0.23, 0.03, 0.11，利用赫夫曼树设计一种前缀编码</p><p><img src="image-20250106154901650.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a: 0110</span><br><span class="line">b: 10</span><br><span class="line">c: 1110</span><br><span class="line">d: 1111</span><br><span class="line">e: 110</span><br><span class="line">f: 00</span><br><span class="line">g: 0111</span><br><span class="line">h: 010</span><br></pre></td></tr></table></figure><p>保证所有节点都是叶节点即可避免前缀冲突性（每个字符路径唯一，而且没有叶节点在另一个叶节点路径上）</p><h3 id="图相关"><a href="#图相关" class="headerlink" title="图相关"></a>图相关</h3><p>邻接矩阵：就是个二维数据</p><p>邻接表：就是个链表</p><p>极大联通子图（强联通分量）：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通；用于缩点</p><p>极小联通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通；用于生成树</p><p>强连通图：任意两个点之间有双向可抵达的通路</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>选择已知树上的最小边并加入</p><ol><li>从任意一个顶点开始，将它加入生成树</li><li>每次选择一条权值最小、且值连接生成树中顶点与生成树外顶点的边</li><li>重复步骤2，直到生成树包含图中的所有顶点</li></ol><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>选择最小边并判断是否成环</p><ol><li>将所有的边按边权从小到大排序</li><li>从权值最小的开始，逐条简称该边是否成环（并查集）<ul><li>如果不成环，则加入生成树</li><li>如果形成环，则跳过这条边</li></ul></li><li>重复步骤2，直到生成树包含n-1条边</li></ol><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>见<a href="https://coperlm.github.io/2025/01/06/红黑树学习/">二叉平衡树</a>一章</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>这么难我都看不懂</p>]]></content>
      
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树学习</title>
      <link href="/2025/01/06/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/06/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>BST 二叉查找树 -&gt; AVL 平衡二叉树 -&gt; RBT 红黑树</p><span id="more"></span><hr><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ol><li>左子树上所有结点的值均小于或等于它的根结点的值</li><li>右子树上所有结点的值均大于或等于它的根结点的值</li><li>左、右子树也分别为二叉排序树</li></ol><p>理想情况下是这样子</p><p><img src="8555d3dc4ccc9c65bd59977ff14397ee.png" alt></p><p>存在的问题：如果BST树的节点正好从大到小的插入，此时树的结构也类似于链表结构，这时候的查询或写入耗时与链表相同，最坏时间复杂为线性</p><p>这时候就有了平衡二叉树AVL（发明者名字简写）</p><p>AVL也属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ol><li>AVL树是最先发明的自平衡二叉查找树</li><li>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树</li><li>增加和删除可能需要通过一次或多次树旋转来重新平衡这个树</li></ol><p>平衡二叉树的特性</p><ol><li><p>对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大</p></li><li><p>对于AVL树而言，其中任何子树仍然是AVL树</p></li><li>每个节点的左右子节点的高度之差的绝对值最多为1</li></ol><p>也就是说，AVL树=BST树+自平衡功能</p><p>具体怎么旋转？</p><p>记住这四张图就好</p><p><img src="82f3502b5be24051bd7688b1e0f36135.png" alt></p><p><img src="dea622e0576539552458e3afcffb1f59.png" alt></p><p><img src="a50f45a2c27e4f330603481789d5234c.png" alt></p><p><img src="24326f9fded29e6f566738f86525d468.png" alt></p><p>那如何删除呢？</p><ol><li>叶子节点直接删除，判断平衡进行调整直到根节点</li><li>只有左（或右）子树，节点删除，以左（或右）子树替代，判断平衡进行调整直到根节点</li><li>删除的节点既有左子树又有右子树，找到其前驱节点（左子树中最大值的节点）或者后驱节点（右子树中最小值的节点）将其替换，判断平衡进行调整直到根节点</li></ol><p>缺点：</p><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;= 1</p><p>所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡</p><p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于查询场景（而不是增加删除频繁的场景）</p><p>红黑树：牺牲了部分平衡性，以换取插入/删除操作时较少的旋转操作，整体来说性能要优于AVL树</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ol><li>节点非黑即红（颜色属性）</li><li>根节点一定是黑色（根属性）</li><li>叶子节点（NIL）一定是黑色（叶子属性）</li><li>每个红色节点的两个子节点都为黑色（红色属性）</li><li>从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点（平衡属性）</li></ol><p><img src="20200901114718174.png" alt></p><p>RBT使用空间去换时间，在AVL的节点上，增加了<strong>颜色属性</strong>的数据，换取后面平衡操作的次数减少</p><p>红黑树并不是一棵平衡二叉树（见图），但是基于<code>性质5</code>，从任一节点到每个叶子的所有路径都包含相同数目的黑色节点，故 以黑色节点的高度作为约束，RBT的左子树和右子树的层数是相同的</p><p>红黑树的平衡称为<strong>黑色完美平衡</strong></p><p>恢复平衡的三个操作：变色，左旋，右旋</p><p>如何维护红黑树：</p><ul><li><p>初始状态只有一个黑色节点（同时是根节点和叶子节点）</p></li><li><p>插入新节点：</p><p>因为父节点为黑色的概率较大，默认插入新节点为红色可以避免颜色冲突</p><ol><li><p>插入节点的Key已经存在：更新当前节点的值为插入节点的值，颜色不变<img src="20210412094118977.png" alt></p></li><li><p>插入节点的父节点为黑色：由于节点默认红色，所以可以直接插入而无需做自平衡</p><p><img src="20210412094724987.png" alt></p></li><li><p>插入节点的父节点为红色</p><p>分为两种情况：叔叔节点是红色还是黑色</p><p>如果叔叔节点是红色，则如图变换，再以点P为基点进行自平衡</p><p><img src="2021041210371914.png" alt></p><p>如果叔叔节点是黑色，如图变换即可</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdG" alt="在这里插入图片描述"></p><p><img src="20210412153954767.png" alt="在这里插入图片描述"></p><p>反方向同理</p></li></ol></li></ul><p>实验代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色枚举，0 表示黑色，1 表示红色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; BLACK, RED &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;          <span class="comment">// 节点值</span></span><br><span class="line">    Color color;       <span class="comment">// 节点颜色</span></span><br><span class="line">    Node* left;        <span class="comment">// 左子节点</span></span><br><span class="line">    Node* right;       <span class="comment">// 右子节点</span></span><br><span class="line">    Node* parent;      <span class="comment">// 父节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量定义</span></span><br><span class="line">Node* root = <span class="literal">nullptr</span>;  <span class="comment">// 红黑树根节点</span></span><br><span class="line">Node* NIL = <span class="literal">nullptr</span>;   <span class="comment">// 哨兵节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化哨兵节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeNILNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL = <span class="keyword">new</span> Node;</span><br><span class="line">    NIL-&gt;color = BLACK;</span><br><span class="line">    NIL-&gt;left = NIL-&gt;right = NIL-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line"><span class="function">Node* <span class="title">createNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;color = RED; <span class="comment">// 新插入节点默认为红色</span></span><br><span class="line">    newNode-&gt;left = newNode-&gt;right = newNode-&gt;parent = NIL;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(Node*&amp; root, Node* x)</span> </span>&#123;</span><br><span class="line">    Node* y = x-&gt;right;       <span class="comment">// 设置 y 为 x 的右子节点</span></span><br><span class="line">    x-&gt;right = y-&gt;left;       <span class="comment">// 将 y 的左子树移为 x 的右子树</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != NIL) &#123;</span><br><span class="line">        y-&gt;left-&gt;parent = x;  <span class="comment">// 更新父指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;    <span class="comment">// 将 y 的父节点指向 x 的父节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent == NIL) &#123;</span><br><span class="line">        root = y;             <span class="comment">// 如果 x 是根节点，更新根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;  <span class="comment">// x 是左子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y; <span class="comment">// x 是右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;left = x;              <span class="comment">// 将 x 设置为 y 的左子节点</span></span><br><span class="line">    x-&gt;parent = y;            <span class="comment">// 更新 x 的父指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(Node*&amp; root, Node* y)</span> </span>&#123;</span><br><span class="line">    Node* x = y-&gt;left;        <span class="comment">// 设置 x 为 y 的左子节点</span></span><br><span class="line">    y-&gt;left = x-&gt;right;       <span class="comment">// 将 x 的右子树移为 y 的左子树</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != NIL) &#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y; <span class="comment">// 更新父指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;parent = y-&gt;parent;    <span class="comment">// 将 x 的父节点指向 y 的父节点</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == NIL) &#123;</span><br><span class="line">        root = x;             <span class="comment">// 如果 y 是根节点，更新根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;left) &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;  <span class="comment">// y 是左子节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x; <span class="comment">// y 是右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;right = y;             <span class="comment">// 将 y 设置为 x 的右子节点</span></span><br><span class="line">    y-&gt;parent = x;            <span class="comment">// 更新 y 的父指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复插入导致的红黑树性质破坏</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fixInsert</span><span class="params">(Node*&amp; root, Node* z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123; <span class="comment">// 父节点是红色时可能违反性质</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123; <span class="comment">// 父节点是祖父节点的左子节点</span></span><br><span class="line">            Node* y = z-&gt;parent-&gt;parent-&gt;right; <span class="comment">// 叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123; <span class="comment">// 叔叔节点是红色</span></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;     <span class="comment">// 父节点变黑</span></span><br><span class="line">                y-&gt;color = BLACK;            <span class="comment">// 叔叔节点变黑</span></span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED; <span class="comment">// 祖父节点变红</span></span><br><span class="line">                z = z-&gt;parent-&gt;parent;       <span class="comment">// 将 z 移动到祖父节点继续调整</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123; <span class="comment">// z 是父节点的右子节点</span></span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(root, z);    <span class="comment">// 左旋转父节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;    <span class="comment">// 父节点变黑</span></span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED; <span class="comment">// 祖父节点变红</span></span><br><span class="line">                <span class="built_in">rightRotate</span>(root, z-&gt;parent-&gt;parent); <span class="comment">// 右旋祖父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父节点是祖父节点的右子节点，逻辑对称</span></span><br><span class="line">            Node* y = z-&gt;parent-&gt;parent-&gt;left; <span class="comment">// 叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = z-&gt;parent-&gt;parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    <span class="built_in">rightRotate</span>(root, z);</span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">leftRotate</span>(root, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;color = BLACK; <span class="comment">// 根节点始终是黑色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个新节点到红黑树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node* z = <span class="built_in">createNode</span>(data);</span><br><span class="line">    Node* y = NIL;       <span class="comment">// 用于记录 z 的父节点</span></span><br><span class="line">    Node* x = root;      <span class="comment">// 从根节点开始搜索插入位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != NIL) &#123;   <span class="comment">// 找到插入位置</span></span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;data &lt; x-&gt;data) &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;       <span class="comment">// 设置 z 的父节点</span></span><br><span class="line">    <span class="keyword">if</span> (y == NIL) &#123;      <span class="comment">// 树为空，z 为根节点</span></span><br><span class="line">        root = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;data &lt; y-&gt;data) &#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fixInsert</span>(root, z);  <span class="comment">// 修复红黑树性质</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != NIL) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initializeNILNode</span>(); <span class="comment">// 初始化哨兵节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">25</span>);</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://www.cnblogs.com/crazymakercircle/p/16320430.html">红黑树（图解+秒懂+史上最全）</a></p><p><a href="https://cloud.tencent.com/developer/article/1739709">【动态图文详解，史上最易懂的红黑树讲解】手写红黑树（Red Black Tree）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络有手就行诶我手呢</title>
      <link href="/2025/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%E8%AF%B6%E6%88%91%E6%89%8B%E5%91%A2/"/>
      <url>/2025/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%E8%AF%B6%E6%88%91%E6%89%8B%E5%91%A2/</url>
      
        <content type="html"><![CDATA[<p>计算机网络刷题记录</p><span id="more"></span><hr><p><img src="image-20250104213452667.png" alt></p><p>考虑电路交换的三个阶段</p><p>建立连接：$s$（题干给出）</p><p>数据传输：$\frac{x}{b}$（报文长度除以数据率就是所有报文都传输过去所需要的时间）</p><p>连接释放：$kd$（连接释放的报文直接发送，从发送端到接收端所需要的时间为链路段数乘以每段的传播时延）</p><p>分组交换</p><p>报文如果直接传输，需要的代价是 $\frac{x}{b}$</p><p>但是第一个报文未接收完成，后面的节点都是不在工作的，所以这里的代价为空闲的链路数乘以分组除以数据率 $(k-1)\frac{p}b$</p><p>加上个倾斜，也就是加上 $kd$</p><p><img src="3f3ffb681c90ff1f63f56a4314e8beb.png" alt></p><p>要使分组交换比电路交换快，则：</p><script type="math/tex; mode=display">s+\frac{x}b+kd>\frac{x}b+(k-1)\frac{p}b+kd</script><p>即 $s&gt;(k-1)\frac{p}b$</p><p><img src="f0876362669ece5b4c0fb1ad5016f198.png" alt></p><p><img src="image-20250104220123260.png" alt></p><p>考虑原始的状态 $\frac{x}b+(k-1)\frac{p}b+kd$</p><p>没有传播时延，再考虑分组控制信息固定长度，则 $\frac{x}p\cdot\frac{p+h}b+(k-1)\frac{p+h}b$</p><p>整理得 $\frac{k-1}b p+\frac{xh}bp^{-1}+\frac{x+(k-1)h}b$</p><p>函数值最大，则 $\frac{k-1}b p=\frac{xh}bp^{-1}$</p><p>解得 $p=\sqrt{\frac{xh}{k-1}}$</p><p><img src="image-20250105120925533.png" alt></p><p>发送时延=数据长度/数据发送速率</p><p>传播时延=距离/物理传播速率</p><p>(1) 发送时延=$\frac{10^7bit}{100<em>10^3b/s}=1</em>10^2s$ ，传播时延=$\frac{1000<em>10^3m}{2</em>10^8m/s}=5*10^{-3}s$</p><p>(2) 发送时延=$\frac{10^3bit}{1<em>10^9b/s}=1</em>10^{-6}s$ ，传播时延=$\frac{1000<em>10^3m}{2</em>10^8m/s}=5*10^{-3}s$</p><p><img src="image-20250105121741500.png" alt></p><p>正在传输的比特数=传播时延*数据率</p><p>传播时延=媒体长度/传播速度</p><p>(1) 传输时延=$\frac{1<em>10^{-1}m}{2</em>10^8m/s}=5*10^{-10}s$</p><p>$1Mb/s:\quad 5<em>10^{-10}s</em>1<em>10^6b/s=5</em>10^{-4}bit$</p><p>$1Gb/s:\quad 5<em>10^{-10}s</em>1<em>10^9b/s=5</em>10^{-1}bit$</p><p>(2) 传输时延=$\frac{100m}{2<em>10^8m/s}=5</em>10^{-7}s$</p><p>$1Mb/s:\quad 5<em>10^{-7}s</em>1<em>10^6b/s=5</em>10^{-1}bit$</p><p>$1Gb/s:\quad 5<em>10^{-7}s</em>1<em>10^9b/s=5</em>10^{2}bit$</p><p>(3) 传输时延=$\frac{100<em>10^3m}{2</em>10^8m/s}=5*10^{-4}s$</p><p>$1Mb/s:\quad 5<em>10^{-4}s</em>1<em>10^6b/s=5</em>10^{2}bit$</p><p>$1Gb/s:\quad 5<em>10^{-4}s</em>1<em>10^9b/s=5</em>10^{5}bit$</p><p>(4) 传输时延=$\frac{5000<em>10^3m}{2</em>10^8m/s}=2.5*10^{-2}s$</p><p>$1Mb/s:\quad 2.5<em>10^{-2}s</em>1<em>10^6b/s=2.5</em>10^{4}bit$</p><p>$1Gb/s:\quad 2.5<em>10^{-2}s</em>1<em>10^9b/s=2.5</em>10^{7}bit$</p><p><img src="image-20250105123613753.png" alt></p><p>由题意 $2W=20000$</p><p>码元变为16，则数据率$=2W\log_216=80000bit/s$</p><p><img src="image-20250105135446625.png" alt>+</p><p>最长工作距离$=\frac{20dB}{0.7dB/km}=\frac{200}7km$</p><p>衰减$=\frac{20dB}{100km}=0.2dB/km$</p><p><img src="image-20250105135804557.png" alt></p><p>$\frac{2<em>10^8}{1200</em>10^{-9}}=\frac53*10^{14}Hz$</p><p><img src="image-20250105140242576.png" alt></p><p>这种题，直接逐项相加即可</p><p>$S\cdot A=\frac18\sum_{i=1}^8S_iA_i=\frac{1-1+3+1-1+3+1+1}8=1$</p><p>$S\cdot B=\frac18\sum_{i=1}^8S_iB_i=\frac{1-1-3-1-1-3+1-1}8=-1$</p><p>$S\cdot C=\frac18\sum_{i=1}^8S_iC_i=\frac{1+1+3+1-1-3-1-1}8=0$</p><p>$S\cdot D=\frac18\sum_{i=1}^8S_iD_i=\frac{1+1+3-1+1+3+1-1}8=1$</p><p>故AD发送了数据1，B发送了数据0，C未发送数据</p><p><img src="image-20250105144336881.png" alt></p><p>需要发送的数据 <code>1101011011</code>，补齐位数为 <code>11010110110000</code></p><p>校验多项式 <code>10011</code></p><p>做模2减法（逐位异或），得到余数 <code>0111</code></p><p><img src="image-20250105151857166.png" alt></p><p>需要发送的数据 <code>101110</code>，补齐位数为 <code>101110000</code></p><p>校验多项式 <code>1001</code></p><p>做模2减法（逐位异或），得到余数 <code>011</code></p><p><img src="image-20250105152505594.png" alt></p><p>PPP协议中 0x7D 是转义字符</p><ul><li>0x7D本身表示转义字符</li><li>如果数据中有0x7E（帧的边界字符），则它也会被转义成0x7D 0x5E</li><li>如果数据中有0x7D，则它会被转义成0x7D 0x5D</li></ul><p><img src="image-20250105154132283.png" alt></p><p><img src="image-20250105154523838.png" alt></p><p>原文：0110111111111100</p><p>填充后：011011111011111000</p><p>填充后：0001110111110111110110</p><p>原文：00011101111111111110</p><p><img src="image-20250105154935825.png" alt></p><p>单程传播时延 $\tau=\frac{1<em>10^3m}{2</em>10^8m/s}=5*10^{-6}s$</p><p>往返传播时延 $2\tau=10*10^{-6}s$</p><p>$2\tau$ 即为争用期。<br>为了能够按照CSMA/CD 工作，最小帧的发送时间即为争用期$10\mu s$发送的数据量</p><p>$1<em>10^9b/s</em>10<em>10^{-6}s=1</em>10^4b=1250B$</p><p><img src="image-20250105161041795.png" alt></p><p>等待时间=$2\tau*r$</p><p>10Mb/s的以太网争用期为$51.2\mu s$，则等待时间=5.12ms</p><p>100Mb/s的以太网争用期为$5.12\mu s$，则等待时间=0.512ms</p><p><img src="image-20250105161400348.png" alt></p><p>第三章还剩下一些，暂时丢掉了~</p><p><img src="image-20250105162027793.png" alt></p><p>01000101 00000000<br>00000000 00011100<br>00000000 00000001<br>00000000 00000000<br>00000100 00010001<br>00000000 00000000<br>00001010 00001100<br>00001110 00000101<br>00001100 00000110<br>00000111 00001001<br>$\rightarrow$<br>01003532 00023414<br>01110100 01001110<br>$\rightarrow$取反码<br>10001011 10110001</p><p><img src="image-20250105164451421.png" alt></p><p>45 00<br>00 1C<br>00 01<br>00 00<br>04 11<br>00 00<br>0A 0C<br>0E 05<br>0C 06<br>07 09<br>$\rightarrow$<br>74 4E</p><p>十六进制太难算了</p><p><img src="image-20250105164949635.png" alt></p><p>第二个局域网所能传送的最长数据帧中的数据部分只有1200bit，即每个IP数据片的数据部分不超过1200-160(bit)，由于片偏移是以8字节即64bit为单位，所以IP数据片的数据部分不超过1024bit</p><p>故3200bit的报文要分4个数据片，所以第二个局域网向上传送的比特数等于(3200+4*160)=3840bit</p><p><img src="image-20250105165917792.png" alt></p><p>128.96.39.10属于子网128.96.39.0~128.96.39.127，故下一跳接口为m0</p><p>128.96.30.12属于子网128.96.39.0~128.96.39.127，故下一跳接口为R2</p><p>128.96.40.151不在子网128.96.40.0~128.96.40.127，故使用默认路由R4</p><p>192.4.153.17属于子网192.4.153.0~192.4.153.127，故下一跳接口为R3</p><p>192.4.153.90不在子网192.4.153.0~192.4.153.63，故使用默认路由R4</p><p><img src="image-20250105195111766.png" alt></p><p>IP数据包固定首部长度即为20字节，剩下总共3980字节</p><p>分成最大数据长度为1500字节，去掉首部长度为1480字节</p><p>3980/1480&gt;2，故划分为三个数据报片</p><p>第一片：数据字段长度为1480，片偏移为0，MF为1</p><p>第二片：数据字段长度为1480，片偏移为185，MF为1</p><p>第三片：数据字段长度为1020，片偏移为370，MF为0</p><p><img src="image-20250105201350480.png" alt></p><p>132:10000100<br>133:10000101<br>134:10000110<br>135:10000111</p><p>故共同前缀为 10000100(132)，总共22位</p><p>最大可能聚合为 <code>212.56.132.0/22</code></p><p><img src="image-20250105201719096.png" alt></p><p>后者包含于前者，因为前面的序列都相同</p><p><img src="image-20250105201851483.png" alt></p><p>一眼是(1)哇</p><p><img src="image-20250105201924852.png" alt></p><p>地址0/4与任意IPv4地址前四位为0000的地址都匹配</p><p><img src="image-20250105202103576.png" alt></p><p>只有前11位相同（截止到第二位的16，即第12位）</p><p><img src="image-20250105202256152.png" alt></p><p>2 4 11 30</p><p><img src="image-20250105202740623.png" alt></p><p>20=8+8+4</p><p>84写成二进制是01010100，取前四位为0101xxxx</p><p>最小01010000，即为80；最大01011111，即为95</p><p>最小地址为 140.120.80.00，最大地址为 140.120.95.255</p><p>地址掩码为 255.255.240.0</p><p>地址块中共有地址 $2^{32-20}=2^{12}=4096$ 个</p><p>相当于C类地址 $2^{12}/2^{8}=2^4=16$ 个</p><p><img src="image-20250105203750959.png" alt></p><p>第一步：下一跳全部改为C，距离+1</p><p>第二步：和原有的进行对比，选择相对较少的那个</p><p><img src="image-20250105203929060.png" alt></p><p><img src="image-20250105204005784.png" alt></p><p>29:00011101<br>32:00100000</p><p>地址数为 256*4=1024</p><p>虽然这两个地址是连续的地址块，但无法写成前缀的形式。</p><p><img src="image-20250105204300166.png" alt></p><p>网络掩码：255.255.255.224</p><p>网络前缀长度：27</p><p>网络后缀长度：32-27=5</p><p><img src="image-20250105204814439.png" alt></p><p>地址数：$2^5=32$ 个</p><p>首地址：<code>167.199.170.64</code></p><p>末地址：<code>167.199.170.95</code></p><p><img src="image-20250105205006450.png" alt></p><p>子网N1：14.24.74.0/25<br>子网N2：14.24.74.128/26<br>子网N3：14.24.74.196/28</p><p><img src="image-20250105205232516.png" alt></p><p>都匹配，根据最长前缀匹配原则，选择路由3</p><p><img src="image-20250105205449048.png" alt></p><p>11001000 00111000 10101000 00000000/21</p><p>$\frac{2^{32-21}}{2^8}=2^3=8$</p><p><img src="image-20250105205738010.png" alt></p><p>::F53:6382:AB00:67DB:BB27:7332<br>::4D:ABCD<br>::AF36:7328:0000:87AA:0398<br>2819:00AF::35:0CB2:B271</p><p><img src="image-20250105210126907.png" alt></p><p>0000:0000:0000:0000:0000:0000:0000:0000<br>0000:00AA:0000:0000:0000:0000:0000:0000<br>0000:1234 :0000:0000:0000:0000:0000:0003<br>0123:0000:0000:0000:0000:0000:0001:0002</p><p><img src="image-20250105211333272.png" alt></p><p>UDP的首部有8字节，故总共8200字节</p><p>IP数据包的最大长度为1500字节，首部20字节，故应当分为六片</p><p>前五段数据字段的长度为1480字节，第六片为800字节</p><p>片偏移为0,185,370,555,740,925</p><p><img src="image-20250105211342900.png" alt></p><p>UDP首部分别是 源端口 目的端口 长度 校验和</p><p>因此源端口是 $6<em>256+3</em>16+2=1586$</p><p>目的端口是 $4*16+5=69$</p><p>用户数据总长度为 $16+12=28$</p><p>目的端口号 69&lt;1023，是熟知端口，为服务器端使用的端口</p><p>使用的服务程序是TFTP</p><p><img src="image-20250105212010982.png" alt></p><p><img src="image-20250105212031876.png" alt></p><p>TCP报文段首部序号字段占4字节，共$2^{32}$个序号</p><p>TCP是面向字节流的，每个序号对应一个数据字节，因此在序号不重复使用的条件下，一次性能发送$2^{32}$个字节，因此L的最大值为4GB</p><p>10Mbit/s=1.25MB/s</p><p>所需时间=$\frac{L+\lceil\frac{L}{1460}\rceil*66}{1.25MB/s}$</p><p><img src="image-20250106074522959.png" alt></p><p>(1) 第一个报文段是70-99的数据，携带总共30个字节的数据</p><p>(2) 发回的确认号应当是100，代表100之前的序号皆被正确收到并且期待第100号</p><p>(3) 80个字节</p><p>(4) 70</p><p><img src="image-20250106075110887.png" alt></p><p>最大吞吐量=$\frac{65535B*8b/B}{20ms}=26.214Mb/s$</p><p><img src="image-20250106075351878.png" alt></p><p>发送65535字节所需要的时间$T=T_D+RTT=\frac{65536B<em>8b/B}{1</em>10^9bit/s}+10ms*2=20.52428ms$</p><p>最大吞吐量$\frac{L}T=\frac{L}{\frac{L}C+RTT}=\frac{65536B*8b/B}{20.52428ms}=25.544Mb/s$</p><p>信道利用率=吞吐量/信道带宽=传播时延/总时延=2.5544%</p><p><img src="image-20250106080048008.png" alt></p><ol><li>初始化参数</li></ol><p>- 初始的<code>EstimatedRTT</code>和<code>DevRTT</code>可以根据系统预设值或初始采样值来设定。</p><p>- 常见的初始值：</p><p>  - <code>EstimatedRTT = 初始 RTT 样本值</code></p><p>  - <code>DevRTT = 初始 RTT 样本值 / 2</code>（或其他合理假设值）</p><ol><li>更新 <code>EstimatedRTT</code></li></ol><p>当采集到新的RTT样本值<code>SampleRTT</code>时，更新<code>EstimatedRTT</code>：</p><p>$\text{EstimatedRTT} = (1 - \alpha) \times \text{EstimatedRTT} + \alpha \times \text{SampleRTT}$</p><p>- 这是一个加权平均公式，用于平滑RTT的估计值。</p><p>- 参数$\alpha$的典型值是0.125（即1/8）。</p><ol><li>更新 <code>DevRTT</code></li></ol><p>基于<code>SampleRTT</code>与<code>EstimatedRTT</code>的差异，更新<code>DevRTT</code>（估算RTT的平均偏差）：</p><p>$\text{DevRTT} = (1 - \beta) \times \text{DevRTT} + \beta \times |\text{SampleRTT} - \text{EstimatedRTT}|$</p><p>- 这里使用的是绝对偏差来衡量RTT的波动程度。</p><p>- 参数$\beta$的典型值是0.25（即1/4）。</p><ol><li>计算 RTO</li></ol><p>根据更新后的<code>EstimatedRTT</code>和<code>DevRTT</code>计算<code>RTO</code>：</p><p>$\text{RTO} = \text{EstimatedRTT} + 4 \times \text{DevRTT}$</p><p>- 加权偏差部分（$4 \times \text{DevRTT}$）用于增加容忍度，防止因RTT波动引发过早重传。</p><ol><li>动态调整</li></ol><p>- RTO的上下限限制：在实际实现中，RTO通常会被限制在一个范围内。例如：</p><p>  - 最小值：1秒</p><p>  - 最大值：60秒</p><p>  这样可以避免计算结果极端化导致性能问题。</p><p>(1) RTO=4.5s</p><p>(2) RTTs=$\frac78$旧的RTT+$\frac18$新的RTT=1.625s</p><p>​     RTTd=$\frac34$旧的RTTd+$\frac14$|RTTs-新的RTT样本|=0.78125s</p><p>​     RTO= 4.75s</p><p><img src="image-20250106081510926.png" alt></p><p>RTT0=30ms</p><p>RTT1=0.9RTT0+0.1RTT=29.6ms</p><p>RTT2=0.9RTT1+0.1RTT=29.84ms</p><p>RTT3=0.9RTT2+0.1RTT=29.256ms</p><p>$\alpha$取值较小，RTTs受RTT样本值的影响较小</p><p><img src="image-20250106081736760.png" alt></p><p>ssthresh=上次拥塞值/2</p><p><img src="image-20250106082009764.png" alt></p><p><img src="image-20250106082026328.png" alt></p><p><img src="image-20250106082246782.png" alt></p><p>(2) 慢开始时间间隔：[1,6]和[23,26]</p><p>(3) 拥塞避免时间间隔：[6,16]和[17,22]</p><p>(4) 第16轮是收到了重复帧，第22抡是超时检测</p><p>(5) 1-&gt;32, 18-&gt;21, 24-&gt;13</p><p>(6) 第七轮</p><p>(7) 4</p><p>半期考相关考点</p><ol><li>集线器平分带宽，交换机都能使用最大带宽</li><li>集线器不能隔离广播域和冲突域，交换机可以隔离冲突域但是不能隔离广播域</li><li>已知网络利用率求网络延迟是最小值的多少倍，$(1-利用率)^{-1}$</li><li>最小单位：物理层：比特/位；数据链路层：帧；网络层：分组；传输层：数据报；应用层：数据</li><li>CSMA/CD是在介质访问控制（MAC层）实现的</li><li>传统以太网最短有效帧长位64字节，争用期为 $51.2\mu s$</li><li>以太网的物理地址的长度为48位，IPv4地址的长度为32位</li><li>IP首部定长部分为20字节</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理0轮预习</title>
      <link href="/2025/01/02/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%860%E8%BD%AE%E9%A2%84%E4%B9%A0/"/>
      <url>/2025/01/02/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%860%E8%BD%AE%E9%A2%84%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>我滴进度已经完蛋了</p><span id="more"></span><h2 id="光学"><a href="#光学" class="headerlink" title="光学"></a>光学</h2><h3 id="衍射"><a href="#衍射" class="headerlink" title="衍射"></a>衍射</h3><h4 id="通用公式"><a href="#通用公式" class="headerlink" title="通用公式"></a>通用公式</h4><p>$\delta=a\frac{x}f$  $光程差=缝宽*\tan\theta$</p><p>暗纹 $\delta=\pm k\lambda$，明纹 $\delta=\pm (k+0.5)\lambda$</p><h4 id="中央明纹宽度"><a href="#中央明纹宽度" class="headerlink" title="中央明纹宽度"></a>中央明纹宽度</h4><p>$l=2f\frac\lambda a$</p><h4 id="光栅"><a href="#光栅" class="headerlink" title="光栅"></a>光栅</h4><p>$\delta=(a+b)|\sin\theta-\sin\varphi|=k\lambda$</p><p>缺级 $k=\frac{a+b}{a}k’$</p><p>光栅常数 $a+b$</p><p>距离中心距离 $x=f\cdot\tan\theta,(a+b)|\sin\theta-\sin\varphi|=k\lambda$</p><h3 id="双缝干涉"><a href="#双缝干涉" class="headerlink" title="双缝干涉"></a>双缝干涉</h3><p>$\delta=d\frac{x}D$  $光程差=缝距*\tan\theta$</p><h4 id="云母覆盖"><a href="#云母覆盖" class="headerlink" title="云母覆盖"></a>云母覆盖</h4><p>$\delta_{覆盖后}-\delta_{覆盖前}=(1-n)l$</p><h3 id="单缝干涉"><a href="#单缝干涉" class="headerlink" title="单缝干涉"></a>单缝干涉</h3><p>反射 单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}$</p><p>反射 不单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}+\frac\lambda 2$</p><p>折射 单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}+\frac\lambda 2$</p><p>折射 不单调 $\delta=2e\sqrt{n_2^2-n_1^2\sin^2\theta}$</p><h3 id="偏振"><a href="#偏振" class="headerlink" title="偏振"></a>偏振</h3><h2 id="振动波动学"><a href="#振动波动学" class="headerlink" title="振动波动学"></a>振动波动学</h2><h3 id="振动"><a href="#振动" class="headerlink" title="振动"></a>振动</h3><h4 id="弹簧拉开"><a href="#弹簧拉开" class="headerlink" title="弹簧拉开"></a>弹簧拉开</h4><p>$\omega=\frac{k}m$  $kx=m\omega^2r,x=r$</p><p>$A=\sqrt{x_0^2+\frac{v_0^2}{\omega^2}}$  $A^2=x_0^2+x^2,x=\frac{v_0}{\omega}$</p><h4 id="能量计算"><a href="#能量计算" class="headerlink" title="能量计算"></a>能量计算</h4><p>能量 $E=\frac12kA^2$</p><p>平均动能 $\overline{E_k}=\frac14kA^2$</p><h4 id="振动合成"><a href="#振动合成" class="headerlink" title="振动合成"></a>振动合成</h4><p>$A=\sqrt{A_1^2+A_2^2+2A_1A_2cos(\varphi_2-\varphi_1)}$</p><p>$\varphi=\arctan\frac{A_1\sin\varphi_1+A_2\sin\varphi_2}{A_1\cos\varphi_1+A_2\cos\varphi_2}$</p><h4 id="求拍频"><a href="#求拍频" class="headerlink" title="求拍频"></a>求拍频</h4><p>$\omega=|\frac{\omega_1}{2\pi}-\frac{\omega_2}{2\pi}|$</p><h4 id="单摆"><a href="#单摆" class="headerlink" title="单摆"></a>单摆</h4><p>$\omega=\sqrt{\frac{g}{l}},T=\frac{2\pi}{\omega},f=\frac{\omega}{2\pi}$</p><h3 id="波动"><a href="#波动" class="headerlink" title="波动"></a>波动</h3><h2 id="气体热力学"><a href="#气体热力学" class="headerlink" title="气体热力学"></a>气体热力学</h2><h3 id="气体压强体积温度能量"><a href="#气体压强体积温度能量" class="headerlink" title="气体压强体积温度能量"></a>气体压强体积温度能量</h3><h3 id="热力学第一定理"><a href="#热力学第一定理" class="headerlink" title="热力学第一定理"></a>热力学第一定理</h3><h3 id="气体的速率"><a href="#气体的速率" class="headerlink" title="气体的速率"></a>气体的速率</h3><h3 id="循环效率"><a href="#循环效率" class="headerlink" title="循环效率"></a>循环效率</h3><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论一轮复习</title>
      <link href="/2024/12/28/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/12/28/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%80%E8%BD%AE%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>记录概率论的学习内容</p><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="image-20241226153014795.png" alt></p><p><img src="image-20241226153156568.png" alt></p><h2 id="一、随机事件和概率"><a href="#一、随机事件和概率" class="headerlink" title="一、随机事件和概率"></a>一、随机事件和概率</h2><p><img src="image-20241226155309296.png" alt></p><p><img src="image-20241226155749497.png" alt></p><h3 id="1-古典概型"><a href="#1-古典概型" class="headerlink" title="1.古典概型"></a>1.古典概型</h3><h3 id="2-几何概型"><a href="#2-几何概型" class="headerlink" title="2.几何概型"></a>2.几何概型</h3><h3 id="3-重要公式"><a href="#3-重要公式" class="headerlink" title="3.重要公式"></a>3.重要公式</h3><h3 id="4-独立性判定"><a href="#4-独立性判定" class="headerlink" title="4.独立性判定"></a>4.独立性判定</h3><h2 id="二、一维随机变量及其分布"><a href="#二、一维随机变量及其分布" class="headerlink" title="二、一维随机变量及其分布"></a>二、一维随机变量及其分布</h2><p><img src="image-20241226155849403.png" alt></p><h3 id="1-判分布"><a href="#1-判分布" class="headerlink" title="1.判分布"></a>1.判分布</h3><p>随机变量：$X:\Omega\rightarrow\mathbb{R}$</p><p>分布函数：$X\sim F(x),F(x)=P(X\leq x),F(x)\in[0,1]$</p><p> <img src="image-20241226161408379.png" alt></p><p>对于连续型$F(x)=\int_{-\infty}^{x}f(t)dt,x\in\mathbb{R}$</p><p><img src="image-20241226161715853.png" alt></p><script type="math/tex; mode=display">\left\{\begin{align}&F(-\infty)=0,\\&F(+\infty)=1,\\&\sum_ip_i=1,\\&\int_{-\infty}^{+\infty}f(x)dx=1\end{align}\right.</script><p><img src="image-20241226162907433.png" alt></p><p>A</p><p><img src="image-20241226163018346.png" alt></p><p><img src="6274990073b1f018f2b3bd296672d12.jpg" alt></p><p>B选项解法二：也可以使用部分积分公式$\int udv=uv-\int vdu$</p><h1 id="部分积分公式推导过程"><a href="#部分积分公式推导过程" class="headerlink" title="部分积分公式推导过程"></a>部分积分公式推导过程</h1><p><img src="image-20241226164835164.png" alt></p><p>其中：$u=v=F(x)$</p><p>带入部分积分公式：$\int F(x) dF(x)=[F(x)F(x)]|_{-\infty}^{+\infty}−\int F(x)dF(x)$</p><p>故 $\int F(x) dF(x)=\frac{1}{2}$</p><p>则 $g_2(x)$ 可以作为概率密度</p><p>$g_1(x),g_2(x),g_3(x)$可以作为概率密度， $g_4(x)$ 不能作为概率密度</p><p>C</p><h3 id="2-求分布"><a href="#2-求分布" class="headerlink" title="2.求分布"></a>2.求分布</h3><ul><li><p>离散型分布</p><ul><li><p>0-1分布 $X\sim B(1,p),X(伯努利计数变量)\sim \left(\begin{array}{l}0&amp;\quad1\p&amp;1-p\end{array}\right)$</p></li><li><p>二项分布 $X\sim B(n,p)$ 分布律 $U_k=P{X=k}=C_n^kp^k(1-p)^{n-k}$</p></li><li><p>几何分布 $X\sim G(p)$ 首中即停止 $P{X=k}=p\cdot (1-p)^{k-1}$</p><p>无记忆性<img src="image-20241226172043086.png" alt></p></li><li><p>超几何分布<img src="image-20241226172116840.png" alt></p></li><li>柏松分布 稀有事件的概率 $P{X=k}=\frac{\lambda^k}{k!}e^{-\lambda}$，$EX=\lambda$</li></ul></li></ul><p>泊松定理 若$X\sim B(n,p)$，当$n$很大，$p$很小，$\lambda=np$ 适中时，二项分布可用泊松分布近似表示；一般地，当$n&gt;20,p<0.05$ 时，用泊松近似公式通近二项分布效果比较好，特别当$n>100,np&lt;10$ 时，逼近效果更佳</0.05$></p><script type="math/tex; mode=display">C_n^kp^k(1-p)^{n-k}\approx\frac{\lambda^k}{k!}e^{-\lambda}</script><p><img src="image-20241226172929663.png" alt></p><script type="math/tex; mode=display">\begin{align}\because\ &Z\sim B(2,\frac13)\\&X+Y+Z=2\\\therefore\ &X+Y=2-Z\sim B(2,\frac23)\end{align}</script><p>B</p><p><img src="image-20241227084704187.png" alt></p><p>8</p><p><img src="image-20241227084958983.png" alt></p><p><img src="3d41f9d1474d853ccd93e271382de97.jpg" alt></p><p>D</p><ul><li><p>连续型分布</p><ul><li><p>均匀分布 $X\sim U(a,b)$</p><script type="math/tex; mode=display">f(x)=\left\{\begin{align}&\frac1{b-a},a<x<b\\ &0,otherwise\end{align}\right.</script><script type="math/tex; mode=display">F(x)=\left\{\begin{align}&0,x<a\\&\frac{x-a}{x-b},a\leq x<b\\ &1,x\ge b\end{align}\right.</script><p><img src="image-20241227090909632.png" alt></p></li><li><p>指数分布 $X\sim E(\lambda)$</p><script type="math/tex; mode=display">f(x)=\left\{\begin{align}&\lambda e^{-\lambda x},x\ge0\\ &0,otherwise\end{align}\right.\quad(\lambda>0)</script><script type="math/tex; mode=display">F(x)=\left\{\begin{align}&1-e^{-\lambda x},x\ge0\\&0,x<0\end{align}\right.\quad(\lambda>0)</script><p><img src="image-20241227092018265.png" alt></p><p>$t,s&gt;0$时，$P{X\ge t+s|X\ge t}=P{X\ge s}$ 称为指数分布的无记忆性</p><p>$EX=\frac1\lambda$称为平均寿命，也称为平均等待时间，$\lambda$称为失效频率，它是一个常数，失效频率不变，元件无损耗，才有无记忆性</p></li><li><p>正态分布 $X\sim N(\mu,\sigma^2)$</p><script type="math/tex; mode=display">X\sim f(x)=\frac1{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}</script><p>$\mu=0,\sigma=1$时为标准正态分布</p></li></ul></li></ul><p><img src="image-20241227093654288.png" alt></p><p><img src="image-20241227095003089.png" alt></p><p><img src="image-20241227095053035.png" alt></p><p><img src="image-20241227122206944.png" alt></p><p><img src="image-20241227164905346.png" alt></p><p><img src="image-20241227165359766.png" alt></p><p>此分布为威布尔分布，是考虑元件损耗的寿命分布；若$m=1$，则成为指数分布，是理想元件（无损耗）的寿命分布</p><p><img src="image-20241227165618501.png" alt></p><p><img src="image-20241227170404306.png" alt></p><p><img src="image-20241227170602755.png" alt></p><p>A</p><p><img src="image-20241227170813857.png" alt></p><p><img src="image-20241227172128771.png" alt></p><h3 id="3-用分布"><a href="#3-用分布" class="headerlink" title="3.用分布"></a>3.用分布</h3><p><img src="image-20241227172253427.png" alt></p><p>A</p><p><img src="image-20241227172718820.png" alt></p><p>A</p><p><img src="image-20241227172955625.png" alt></p><p><img src="image-20241227173344657.png" alt></p><p>A</p><p><img src="image-20241227173657936.png" alt></p><p>注意这里是$\ge$</p><p>$k\in[1,3]$</p><h2 id="三、一维随机变量函数的分布"><a href="#三、一维随机变量函数的分布" class="headerlink" title="三、一维随机变量函数的分布"></a>三、一维随机变量函数的分布</h2><p><img src="image-20241227174148198.png" alt></p><h3 id="1-离散型-gt-离散型"><a href="#1-离散型-gt-离散型" class="headerlink" title="1.离散型-&gt;离散型"></a>1.离散型-&gt;离散型</h3><script type="math/tex; mode=display">Y\sim \left(\begin{array}{l}g(x_1)&g(x_2)& ...\\\quad p_1&\quad p_2&...\end{array}\right)</script><p><img src="image-20241227174532760.png" alt></p><p><img src="image-20241227175235924.png" alt></p><h3 id="2-连续型-gt-连续型（或混合型）"><a href="#2-连续型-gt-连续型（或混合型）" class="headerlink" title="2.连续型-&gt;连续型（或混合型）"></a>2.连续型-&gt;连续型（或混合型）</h3><p>感觉讲解过程很复杂，还是直接看例题吧</p><p><img src="image-20241227180950170.png" alt></p><p><img src="image-20241227175819907.png" alt></p><p><img src="image-20241227180858952.png" alt></p><p><img src="image-20241227181144259.png" alt></p><p><img src="image-20241227213217020.png" alt></p><p><img src="image-20241227213349706.png" alt></p><p>不是哥们，这玩意有点逆天</p><p><img src="image-20241227225402554.png" alt></p><p><img src="image-20241227230811534.png" alt></p><p>解法二有点不理解，但是好厉害···</p><h3 id="3-连续型-gt-离散型"><a href="#3-连续型-gt-离散型" class="headerlink" title="3.连续型-&gt;离散型"></a>3.连续型-&gt;离散型</h3><p>若$X\sim f_X(x)$，且$Y= g(X)$是离散型随机变量；首先确定$Y$的可能取值$a$，然后通过计算概率$P{Y=a}$求得$Y$的概率分布</p><p><img src="image-20241227232845496.png" alt></p><p><img src="image-20241227232754668.png" alt></p><p>题解给的做法，直接用几何分布的无记忆性</p><p><img src="image-20241227232927146.png" alt></p><h2 id="四、多为随机变量及其分布"><a href="#四、多为随机变量及其分布" class="headerlink" title="四、多为随机变量及其分布"></a>四、多为随机变量及其分布</h2><p><img src="image-20241227234626568.png" alt></p><p><img src="image-20241227234637877.png" alt></p><h3 id="1-判分布-1"><a href="#1-判分布-1" class="headerlink" title="1.判分布"></a>1.判分布</h3><script type="math/tex; mode=display">F(x,y)=P\{X\leq x,Y\leq y\}</script><p>$F(x,y)$是联合分布函数的充要条件：单调性，右连续性，有界性，非负性</p><script type="math/tex; mode=display">\left\{\begin{align}&F(-\infty,y)=0,F(x,-\infty)=0,\\&F(-\infty,-\infty)=0,F(+\infty,+\infty)=1,\\&\sum_j\sum_ip_{ij}=1,\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(x,y)dxdy=1\end{align}\right.</script><h3 id="2-求分布-1"><a href="#2-求分布-1" class="headerlink" title="2.求分布"></a>2.求分布</h3><h4 id="求联合分布"><a href="#求联合分布" class="headerlink" title="求联合分布"></a>求联合分布</h4><ul><li><p>求$F(x,y),p_{ij},f(x,y)$</p><ul><li>$(X,Y)\sim p_{ij}$，则$F(x,y)=P{X\leq x,Y\leq y}=\sum_{x_i\leq x,y_i\leq y}p_{ij}$</li><li>$(X,Y)\sim f(x,y)$，则$F(x,y)=P{X\leq x,Y\leq y}=\int_{-\infty}^{+\infty}du\int_{-\infty}^{+\infty}f(u,v)dv$</li></ul></li><li><p>二维均匀分布</p><script type="math/tex; mode=display">f(x,y)=\left\{\begin{align}&\frac1{S_D},(x,y)\in D\\&0,其他\end{align}\right.</script></li><li><p>二维正态分布 $(X,Y)\sim N(\mu_1,\mu2;\sigma_1^2,\sigma_2^2;\rho)$</p><script type="math/tex; mode=display">f(x,y)=\frac1{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}exp(-\frac1{2(1-\rho^2)}((\frac{x-\mu_1}{\sigma_1})^2-2\rho(\frac{x-\mu_1}{\sigma_1})(\frac{y-\mu_2}{\sigma_2})+(\frac{y-\mu_2}{\sigma_2})^2))</script><p><img src="image-20241228002324187.png" alt></p></li></ul><h4 id="求边缘分布"><a href="#求边缘分布" class="headerlink" title="求边缘分布"></a>求边缘分布</h4><script type="math/tex; mode=display">F_X(x)=F(x,+\infty),F_Y(y)=F(+\infty,y)\\  p_{i*}=\sum_jp_{ij},p_{*j}=\sum_ip_{ij}\\  f_X(x)=\int_{-\infty}^{+\infty}f(x,y)dy,f_Y(y)=\int_{-\infty}^{+\infty}f(x,y)dx</script><h4 id="求条件分布"><a href="#求条件分布" class="headerlink" title="求条件分布"></a>求条件分布</h4><p><img src="image-20241228003103701.png" alt></p><h4 id="判独立"><a href="#判独立" class="headerlink" title="判独立"></a>判独立</h4><p><img src="image-20241228003309350.png" alt></p><h3 id="3-用分布-1"><a href="#3-用分布-1" class="headerlink" title="3.用分布"></a>3.用分布</h3><p><img src="image-20241228003200867.png" alt></p><p><img src="image-20241228003218431.png" alt></p><p><img src="image-20241228003920736.png" alt></p><p><img src="image-20241228004001647.png" alt></p><p><img src="image-20241228204716039.png" alt></p><p><img src="image-20241228204803089.png" alt></p><p><img src="image-20241228204920097.png" alt></p><p>$a=0.1,b=0.1,c=0.5,d=0$</p><p><img src="image-20241228210508101.png" alt></p><p><img src="image-20241228211129615.png" alt></p><p><img src="image-20241228211232751.png" alt="image-20241228211232751"></p><p><img src="image-20241228212850307.png" alt></p><p><img src="image-20241228212947584.png" alt></p><p><img src="image-20241228214934142.png" alt></p><p><img src="image-20241228215529903.png" alt></p><p><img src="image-20241229143532802.png" alt></p><p><img src="image-20241229145457186.png" alt></p><p><img src="image-20241229145628258.png" alt></p><p><img src="image-20241229150523813.png" alt></p><h2 id="五、一维随机变量函数的分布"><a href="#五、一维随机变量函数的分布" class="headerlink" title="五、一维随机变量函数的分布"></a>五、一维随机变量函数的分布</h2><p><img src="image-20241229150605527.png" alt></p><p><img src="image-20241229150631218.png" alt></p><h3 id="1-多维-gt-一维"><a href="#1-多维-gt-一维" class="headerlink" title="1.多维-&gt;一维"></a>1.多维-&gt;一维</h3><p>2.</p><p>3.</p><h2 id="六、数学特征"><a href="#六、数学特征" class="headerlink" title="六、数学特征"></a>六、数学特征</h2><p><img src="image-20241229150733335.png" alt></p><p><img src="image-20241229150814358.png" alt></p><h3 id="1-数学期望"><a href="#1-数学期望" class="headerlink" title="1.数学期望"></a>1.数学期望</h3><p><img src="image-20241229151120087.png" alt="image-20241229151120087"></p><h3 id="2-方差"><a href="#2-方差" class="headerlink" title="2.方差"></a>2.方差</h3><p>3.</p><h2 id="七、大数定理和中心极限定理"><a href="#七、大数定理和中心极限定理" class="headerlink" title="七、大数定理和中心极限定理"></a>七、大数定理和中心极限定理</h2><p><img src="image-20241229151301493.png" alt></p><h3 id="1-依概率收敛"><a href="#1-依概率收敛" class="headerlink" title="1.依概率收敛"></a>1.依概率收敛</h3><p>设随机变量$X$与随机变量序列${X_n}(n=1,2,3,…)$，如果对任意的$\varepsilon&gt;0$，有</p><script type="math/tex; mode=display">\lim_{n\rightarrow x}P\{|X_n-X|\ge\varepsilon\}=0\\或\\\lim_{n\rightarrow x}P\{|X_n-X|<\varepsilon\}=1</script><p>则称随机变量序列${X_n}$依概率收敛于随机变量$X$，记为</p><p>$\lim_{n\to\infty}X_{n}=X(P)$ 或 $X_{n}{\overset{p}\longrightarrow}X(n\to\infty)$</p><h3 id="2-大数定律"><a href="#2-大数定律" class="headerlink" title="2.大数定律"></a>2.大数定律</h3><h4 id="切比雪夫大数定律"><a href="#切比雪夫大数定律" class="headerlink" title="切比雪夫大数定律"></a>切比雪夫大数定律</h4><p>相互独立 方差存在且一致有上界</p><p>则${X_n}$服从大数定理 $\frac1n\sum_{i=1}^nX_i\overset{p}\longrightarrow\frac1n\sum_{i=1}^nEX_i$</p><h4 id="伯努利大数定律"><a href="#伯努利大数定律" class="headerlink" title="伯努利大数定律"></a>伯努利大数定律</h4><p>$\mu_n$是$n$重伯努利实验中事件$A$发生的次数，$A\sim B(n,p)$，则 $\frac{\mu_n}n\overset{p}\longrightarrow p$</p><h4 id="辛钦大数定律"><a href="#辛钦大数定律" class="headerlink" title="辛钦大数定律"></a>辛钦大数定律</h4><p>相互独立 同分布 期望存在</p><p>则 $\frac1n\sum_{i=1}^nX_i\overset{p}\longrightarrow\mu$</p><h4 id="大数定律同一个结论"><a href="#大数定律同一个结论" class="headerlink" title="大数定律同一个结论"></a>大数定律同一个结论</h4><p>$\frac1n\sum_{i=1}^nX_i\overset{p}\longrightarrow E(\frac1n\sum_{i=1}^nX_i)$</p><h3 id="3-中心极限定理"><a href="#3-中心极限定理" class="headerlink" title="3.中心极限定理"></a>3.中心极限定理</h3><p>列维-林德伯格定理</p><p>棣莫弗-拉普拉斯定理</p><p>中心极限定理同一个结论</p><h2 id="八、统计量及其分布"><a href="#八、统计量及其分布" class="headerlink" title="八、统计量及其分布"></a>八、统计量及其分布</h2><p><img src="image-20241229154208904.png" alt></p><h3 id="1-统计量"><a href="#1-统计量" class="headerlink" title="1.统计量"></a>1.统计量</h3><p>样本均值 $\overline{X}=\frac1n\sum_{i=1}^{n}X_i$ </p><p>样本方差 $s^{2}=\frac{1}{n-1}\sum _ {i=1}^ {n}(X_i-\overline{X})^{2} = \frac {1}{n-1}(\sum _ {i=1}^ {n}X_ {i}^ {2}-\overline{X}^2)$（无偏估计）</p><p>样本 $k$ 阶原点矩 $ A_ {k}  = \frac {1}{n} \sum _ {i=1}^ {n} x^ {k}  (k=1,2, \cdots )$</p><p>样本 $k$ 阶中心矩 $ B_ {k}  =  \frac {1}{n}   \sum _ {i=1}^ {n}   (X_ {i}-\overline {X})^ {k}  (k=2,3, \cdots  )$</p><p>顺序统计量 将样本n个观测量按其取值从小到大的顺序排列</p><h3 id="2-统计量的分布"><a href="#2-统计量的分布" class="headerlink" title="2.统计量的分布"></a>2.统计量的分布</h3><h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><p>略</p><p>$\chi^2$分布</p><p>3.正态总体下的常用结论</p><p>九、参数估计与假设检验</p><p>1.点估计和评价标准</p><p>2.区间估计与假设检验</p><h2 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h2><p>还有两个小时进考场，浅速通一下概率论</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基本概率</span><br><span class="line">联合概率求独立性</span><br><span class="line">连续函数的概率密度</span><br><span class="line">边缘密度和独立性</span><br><span class="line">协方差</span><br><span class="line">矩估计量和最大似然估计量</span><br><span class="line">显著性水平应用题</span><br></pre></td></tr></table></figure><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>$D(aX+bY)=a^2D(X)+b^2D(Y)+2abCov(X,Y)$</p><p>$Cov(X,Y)=E(XY)-E(X)E(Y)$</p><p>$\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)}\cdot\sqrt{D(Y)}}$</p><p><img src="image-20241230143604750.png" alt></p><h3 id="矩估计量和最大似然估计量"><a href="#矩估计量和最大似然估计量" class="headerlink" title="矩估计量和最大似然估计量"></a>矩估计量和最大似然估计量</h3><p><img src="image-20241230143709401.png" alt></p><h3 id="显著性水平应用题"><a href="#显著性水平应用题" class="headerlink" title="显著性水平应用题"></a>显著性水平应用题</h3><p>要检验的假设是 $H_0: \mu$ 符合要求, $H_1:\mu$ 不符合要求（2分）</p>]]></content>
      
      
      
        <tags>
            
            <tag> mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零知识证明学习</title>
      <link href="/2024/12/19/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/12/19/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>241219阅读《Chameleon-Hashes with Ephemeral Trapdoors And Applications to Invisible Sanitizable Signatures》遇到了NIZKPoK，故学习一下</p><span id="more"></span><hr><h2 id="NIZKPoK"><a href="#NIZKPoK" class="headerlink" title="NIZKPoK"></a>NIZKPoK</h2><p>Non-Interactive Zero-Knowledge Proof 非交互零知识证明</p><h3 id="论文中的体现"><a href="#论文中的体现" class="headerlink" title="论文中的体现"></a>论文中的体现</h3><script type="math/tex; mode=display">\begin{align}&Generate\ \pi\leftarrow NIZKPoK\{(x):h=g^x\}\\&if\ \pi\ is\ not\ valid, return\perp\end{align}</script><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>证明着想要证明自己知道某个值$x$，而不透露$x$本身</p><h3 id="Fiat-Shamir变换（简化的非交互证明）"><a href="#Fiat-Shamir变换（简化的非交互证明）" class="headerlink" title="Fiat-Shamir变换（简化的非交互证明）"></a>Fiat-Shamir变换（简化的非交互证明）</h3><ol><li>初始化：$g$和$h$是公开的参数，$x$是秘密（证明者知道它）</li><li>生成证明：随机选择一个随机值$r$，计算承诺值$t=h*g^r$</li><li>计算挑战：生成一个挑战$c$（通常通过哈希函数生成）</li><li>计算响应：计算 $z=r+c*x$</li><li>发送证明：发送三元组$(t,c,z)$</li><li>验证：验证者检查是否满足$g^z=t*h^c$</li></ol><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#这份是手搓的，放进代码复现成功</span><br><span class="line">def gen_NIZK( g , x , p ):</span><br><span class="line">    h = pow( g , x , p )</span><br><span class="line">    r = random.randint( 1 , p )</span><br><span class="line">    t = pow( g , r , p )</span><br><span class="line">    c = SM3(&quot;窝丝一个挑战&quot;)</span><br><span class="line">    z = r+c*x</span><br><span class="line">    return (t,c,z),(g,p,h)</span><br><span class="line"></span><br><span class="line">def verf_NIZK( pi ):</span><br><span class="line">    ( t , c , z ) , ( g , p , h ) = pi</span><br><span class="line">    if pow( g , z , p ) == t * pow( h , c , p ) % p:</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure><p><a href="https://github.com/coperlm/Crypto-Repro/blob/main/Chameleon%20Hashes/Ephemeral%20Trapdoors/main.py">完整代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#这份是gpto1写的，不过是基于椭圆曲线的</span><br><span class="line">from ecdsa import SECP256k1, SigningKey, VerifyingKey</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># 曲线参数</span><br><span class="line">curve = SECP256k1</span><br><span class="line">G = curve.generator  # 基点 g</span><br><span class="line">n = curve.order      # 阶</span><br><span class="line"></span><br><span class="line"># 私钥 x（随机生成）</span><br><span class="line">x_sk = SigningKey.generate(curve=curve)</span><br><span class="line">x = x_sk.privkey.secret_multiplier  # x 的数值</span><br><span class="line"># 公钥 h = g^x</span><br><span class="line">h_vk = x_sk.verifying_key</span><br><span class="line">h = h_vk.pubkey.point</span><br><span class="line"></span><br><span class="line">def nizkpok_prove(x):</span><br><span class="line">    # 证明者生成随机数 r</span><br><span class="line">    r_sk = SigningKey.generate(curve=curve)</span><br><span class="line">    r = r_sk.privkey.secret_multiplier</span><br><span class="line">    # 计算承诺 t = g^r</span><br><span class="line">    t = r * G</span><br><span class="line">    # 计算挑战 e = Hash(g || h || t)</span><br><span class="line">    e = hashlib.sha256()</span><br><span class="line">    e.update(int(G.x()).to_bytes(32, &#x27;big&#x27;) + int(G.y()).to_bytes(32, &#x27;big&#x27;))</span><br><span class="line">    e.update(int(h.x()).to_bytes(32, &#x27;big&#x27;) + int(h.y()).to_bytes(32, &#x27;big&#x27;))</span><br><span class="line">    e.update(int(t.x()).to_bytes(32, &#x27;big&#x27;) + int(t.y()).to_bytes(32, &#x27;big&#x27;))</span><br><span class="line">    e_int = int(e.hexdigest(), 16) % n</span><br><span class="line">    # 计算响应 s = r + e * x mod n</span><br><span class="line">    s = (r + e_int * x) % n</span><br><span class="line">    return (e_int, s)</span><br><span class="line"></span><br><span class="line">def nizkpok_verify(h, proof):</span><br><span class="line">    e_int, s = proof</span><br><span class="line">    # 计算 t&#x27; = g^s + (-h^e)</span><br><span class="line">    sG = s * G</span><br><span class="line">    eH = e_int * h</span><br><span class="line">    # 获取 eH 的负元</span><br><span class="line">    neg_eH = (n - 1) * eH</span><br><span class="line">    # 计算 t&#x27; = sG + (-eH)</span><br><span class="line">    t_prime = sG + neg_eH</span><br><span class="line">    # 重新计算挑战 e&#x27; = Hash(g || h || t&#x27;)</span><br><span class="line">    e_prime = hashlib.sha256()</span><br><span class="line">    e_prime.update(int(G.x()).to_bytes(32, &#x27;big&#x27;) + int(G.y()).to_bytes(32, &#x27;big&#x27;))</span><br><span class="line">    e_prime.update(int(h.x()).to_bytes(32, &#x27;big&#x27;) + int(h.y()).to_bytes(32, &#x27;big&#x27;))</span><br><span class="line">    e_prime.update(int(t_prime.x()).to_bytes(32, &#x27;big&#x27;) + int(t_prime.y()).to_bytes(32, &#x27;big&#x27;))</span><br><span class="line">    e_prime_int = int(e_prime.hexdigest(), 16) % n</span><br><span class="line">    # 验证 e 是否等于 e&#x27;</span><br><span class="line">    return e_int == e_prime_int</span><br><span class="line"></span><br><span class="line"># 生成证明</span><br><span class="line">proof = nizkpok_prove(x)</span><br><span class="line"></span><br><span class="line"># 验证证明</span><br><span class="line">is_valid = nizkpok_verify(h, proof)</span><br><span class="line">print(&quot;证明是否有效：&quot;, is_valid)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IELTS备考方案</title>
      <link href="/2024/12/13/IELTS%E5%A4%87%E8%80%83%E6%96%B9%E6%A1%88/"/>
      <url>/2024/12/13/IELTS%E5%A4%87%E8%80%83%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>记录如何备考雅思</p><span id="more"></span><p>笔者四级都没过就开始想IELTS了（菜菜</p><p>而且考一次2k多（穷穷</p><p>但是还是要准备一下下的</p><hr><h1 id="关于背单词"><a href="#关于背单词" class="headerlink" title="关于背单词"></a>关于背单词</h1><p>一开始是用的百词斩来背单词</p><p>不过后面就破产了（</p><p><img src="bcz.jpg" alt></p><p>然后斥巨资买了这本书背（感觉背单词，用纸质书更舒服一点）</p><p><img src="image-20241213123128346.png" alt></p><p>只不过进度感人（悲</p><p>单词背完之后，理论上是刷剑雅（一般是盗版或者电子版，正版买不起一点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#剑雅使用教程</span><br><span class="line">1️⃣剑桥雅思4-6：较早版本的题目，初学者可用于前期了解题型</span><br><span class="line">2️⃣剑桥雅思7-9：开始全面的模拟练习，包括听、说、读、写四个部分</span><br><span class="line">3️⃣剑桥雅思10-12：版本难度与现在的雅思考试接近，模考冲刺反复刷，检查和修正自己的错误</span><br><span class="line">4️⃣剑桥雅思13-19：最新版本的题目，应该是最接近当前雅思考试的，可以用来考前练习，检验自己的备考效果</span><br></pre></td></tr></table></figure><p><img src="image-20241213123919350.png" alt></p><p><img src="image-20241213123933820.png" alt></p><p><img src="image-20241213123944373.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学学习路径</title>
      <link href="/2024/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
      <url>/2024/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>本篇文章用于记录学习密码学的路径</p><p>有些是已经走过的路，有些是还没走也即将要走的路</p><span id="more"></span><hr><p>笔者大一录取至网络空间安全专业，加入了网络与信息安全社团，接触到了CTF的五大方向</p><p>高考结束之后的暑假，几个方向的题目都做了一点（除了pwn，环境太难配），然后去社团面试；听了学长们的建议，计划选一个方向，了解了几个方向都有什么特点，学长说密码学应该是五大方向里最深的一个，然后也是因为从小对数学比较感兴趣，就选择了密码学</p><p>上一任的密码学部部长是星盟安全的，然后他就建议每周写周记，记录一下自己每周学了什么，然后我整个学期基本每周都写——收获颇丰</p><p>这里是大一上学期的周记</p><p><img src="大一上.png" alt></p><p>这边是寒假记的，寒假只有一个月所以有四篇</p><p><img src="寒假.png" alt></p><p>这样子，在<a href="https://buuoj.cn/">BUUOJ</a>上刷了一百多道密码学题目，nss上也做了一些，主要是这两个平台，然后打过一些比赛</p><p>通过这半年的锻炼吧，感觉主要提升的是代码能力，感觉自己现在运用python的能力已经不亚于使用cpp了（当然python很多用法要现查现用，还是不太能用来打算法）；只不过打CTF的密码学还是并不是很强，很多攻击方式有待学习</p><p>然后下学期对于密码学的学习就比较断断续续了，下学期比较多的时间去弄嵌入式了</p><p>大概是24年五月份，正式配置并启用的github page，然后就有了这个博客，后来陆陆续续在上面记点东西（虽然很多烂尾了）</p><p>大概也是大一下，好像是快学期末了，意识到CTF的Crypto不是真正的密码学，然后开始科研方向，入门学习是看这本书（虽然我看的是中文版，寒假打算看下原著）</p><p><img src="image-20241212195930695.png" alt></p><p>这本书介绍的是密码学的基础算法，应该是在清华大学杨波的那本书之上的（毕竟是英文教材）</p><p>之后是一本规约相关的书</p><p><img src="image-20241212200428169.png" alt></p><p>这本书就相对困难一点了，也可以看中文版《安全规约导论》（好像说中文版里有的地方有点问题）</p><p>之后了解到一篇论文讲公钥密码的学习</p><p><img src="image-20241212200548291.png" alt></p><p>这篇论文主要是介绍的学习路径，还有30篇推荐阅读的论文（计划这学期读完）</p><p>前面的推荐阅读里（不是30篇公钥密码里面的）出现了上述两本书，但是又不限于这两本书，其他书目待完成上述论文的阅读之后再决定什么时候看</p><p>大概看完了上述内容，就可以做点东西了~</p><p>但是我还没看完！（悲</p><hr><p>之后的路线：计划先打好基础，然后搞搞变色龙哈希，之后再找个跳板，读研之前学习一定的后量子并在这个领域进行研究</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年终总结&amp;回首过去几年</title>
      <link href="/2024/12/02/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E5%9B%9E%E9%A6%96%E8%BF%87%E5%8E%BB%E5%87%A0%E5%B9%B4/"/>
      <url>/2024/12/02/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E5%9B%9E%E9%A6%96%E8%BF%87%E5%8E%BB%E5%87%A0%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>算是个年终总结，也总结了半秩</p><span id="more"></span><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><h3 id="高一"><a href="#高一" class="headerlink" title="高一"></a>高一</h3><p>大概是2020年，卡线进了沧州一中</p><p>当时成绩平平无奇，在普通班大概是排二十多名的位置</p><p><img src="image-20241202144250842.png" alt="高一上第一次月考"></p><p>然后高一还是比较平静的吧，刚开学不久学校有信竞集训队招新，然后去考了个试，然后进了集训队，认识了很多大佬</p><p>开学后三个月，去打了CSP-S2020，T1打了三个小时，最后一个小时都在吃东西~</p><p>赛后测试代码，T1（儒略日，大模拟）拿了10分，原本能晋级的，结果忘记给每道题都建立一个文件夹了，然后遗憾退场（悲</p><p>noip2021再战</p><p>至于whk，那时候马上就要是”得E门生“了</p><p><img src="image-20241202145710662.png" alt="高一下开学考试"></p><p>不过排名基本没变，大概班里二十多名，学校七八百名（物理组合）</p><p><img src="image-20241202150037553.png" alt="高二上开学考试"></p><p>直到高二，一直如此</p><h3 id="高二"><a href="#高二" class="headerlink" title="高二"></a>高二</h3><p>CSP/NOIP2021前夕，几乎全天待在机房练题，whk基本没时间学</p><p>那段时间的大致安排是，上午正常上课，然后下午和晚自习就在机房里备赛；然后我那段时间基本上是上午课间的时候抓紧时间写作业，有时可以把作业（已经想不到当时是怎么卷的了）；noip打完之后回归whk，基本上白天写完作业绰绰有余，晚上可以自己写练习册了</p><p>最后结果，csp省二 noip省三，有点小遗憾，但也知足了</p><p>没找到当时的成绩，我只记得刚打完csp回来的月考，没进前900来着</p><p>打完比赛，就可以开始专心学whk了</p><p><img src="image-20241202150701106.png" alt="高二上12.06半月考"></p><p>这次好歹是上500分了</p><p>转眼到了高二下学期，联考成绩单没在智学网上找到，不过我印象比较深刻，班上第二名，物理组总排第299（这辈子头一次进前300）</p><h3 id="高三"><a href="#高三" class="headerlink" title="高三"></a>高三</h3><p>然后高三了，就都卷起来了，进步就比较困难了，常年稳定在400-500这样子，不过也是鸡汤看的不少，知道高三心态很重要，然后就埋头学习，学累了看会鸡汤，然后继续学（大雾</p><p>讲真压力不小，集训队的其他dalao都进阶北大班了，我还在普通班</p><p>题目难度上来了，分数基本在450左右，但是排名基本不变</p><p>好像是高三上学期，数学一直没有什么进步，比较感动自己的是把朱昊鲲《2000题》一个月刷了一遍（还把错题总结出来了），基本上是每个晚自习都在刷，中午午休的时候也刷；正好赶上一次运动会，记得那一天正好把几何的一大章写完</p><p><img src="image-20241202151213189.png" alt="高三一模"></p><p><img src="image-20241202151255821.png" alt="高考前以后一次考试"></p><p>高三下学期，快高考了，但是语文基本没上过百；听了石油的说法，思考了一下，然后做了一个挺斩钉截铁的决定，拿出整整15天的时间，这段时间每科自己买的试卷都不做了，就只做语文高考真题。在这之后虽然语文依旧没有起色，但是最后高考的时候数学英语发挥的一般，而语文118。我觉得和这一抉择有很大的关联</p><p>高考前一两个月吧，我和我同桌经常一块刷题，在限定时间内比正确率，物化生都刷，数学也刷，嘎嘎刷；讲真那段时间刷题真的刷爽了，有一次45分钟我做了两套物理试卷（好像是名校模考卷）的选择题，总共只错了三道题，总之就是挺爽的</p><p>最终一分不浪费，录取到了FJNU</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>感觉大一还是相对迷茫的，不过也有不少收获</p><p>先说算法竞赛，因为高中学过，所以理所当然大学想打ACM，但是由于比较复杂的原因，最终没有选择ACM（属于是取舍的问题，不过后来想明白了）</p><p>因为大一就下定决心不保研了，所以学业这边相对轻松；然后就可以随便打比赛，一段时间的练习逐渐成为了python中手（不是高手也不是低手），CTF被学长带飞然后拿了奖；RoboMaster这边也学到了不少嵌入式知识；而且还混了个数学建模小比赛的奖</p><p>机器人相关，沧一有这样的社团但是不在普通班招，有点遗憾；这也是我大学来机器人社团学和本专业毫无关联的嵌入式的原因之一，耗费了不少时间和精力，但是感觉相当划算，现在想自己手搓个什么简单电路基本没有问题，即使有问题也解能决问题</p><p><img src="bd2fc92f357bfaf2a97896fbc76713c.jpg" alt="我有很多证但都是准考证"></p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>大二这一年还没过完，不过想清楚很多事情；很多东西都是要取舍，知道了自己需要什么，需要做什么，因而之后的道路也比较清晰了</p><hr><p>关于算法竞赛，太功利去看待他并不是一件好事，但是确实很锻炼思维能力；虽然没进大学的集训队，这段时间也经常打Codeforces，前两天的校赛还取得了不错的成绩</p><p><img src="366a54510264d19b798861a4dbaadfe.jpg" alt></p><p>关于CTF，它和以后的就业是相对绑定的；大一锻炼了一年的代码能力，现在手搓（或者熟练使用AI）完成个什么算法也相对轻松；所以基本而言是有利的，性价比较高的</p><p>现在机器人这边也在干一个<a href="https://coperlm.github.io/2024/11/24/RoboMaster%E7%A6%8F%E5%BB%BA%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62025%E8%B5%9B%E5%AD%A3-%E9%A3%9E%E9%95%96%E7%BB%84%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/">小项目</a>，确实不大，但也学到很多东西</p><p>后面的路，应当会越走越宽的</p><p><img src="6563a752f41212fd722cce1e66e8697.jpg" alt="end"></p><p>未完待续~</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FJNU2024低程赛题解</title>
      <link href="/2024/12/02/FJNU2024%E4%BD%8E%E7%A8%8B%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/12/02/FJNU2024%E4%BD%8E%E7%A8%8B%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://fjnuacm.top/contest/674c47729613c4d16c3f81cf">比赛链接</a></p><p>题目按总过题数量降序排列</p><span id="more"></span><h2 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int a , b;cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    int c = a - b;if( c &lt; 0 ) c = -c;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H"><a href="#H" class="headerlink" title="H."></a>H.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int a , b , c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    if( a == b &amp;&amp; b == c ) cout &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">    else if( a == b || b == c || a == c ) cout &lt;&lt; 2 &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; 3 &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G"><a href="#G" class="headerlink" title="G."></a>G.</h2><p>前面填充<code>0</code>，剩下的位数从头开始输出字符串，直到凑齐n位，即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n , k;cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;cin &gt;&gt; s;</span><br><span class="line">    for(int i = 1;i &lt;= k;i ++)&#123;</span><br><span class="line">        cout &lt;&lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = k+1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cout &lt;&lt; s[i-k-1];</span><br><span class="line">    &#125;cout &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h2><p>小模拟，过的人还是挺多的，理清思路就好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int x , k , r;</span><br><span class="line"></span><br><span class="line">int leng( int num )&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    while( num )&#123;</span><br><span class="line">        num /= 10;</span><br><span class="line">        ans ++;</span><br><span class="line">    &#125;if( ans == 0 ) ans = 1;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void space( int num )&#123;</span><br><span class="line">    for(int i = 1;i &lt;= num;i ++) cout &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">    int len_init = leng(k) + 1 + leng(x);</span><br><span class="line">    while( x )&#123;</span><br><span class="line">        space( len_init - leng(k) - 1 - leng(x) );</span><br><span class="line">        r = x % k;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; &quot;|&quot; &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">        if( r &lt; 10 ) cout &lt;&lt; r;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout &lt;&lt; char(r-10+&#x27;A&#x27;);</span><br><span class="line">        &#125;cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">        space( len_init - leng(x) );</span><br><span class="line">        for(int i = 1;i &lt;= leng(x);i ++) cout &lt;&lt; &quot;-&quot;;</span><br><span class="line">        cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">        x /= k;</span><br><span class="line">    &#125;space(len_init-1);cout &lt;&lt; 0 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F."></a>F.</h2><p>一开始想二分套二分（大雾），后来发现只需要记录最长连续<code>L</code>的个数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n;string s;</span><br><span class="line">int top_R[N];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    int top_num = 0;</span><br><span class="line">    int ans = 1 , conti = 1;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        if( s[i-1] == &#x27;L&#x27; ) conti ++;</span><br><span class="line">        else&#123;</span><br><span class="line">            conti = 1;</span><br><span class="line">        &#125;ans = max( conti , ans );</span><br><span class="line">    &#125;cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h2><p>暴力会TLE，时间复杂度为 $O(2^n)$，即使是夹半搜索也要 $2^{50}$ 量级，故考虑dp</p><p>感觉和背包问题比较像，甚至要简单一点；不同点在于背包问题是求最优，而本题是求是否到达</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n , x;</span><br><span class="line">int a[110] , b[110];</span><br><span class="line">int dp[10010][110];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        for(int p = min(a[i],b[i]);p &lt;= x;p ++)&#123;</span><br><span class="line">            if( p &gt;= a[i] ) dp[p][i] |= dp[p-a[i]][i-1];</span><br><span class="line">            if( p &gt;= b[i] ) dp[p][i] |= dp[p-b[i]][i-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dp[x][n] ) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h2><p>并查集问题（当时写的时候以为是公共祖先弱化版，忘了并查集这个东西了）</p><p>然后判断每种情况的状态，最后合并即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e5;</span><br><span class="line">int n , m;</span><br><span class="line">int ans , x , y , z;</span><br><span class="line">int bin[N+10];</span><br><span class="line">int fa[N+10];</span><br><span class="line"></span><br><span class="line">int get_fa( int p )&#123;</span><br><span class="line">    if( fa[p] == p ) return p;</span><br><span class="line">    return get_fa(fa[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= m;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        if( bin[x] == 0 &amp;&amp; bin[y] == 0 )&#123;</span><br><span class="line">            ans ++;</span><br><span class="line">        &#125;else if( bin[x] &amp;&amp; bin[y] )&#123;</span><br><span class="line">            if( get_fa(x) != get_fa(y) )&#123;</span><br><span class="line">                ans --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;bin[x] = bin[y] = 1;</span><br><span class="line">        fa[get_fa( x )] = fa[get_fa( y )] = min( get_fa( x ) , get_fa( y ) );</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        if( bin[i] == 0 ) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-1"><a href="#G-1" class="headerlink" title="G."></a>G.</h2><p>这题我也不知道怎么过的，应该是运气好凑巧了吧</p><p>结束前十分钟写完思路发现样例二过不了，以为是假了，然后写下了<code>//做法假了，没时间了，开摆！</code>这句；后来发现忘了翻转这一步，加上了然后样例二过了，一提交居然AC了</p><p>首先观察样例，因为存在不同解，所以试图找到解的规律</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 3 4 -4 -7 -4 -1</span><br></pre></td></tr></table></figure><p>对以上操作积分一次（这个比喻有点抽象），可以发现只要确定了第一项，后面的就都确定了</p><p>不妨设第一项为 <code>0</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原式为： 2  3  3  4  -4  -7  -4  -1</span><br><span class="line">积分后：0  2  1  2  2  -6  -1  -3  2</span><br></pre></td></tr></table></figure><p>然后改变第一项，可以发现奇数项和偶数项分别加减第一项的改变值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原式为： 2  3  3  4  -4  -7  -4  -1</span><br><span class="line">积分后：0  2  1  2  2  -6  -1  -3  2</span><br><span class="line">改首项：1  1  0  3  1  -5  -2  -2  1</span><br></pre></td></tr></table></figure><p>这时，我们只需要确定第一项即可</p><p>但是第一项的范围为 ±1e9，所以需要借助和 <code>幸运数字</code> 的差值</p><p>进一步的，<strong>我们如果希望改变后的数字是幸运数字，只需要和目标的幸运数字们分别作差</strong>；差值结果即为<strong>第一项为某一数字</strong>后，这一项在变换（积分）后会变为幸运数字</p><p>由于每个幸运数字不同，故我们对于这个二维列表，只需要统计出现相同数字的最大次数即可（使用map进行统计）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5;</span><br><span class="line">int n , m;</span><br><span class="line">int s[N+10] , t[15];</span><br><span class="line">int state[N+10][11];</span><br><span class="line"></span><br><span class="line">map &lt; int , int &gt; mp;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= m;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    state[1][0] = 0;</span><br><span class="line">    for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">        state[i][0] = s[i] - state[i-1][0];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        for(int j = 1;j &lt;= m;j ++)&#123;</span><br><span class="line">            state[i][j] = t[j] - state[i][0];</span><br><span class="line">            if( i % 2 ) state[i][j] = -state[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        for(int j = 1;j &lt;= m;j ++)&#123;</span><br><span class="line">            mp[state[i][j]] ++;</span><br><span class="line">            ans = max( ans , mp[state[i][j]] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoboMaster福建师范大学2025赛季 飞镖组开发日志</title>
      <link href="/2024/11/24/RoboMaster%E7%A6%8F%E5%BB%BA%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62025%E8%B5%9B%E5%AD%A3-%E9%A3%9E%E9%95%96%E7%BB%84%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/2024/11/24/RoboMaster%E7%A6%8F%E5%BB%BA%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A62025%E8%B5%9B%E5%AD%A3-%E9%A3%9E%E9%95%96%E7%BB%84%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>本篇文章用于记录飞镖组开发日志，便于后人学习</p><p>因为也不是什么很珍贵的东西，所以没有上锁，希望其他队伍看到后能指点一二</p><p><a href="https://github.com/coperlm/FJNU_RM2025Tracking_Dart">电控代码开源</a></p><span id="more"></span><h2 id="此前的进度2024-11-24"><a href="#此前的进度2024-11-24" class="headerlink" title="此前的进度2024.11.24"></a>此前的进度2024.11.24</h2><p>版本：0.4</p><p><img src="飞镖电控进度.png" alt></p><p><img src="4ce449b5537292c77ccf71d186d179f.jpg" alt></p><p>硬件选型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主控：STM32f103c6t6</span><br><span class="line">陀螺仪：mpu6500</span><br><span class="line">通信：蓝牙串口模块</span><br><span class="line">舵机：3.7g舵机*2</span><br><span class="line">电池：格氏2s 450mAh 75C</span><br><span class="line">涵道：群汐30MM涵道 QF1611-14000KV</span><br><span class="line">电调：好盈天行者电调 20A V2 支持反转</span><br><span class="line">视觉：暂无</span><br></pre></td></tr></table></figure><p>对于陀螺仪部分</p><ul><li>使用mpu6500读取三个方向的速度和加速度</li><li>自写函数进行dmp解算获得pitch yaw roll，但是yaw会有累计偏转</li><li>解决yaw偏转（待解决）</li></ul><p>对于通信部分</p><ul><li>使用蓝牙模块进行串口通信</li><li>只有发送</li></ul><p>对于舵机</p><ul><li>转幅对应的pwm波为50-250（具体见配置和代码）</li></ul><p>对于电池</p><ul><li>小心使用！小心使用！小心使用！！！</li></ul><p>对于涵道</p><ul><li>三根线分别接电调的三个香蕉头</li></ul><p>对于电调</p><ul><li>xt30头接2s供电</li><li>杜邦头红线接单片机5V，黑线接地，白线为pwm波，范围为500-1000（具体见配置）</li></ul><p>对于视觉</p><ul><li>暂无</li></ul><p><a href="https://coperlm.github.io/2024/11/08/hal%E5%BA%93c6t6-Freerots/">FREEROTS</a></p><hr><h2 id="UPD2024-11-28"><a href="#UPD2024-11-28" class="headerlink" title="UPD2024.11.28"></a>UPD2024.11.28</h2><p>版本：0.5</p><p>陀螺仪问题已解决，直接用ai写的dmp解算并且甚至没有很大的零漂！（大雾）</p><p>至少确实能用了，而且一点点的零漂不会太影响镖体（但愿）</p><p>下一阶段开始把涵道驱动模块移植到这块焊的乱七八糟的板子上（大雾</p><p>但是移植过程中又不转了，这段时间二分查找一下bug，然后周六上午和视觉联调</p><h2 id="UPD2024-11-30"><a href="#UPD2024-11-30" class="headerlink" title="UPD2024.11.30"></a>UPD2024.11.30</h2><p>版本：0.6</p><p>已成功和视觉组联调，使用星瞳openMV接收数据成功，存在少量丢包</p><p>此版本可以通过视觉参数来返回给舵机（模式3）</p><p>舵机模块今天断线了，测试版demo很容易断线，需要谨慎使用，开始找人画板（</p><p><img src="demo2.jpg" alt></p><h2 id="UPD2024-12-05"><a href="#UPD2024-12-05" class="headerlink" title="UPD2024.12.05"></a>UPD2024.12.05</h2><p>版本：0.7</p><p>新增pid控制舵面</p><p>改为线性控制，应该更平滑一点</p><p>周末测一下</p><h2 id="UPD2024-12-10"><a href="#UPD2024-12-10" class="headerlink" title="UPD2024.12.10"></a>UPD2024.12.10</h2><p>发现舵面不需要pid（大雾），抖来抖去是因为视觉传过来的数据有丢，计划写个校验</p><p>今天先把环境配好（雾）</p><h2 id="UPD2024-12-15"><a href="#UPD2024-12-15" class="headerlink" title="UPD2024.12.15"></a>UPD2024.12.15</h2><p>版本：0.8</p><p>问了一下视觉组的学长，学习了一下其他兵种的先进经验</p><p>加了个头和尾，然后直接读很多数据（视觉发送比电控接收快很多）</p><p>直接从字符串里取数据即可</p><p>通信问题基本解决</p><p>之后需要干的，就是依次修改接收窗口，优化数据正确率，然后就是想想飞控该怎么写了</p><h2 id="UPD2024-12-19"><a href="#UPD2024-12-19" class="headerlink" title="UPD2024.12.19"></a>UPD2024.12.19</h2><p>数据通信延迟太高（错误的数据太多了）</p><p>今天想了个办法，直接发hex，这样可以减少30%的通信数据，延迟大大减小</p><p>但是几秒钟可能就会有一个数据出错</p><p>下一阶段计划改为一位起始位，一位终止位和一位校验位</p><p>如果直接用可见ascll，还可以再减少一位（大雾</p><h2 id="UPD2024-12-25"><a href="#UPD2024-12-25" class="headerlink" title="UPD2024.12.25"></a>UPD2024.12.25</h2><p>南航开源了机械图纸，该跳出来看了</p><p>控制算法没有开源，不过据说比较简单，然后重新翻<a href="https://www.bilibili.com/video/BV1ox4y1W783?t=642.9">青工会</a>，找到了这个控制算法</p><p><img src="image-20241225180451009.png" alt></p><h2 id="UPD2024-12-26"><a href="#UPD2024-12-26" class="headerlink" title="UPD2024.12.26"></a>UPD2024.12.26</h2><p>这两天研究了一下控制算法，然后自己重画了一遍这张图</p><p><img src="飞控.jpg" alt></p><p>学习了一下，大概思路和简单过程代码有了</p><p>不过自己写的dmp解算不包含角速度，这两天需要加上这个</p><p>预计元旦之前吧</p><h2 id="UPD2024-12-30"><a href="#UPD2024-12-30" class="headerlink" title="UPD2024.12.30"></a>UPD2024.12.30</h2><p>这几天在预习期末考试就没有推进度</p><p>然后为了应对中期，设置了个临时task</p><p>待解决问题</p><ul><li>涵道<ul><li>驱动不稳定</li><li>无法移植</li><li>不知道本质波形函数</li></ul></li><li>视觉<ul><li>传输有误 -&gt; 压画质</li></ul></li></ul><h2 id="UPD2025-01-03"><a href="#UPD2025-01-03" class="headerlink" title="UPD2025.01.03"></a>UPD2025.01.03</h2><p>这几天大概每天投入一个小时左右，都有进度，但是没写~</p><p>今天比较飞跃性的是，把视觉出错的问题解决了</p><p>然后涵道也会驱动了，只不过不知道为什么用Freerots驱动不了</p><h2 id="UPD2025-02-18"><a href="#UPD2025-02-18" class="headerlink" title="UPD2025.02.18"></a>UPD2025.02.18</h2><p>假期进度搁置了</p><p>今天把飞控算法基本完成了，今天晚上去拿摄像头，明天测试</p>]]></content>
      
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变色龙哈希学习笔记</title>
      <link href="/2024/11/24/%E5%8F%98%E8%89%B2%E9%BE%99%E5%93%88%E5%B8%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/24/%E5%8F%98%E8%89%B2%E9%BE%99%E5%93%88%E5%B8%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>用于记录变色龙哈希的学习历程</p><p>没写完，不打算写了~</p><span id="more"></span><h2 id="Chameleon-Hashing-and-Signatures"><a href="#Chameleon-Hashing-and-Signatures" class="headerlink" title="Chameleon Hashing and Signatures"></a>Chameleon Hashing and Signatures</h2><p>作者：Hugo Krawczyk, Tal Rabin</p><p>时间：1997</p><hr><h3 id="Based-on-Claw-free-Trapdoor-Permutations"><a href="#Based-on-Claw-free-Trapdoor-Permutations" class="headerlink" title="Based on Claw-free Trapdoor Permutations"></a>Based on Claw-free Trapdoor Permutations</h3><h4 id="General-Construction"><a href="#General-Construction" class="headerlink" title="General Construction"></a>General Construction</h4><h5 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h5><p><img src="image-20241124144432630.png" alt></p><p><img src="image-20241124144500854.png" alt></p><h5 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#基于线性方程进行模拟</span><br><span class="line">import random</span><br><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">a = 0 ; b = 0 ; c = 0 ; d = 0 ; p = 0</span><br><span class="line"></span><br><span class="line">def init():</span><br><span class="line">    global a, b, c, d, p</span><br><span class="line">    p = getPrime(512)</span><br><span class="line">    while True:</span><br><span class="line">        a = random.randint(1, 2**512)</span><br><span class="line">        c = random.randint(1, 2**512)</span><br><span class="line">        if gmpy2.gcd(a, p) == 1 and gmpy2.gcd(c, p) == 1:  # 确保 a 和 c 与 p 互质</span><br><span class="line">            break</span><br><span class="line">    b = random.randint(1, 2**512)</span><br><span class="line">    d = random.randint(1, 2**512)</span><br><span class="line"></span><br><span class="line"># 线性变换函数</span><br><span class="line">def f1(x):</span><br><span class="line">    return (a * x + b) % p</span><br><span class="line"></span><br><span class="line">def f2(x):</span><br><span class="line">    return (c * x + d) % p</span><br><span class="line"></span><br><span class="line"># 线性变换逆函数</span><br><span class="line">def inv_f1(y):</span><br><span class="line">    return (y - b) * gmpy2.invert(a, p) % p</span><br><span class="line"></span><br><span class="line">def inv_f2(y):</span><br><span class="line">    return (y - d) * gmpy2.invert(c, p) % p</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    init()</span><br><span class="line">    m1 = bytes_to_long(b&#x27;flag&#123;Chameleon_Hash_is_good&#125;&#x27;)</span><br><span class="line">    r1 = random.randint( 1 , p - 1 )</span><br><span class="line"></span><br><span class="line">    # 计算 H(m1, r1)</span><br><span class="line">    H = r1</span><br><span class="line">    for i in str(bin(m1)[2:]):</span><br><span class="line">        if i == &#x27;1&#x27;:</span><br><span class="line">            H = f1(H)</span><br><span class="line">        else:</span><br><span class="line">            H = f2(H)</span><br><span class="line">    print(f&quot;H(m1, r1): &#123;H&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    m2 = bytes_to_long(b&#x27;flag&#123;I_agree_with_msg1&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">    # 构造新的随机数 r2，使 H(m1, r1) = H(m2, r2)</span><br><span class="line">    r2 = H</span><br><span class="line">    for i in reversed(str(bin(m2)[2:])):  # 逆序推回原随机数</span><br><span class="line">        if i == &#x27;1&#x27;:</span><br><span class="line">            r2 = inv_f1(r2)</span><br><span class="line">        else:</span><br><span class="line">            r2 = inv_f2(r2)</span><br><span class="line">    print(f&quot;Recovered r2: &#123;r2&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 验证碰撞：计算 H(m2, r2)</span><br><span class="line">    H2 = r2</span><br><span class="line">    for i in str(bin(m2)[2:]):</span><br><span class="line">        if i == &#x27;1&#x27;:</span><br><span class="line">            H2 = f1(H2)</span><br><span class="line">        else:</span><br><span class="line">            H2 = f2(H2)</span><br><span class="line">    print(f&quot;H(m2, r2): &#123;H2&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 验证碰撞结果</span><br><span class="line">    if H == H2:</span><br><span class="line">        print(&quot;Hash collision successful!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;Hash collision failed!&quot;)</span><br></pre></td></tr></table></figure><h4 id="Based-on-the-Intractability-of-Factoring"><a href="#Based-on-the-Intractability-of-Factoring" class="headerlink" title="Based on the Intractability of Factoring"></a>Based on the Intractability of Factoring</h4><h5 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h5><p><img src="image-20241124145028359.png" alt></p><h5 id="计算过程-1"><a href="#计算过程-1" class="headerlink" title="计算过程"></a>计算过程</h5><p><img src="image-20241124145111175.png" alt></p><p><img src="image-20241124145458358.png" alt></p><h5 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h5><p>该问题的核心为平方根的计算，可以规约到因数分解问题</p><p>给定 $n = p \cdot q$ 和一个整数 $y \in \mathbb{Z}_n$，想要找到 $x \in \mathbb{Z}_n$ 使得：</p><script type="math/tex; mode=display">x^2 \equiv y \mod n</script><p>也就是计算 $y$ 在模 $n$ 下的平方根。</p><p>这在一般情况下是一个困难的问题，除非知道 $n$ 的两个素因数 $p$ 和 $q$。</p><p><img src="image-20241124145848008.png" alt></p><h5 id="实验代码-1"><a href="#实验代码-1" class="headerlink" title="实验代码"></a>实验代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#总是有问题，后面再解决</span><br></pre></td></tr></table></figure><h4 id="Based-on-Discrete-Log"><a href="#Based-on-Discrete-Log" class="headerlink" title="Based on Discrete Log"></a>Based on Discrete Log</h4><h5 id="系统参数-1"><a href="#系统参数-1" class="headerlink" title="系统参数"></a>系统参数</h5><p><img src="image-20241124150443879.png" alt></p><h5 id="计算过程-2"><a href="#计算过程-2" class="headerlink" title="计算过程"></a>计算过程</h5><p><img src="image-20241124150515030.png" alt></p><h5 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h5><p>已知 $CH(m,r) = g^m\cdot y^r$</p><p>即 $CH(m,r) = g^m\cdot g^{x\cdot r} = g^{m+x\cdot r}$</p><p>故令 $CH(m’,r’)\equiv CH(m,r)\mod p$</p><p>有 $g^{m’+x\cdot r’}\equiv g^{m+x\cdot r}\mod p$</p><p>即 $m’+x\cdot r’\equiv m+x\cdot r\mod q$</p><p>移项得到 $r’\equiv r+\frac{m-m’}{x}\mod q$</p><h5 id="实验代码-2"><a href="#实验代码-2" class="headerlink" title="实验代码"></a>实验代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#具体见比赛代码</span><br><span class="line">SK = random.randint(1, q)</span><br><span class="line">PK = pow( g , x , p )</span><br><span class="line"></span><br><span class="line">r1 = random.randint(1, q)</span><br><span class="line">CH = pow( g , h , p ) * pow( PK , r1 , p ) % p</span><br><span class="line">r2 = exgcd(SK,q)[0] * ( H(m1) - H(M2) + SK * r1 ) % q</span><br></pre></td></tr></table></figure><h3 id="Chameleon-Signature-Schemes"><a href="#Chameleon-Signature-Schemes" class="headerlink" title="Chameleon Signature Schemes"></a>Chameleon Signature Schemes</h3><h4 id="Chameleon-Signing"><a href="#Chameleon-Signing" class="headerlink" title="Chameleon Signing"></a>Chameleon Signing</h4><h5 id="签名步骤"><a href="#签名步骤" class="headerlink" title="签名步骤"></a>签名步骤</h5><p><img src="image-20241124152140812.png" alt></p><h5 id="验证步骤"><a href="#验证步骤" class="headerlink" title="验证步骤"></a>验证步骤</h5><p><img src="image-20241124152215559.png" alt></p><h5 id="争议解决"><a href="#争议解决" class="headerlink" title="争议解决"></a>争议解决</h5><p><img src="image-20241124152245224.png" alt></p><h4 id="Enhancements"><a href="#Enhancements" class="headerlink" title="Enhancements"></a>Enhancements</h4><h5 id="The-recipient’s-identity"><a href="#The-recipient’s-identity" class="headerlink" title="The recipient’s identity"></a>The recipient’s identity</h5><p>签名时不仅绑定消息的哈希值，还绑定接收者 RRR 的身份 $id_R$。这样可以避免签名者更改签名中的身份信息。</p><h5 id="Exposure-freeness"><a href="#Exposure-freeness" class="headerlink" title="Exposure-freeness"></a>Exposure-freeness</h5><h5 id="Memory-requirements"><a href="#Memory-requirements" class="headerlink" title="Memory requirements"></a>Memory requirements</h5><h4 id="Security-Requirements"><a href="#Security-Requirements" class="headerlink" title="Security Requirements"></a>Security Requirements</h4><h3 id="A-Full-Chameleon-Signature-Scheme"><a href="#A-Full-Chameleon-Signature-Scheme" class="headerlink" title="A Full Chameleon Signature Scheme"></a>A Full Chameleon Signature Scheme</h3><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p><img src="image-20241124153839032.png" alt></p><p><img src="image-20241124153903831.png" alt></p><hr><h2 id="Chameleon-Hashing-without-Key-Exposure"><a href="#Chameleon-Hashing-without-Key-Exposure" class="headerlink" title="Chameleon Hashing without Key Exposure"></a>Chameleon Hashing without Key Exposure</h2><p>作者：Xiaofeng Chen</p><p>时间：2004</p><hr><h3 id="Preliminary-Works"><a href="#Preliminary-Works" class="headerlink" title="Preliminary Works"></a>Preliminary Works</h3><h4 id="Gap-Diffie-Hellman-Group"><a href="#Gap-Diffie-Hellman-Group" class="headerlink" title="Gap Diffie-Hellman Group"></a>Gap Diffie-Hellman Group</h4><p>设 $G$ 是一个由生成元 $g$ 生成的循环乘法群，其阶数为素数 $q$。假设 $G$ 上的求逆运算和乘法运算可以高效完成。在这样的群 $G$ 上，定义以下三个问题：</p><p><img src="image-20241124161938171.png" alt></p><p>一个群 $G$ 被称为 Gap Diffie-Hellman 群，如果：</p><ol><li>判定性 Diffie-Hellman 问题（DDHP）可以在多项式时间内高效解决。</li><li>计算性 Diffie-Hellman 问题（CDHP）在没有特殊辅助信息的情况下没有多项式时间算法能够解决。</li></ol><p>换句话说，在这样的群中，验证 $g^c = g^{ab}$ 是简单的，但直接计算$g^{ab}$ 是困难的。</p><h4 id="Chameleon-Hashing"><a href="#Chameleon-Hashing" class="headerlink" title="Chameleon Hashing"></a>Chameleon Hashing</h4><h5 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h5><p><img src="image-20241124162706889.png" alt></p><p><img src="image-20241124162723878.png" alt></p><h5 id="Security-properties"><a href="#Security-properties" class="headerlink" title="Security properties"></a>Security properties</h5><p><img src="image-20241124162905738.png" alt></p><h5 id="Mention"><a href="#Mention" class="headerlink" title="Mention"></a>Mention</h5><p>“Key Exposure Problem” is not but——</p><p><img src="image-20241125121442330.png" alt></p><p>（这一条存疑）</p><h4 id="how-to-key-exp"><a href="#how-to-key-exp" class="headerlink" title="how to key_exp"></a>how to key_exp</h4><script type="math/tex; mode=display">CH(m)=g^{m+x\cdot r} \\CH(m')=g^{m'+x\cdot r'}</script><p>$g$是系统公共参数，已知</p><script type="math/tex; mode=display">\begin{flalign}已知&\ g^my^r=g^{m'}y^{r'}\\所以有&\ g^mg^{x\cdot r}=g^{m'}y^{x\cdot r'}\\则有&\ m+x\cdot r=m'+x\cdot r'\\移项得到&\ x=\frac{m-m'}{r'-r}\end{flalign}</script><h2 id="On-the-Key-Exposure-Problem-in-Chameleon-Hashes"><a href="#On-the-Key-Exposure-Problem-in-Chameleon-Hashes" class="headerlink" title="On the Key Exposure Problem in Chameleon Hashes"></a>On the Key Exposure Problem in Chameleon Hashes</h2><p>作者：Giuseppe Ateniese</p><p>时间：2004</p><hr><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>上一篇论文提供了一种密钥无暴露变色龙哈希函数的具体构造，该函数在具有双线性配对的 Gap 群设置下工作。虽然这无疑是密钥无暴露变色龙哈希的第一个完整构造，但它并没有解决是否存在基于其他加密假设或更高效方案的构造的问题，例如与 [12] 中的原始变色龙哈希函数具有可比性能的构造。</p><p>Ateniese, G., de Medeiros, B.:<br>Identity-based chameleon hash and applications.<br>In Fi-<br>nancial Cryptography 2004. LNCS 3110, Springer-Verlag (2004) 164–180. Available online at<br><a href="http://eprint.iacr.org/2003/167/">http://eprint.iacr.org/2003/167/</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一道2024.11.17做法南辕北辙的简单算法题</title>
      <link href="/2024/11/21/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%932024-11-17%E5%81%9A%E6%B3%95%E5%8D%97%E8%BE%95%E5%8C%97%E8%BE%99%E7%9A%84%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2024/11/21/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%932024-11-17%E5%81%9A%E6%B3%95%E5%8D%97%E8%BE%95%E5%8C%97%E8%BE%99%E7%9A%84%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/2037">Codeforces Round 988 (Div. 3)</a>因为当天有点头疼，飞速过了ABC，D卡住了，就去睡觉了</p><p>后来发现做法南辕北辙了</p><p>题目链接：<a href="https://codeforces.com/contest/2037/problem/D">D. Sharky Surfing</a></p><span id="more"></span><p>我的思路：</p><p>大致是从后往前扫，每次都要排序一次，然后选最优的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n , m , L;</span><br><span class="line">int l[N+10] , r[N+10];</span><br><span class="line">int x[N+10] , v[N+10];</span><br><span class="line">int tempque[N+10] , top = 0;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    // ios::sync_with_stdio( false );</span><br><span class="line">    int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i &lt;= m;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; x[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int jump_max = 0;</span><br><span class="line">        for(int i = 1;i &lt;= m;i ++)&#123;</span><br><span class="line">            if( x[i] &lt; l[n] ) jump_max += v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;bool flag = 1;</span><br><span class="line">        for(int i = n,j = m;j &gt;= 1;i --)&#123;</span><br><span class="line">            if( jump_max &gt; r[i] - l[i] + 1 )&#123;</span><br><span class="line">                top = 0;</span><br><span class="line">                while( x[j] &gt; l[i] )&#123;</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;</span><br><span class="line">                while( x[j] &gt; l[i-1] )&#123;</span><br><span class="line">                    tempque[++top] = v[j--]; </span><br><span class="line">                &#125;</span><br><span class="line">                if( top == 0 ) continue;</span><br><span class="line">                sort( tempque + 1 , tempque + top + 1 );</span><br><span class="line">                int k = 1;</span><br><span class="line">                cout &lt;&lt; &quot;jp: &quot; &lt;&lt; jump_max &lt;&lt; endl;</span><br><span class="line">                while( jump_max - tempque[k] &gt; r[i] - l[i] + 1 )&#123;</span><br><span class="line">                    cout &lt;&lt; &quot;del: &quot; &lt;&lt; jump_max &lt;&lt; &quot; &quot; &lt;&lt; tempque[k] &lt;&lt; endl;</span><br><span class="line">                    cout &lt;&lt; &quot;de2: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; r[i] - l[i] + 1 &lt;&lt; endl;</span><br><span class="line">                    jump_max -= tempque[k++];</span><br><span class="line">                    ans ++;</span><br><span class="line">                    if( k == top ) break;</span><br><span class="line">                &#125;cout &lt;&lt; &quot;K1: &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; top &lt;&lt; endl;</span><br><span class="line">                while( k &lt;= top ) jump_max -= tempque[k++];</span><br><span class="line">                for(int kk = 1;kk &lt;= top;kk ++) tempque[kk] = 0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">                flag = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;if( flag ) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        // for(int j = 1;j &lt;= m;j ++) tempque[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来第二个测试点的第一百多行wa了，我意识到做法假了，去看题解了</p><p>正解：正着扫，直接用堆存，贪心最大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt; int , vector&lt; int &gt; , less &lt; int &gt; &gt; q;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n , m , L;</span><br><span class="line">int l[N+10] , r[N+10];</span><br><span class="line">int x[N+10] , v[N+10];</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio( false );</span><br><span class="line">    int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i &lt;= m;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; x[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0 , jump_range = 0;</span><br><span class="line">        int tool_top = 1;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            while( l[i] &gt; x[tool_top] &amp;&amp; tool_top &lt;= m )&#123;</span><br><span class="line">                q.push(v[tool_top++]);</span><br><span class="line">            &#125;</span><br><span class="line">            while( r[i] - l[i] + 1 &gt; jump_range )&#123;</span><br><span class="line">                if( q.empty() ) &#123;</span><br><span class="line">                    ans = -1;break;</span><br><span class="line">                &#125;</span><br><span class="line">                jump_range += q.top();</span><br><span class="line">                q.pop();ans ++;</span><br><span class="line">            &#125;if( ans == -1 ) break;</span><br><span class="line">        &#125;while( !q.empty() ) q.pop();</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>不要钻牛角尖；简单题想复杂了，可以先吃点东西~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.11.13组会</title>
      <link href="/2024/11/13/2024-11-13%E7%BB%84%E4%BC%9A/"/>
      <url>/2024/11/13/2024-11-13%E7%BB%84%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="307c6eabb0db367344b32e4da242361fa556607c2e11166cc5dbb4516001b20e">7b22b1899bb4d215751e07a80f0d88deb2614f28e80f008bc2b112134b341b269ac033ff42f7078e7d01a084c3769a0cb2063eaead925b8aa04d900019bdd5dfa7fe379d5495bb9baa52c0410b4fab87e4eed009db153f2d6bac4ed1734734ea4b08fd37599b30d983f51893ce484b97d40a16035ae00c256444987677f23777d3dad6a27f8c8e8f4041b3f8c0c3efeb400621fec5ce330c321ff8950ee04ca3ae56b77f62fa41f626740356268a8a1f75fe8a69ac974e7ba020368d3918583f05d86b9c5ace613ae4e7401f53adc6712ef8b3719f68cd068d716e4ee8535b2efea5297b6cb3dcb1462bb34ff9f0cf4fc148fd6012e68138f2592527c65da13c4aba8f550a4ed071ad6341791afbdc58dd4470b71cfd6643c3a2838a57e412b5aa0e456ce83e8c0bd2bdfc720529b87c8b37b42754aa01a117b90c6ecc50ab6a3d9ce8e0c699e352722ab4366d218c4fda666075414b235e9764a0fbbc3b6a9c40007f697361b42607175cc415baad86cba56dbc3ba11fa1c760d7932a3b3fc0054b0ed450d7aa94ce3a8fa332d11002bf7d3824b992af0a085decd53e7999cc2d2e6c1930f811ae7168f9773de1ac711cf177e88b291867dea6ce7db89ad6b4b291a5d11b8f067d8ebc1efd685c49463fdcff5f48cebf3d67d0f2e1c8654ed0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> meetings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九届全国密码技术竞赛参赛游记</title>
      <link href="/2024/11/12/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E7%AB%9E%E8%B5%9B%E5%8F%82%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
      <url>/2024/11/12/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E7%AB%9E%E8%B5%9B%E5%8F%82%E8%B5%9B%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>确切而言，这并不能算得上是游记，因为是个线上作品赛，然后没晋级</p><p>不过收获的东西也不少，值得记录一下</p><span id="more"></span><p><a href="https://www.chinacodes.com.cn/">竞赛官网</a></p><p>比赛刚开始报名，我还是个什么都不懂的小白（虽然现在也是）</p><p>然后师兄师姐们在那边弄比赛，问我要不要一起报名，这种好事当然要报名（</p><p>然后就有了这篇游记（也算是游记吧</p><hr><p>这次比赛我负责的是文档部分，当然代码也需要看懂</p><p>师兄写的代码很直观很可读，很容易就读完了，然后开始写文档</p><p>这算是我第一次写这种文档，还在积累经验中</p><p>后续逐渐完善，然后交上了，然后······就没有然后了~</p><hr><p>通过比赛我学到的东西：</p><ol><li>关于密码学，什么是有贡献的，什么是无效的</li></ol><p>无效的是指，简单的缝合怪，把已有成果结合在一起，但是对学术界帮助不大</p><p>有贡献的是指，切切实实有创新点，例如给某个密码学算法新增了某个功能，或者提高安全性这样子</p><p>这次比赛，我们写的东西（不方便透露）应当算是比较无共享的，单纯将一些东西缝合在一起（当然也有可能是我写文档写得不好导致的）</p><p>虽然有代码实现，但是并未将这个作为亮点来展示，没有坚持一开始的方案（也是因为遇到的困难过多了）</p><ol><li>写文件的要细心</li></ol><p><img src="1.jpg" alt></p><p>感谢导师给改的文章，我看完导师标的内容，感觉要替导师吐血了——怎么这么多格式有问题的</p><p>文件保存好了，以后写文章要再翻阅</p><ol><li>赛后看了隔壁组师兄的作品，发现了差距</li></ol><p>无论是作品含金量和页面颜值，我们都是被碾压的</p><p>然后又看了看师兄做的PPT，很多图片，很好看</p><p>我意识到，读研的话做PPT做的好看十分重要；所以需要多收集一些做的好看的PPT进行阅读和模仿</p><ol><li>然后就是学期计划，该推进度了（悲</li></ol><p>二八定律：百分之70的学期过去了，只完成了30%的task</p><p>无论如何，加油加油</p><p><img src="2.gif" alt></p><hr><p><strong>密码学竞赛作品制作有感24-10-17</strong></p><p>最近和两个师兄在准备密码学竞赛，我们的作品是online-offline 数字签名，用sm2和sm3去实现</p><p>最一开始我重构了一下变色龙哈希文件的内容，去掉了没有用的代码，顺便改了一下库函数（因为有一个库，pip无法直接安装）</p><p>之后文档大致完成之后，因为是在线离线签名，可以应用在轻量级设备上，所以我想移植到单片机上，但是stm32仅支持c/cpp，然后买了个pico，但是开发经验太少导致不会玩，于是转回stm32，最终耗时二十小时左右，最终被玄学问题卡住了</p><p>之后计划使用centos-mini运行代码测试效率，开始搭建环境······</p><p>然后看了一下师兄画的图，和导师交流了一下，得知以上我做的对比赛而言并不是很重要，重要的是在图表中展示出效率之高</p><p>然后微调了一下代码···</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">改之前:</span><br><span class="line">验证结果为:1</span><br><span class="line">总时间为:1.7519575000042096</span><br><span class="line">在线时间:1.1509204999892972</span><br><span class="line">改之后:</span><br><span class="line">验证结果为:1</span><br><span class="line">总时间为:1.7590351999970153</span><br><span class="line">在线时间:0.5761120000388473</span><br></pre></td></tr></table></figure><p>效率飙升！</p><p>画出来的图表也十分可观</p><p>后来总结了一下，写文章重要的是怎么让专家看着觉得做出东西了，尤其是画图，一定要展现出轻量级（具体值少于1s就可以了），所以数据选择很重要；还有就是注意细节，每个点都要多校验一遍</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIS学习笔记</title>
      <link href="/2024/11/11/LIS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/11/LIS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前情提要：蓝桥杯校赛压轴题，是道朴素最长上升子序列板子题；没做出来，故学习记录一下</p><span id="more"></span><p><img src="1.jpg" alt></p><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.com.cn/problem/B3637">题目链接</a></h3><p>设原数列为 <code>1,2,4,1,3,4</code>，$f(x)$ 表示以第 $i$ 个数为结尾的最长上升子序列的长度</p><div class="table-container"><table><thead><tr><th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>$a_i$</td><td>1</td><td>2</td><td>4</td><td>1</td><td>3</td><td>4</td></tr><tr><td>$f(n)$</td><td>1</td><td>2</td><td>3</td><td>1</td><td>3</td><td>4</td></tr></tbody></table></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>读入数据</li><li>大循环开始，从 $1$ 到 $n$，计算 $f_i$，记得初始值是 $1$</li><li>小循环，从 $1$ 到 $i−1$，如果 $a_j$ 小于 $a_i$ 的话，说明这个数可以和 $f_i$ 组成上升子序列，则 $f_i$ 取 $max⁡(f_i,f_j+1)$</li><li>寻找最大值</li></ul><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 5e3;</span><br><span class="line">int a[N+10];</span><br><span class="line">int f[N+10];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n;cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        f[i] = 1;</span><br><span class="line">        for(int j = 1;j &lt;= i-1;j ++)&#123;</span><br><span class="line">            if( a[j] &lt; a[i] ) f[i] = max( f[i] , f[j]+1 );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;int ans = 0;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) ans = max( ans , f[i] );</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分优化"><a href="#二分优化" class="headerlink" title="二分优化"></a>二分优化</h3><p>我们定义一个数组 <code>tails</code>，其中 <code>tails[k]</code> 表示长度为 $k+1$ 的上升子序列的最小尾元素。该数组帮助我们追踪可能构成的上升子序列的最小值，从而达到优化的效果。算法的核心步骤是：</p><ol><li><p>遍历数组 <code>a</code> 中的每个元素 <code>num</code>。</p></li><li><p>使用二分查找在 <code>tails</code> 中找到第一个大于等于 <code>num</code> 的位置 <code>pos</code>。</p><ul><li><p>如果 <code>pos</code> 等于 <code>tails</code> 的长度，说明 <code>num</code> 比 <code>tails</code> 中所有元素都大，可以直接将 <code>num</code> 添加到 <code>tails</code> 末尾，增加子序列长度。</p></li><li><p>否则，用 <code>num</code> 替换 <code>tails[pos]</code>，以确保 <code>tails</code> 保持递增且末尾值尽可能小。</p></li></ul></li><li><p>最终 <code>tails</code> 的长度即为最长上升子序列的长度。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 5e3;</span><br><span class="line">int a[N+10];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int n;cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];</span><br><span class="line">    vector&lt; int &gt; tails;</span><br><span class="line">    for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">        int num = a[i];</span><br><span class="line">        auto pos = lower_bound( tails.begin() , tails.end() , num );</span><br><span class="line">        if( pos == tails.end() )&#123;</span><br><span class="line">            tails.push_back( num );// 如果 num 比所有元素都大，添加到末尾</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            *pos = num;// 替换找到的第一个 &gt;= num 的位置，保证尾部元素尽量小</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; tails.size() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荔枝橙味CF糕守</title>
      <link href="/2024/11/11/%E8%8D%94%E6%9E%9D%E6%A9%99%E5%91%B3CF%E7%B3%95%E5%AE%88/"/>
      <url>/2024/11/11/%E8%8D%94%E6%9E%9D%E6%A9%99%E5%91%B3CF%E7%B3%95%E5%AE%88/</url>
      
        <content type="html"><![CDATA[<p>本文汇总了CF如何上分的两篇博客</p><span id="more"></span><h1 id="来源于2426"><a href="#来源于2426" class="headerlink" title="来源于2426"></a>来源于2426</h1><h2 id="rating-1000-1400"><a href="#rating-1000-1400" class="headerlink" title="rating 1000-1400"></a>rating 1000-1400</h2><p>到达青名（1400）需要做到三点。</p><ul><li>能够快速写出模拟题（5到10分钟内）</li><li>能够快速写出暴力（5到10分钟内）</li><li>能够在脑子里或草稿纸上把问题分情况讨论（例如，N=2、N=3、N&gt;=4）</li></ul><p>举个例子，在Codeforces Round #556中，如果你可以做到以上三点，就可以很惊喜地在Div2中达到200名，这是一个很夸张的例子。但在Codeforces Round #554 (Div. 2)中，你只能达到3400名，rating1250及以下的参赛者可以上分。</p><p>平均来说，如果你可以做到以上三点，rating就可以达到1400。</p><p><strong>[[如何训练]]</strong></p><p>首先，建议打ABC；尽管CF上有很多好题，但如果你想更容易地练习编程，最好去刷AtCoder。</p><p>特别地，推荐做ABC中的B题和C题。做B题可以学到如何更快地写模拟和暴力，做C题可以学到如何想题、如何用草稿纸更快地想出解决方案。如果你切了所有的B题和C题，就会学到很多，变得更强。</p><p>可以借助<a href="https://kenkoooo.com/atcoder#/table//">AtCoder problems</a>的帮助刷AtCoder，你能从这个网站知道自己做了哪些题。</p><p>当你刷AtCoder时，有几点很重要：</p><ul><li>当你想不出解决方案时，应该在思考B题15分钟、思考C题30分钟后再看题解。可悲的是，最近几场ABC没有英文题解，但你可以读标程（题解中很可能包含标程的链接）。</li><li>即使你AC了某道题，在习惯快速写代码前，还是可以通过阅读大佬的源代码学到一些东西。所以建议看一些简单的源代码。</li><li>特别是当你做C题时，推荐你用草稿纸辅助思考。不用纸的话，用白板打草稿也可以。</li></ul><h2 id="rating-1400-1900"><a href="#rating-1400-1900" class="headerlink" title="rating 1400~1900"></a>rating 1400~1900</h2><p>CF上人数最多的rating区间是[1400, 1500]。他们都很想上分，但从1500开始上分比较困难，很多人放弃了。但也有很多人坚持训练，成功上分。</p><p>要达到1900，需要下面的技巧：</p><ul><li><p>掌握并能够使用以下主要算法：</p><ul><li>暴力</li><li>动态规划</li><li>深度优先搜索</li><li>广度优先搜索</li><li>迪杰斯特拉</li><li>树状数组</li><li>排列数、组合数</li><li>乘法逆元</li><li>位掩码</li><li>二分查找</li></ul><p>注意：一般而言在rating 1800前，线段树不是必须的。上紫以后才需要学的线段树。</p></li><li><p>提高手速（例如，R1100的题目5分钟写好，R1400的题目10分钟写好）。手速在CF很重要，因为一般来说，如果题目难度范围很大，手速会在很大程度上影响rating。</p></li></ul><p><strong>[[如何训练]]</strong></p><p>如果你不擅长快速写代码、快速调试，就应该刷AtCoder。事实上，从统计学上讲，很多日本选手手速很快，但不擅长解决难题，觉得是AtCoder的锅。</p><p>推荐做ABC的C题和D题。平均来说，如果能在10分钟内解决C题，在20分钟内解决D题，你就是手速场中的Div1</p><p>如果你不擅长解难度高于R1400的题，就应该学一些上面提到的算法，做做CF上的板题。举个例子，如果你觉得自己不擅长DP，就刷CF上R1200到R1400的DP标签的题。让人惊讶的是，只有约50道难度小于等于R1400的DP标签的题。</p><p>有趣的是，板题都集中在只有Div2的那些比赛中。如果你不擅长只有Div2的比赛，那么很可能是你不擅长使用典型算法，尤其是上面提到的10种算法。</p><p>如果你能做板题，但不擅长做难度高于R1500的题，就要开始在TopCoder刷题。这类练习对擅长只有Div2的比赛但不擅长Div1+Div2一体的、分开的比赛的人十分有效。</p><p>有时候，尤其是在Div1+Div2的比赛中，一些题目需要数学概念或者思考。因为TopCoder上有很多题用到这些（另外还有简便的实现！），所以你应该刷TopCoder。</p><p>推荐刷最近100场SRM的Div1简单。但有些题真的太难了（甚至粉名都切不掉），所以刷之前，你应该看一下题目的通过率。你可以利用<a href="https://competitiveprogramming.info/来获取一些信息。">https://competitiveprogramming.info/来获取一些信息。</a></p><p>不幸的是，不知道有没有像AtCoder Problems那样，能够看自己在TopCoder SRM中做过哪些题的网站。所以，如果你想记录自己刷过那些题，应该做一个电子表格或者表格，例如：<a href="https://drive.google.com/file/d/1mSy9PM4Km8EVv8Lp4nhitorOe2HbAS1e/view?usp=sharing">https://drive.google.com/file/d/1mSy9PM4Km8EVv8Lp4nhitorOe2HbAS1e/view?usp=sharing</a></p><p>当还是个蓝名时，数学思维也很糟糕。在切了50题Div1简单以后，在TopCoder成了蓝名，在CF成了紫名</p><p>如果你擅长切题，但在比赛中发挥不好，就应该多打虚拟赛。你知道CF的虚拟赛系统吗？你可以虚拟参赛！</p><h2 id="rating-1900-2200"><a href="#rating-1900-2200" class="headerlink" title="rating 1900~2200"></a>rating 1900~2200</h2><p>如果你想达到2200，首先，你应该是Div1，并且参加Div1的比赛。这意味着你应该刷很多难题（R1900或更高）</p><p>即使你手速快或者十分擅长切板题，打Div1比赛也是很难的。可悲的是，有很多选手在蓝名和紫名之间摇摆</p><p>要达到2200，需要以下技巧：</p><ul><li>知道并且会用上面提到的10种算法，还要加个线段树（包括懒标记）</li><li>非常快的手速：R1100 5分钟，R1500 10分钟，R1800 15分钟，R2000 40分钟</li><li>相当好的数学思维和思考问题的能力</li><li>强大的思维，可以支持超过1小时的思考，即使在Div1比赛中途落后了也不放弃</li></ul><p><strong>[[如何训练]]</strong></p><p>这只是的训练方式：在rating2000时打了很多虚拟比赛。在这里，虚拟比赛并不意味着“虚拟参与”，而是选择4到5道难度在自己rating附近的题目（举个例子，目前rating是2000，那么选择CF中R2000的题目），并且在2小时内切掉</p><p>你可以利用<a href="https://vjudge.net/。在这个网站，你可以从很多OJ上（AtCoder、CF、Hackerrank、Codechef、POJ……）拉题组一场虚拟赛">https://vjudge.net/。在这个网站，你可以从很多OJ上（AtCoder、CF、Hackerrank、Codechef、POJ……）拉题组一场虚拟赛</a></p><p>如果你在虚拟赛中不能切掉这些题，而且没有想出解决方案，就应该去谷歌查题解（举个例子，如果你想找Codeforces Round #556 (Div. 1)的题解，就去谷歌搜“Codeforces Round #556 editorial”）</p><p>在CF上分还有一件重要的事。为了更快的手速，你应该准备一些板子。例如，认为线段树板子、懒标记线段树板子、CRT的板子、FFT的板子、计算几何板子等等都是很有效的</p><h3 id="rating-2200-2400"><a href="#rating-2200-2400" class="headerlink" title="rating 2200~2400"></a>rating 2200~2400</h3><p>这是本博客关于训练技巧的最后一部分。事实上，卡在橙名很久了，就连在虚拟赛中平均表现也是橙名。这是因为之前的训练方法在橙名遇到了障碍</p><p>Rating 2200到2400事实上非常难——如果你平均表现2200，如果你练习赛打得更多，上粉（到2400）看上去也没那么难。但是平均表现2400比你想象的要难得多。如果你的rating正好是2400，那么在Div1的比赛上，你一般要打进前20%（例如，如果有525人参加，那么你应该最差在105名）才能上分</p><p>要达到2400，需要以下技巧：</p><ul><li>Rating达到2200</li><li>在Div1比赛中切掉AC少于100人的难题</li></ul><p>如果你想切难题和用ad-hoc临时方法的题，根据TozanSoutherPacks在上一篇博客下的评论（<a href="http://codeforces.com/blog/entry/53341?#comment-373965），“要达到2600分乃至更高，你应该切Boss题，所有这些都是临时问题或者步骤很多的问题。”觉得那是对的，但是对来说，觉得即使你只想达到2400分，切步骤很多的临时问题也是有必要的。">http://codeforces.com/blog/entry/53341?#comment-373965），“要达到2600分乃至更高，你应该切Boss题，所有这些都是临时问题或者步骤很多的问题。”觉得那是对的，但是对来说，觉得即使你只想达到2400分，切步骤很多的临时问题也是有必要的。</a></p><p><strong>[[如何训练]]</strong></p><p>达到2400分最安全的方法是“切4000道题”。就在TopCoder、AtCoder、CF等OJ上切了超过4000题</p><p>事实上，有一个传说（或者说是事实）是，最NB的选手tourist在他这辈子切了一万多题</p><p>但是可能很多人觉得自己没时间。所以会给你一些更高效的途径</p><p>首先，AtCoder上有很多教育题。推荐你做<strong>ARC尤其是ARC058到ARC090</strong>的E题和F题（尤其是AtCoder中700到900点的题目）。尽管以前的ARC在“思维”和“模板”之间是平衡的，但可悲的是，认为AGC和最近的ARC实际上太偏向思维了，所以如果你的目标是在CF上分，不推荐它们（尽管如果你想达到2600乃至更高，还是要刷AGC）</p><p>对来说，实际上，刷了ARC以后，在CF虚拟赛的平均表现从2100提高到了2300（I could not reach 2400 because start was early）</p><p>如果你切不动题，推荐你放弃思考并且看题解的时间如下：</p><div class="table-container"><table><thead><tr><th>AtCoder点值</th><th>CF难度</th><th>思考时间</th></tr></thead><tbody><tr><td>600</td><td>R2000</td><td>40分钟</td></tr><tr><td>700</td><td>R2200</td><td>50分钟</td></tr><tr><td>800</td><td>R2400</td><td>60分钟</td></tr><tr><td>900</td><td>R2600</td><td>70分钟</td></tr><tr><td>1000</td><td>R2800</td><td>80分钟</td></tr></tbody></table></div><p>如果你切了AtCoder上的教育题，你编程比赛的技能将会有所提高。但还有另一个问题，没有付诸实践，你没办法上分</p><p>所以，你应该至少在CF上打50场虚拟赛（尤其是Div1）。在虚拟赛中，你可以学到，紫名、橙名应该如何打比赛（比如比赛策略），以及如何在CF比赛中利用在AtCoder学到的技巧。<strong>强烈推荐在虚拟赛后看看所有题的题解，除了太难的题</strong>（比如在比赛中AC人数少于30的题）。还建议，在打完比赛看完题解后在笔记本上写一些对于比赛策略、教训和可以改进的地方的反思</p><p>此外，建议你每周一次，花点时间思考一些难题（比如CF上R2800的题）。如果你想了很久也想不出来，建议你去读题解，因为那样你可以学到很多。解决难题可能会给你一场上分100+的机会，也会给你更快解决简单题的机会</p><p>最后，猜这个方法对于超过30%的人奏效，因为用这个方法在CF上粉，square1001用这个方法在TopCoder上红。希望的方法可以产生新的粉名</p><h2 id="训练心理"><a href="#训练心理" class="headerlink" title="训练心理"></a>训练心理</h2><p>心理问题是选手中最常见的问题之一。即使对，直到最近两个月前，出于对一场掉分100+的恐惧，超过9个月没打过CF上rated的比赛。另外，还有几场比赛甚至都做不到看下一个题，因为做不出来更简单的题，心态崩了</p><p>最近发现一种锻炼心态的办法</p><ul><li>制定一个比赛前的常规程序。这能让们在比赛期间集中注意力<ul><li>事实上，就而言，的常规程序是在比赛快开始时看着倒计时减少到0。黑红大佬yutaka1999实际上在IOI开始前就在修禅</li></ul></li><li>如果你比赛中没发挥好（比如20分钟内切不掉B题），不去看榜也是个好主意</li><li>还有一件重要的事：“比赛过程中不要管rating”<ul><li>觉得，即使这场要掉分，下一场上分的可能性也提高了。这就是为什么在比赛过程中不管rating</li></ul></li><li>不要过于在意之前犯过的错误。错误也是一次好的学习机会，每个人都会犯错。即使是tourist也曾经在AtCoder World Tour Finals上翻车<ul><li>觉得吧，“rating”和“你犯过多少错、做过多少<strong>反思</strong>”之间存在关联</li></ul></li></ul><p>以上这些方法不仅在正式比赛中适用，还在虚拟赛中适用。注意：比赛中不要有太大的压力，开心就好</p><p><img src="image-20241111140735122.png" alt></p><h1 id="来源于2909"><a href="#来源于2909" class="headerlink" title="来源于2909"></a>来源于2909</h1><p>上级篇是针对想成为AtCoder黄名（2000+，对应CF2200+），以及橙名（2400，对应CF2522+）阶段的选手的进步指南</p><p><img src="image-20241111142431742.png" alt></p><p>右边的评价来自于AtCoder的老版chokudai的<a href="https://chokudai.hatenablog.com/entry/2019/02/11/155904">博客</a></p><p><img src="psc3.png" alt></p><h2 id="成为黄名选手的6个要求"><a href="#成为黄名选手的6个要求" class="headerlink" title="成为黄名选手的6个要求"></a>成为黄名选手的6个要求</h2><p>为了在AtCoder里成为黄名，你需要达到2000分（CF2200分）</p><ol><li>在AtCoder Beginner Contest里稳定切掉5题</li><li>在AtCoder Beginner Conetst里半数情况切掉6题</li><li>简单的问题（500分内）尽快解决</li><li>根据相关数据，A题1分内，B题2分内，C题5分内，D题10分内，E题20分内比较合理</li><li>理论上你最好在40分钟内切掉5题</li><li>AGC之类对数学要求比较高的比赛里，最好能切掉2题</li></ol><p>这是在竞赛里黄名选手的平均表现。为了保持这个表现，你需要做到以下6点。当然水色选手要做到的4点你也要做到（中级篇内容）</p><p><strong>条件1</strong><br>挑战程序设计竞赛（AKA蚁书）上面记载的大部分算法和数据结构都要理解。具体来说，需要了解以下23个算法和5个数据结构</p><p>中级篇2-1节里的12个算法和3个数据结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">枚举二分搜索深度优先搜索广度优先搜索</span><br><span class="line">动态规划DijkstraFloydKruskal</span><br><span class="line">线性筛快速幂逆元前缀和·差分</span><br><span class="line">图论树并查集</span><br></pre></td></tr></table></figure><p>中级篇没有提到但是挑战里写过的11个算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">离散化分治矩阵乘</span><br><span class="line">博弈论(原文是Grundy数)字符串哈希 分块</span><br><span class="line">最小割二分图判定 二分图匹配</span><br></pre></td></tr></table></figure><p>中级篇没有提到但是挑战里写过的2个数据结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树状数组 线段树与懒标记</span><br></pre></td></tr></table></figure><p><strong>条件2</strong></p><p>条件1介绍的算法和数据结构，在各种比赛里学会使用，同时将本文介绍的算法和数据结构熟练掌握，变成自己的东西</p><p><strong>条件3</strong><br>有一定的数学能力</p><p>在AtCoder里，不仅仅考验你能否灵活使用各种算法的能力，也频繁出现了大量的数学问题（和中级篇2-3里95-100的问题一样），问题也越来越难和多样。因此，为了成为黄名选手，要多多做一些数学题</p><p><strong>条件4</strong></p><p>25行左右的程序，基本Bug Free写出来</p><p>60行左右的程序，基本很快地写出来，出了BUG也能在10分钟内解决</p><p>实际上，60行左右的程序，能够30分钟内写完并且de完bug，是大概率能AK掉ABC的</p><p><strong>条件5</strong></p><p>打字速度要快！经验来讲，1分钟要350个字符才够用</p><p>实际上，一些高排名选手里也有打字很慢的人（200个字符左右），但是想在ABC里拿到好成绩，打字速度实在太重要了</p><p>比如说AtCoder 148里，30分钟AK和40分钟AK，差距250以上的表现分</p><p><strong>条件6</strong></p><p>一般来说，AtCoder的过去的题目要做1000题以上</p><p><strong>补充</strong></p><p>以上的6个条件满足了的话，ABC的E问题基本难不倒你。F问题的话，如果是超过250人做出来的场次，你应该也能做出来才对</p><p>顺便一提，最近15场ABC（141~155），F问题做出来的超过250人的场次有7场。因此AK掉ABC的概率应该是3-5成</p><p>满足了6个条件，再练练数学能力，AGC的问题解决出来的概率应该会慢慢增加</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>掌握11个全新的算法</li><li>学会2个新的数据结构</li><li>去解决TopCoder SRM的问题，锻炼数学能力</li><li>去解决JOI（日本信奥）的题目，锻炼能力</li><li>解决以前Contest的题目</li><li>多多VP找感觉</li><li>练打字速度</li></ol><hr><p>references:</p><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-1-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-10001400">https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-1-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-10001400</a></p><p><a href="https://www.acwing.com/blog/content/15042/">https://www.acwing.com/blog/content/15042/</a></p><p><a href="https://juejin.cn/post/7186915748395270201">https://juejin.cn/post/7186915748395270201</a></p><p><a href="https://www.luogu.com.cn/article/yx1u034q">https://www.luogu.com.cn/article/yx1u034q</a></p><p><a href="https://blog.csdn.net/m0_45699242/article/details/123741377">https://blog.csdn.net/m0_45699242/article/details/123741377</a></p><p><a href="https://github.com/azl397985856/cf">https://github.com/azl397985856/cf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hal库c6t6 Freerots</title>
      <link href="/2024/11/08/hal%E5%BA%93c6t6-Freerots/"/>
      <url>/2024/11/08/hal%E5%BA%93c6t6-Freerots/</url>
      
        <content type="html"><![CDATA[<p>写篇博客，不为别的，就怕以后忘了咋整了</p><p>Freerots这玩意忒好用了</p><span id="more"></span><h1 id="如何开Freerots"><a href="#如何开Freerots" class="headerlink" title="如何开Freerots"></a>如何开Freerots</h1><p>SYS这边选个时钟</p><p><img src="image-20241108173918865.png" alt></p><p>然后如图一路选下来，别忘了添加任务</p><p><img src="image-20241108174035075.png" alt></p><p>其他的常规配置，然后生成代码就可以了</p><p>打开<code>freertos.c</code>文件，正常加入点灯代码就可以了</p><p><img src="image-20241108174219193.png" alt></p><p>以上内容的参考：</p><p><a href="https://www.cnblogs.com/Meiyangyang945/p/15106513.html">https://www.cnblogs.com/Meiyangyang945/p/15106513.html</a></p><hr><h1 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h1><p><img src="image-20241108174332906.png" alt></p><p>买不起好芯片，内存不够</p><p>改一下代码里的内容</p><p>将<code>#define configTOTAL_HEAP_SIZE                    ((size_t)10240)</code></p><p>修改为<code>#define configTOTAL_HEAP_SIZE                    ((size_t)(1024*5)</code>即可</p><p>参考：</p><p><a href="https://blog.csdn.net/king110108/article/details/110038173">https://blog.csdn.net/king110108/article/details/110038173</a></p><p><a href="https://file.elecfans.com/web2/M00/9B/99/pYYBAGQip7KAOU2vAAfDySG_a10157.pdf">https://file.elecfans.com/web2/M00/9B/99/pYYBAGQip7KAOU2vAAfDySG_a10157.pdf</a></p><h1 id="报错2"><a href="#报错2" class="headerlink" title="报错2"></a>报错2</h1><p><img src="image-20241108174700188.png" alt></p><p>一大堆啥玩意哇</p><p>贴搜索引擎一看，是cpp导致的</p><p><img src="image-20241108174736008.png" alt></p><p>魔术棒中把<code>misc_controls</code>的<code>--cpp11</code>去掉即可</p><p>参考：</p><p><a href="https://blog.csdn.net/timberman666/article/details/132723352">https://blog.csdn.net/timberman666/article/details/132723352</a></p><h1 id="报错3"><a href="#报错3" class="headerlink" title="报错3"></a>报错3</h1><p>数日之后，又出现了报错2的内容</p><p>改成多少都没用了</p><p>开O2优化即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人联盟赛/对抗赛游记回忆记录</title>
      <link href="/2024/10/31/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%81%94%E7%9B%9F%E8%B5%9B-%E5%AF%B9%E6%8A%97%E8%B5%9B%E6%B8%B8%E8%AE%B0%E5%9B%9E%E5%BF%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/31/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%81%94%E7%9B%9F%E8%B5%9B-%E5%AF%B9%E6%8A%97%E8%B5%9B%E6%B8%B8%E8%AE%B0%E5%9B%9E%E5%BF%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>整理游记和会议记录的时候，发现机器人比赛的高校联盟赛和超级对抗赛的游记我没有写过，故凭借记忆（和手机相册）补一份</p><p>记忆可能会随着时间而失真，故趁现在赶紧记录一份（顺便分享一波图片）</p><p><img src="3.jpg" alt></p><span id="more"></span><p>其实我在star机器人比赛的2024赛季中，对队伍的贡献并不是很多，基本上全靠学长带飞</p><h2 id="高校联盟赛"><a href="#高校联盟赛" class="headerlink" title="高校联盟赛"></a>高校联盟赛</h2><p>今年的联盟赛举办在了福建理工，就在隔壁，很近很近</p><p><img src="1.jpg" alt></p><p>比赛前的几天，去福建理工的实验室参观了一下下，好大好大~，而且他们还有1v1用的场地~</p><p>据说是因为他们的RM和RC合并了（思考</p><p>新步兵一直在修，平步倒是可以嘎嘎乱杀~</p><hr><p>报道当天，看到了厦大他们包车过来（好有钱），而且是他们学校自己的车（羡慕.jpg）</p><p><img src="2.jpg" alt></p><p>第一次来RoboMaster的比赛现场，很激动的好叭</p><p>（场馆内不让拍照，所以这里该有很多张赛场的照片但是实际上没有）</p><hr><p>开赛之时，有几次紧急修车紧急换线，学长直接拿着电烙铁焊车上的线，而且是在马上就要检录的时候</p><p>有的时候突发卡弹的问题，很多人一顿手忙脚乱，然后被摩擦轮划伤~</p><p>（此处少了好几张图片，规定说场馆内不让拍照~）</p><p>然后过程中，学长们通了很多宵（联盟赛的时候我本人的作息还是相对正常的），终于夺得季军</p><p><img src="10.jpg" alt></p><h2 id="超级对抗赛"><a href="#超级对抗赛" class="headerlink" title="超级对抗赛"></a>超级对抗赛</h2><p>这个就比较不一样了，地点是在长沙</p><p><img src="29.jpg" alt></p><p>这次我被分配到的任务是调老步兵</p><p><img src="4.jpg" alt></p><p><img src="9.jpg" alt></p><p>这辆车确实比较抽象，设计有挺多不合理的地方，不过确实能用，而且基本功能也比较完善</p><p>最终，把老步兵的代码从能用变成不能用又在学长的帮助下变成能用了（大雾</p><p>赛前还去考了一次普通话嘿嘿~</p><p><img src="5.jpg" alt></p><p>然后粗发粗发</p><p><img src="7.jpg" alt></p><p><img src="6.jpg" alt></p><p>昨天晚上学长们通宵调车，然后睡死在高铁上（学长太帅，码一下码一下）</p><p><img src="11.jpg" alt></p><p>刚到长沙，就见识到了大城市的繁华</p><p><img src="12.jpg" alt></p><p><img src="13.jpg" alt></p><p><img src="14.jpg" alt></p><p><img src="15.jpg" alt></p><p><img src="16.jpg" alt></p><p>喝到了正版的茶颜悦色（3pin的吸管嘿嘿）</p><p><img src="23.jpg" alt></p><p><img src="24.jpg" alt></p><p>比赛那几天正好赶上周杰伦的演唱会，好多人好多人</p><p><img src="32.jpg" alt></p><hr><p>但是正事，还是打比赛（头一次通宵调车，但实际上还是学长是主力</p><p>在羽毛球馆还有很多其他学校一起</p><p><img src="17.jpg" alt></p><p><img src="18.jpg" alt></p><p><img src="19.jpg" alt></p><p><img src="20.jpg" alt></p><p><img src="26.jpg" alt></p><p>检录了检录了</p><p><img src="21.jpg" alt></p><p><img src="25.jpg" alt></p><p>最终因为没有荧光充能，而且其他的车比较健康，备车就没有什么用了</p><p>然后我也没什么用了（），就去干后勤了（讲真一个人干后勤真的忙不过来，只能拉上指导老师一块儿来搬东西~）</p><p><img src="30.jpg" alt></p><p><img src="27.jpg" alt></p><p><img src="28.jpg" alt></p><p>开赛了，如果不是裁判系统有问题，北信科就没了</p><p>之后又被南航打爆了~</p><p>然后就结束了~</p><p><img src="31.jpg" alt></p><hr><p>打完比赛，去了趟橘子洲头</p><p><img src="33.jpg" alt></p><p><img src="34.jpg" alt></p><p>和同学一起去鬼屋玩（再也不穿短裤去了（哭）</p><p><img src="36.jpg" alt></p><p>酒店楼下有份炒粉，我问老板怎么每天都在这卖，他说卖几十年了</p><p><img src="35.jpg" alt></p><p>味道不错</p><p><img src="37.jpg" alt></p><p>第一次听青工会（估计也是最后一次），收获颇丰</p><p><img src="40.jpg" alt></p><p>回来之后新买了个烙铁（钱包滴血ing）</p><p><img src="38.jpg" alt></p><hr><p>结语：rm这个比赛，包好的</p><p><img src="22.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会议/竞赛游记合集</title>
      <link href="/2024/10/30/%E4%BC%9A%E8%AE%AE%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0%E5%90%88%E9%9B%86/"/>
      <url>/2024/10/30/%E4%BC%9A%E8%AE%AE%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>本篇文章用于汇总参加的会议/组会的总结链接</p><p>部分内容已加锁</p><span id="more"></span><h2 id="组会"><a href="#组会" class="headerlink" title="组会"></a>组会</h2><p><a href="https://coperlm.github.io/2024/10/30/2024-10-30组会/">2024.10.30组会</a></p><p><a href="https://coperlm.github.io/2024/09/19/2024.9.18组会/">2024.9.18组会</a></p><p><a href="https://coperlm.github.io/2024/09/11/2024.9.11组会/">2024.9.11组会</a></p><p><a href="https://coperlm.github.io/2024/09/02/2024.9.4组会/">2024.9.4组会</a></p><h2 id="其他会议-竞赛"><a href="#其他会议-竞赛" class="headerlink" title="其他会议/竞赛"></a>其他会议/竞赛</h2><p><a href="https://coperlm.github.io/2024/09/20/2024-9-20南洋理工密码学报告-观后总结/">2024.9.20南洋理工密码学报告 观后总结</a></p><p><a href="https://coperlm.github.io/2024/10/31/机器人联盟赛-对抗赛游记回忆记录/">机器人联盟赛/对抗赛游记回忆记录</a>（2024）</p><p><a href="https://coperlm.github.io/2024/08/13/厦大一日游（机器人大赛）/">厦大一日游（机器人大赛）</a>（2023）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 常驻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.10.30组会</title>
      <link href="/2024/10/30/2024-10-30%E7%BB%84%E4%BC%9A/"/>
      <url>/2024/10/30/2024-10-30%E7%BB%84%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c960fd6f9d1cb17cf454ce075e3f9e4837fbc240c96cc593d582ea162804e765">7b22b1899bb4d215751e07a80f0d88de9e961fa3e70fbc1ff6cba48e977e425d6990bac9e6f428a573d21a80577428175b2d7a167dd0c28ad1052dc69cff23ec7db1feec24acf3433122a642ede696fac1c18c6879961e8735a0f0eca93fa72cad4ad3e4d1929d16df31ab82d34972d0f3b44cdb30dd51d690bbdab84c1aff4dccbb6b17f5844d1306c5ae56c5cd20b5fba6d958ab415358cb377440debec707f13609b4fa0d179dc789b77dcfe509dfcc605d2cd9c59e5e36b22bcb5aadd720c6de42212d2ca5ed9f69d6c34654ffe4e835500e8becdac2933f38235fb1cfe1f200722819020076a43dfee15a140108941fe0750ac59d26f28987d416d3fac74180cb123bd84a8cfde43529efd7b641d4984f24d4d0420232023070393e1dbf782b66c51631447182d0189af789c6fa904c81a4dea27a5c9211e08130cd20e51766a1f3436d1439da814b72711ab1dcc452b83f4ffa994dbf2d72b160da2432c0ea12d44fa33a819f74be7d3747de8cf70e11da80de0a3b7e7de4a23a7758aee46514ec614102af43dff4a290b644509aa096f09bceea0879b28d02bdb117db990b64a8c399ad863585015aeb1e32aeb228663aeb827732027fb3bb46c6ee1a7aab47fdc614fe48cb2b4c53b1628f470ebc443a24d83b0be5ce73fbbe5cf15d40116bf3f72513c8e953354b92caee2e335dda837cca3c0bba06d89a6df8487b77666356d62288b49c460c475a1a053e84f997c0ba23a4149f6c0c06bac30b5f4182d47242d39a9a92b25dcb6cc1ba4d891aef34279e240181be0d16073de3f71e2aebe1b277794ff4bcdae4f0de06aaa3016fa73da7a1886955f814dd17d86504a5e2df60b9d21628742af7c66bd8a0504617c7b72b504bc9152d123f49d5e8f35a6acff0de3d688222cd81e1f69ad930531c00f762ab35bc336c31009eea86a79e0cb8ba3690f9bd1f6e79bb8bf2f8a15d9bb2e92953600b6d6731072515056a59f82c43dc2c37c02aa26533a3ac6058d0c350d910fa85ded6824de7001e96c116df99e222329408f4ce4b957e9727035f1d4e007639a9b01f7c925229785c8b1808ef3142b2ed283069e67cf83277968dc1d9faa764604e7a1825d558322addde72561f3118ad4ad252db319ddbd451b6313810ff3e3bb5b37ec1bdb29f6f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> meetings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2024crypto题解（青龙组）</title>
      <link href="/2024/10/29/%E7%BD%91%E9%BC%8E%E6%9D%AF2024crypto%E9%A2%98%E8%A7%A3%EF%BC%88%E9%9D%92%E9%BE%99%E7%BB%84%EF%BC%89/"/>
      <url>/2024/10/29/%E7%BD%91%E9%BC%8E%E6%9D%AF2024crypto%E9%A2%98%E8%A7%A3%EF%BC%88%E9%9D%92%E9%BE%99%E7%BB%84%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>目前只更新了青龙组的题目</p><span id="more"></span><h2 id="CRYPTO1"><a href="#CRYPTO1" class="headerlink" title="CRYPTO1"></a>CRYPTO1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">d = getPrime(299)</span><br><span class="line">e = inverse(d,(p-1)*(q-1))</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">hint1 = p &gt;&gt; (512-70)</span><br><span class="line">hint2 = q &gt;&gt; (512-70)</span><br><span class="line"></span><br><span class="line">print(f&quot;n = &#123;n&#125;&quot;)</span><br><span class="line">print(f&quot;e = &#123;e&#125;&quot;)</span><br><span class="line">print(f&quot;c = &#123;c&#125;&quot;)</span><br><span class="line">print(f&quot;hint1 = &#123;hint1&#125;&quot;)</span><br><span class="line">print(f&quot;hint2 = &#123;hint2&#125;&quot;)</span><br><span class="line"></span><br><span class="line">n = 114118679597315994458138232536029700477506764789782067073905766324635160145597602207164997807103187990046901850125798774503781767630201814025142189432534890147340404293319424524872695905368897290630698362559606549134377263394129199145835483978820237203114250882524438599220793209608842281879976692805855046971</span><br><span class="line">e = 60930873636939710528141652371287627298970658591028170597199994159301433213017349592910581153194811053524011559886529831760967700162629319952838130973563991607758850226327915934518549584588693854388996425152821459866209334446088324204759334980239670811977086959854952233887459542997456604453766160444477603017</span><br><span class="line">c = 11058775585296329544235824126670578486484201903851563493984057289075513008773878014007377223222464555346135675900619903617528838701118612201290486747980233570288315027654510774940371032813981282018787668864123759554297515664915358447425647424759926416629451915378248520432568536260902676664298855076689608823</span><br><span class="line">hint1 = 884675140903190287932</span><br><span class="line">hint2 = 1000130673738973880482</span><br></pre></td></tr></table></figure><hr><p>和领航杯2023密码学题目bd为重题</p><p>原来原来是论文题</p><p>有两种解法，一种是基于<a href="https://www.davidwong.fr/papers/david_wong_rsa_lll_boneh_durfee__2015.pdf">格规约</a>的，另一种是基于<a href="https://eprint.iacr.org/2023/367.pdf">小私指数</a>的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#reference</span><br><span class="line">https://www.cnblogs.com/mumuhhh/p/17789591.html</span><br><span class="line">https://dexterjie.github.io/2023/09/12/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/2023%E9%A2%86%E8%88%AA%E6%9D%AF/?highlight=%E9%A2%86%E8%88%AA%E6%9D%AF#bd</span><br></pre></td></tr></table></figure><h2 id="CRYPTO2"><a href="#CRYPTO2" class="headerlink" title="CRYPTO2"></a>CRYPTO2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import gmpy2</span><br><span class="line">import random</span><br><span class="line">import binascii</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from sympy import nextprime</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from Crypto.Util.Padding import pad</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">from FLAG import flag</span><br><span class="line">#flag = &#x27;wdflag&#123;123&#125;&#x27;</span><br><span class="line">def victory_encrypt(plaintext, key):</span><br><span class="line">    key = key.upper()</span><br><span class="line">    key_length = len(key)</span><br><span class="line">    plaintext = plaintext.upper()</span><br><span class="line">    ciphertext = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    for i, char in enumerate(plaintext):</span><br><span class="line">        if char.isalpha():</span><br><span class="line">            shift = ord(key[i % key_length]) - ord(&#x27;A&#x27;)</span><br><span class="line">            encrypted_char = chr((ord(char) - ord(&#x27;A&#x27;) + shift) % 26 + ord(&#x27;A&#x27;))</span><br><span class="line">            ciphertext += encrypted_char</span><br><span class="line">        else:</span><br><span class="line">            ciphertext += char</span><br><span class="line"></span><br><span class="line">    return ciphertext</span><br><span class="line"></span><br><span class="line">victory_key = &quot;WANGDINGCUP&quot;</span><br><span class="line">victory_encrypted_flag = victory_encrypt(flag, victory_key)</span><br><span class="line"></span><br><span class="line">p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f</span><br><span class="line">a = 0</span><br><span class="line">b = 7</span><br><span class="line">xG = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</span><br><span class="line">yG = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</span><br><span class="line">G = (xG, yG)</span><br><span class="line">n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141</span><br><span class="line">h = 1</span><br><span class="line">zero = (0,0)</span><br><span class="line"></span><br><span class="line">dA = nextprime(random.randint(0, n))</span><br><span class="line"></span><br><span class="line">if dA &gt; n:</span><br><span class="line">    print(&quot;warning!!&quot;)</span><br><span class="line"></span><br><span class="line">def addition(t1, t2):</span><br><span class="line">    if t1 == zero:</span><br><span class="line">        return t2</span><br><span class="line">    if t2 == zero:</span><br><span class="line">        return t2</span><br><span class="line">    (m1, n1) = t1</span><br><span class="line">    (m2, n2) = t2</span><br><span class="line">    if m1 == m2:</span><br><span class="line">        if n1 == 0 or n1 != n2:</span><br><span class="line">            return zero</span><br><span class="line">        else:</span><br><span class="line">            k = (3 * m1 * m1 + a) % p * gmpy2.invert(2 * n1 , p) % p</span><br><span class="line">    else:</span><br><span class="line">        k = (n2 - n1 + p) % p * gmpy2.invert((m2 - m1 + p) % p, p) % p</span><br><span class="line">    m3 = (k * k % p - m1 - m2 + p * 2) % p</span><br><span class="line">    n3 = (k * (m1 - m3) % p - n1 + p) % p</span><br><span class="line">    return (int(m3),int(n3))</span><br><span class="line"></span><br><span class="line">def multiplication(x, k):</span><br><span class="line">    ans = zero</span><br><span class="line">    t = 1</span><br><span class="line">    while(t &lt;= k):</span><br><span class="line">        if (k &amp;t )&gt;0:</span><br><span class="line">            ans = addition(ans, x)</span><br><span class="line">        x = addition(x, x)</span><br><span class="line">        t &lt;&lt;= 1</span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line">def getrs(z, k):</span><br><span class="line">    (xp, yp) = P</span><br><span class="line">    r = xp</span><br><span class="line">    s = (z + r * dA % n) % n * gmpy2.invert(k, n) % n</span><br><span class="line">    return r,s</span><br><span class="line"></span><br><span class="line">z1 = random.randint(0, p)</span><br><span class="line">z2 = random.randint(0, p)</span><br><span class="line">k = random.randint(0, n)</span><br><span class="line">P = multiplication(G, k)</span><br><span class="line">hA = multiplication(G, dA)</span><br><span class="line">r1, s1 = getrs(z1, k)</span><br><span class="line">r2, s2 = getrs(z2, k)</span><br><span class="line"></span><br><span class="line">print(&quot;r1 = &#123;&#125;&quot;.format(r1))</span><br><span class="line">print(&quot;r2 = &#123;&#125;&quot;.format(r2))</span><br><span class="line">print(&quot;s1 = &#123;&#125;&quot;.format(s1))</span><br><span class="line">print(&quot;s2 = &#123;&#125;&quot;.format(s2))</span><br><span class="line">print(&quot;z1 = &#123;&#125;&quot;.format(z1))</span><br><span class="line">print(&quot;z2 = &#123;&#125;&quot;.format(z2))</span><br><span class="line"></span><br><span class="line">key = sha256(long_to_bytes(dA)).digest()</span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC)</span><br><span class="line">iv = cipher.iv</span><br><span class="line">encrypted_flag = cipher.encrypt(pad(victory_encrypted_flag.encode(), AES.block_size))</span><br><span class="line">encrypted_flag_hex = binascii.hexlify(iv + encrypted_flag).decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;Encrypted flag (AES in CBC mode, hex):&quot;, encrypted_flag_hex)</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line"># r1 = 28857061626266697731960297346547380130694223166851804642930502594650578288425</span><br><span class="line"># r2 = 28857061626266697731960297346547380130694223166851804642930502594650578288425</span><br><span class="line"># s1 = 81842916501936654327181596127464444170184582938148211467350979906270329843047</span><br><span class="line"># s2 = 54199410087637342004207138894657653701426382978399616033659324046436549994669</span><br><span class="line"># z1 = 114768147762808206397023700697633814229154932218327120646122869299219028759434</span><br><span class="line"># z2 = 63513092260201266423877548128429517837199255134650637253201969399356248912467</span><br><span class="line"># (&#x27;Encrypted flag (AES in CBC mode, hex):&#x27;, u&#x27;51559ebae12fdd12e0e84df2baf07e3389b688398a71b62717fb77e0f6abdd40d848ee028b70681bc566ef2729d80b7a2778ad5b322b68501b6bbcef820b4719&#x27;)</span><br></pre></td></tr></table></figure><hr><p>观察这一部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def getrs(z, k):</span><br><span class="line">    (xp, yp) = P</span><br><span class="line">    r = xp</span><br><span class="line">    s = (z + r * dA % n) % n * gmpy2.invert(k, n) % n</span><br><span class="line">    return r,s</span><br><span class="line"></span><br><span class="line">z1 = random.randint(0, p)</span><br><span class="line">z2 = random.randint(0, p)</span><br><span class="line">k = random.randint(0, n)</span><br><span class="line">P = multiplication(G, k)</span><br><span class="line">hA = multiplication(G, dA)</span><br><span class="line">r1, s1 = getrs(z1, k)</span><br><span class="line">r2, s2 = getrs(z2, k)</span><br></pre></td></tr></table></figure><p>已知<code>z1,z2,r1,r2,s1,s2</code></p><p>有方程组</p><script type="math/tex; mode=display">\begin{cases}s1=(z1+r1*dA)*k^{-1}\quad\mod n \\s2=(z2+r2*dA)*k^{-1}\quad\mod n\end{cases}</script><p>联立消去 $k^{-1}$ 得到 $s1<em>(z2+r2</em>dA)=s2<em>(z1+r1</em>dA)\quad\mod n$</p><p>提取出 $dA$ 得到 $dA=(z2<em>s1-z1-s2)</em>(s2<em>r1-r2</em>s1)^{-1}\quad\mod n$</p><p>容易得到 $dA$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">dA = (z2*s1-z1*s2)*gmpy2.invert(s2*r1-r2*s1,n)%n</span><br><span class="line">print( dA )</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#output</span><br><span class="line">dA=10570650820062854135188945698682652204931348462301149982644765996528871376101</span><br></pre></td></tr></table></figure><p>无脑解AES和古典即可，这个ai就能干</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from Crypto.Util.Padding import unpad</span><br><span class="line">from Crypto.Hash import SHA256</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line"># 使用恢复的私钥 dA</span><br><span class="line">dA = 10570650820062854135188945698682652204931348462301149982644765996528871376101</span><br><span class="line"># 计算 AES 密钥</span><br><span class="line">key = SHA256.new(long_to_bytes(dA)).digest()</span><br><span class="line"></span><br><span class="line"># 输入你已经获得的加密数据</span><br><span class="line">encrypted_flag_hex = u&#x27;51559ebae12fdd12e0e84df2baf07e3389b688398a71b62717fb77e0f6abdd40d848ee028b70681bc566ef2729d80b7a2778ad5b322b68501b6bbcef820b4719&#x27;</span><br><span class="line"></span><br><span class="line"># 从十六进制字符串中提取 IV 和加密的标志</span><br><span class="line">encrypted_data = binascii.unhexlify(encrypted_flag_hex)</span><br><span class="line">iv = encrypted_data[:AES.block_size]  # 前 16 字节是 IV</span><br><span class="line">encrypted_flag = encrypted_data[AES.block_size:]  # 剩下的是加密后的标志</span><br><span class="line"></span><br><span class="line"># 创建 AES 解密器</span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line"># 解密并去填充</span><br><span class="line">try:</span><br><span class="line">    decrypted_flag = unpad(cipher.decrypt(encrypted_flag), AES.block_size)</span><br><span class="line">    print(&quot;Decrypted flag:&quot;, decrypted_flag.decode(&#x27;utf-8&#x27;))</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&quot;Decryption failed:&quot;, e)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#output</span><br><span class="line">Decrypted flag: SDSRDO&#123;2DZ35AN97NP3EY15602G02H5ZP50R287&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def victory_decrypt(ciphertext, key):</span><br><span class="line">    key = key.upper()</span><br><span class="line">    key_length = len(key)</span><br><span class="line">    plaintext = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    for i, char in enumerate(ciphertext):</span><br><span class="line">        if char.isalpha():</span><br><span class="line">            shift = ord(key[i % key_length]) - ord(&#x27;A&#x27;)</span><br><span class="line">            decrypted_char = chr((ord(char) - ord(&#x27;A&#x27;) - shift) % 26 + ord(&#x27;A&#x27;))</span><br><span class="line">            plaintext += decrypted_char</span><br><span class="line">        else:</span><br><span class="line">            plaintext += char</span><br><span class="line"></span><br><span class="line">    return plaintext</span><br><span class="line"></span><br><span class="line">victory_key = &quot;WANGDINGCUP&quot;</span><br><span class="line">t = &quot;SDSRDO&#123;2DZ35AN97NP3EY15602G02H5ZP50R287&#125;&quot;</span><br><span class="line"></span><br><span class="line">print( victory_decrypt( t , victory_key ) )</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#output</span><br><span class="line">WDFLAG&#123;2BF35AA97FC3CE15602D02B5FA50E287&#125;</span><br></pre></td></tr></table></figure><p>最后转成小写即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;WDFLAG&#123;2BF35AA97FC3CE15602D02B5FA50E287&#125;&quot;.lower())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#output</span><br><span class="line">wdflag&#123;2bf35aa97fc3ce15602d02b5fa50e287&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习主定理</title>
      <link href="/2024/10/28/%E5%AD%A6%E4%B9%A0%E4%B8%BB%E5%AE%9A%E7%90%86/"/>
      <url>/2024/10/28/%E5%AD%A6%E4%B9%A0%E4%B8%BB%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>之前很早就听机房的学长说主定理了，是用于算法竞赛中分析时间复杂度的，但是一直没有学习过</p><p>今天做DS，又遇到了，题目如下</p><span id="more"></span><h2 id="一道考研题目"><a href="#一道考研题目" class="headerlink" title="一道考研题目"></a>一道考研题目</h2><p><img src="image-20241028092712560.png" alt></p><p>解析：时间复杂度为 $O(nlogn)$</p><p>设 $n=2^k(k\geq0)$，有 $T(2^k)=2T(2^{k-1})+2^k=2^2T(2^{k-2})+2*2^k$</p><p>由此得到递推公式 $T(2^k)=2^iT(2^{k-i})+i*2^k$</p><p>故 $T(2^k)=2^kT(2^0)+k*2^k=(k+1)2^k$</p><p>带回 $n$ 得到 $T(n)=(logn+1)2^{logn}$ 即时间复杂度为 $O(nlogn)$</p><p>这也就是<a href="https://zh.wikipedia.org/zh-cn/归并排序">归并排序(MergeSort)</a>的时间复杂度</p><h2 id="更普适的"><a href="#更普适的" class="headerlink" title="更普适的"></a>更普适的</h2><p>假设有递推关系式 $T(n)=aT(\frac{n}{b})+f(n)$，其中$a\ge1,b&gt;1$</p><p>其中，$n$ 为问题规模，$a$ 为递归的子问题数量，$\frac{n}{b}$ 为每个子问题的规模（假设每个子问题的规模基本一样），$f(n)$ 为递归以外进行的计算工作</p><p>结论：</p><ol><li>若存在$\varepsilon&gt;0$，$f(n)=O(n^{log_b(a)−\varepsilon})$（可不严谨的视作多项式地小于），那么$T(n)=\Theta(n^{log_ba})$</li><li>若存在$\varepsilon&gt;0$，$f(n)=\Theta(n^{log_ba}log^\varepsilon n)$，那么$T(n)=O(n^{log_ba}log^\varepsilon n)$</li><li>若存在$\varepsilon&gt;0$，$f(n)=Ω(n^{log_b(a)+\varepsilon})$（多项式地大于），同时存在常数 $c&lt;1$以及充分大的$n$，满足$af(\frac{n}{b})≤cf(n)$，则$T(n)=\Theta(f(n))$</li></ol><p>符号说明：</p><p><img src="image-20241028151529218.png" alt></p><p>更普适的:</p><p><img src="image-20241028151620398.png" alt></p><p><a href="https://www.doc88.com/p-9761826142176.html">算法证明</a></p><p>更本质的:</p><p>使用 $T(n)=2T(\frac{n}{2})+n$ 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                    f(n)</span><br><span class="line">                /            \</span><br><span class="line">        f(n/b)                f(n/b)</span><br><span class="line">        /        \                /        \</span><br><span class="line">f(n/b^2) f(n/b^2) f(n/b^2) f(n/b^2)</span><br><span class="line">    /    \        /    \        /    \        /    \</span><br><span class="line">    ......(很多次递归以后)</span><br><span class="line">    O(1)O(1)......O(1)O(1)O(1)O(1)</span><br></pre></td></tr></table></figure><p>这里用$O(1)$准确的说是$\Theta(1)$</p><p>主定理到底在做什么？事实上主定理就是对比这两个部分的时间复杂度罢了</p><p><strong>到底是上面那些<code>f(n)</code>操作加起来更耗时, 还是最下层所有叶节点的<code>O(1)</code>加起来更耗时?</strong></p><p>即对于 $T(n)=pf(n)+kO(1)$，$p$ 我们认为它是常数，重点是 $k$，大致数值为 $n^{log_ba}$</p><p>代换一下，得到 $T(n)=pf(n)+n^{log_ba}$，显然这是在对比两项</p><p>对于三种情况：</p><ol><li><p>下层所有叶节点的<code>O(1)</code>加起来更耗时</p><p>$k$（即 $n^{log_ba}$）的增长速度大于了 $f(n)$, 那么 $T(n)=O(nlogba)$</p><p>之所以引入 $\varepsilon$ 只是为了说明增长速度大</p><p>第一种情况下 $k$ 代表的最终处理问题的最小子任务明显占了主导</p></li><li><p>一样耗时</p><p>最小子任务和分割过程一样，没有谁明显的占据了主导低位，因此两个的时间复杂度都得算进去 $T(n)=O(n^{log_ba}⋅logn)$</p></li><li><p>上面那些<code>f(n)</code>操作加起来更耗时</p><p>分治过程占了主导地位，同时这种情况下限制了 $p$ 不会无法被认为是常数</p></li></ol><p>常见形式</p><p><img src="image-20241028155133922.png" alt></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>NOIP2016TGT14</li></ol><p><img src="PBTeBV.png" alt></p><p>根据主定理，此时</p><script type="math/tex; mode=display">a=2,b=4,f(n)=\sqrt n=n^\frac{1}{2}\\log_ba=log_42=\frac{1}{2}</script><p>符合格式 $f(n)=O(n^{log_ba}log^kn)$(2)，此时 $k=0$ </p><p>所以 $T(n)=Θ(n^{log_ba}log^{k+1}n)=Θ(n^\frac{1}{2}log^1n)=Θ(\sqrt nlogn)$</p><p>选择C</p><ol><li>$T(n)=9T(\frac{n}{3})+n$</li></ol><p>根据主定理，此时</p><script type="math/tex; mode=display">a=9,b=3,f(n)=n\\log_ba=log_39=2</script><p>符合格式 $f(n)=O(n^{log_b(a)-\varepsilon})$(1)，此时 $\varepsilon=1$</p><p>所以 $f(n)=O(n^{log_ba})=O(n^2)$</p><ol><li>$T(n)=2T(\frac{n}{2})+2n$</li></ol><p>根据主定理，此时</p><script type="math/tex; mode=display">a=2,b=2,f(n)=2n\\log_ba=log_22=1</script><p>符合格式 $f(n)=O(n^{log_ba}log^kn)$(2)，此时 $k=0$ </p><p>所以 $T(n)=Θ(n^{log_ba}log^{k+1}n)=Θ(n^1log^1n)=Θ(nlogn)$</p><ol><li>$T(n)=2T(\frac{n}{4})+n^2$</li></ol><p>根据主定理，此时</p><script type="math/tex; mode=display">a=2,b=4,f(n)=n^2\\log_ba=log_42=\frac{1}{2}</script><p>符合格式 $f(n)=O(n^{log_b(a)+\varepsilon})$(3)，此时 $\varepsilon=\frac{3}{2}$ </p><p>同时存在常数 $c&lt;1$以及充分大的$n$，满足$af(\frac{n}{b})≤cf(n)$</p><p>所以 $T(n)=Θ(f(n))=O(n^2)$</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>主定理讨论的是对于公式 $T(n)=pf(n)+kO(1)$ 里 <code>p f(n) k</code> 三个变量的增长速度。只不过主定理直接用条件限制了<code>p</code>，所以我们关注的重点就仅在 <code>f(n)</code> 和 <code>k</code> 上了</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86">https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86</a></p><p><a href="https://blog.restkhz.com/post/how-master-theorem-works">https://blog.restkhz.com/post/how-master-theorem-works</a></p><p><a href="https://blog.csdn.net/lanchunhui/article/details/52451362">https://blog.csdn.net/lanchunhui/article/details/52451362</a></p><p><a href="https://www.luogu.com.cn/article/w3avh1ku">https://www.luogu.com.cn/article/w3avh1ku</a></p><p><a href="https://www.mashangxue123.com/tutorials/dsa/master-theorem/">https://www.mashangxue123.com/tutorials/dsa/master-theorem/</a></p><p><a href="https://www.cnblogs.com/coderzjz/p/14272460.html">https://www.cnblogs.com/coderzjz/p/14272460.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.10.20NISA百团题目题解</title>
      <link href="/2024/10/20/2024-10-20NISA%E7%99%BE%E5%9B%A2%E9%A2%98%E7%9B%AE%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/10/20/2024-10-20NISA%E7%99%BE%E5%9B%A2%E9%A2%98%E7%9B%AE%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>三道挺有意思的小题目，记录一下</p><span id="more"></span><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>题目描述：说反话</p><p>题解：</p><p>翻转字符串即可（大雾），时间复杂度是严格线性（大大雾）</p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>题目描述：挑战者选择16/17/18张卡片和先/后手，每方每次可以掀开1/2/3张卡片；挑战者的目标是让敌手掀开最后一张卡牌</p><p>题解：</p><p>如果敌手掀开最后一张牌（即达成挑战目标），则必然最终只剩一张牌（如果剩余的牌数多于1张，则敌手可以掀开一张，这时挑战者并不会达到目标）</p><p>为了使敌手掀开最后一张牌，则只需保留一张牌，即<strong>保证挑战者掀开牌之后，剩余的牌数为4k+1</strong>即可，其中k为非负整数</p><p>在以上情况下，每一轮（指双方操作）后掀开四张卡牌即可保证挑战者一定获胜</p><p><strong>看不懂？直接运行以下代码体验一下吧</strong></p><p>直接使用devcpp运行以下代码即可，记得拓展名是cpp哦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">bool check( int x )&#123;</span><br><span class="line">    if( x == 1 || x == 2 || x == 3 ) return 1;</span><br><span class="line">    cout &lt;&lt; &quot;请输入1/2/3哦，不要输入别的数字喵&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    INIT:;</span><br><span class="line">    cout &lt;&lt; &quot;请输入总牌数：(n=16/17/18)&quot;;</span><br><span class="line">    RST:;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    if( n != 16 &amp;&amp; n != 17 &amp;&amp; n != 18 )&#123;</span><br><span class="line">        cout &lt;&lt; &quot;输入的数据不合法，请重新输入&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;</span><br><span class="line">        goto INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    if( n == 17 )&#123;</span><br><span class="line">        cout &lt;&lt; &quot;你长得好看，让你先手&quot; &lt;&lt; endl;</span><br><span class="line">        N17:;</span><br><span class="line">        int sum = 17 , a;</span><br><span class="line">        while( sum!=1 )&#123;</span><br><span class="line">            cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;请输入你掀开的数量：&quot;;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            if( !check(a) ) continue;</span><br><span class="line">            cout &lt;&lt; &quot;好的，这次我掀开的数量是：&quot; &lt;&lt; 4-a &lt;&lt; endl;</span><br><span class="line">            sum -= 4;</span><br><span class="line">            cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if( n == 16 )&#123;</span><br><span class="line">        cout &lt;&lt; &quot;我长得漂亮，让我先手&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;我掀开的数量是：&quot; &lt;&lt; 3 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; 13 &lt;&lt; endl;</span><br><span class="line">        int sum = 13 , a;</span><br><span class="line">        while( sum!=1 )&#123;</span><br><span class="line">            cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;请输入你掀开的数量：&quot;;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            if( !check(a) ) continue;</span><br><span class="line">            cout &lt;&lt; &quot;好的，我掀开的数量是：&quot; &lt;&lt; 4-a &lt;&lt; endl;</span><br><span class="line">            sum -= 4;</span><br><span class="line">            cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; &quot;我长得漂亮，让我先手&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;我掀开的数量是：&quot; &lt;&lt; 1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;现在剩下未掀开牌的数量是：&quot; &lt;&lt; 17 &lt;&lt; endl;</span><br><span class="line">        goto N17;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;现在只剩下一张牌了，到你掀了，你失败了（嘻嘻）&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;再来一把？这次n是多少你说了算，但是先后手···嘿嘿······&quot; &lt;&lt; endl;</span><br><span class="line">    goto RST;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：</p><p>17张时候，挑战者后手；16或18张时，挑战者先手</p><p>具体策略如上，此题解仅讨论必胜情况</p><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>问题描述：数桥问题</p><p>题解：</p><p>其实这个时间复杂度，（在保证有解的情况下）枚举一下大概率也能出来了，除非因为没有橡皮导致图越画越乱最终看不清楚（</p><p>使用贪心思想时间复杂度为<code>O(N*M)</code>，其中<code>N</code>是点的数量，<code>M</code>是每个点尝试的边的数量</p><p>ai给出的贪心代码，仅供参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义点结构</span><br><span class="line">struct Point &#123;</span><br><span class="line">    int x, y; // 点的坐标</span><br><span class="line">    int degree; // 点的边权（需要连接的边数）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个方向数组，表示右、下</span><br><span class="line">int dx[] = &#123;1, 0&#125;; // 横向和竖向（x+1, y）表示右边，(x, y+1)表示下方</span><br><span class="line">int dy[] = &#123;0, 1&#125;;</span><br><span class="line"></span><br><span class="line">// 检查是否可以在(x1, y1)和(x2, y2)之间连接边</span><br><span class="line">bool canConnect(int x1, int y1, int x2, int y2, vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    // 确保(x2, y2)在图的范围内，且没有交叉边</span><br><span class="line">    if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= grid.size() || y2 &gt;= grid[0].size()) return false;</span><br><span class="line">    if (grid[x1][y1] || grid[x2][y2]) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数：连接点的边，确保边不交叉</span><br><span class="line">void connectPoints(vector&lt;Point&gt;&amp; points, int n, int m) &#123;</span><br><span class="line">    // 创建一个网格表示是否有边（或点）</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0));</span><br><span class="line"></span><br><span class="line">    // 遍历所有点</span><br><span class="line">    for (auto&amp; p : points) &#123;</span><br><span class="line">        int x = p.x, y = p.y, degree = p.degree;</span><br><span class="line">        grid[x][y] = 1; // 将该点标记为存在</span><br><span class="line">        </span><br><span class="line">        // 尝试为该点连接degree条边</span><br><span class="line">        for (int i = 0; i &lt; degree; ++i) &#123;</span><br><span class="line">            for (int d = 0; d &lt; 2; ++d) &#123; // 遍历两个方向（右和下）</span><br><span class="line">                int nx = x + dx[d];</span><br><span class="line">                int ny = y + dy[d];</span><br><span class="line">                if (canConnect(x, y, nx, ny, grid)) &#123;</span><br><span class="line">                    grid[nx][ny] = 1; // 连接边并标记</span><br><span class="line">                    break; // 连接成功，退出当前方向的尝试</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 5, m = 5; // 网格大小</span><br><span class="line">    vector&lt;Point&gt; points = &#123;</span><br><span class="line">        &#123;0, 0, 2&#125;, // (x, y, 边权)</span><br><span class="line">        &#123;2, 1, 1&#125;,</span><br><span class="line">        &#123;3, 4, 3&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    connectPoints(points, n, m);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅学习一下零知识证明</title>
      <link href="/2024/10/13/%E6%B5%85%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
      <url>/2024/10/13/%E6%B5%85%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>之前一直听说零知识证明，但是一直没有学习过相关内容</p><p>今天在阅读陈教授的《Identity-based chameleon hashing and signatures without key exposure》一文中遇到了，故学习记录一下</p><span id="more"></span><h2 id="知识证明和零知识证明"><a href="#知识证明和零知识证明" class="headerlink" title="知识证明和零知识证明"></a>知识证明和零知识证明</h2><p>知识证明是Proofs of Knowledge，零知识证明是Zero-Knowlegde Proof</p><p>二者之间有很多相似点，也有区别，具体如下</p><ol><li><p>信息泄露的程度</p><p>知识证明中，通常证明着不会直接泄露密码，但是可能会提供一些有用的中间信息（例如密文的哈希值）</p><p>零知识证明中，验证者在验证的过程中，不能获得任何相关的信息，除了“证明者知道这个秘密”</p></li><li><p>应用场景</p><p>知识证明更侧重确认某人知道某个密码</p><p>零知识证明不仅确认某人知道某个密码，还确保验证过程中完全不会泄露任何相关信息</p></li></ol><h2 id="知识证明"><a href="#知识证明" class="headerlink" title="知识证明"></a>知识证明</h2><p>定义：证明者向验证者展示他们知道某个秘密值，但不一定完全隐藏这个秘密；关键在于，验证者能够确信证明者确实知道这个秘密值</p><h3 id="离散对数知识证明"><a href="#离散对数知识证明" class="headerlink" title="离散对数知识证明"></a>离散对数知识证明</h3><p>Proof of Knowledge of a Discrete Logarithm</p><p>证明者拥有一个秘密值 $x$，满足 $x = \log_g y$，即 $y = g^x$（离散对数问题）</p><p>证明者想要向验证者证明他确实知道这个 $x$，但不能直接透露 $x$</p><p>过程：</p><ul><li><p>证明者选择一个随机数 $r \in_R \mathbb{Z}_q$（即从 $\mathbb{Z}_q$ 中随机选取一个数，其中 $_R$ 表示均匀随机）</p></li><li><p>计算 $c = H(g, y, g^r)$，这里的 $H$ 是一个抗碰撞的哈希函数，它将输入映射到一个固定长度的输出值</p></li><li><p>计算 $s = r - c \cdot x \mod q$，这一步结合了秘密值 $x$ 和随机值 $r$</p></li><li><p>验证者接收到 $(c, s)$ 之后，检查 $c = H(g, y, g^s \cdot y^c)$ 是否成立</p></li></ul><p>如果这个等式成立，那么验证者可以确信证明者知道离散对数 $x$，但验证者无法直接获得 $x$</p><p>这实际上是基于 <a href="../../../../../2024/10/09/ECDSA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Schnorr</a> 签名的思想——证明者通过使用随机数 $r$ 混淆了秘密 $x$，确保即使提供了 $(c, s)$，也不能反推出 $x$，但同时可以证明其拥有 $x$ 的知识</p><h3 id="两个离散对数相等的知识证明"><a href="#两个离散对数相等的知识证明" class="headerlink" title="两个离散对数相等的知识证明"></a>两个离散对数相等的知识证明</h3><p>Proof of Knowledge for the Equality of Two Discrete Logarithms</p><p>证明者拥有一个秘密 $x$，同时满足 $x = \log_g u = \log_h v$，即证明者想要证明 $u = g^x$ 且 $v = h^x$，这意味着在不同的基 $g$ 和 $h$ 下，它们的离散对数相同</p><p>过程：</p><ul><li>证明者选择一个随机数 $r \in_R \mathbb{Z}_q$</li><li>计算 $c = H(g, h, u, v, g^r, h^r)$ （ $g$ 和 $h$ 指的是两个基，它们对应的值是 $u$ 和 $v$）</li><li>计算 $s = r - c \cdot x \mod q$</li><li>验证者接收到 $(c, s)$ 后，检查 $c = H(g, h, u, v, g^s \cdot u^c, h^s \cdot v^c)$ 是否成立</li></ul><p>如果这个等式成立，验证者就知道证明者确实拥有能够满足这两个离散对数相等的秘密 $x$</p><h3 id="基于身份的两个离散对数相等的知识证明"><a href="#基于身份的两个离散对数相等的知识证明" class="headerlink" title="基于身份的两个离散对数相等的知识证明"></a>基于身份的两个离散对数相等的知识证明</h3><p>Identity-Based Proof of Knowledge for Equality of Two Discrete Logarithms</p><p>基于双线性对的扩展，证明者想证明 $\log_g u = \log_h v$</p><p>其中 $g, h, u, v$ 是通过双线性映射生成的，具体的值如下：</p><script type="math/tex; mode=display">g = e(P, P)\\u = e(P, SID)\\h = e(Q, P)\\v = e(Q, SID)\\</script><p>其中 $P$ 和 $Q$ 是群 $G_1$ 中的元素，$SID$ 是证明者的私钥</p><p>过程：</p><ul><li>证明者选择一个随机数 $r \in_R \mathbb{Z}_q$</li><li>计算 $c = H(g, h, u, v, g^r, h^r)$</li><li><p>然后计算 $S = rP - c \cdot SID$，这里 $S$ 是一个基于群 $G_1$ 元素的值</p></li><li><p>验证者接收到 $(c, S)$ 后，检查 $c = H(g, h, u, v, e(P, S) \cdot u^c, e(Q, S) \cdot v^c)$ 是否成立</p></li></ul><p>如果等式成立，验证者就能相信证明者拥有相同的离散对数 $x$，但又不会获得 $x$ 的具体值</p><h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><p>定义：不泄露任何关于秘密本身的信息就能证明某个声明为真，即验证者不能从证明过程中获得任何除了“声明为真”的附加信息</p><p>零知识证明必须满足三个特性：</p><ol><li>完备性（Completeness）：若证明者知道秘密，则城市的验证者一定能够通过验证</li><li>可靠性（Soundness）：若证明者不知道秘密，则无法欺骗验证者通过验证</li><li>零知识性（Zero-Knowledge）：除了知道证明者确实拥有该秘密，验证者不能通过验证过程获得任何有关秘密的附加信息</li></ol><h3 id="Schnoor协议"><a href="#Schnoor协议" class="headerlink" title="Schnoor协议"></a>Schnoor协议</h3><p>假设有一个循环群 $G$ ，其生成元为 $g$，其阶为一个大素数 $q$，则 Schnorr 协议证明某人知道一个离散对数秘密 $x$，即 $y = g^x \mod p$，其中 $p$ 是大素数模数</p><ol><li>公共参数：<br> 公开循环群 $G$，生成元 $g$，以及验证者要证明的 $y = g^x$。<br> 证明者持有秘密 $x$。</li><li>承诺阶段（Commitment）：<br> 证明者随机选择一个值 $r$，计算承诺值 $t = g^r \mod p$，然后将 $t$ 发给验证者。</li><li>质询阶段（Challenge）：<br> 验证者随机生成一个质询 $e$，其范围通常是 $0 \leq e &lt; q$，并发送给证明者。</li><li>响应阶段（Response）：<br> 证明者计算响应 $s = r + e \cdot x \mod q$，然后将 $s$ 发给验证者。</li><li>验证阶段（Verification）：<br> 验证者通过  $g^s\overset{\text{?}}{=}t\cdot y^e\mod p$  检查证明</li></ol><p>零知识证明的性质在Schnorr协议中的体现</p><p>完备性：如果证明者正确地知道 $x$，那么 $g^s = g^{r + e \cdot x} = g^r \cdot (g^x)^e = t \cdot y^e$，验证者将接受证明。</p><p>可靠性：如果证明者不正确地知道 $x$，则无论如何计算 $s$，该等式都不会以高概率成立。因此，证明者无法欺骗验证者。</p><p>零知识性：验证者在整个过程中，只看到承诺 $t$、质询 $e$、响应 $s$，但由于质询 $e$ 是随机生成的，且验证者无法反推出 $r$ 或 $x$，因此验证者无法从中得到任何有用的信息。验证者只能知道证明者确实知道 $x$。</p><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><p><img src="4f8bafd798af360e10374d0d1c5f834a.png" alt></p><h3 id="三个实例"><a href="#三个实例" class="headerlink" title="三个实例"></a>三个实例</h3><h4 id="《瓦利在哪里？》"><a href="#《瓦利在哪里？》" class="headerlink" title="《瓦利在哪里？》"></a>《瓦利在哪里？》</h4><p><img src="5556e46b8ed2c794024ddb5b3792c83a.gif" alt></p><p>遮住整个图像，通过一个切口来展示瓦利的图像，而不公布具体坐标</p><h4 id="成员证明"><a href="#成员证明" class="headerlink" title="成员证明"></a>成员证明</h4><p>你遇到一个不认识的人，但她声称也是你所在团队的成员。你如何知道是否可以信任她？</p><p>你的团队有一个带锁的保险箱，只有你的团队成员知道秘密组合密码，可以打开保险箱</p><ol><li>验证者写一条秘密信息并放入锁定的保险箱中</li><li>符合要求的证明者知道密钥，打开锁定的保险箱</li><li>证明者将秘密信息交还给验证者</li><li>验证者确信证明者真的知道密钥，因此信任</li></ol><h4 id="不透明定价"><a href="#不透明定价" class="headerlink" title="不透明定价"></a>不透明定价</h4><p>两个人在同一供应商购买相同的物品，但是不知道价格是否相同</p><ol><li>有4个带锁的锁盒，每个盒子上有一个只能放一张纸的小插槽。它们分别标有价格100、200、300和400，并放置在一个安全的私人房间中</li><li>A首先独自进入房间。A的单价是200，A拿走标有200的锁盒的钥匙，并销毁其他盒子的钥匙。离开房间</li><li>B独自进入房间，带有4张纸，其中1张上面有对钩，另外3张上面都有叉号。B的单价是300，故将带有对钩的纸张放入标有300的锁盒中，并将带有叉号的纸张放入其他锁盒中。离开房间</li><li>A可以带着只能打开标有200的锁盒的钥匙返回，发现一张上面有叉号的纸，现在A知道二人价格不同</li><li>B对手回来后，看到A手上有一张上面有叉号的纸，所以现在B也知道二人价格不同</li></ol><h2 id="其他看起来比较新的东西？"><a href="#其他看起来比较新的东西？" class="headerlink" title="其他看起来比较新的东西？"></a>其他看起来比较新的东西？</h2><h3 id="交互式零知识证明"><a href="#交互式零知识证明" class="headerlink" title="交互式零知识证明"></a>交互式零知识证明</h3><p>在交互式零知识证明中，证明者和验证者进行来回对话。这种交互对于验证者确信声明的有效性至关重要。虽然有效，但交互性在某些情况下可能会受到限制。</p><p>优点：安全级别高，非常适合实时应用</p><p>缺点：需要多轮交互，对于异步系统来说并不理想。</p><h3 id="非交互式零知识证明"><a href="#非交互式零知识证明" class="headerlink" title="非交互式零知识证明"></a>非交互式零知识证明</h3><p>顾名思义，非交互式零知识证明消除了证明者和验证者之间对话的需要。来自证明者的一条消息足以让验证者信服。</p><p>优点：高效且可扩展，非常适合区块链和其他去中心化系统</p><p>缺点：与交互式零知识证明相比，安全性稍差</p><h3 id="zk-SNARKs"><a href="#zk-SNARKs" class="headerlink" title="zk-SNARKs"></a>zk-SNARKs</h3><p>zk-SNARK（零知识简洁非交互式知识论证）结合了两个世界的优点。它们是非交互式的，但提供了高水平的安全性，使它们在包括区块链技术在内的各种应用中很受欢迎。</p><p>优点：高度安全、高效、无需交互</p><p>缺点：设置复杂且计算要求较高</p><h3 id="zk-STARKs：透明的后量子安全证明"><a href="#zk-STARKs：透明的后量子安全证明" class="headerlink" title="zk-STARKs：透明的后量子安全证明"></a>zk-STARKs：透明的后量子安全证明</h3><p>zk-STARK 提供了 zk-SNARK 所不具备的透明度。它们不需要可信的设置，这使得它们更加透明，并且可能更安全地抵御量子攻击。</p><p>优点：无需可信设置、抗量子、高度可扩展。</p><p>缺点：证明尺寸更大，计算开销更大。</p><hr><p>后面还有<a href="https://medium.com/@gewenbo888/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E-c21379e3ea83">这一篇</a>没看，不知道他在做什么但是字数好多（</p><p>留个戳，以后大概率不会看了（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reference：</span><br><span class="line">Identity-based chameleon hashing and signatures without key exposure</span><br><span class="line">https://www.secrss.com/articles/58134</span><br><span class="line">https://www.circularise.com/blogs/zero-knowledge-proofs-explained-in-3-examples</span><br><span class="line">https://www.cnblogs.com/primihub/p/17664137.html</span><br><span class="line">https://medium.com/@justin_Aleo/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E-b6fd586bad13</span><br><span class="line">https://blog.csdn.net/Jifu_M/article/details/112254136</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《安全规约导论》阅读笔记</title>
      <link href="/2024/10/09/%E3%80%8A%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B000/"/>
      <url>/2024/10/09/%E3%80%8A%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B000/</url>
      
        <content type="html"><![CDATA[<p>此博客为常驻，用于汇总笔者阅读《安全规约导论》一书的学习笔记</p><p>这本书里的好东西很多，价值很高，值得充分学习</p><p>持续更新中</p><span id="more"></span><ol><li><a href="../../../../../2024/10/10/安全规约前置知识">安全规约前置知识</a> </li><li><a href="../../../../../2024/10/10/安全规约基础">安全规约基础</a> </li><li><a href="../../../../../2024/10/08/荔枝成为BLS短签名糕守">荔枝成为BLS短签名糕守</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 常驻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XU-CMA安全是什么</title>
      <link href="/2024/10/08/XU-CMA%E5%AE%89%E5%85%A8%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2024/10/08/XU-CMA%E5%AE%89%E5%85%A8%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>密码学中数字签名方案的安全模型主要包括两种：存在性不可伪造（Existential Unforgeability against chosen-message attacks, EU-CMA）和强不可伪造（Strong Unforgeability against chosen-message attacks, SU-CMA）， 本文主要对比这两种安全模型。</p><span id="more"></span><p>两种安全模型都是通过敌手（Adversary）和挑战者（Challenger）之间的游戏（Game）来定义的。首先挑战者生成密钥对 $(pk,sk)$ 并发送 $pk$ 给敌手，自己保存 $sk$ 用来生成签名。敌手可以自适应地提交任意消息，挑战者根据敌手提交的消息生成对应的签名并返回给敌手。最后，敌手返回一个伪造的对未查询过的新消息的签名。</p><h3 id="EU-CMA"><a href="#EU-CMA" class="headerlink" title="EU-CMA"></a>EU-CMA</h3><p>在数字签名里标准的安全模型</p><p>在该模型里，敌手可以非随机性地询问任意 message 的 signature 并对任意没有询问过消息的 message 进行 forgery 攻击（第二篇参考文档中还有很多看不懂的东西）</p><p>存在性不可为造安全模型可以使用如下GAME描述：</p><ul><li><p>$Setup$：假设$SP$问哦系统参数。挑战者执行密钥生成算法，生成密钥对 $(pk,sk)$ 并发送 $pk$ 给敌手，挑战者保留 $sk$ 用来回答敌手的签名查询</p></li><li><p>$Query$：敌手自适应的选取任意消息 $m_i$ 进行签名查询。对于敌手提交的消息 $m_i$ ，挑战者执行签名算法生成 $\sigma_{m_i}$ 并将其发送给敌手</p></li><li><p>$Forgery$：敌手返回一个伪造的对于某个消息 $m^{<em>}$ 签名 $\sigma_{m^{</em>}}$，如果：</p><ul><li>$\sigma_{m^<em>}$是一个关于 $m^</em>$ 的合法签名</li><li>关于所有 $m^{*}$ 的签名之前没有被查询过</li></ul><p>则敌手在游戏中获胜，敌手赢得游戏的优势 $\varepsilon$ 就是返回一个合法的伪造签名的概率</p></li></ul><h3 id="SU-CMA"><a href="#SU-CMA" class="headerlink" title="SU-CMA"></a>SU-CMA</h3><p>强不可为造安全模型可以使用如下GAME描述：</p><ul><li><p>$Setup$：假设$SP$问哦系统参数。挑战者执行密钥生成算法，生成密钥对 $(pk,sk)$ 并发送 $pk$ 给敌手，挑战者保留 $sk$ 用来回答敌手的签名查询</p></li><li><p>$Query$：敌手自适应的选取任意消息 $m_i$ 进行签名查询。对于敌手提交的消息 $m_i$ ，挑战者执行签名算法生成 $\sigma_{m_i}$ 并将其发送给敌手</p></li><li><p>$Forgery$：敌手返回一个伪造的对于某个消息 $m^{<em>}$ 签名 $\sigma_{m^{</em>}}$，如果：</p><ul><li>$\sigma_{m^{<em>}}$是一个关于 $m^{</em>}$ 的合法签名</li><li>$m^{<em>}$ 的签名 $\sigma_{m^{</em>}}$ 之前没有被查询过</li></ul><p>则敌手在游戏中获胜，敌手赢得游戏的优势 $\varepsilon$ 就是返回一个合法的伪造签名的概率</p></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>EU-CMA和SU-CMA的区别仅在于敌手获胜条件的判定上 $(Forgery-2)$</p><ul><li>在EU-CMA中的要求是所有的 $m^*$ 的签名在 $Query$ 阶段都没有被查询过</li><li>而在SU-CMA中则只要求在之前的查询操作中没有出现过 $\sigma_{m^<em>}$，也就是说，如果之前查询过关于 $m^</em>$ 的签名 $\sigma_{m^<em>}^{(1)}$，如果敌手可以生成另一个关于 $m^</em>$ 的签名 $\sigma_{m^<em>}^{(2)}$，而且 $\sigma_{m^</em>}^{(1)}\neq \sigma_{m^*}^{(2)}$，也判定为敌手获胜</li></ul><p>显然 SU-CMA 中的敌手拥有更强的能力, 因此可以认为 SU-CMA 相比 EU-CMA 是更强的安全模型.</p><hr><p>reference：</p><p><a href="https://www.cnblogs.com/zywnnblog/p/16111384.html">https://www.cnblogs.com/zywnnblog/p/16111384.html</a></p><p><a href="https://documents.uow.edu.au/~fuchun/jow/011-QAXEDWBAMA.pdf">https://documents.uow.edu.au/~fuchun/jow/011-QAXEDWBAMA.pdf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各式各样的DH</title>
      <link href="/2024/10/08/%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84DH/"/>
      <url>/2024/10/08/%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84DH/</url>
      
        <content type="html"><![CDATA[<p>阅读《Identity-Based Chameleon Hashing and  Signatures Without Key Exposure》一文时，遇到了Decision Diffie-Hellman Problem (DDHP)这一概念，头一次遇到，便搜索了一下，打算学习学习；没想到捅了老挝——<a href="https://blog.csdn.net/mutourend/article/details/105544862">一个DH密钥交换算法能衍生出各式各样的东东</a></p><p>没办法了，学吧</p><p>由于种种原因（我比较懒），目前只学DDHP，其他的先挖个坑</p><span id="more"></span><h2 id="DDHP"><a href="#DDHP" class="headerlink" title="DDHP"></a>DDHP</h2><h3 id="论文里的描述"><a href="#论文里的描述" class="headerlink" title="论文里的描述"></a>论文里的描述</h3><p><img src="image-20241008151017651.png" alt></p><p>大致内容：在特定的群 $G_1$ 中，可以通过计算双线性映射的方式有效地判断一个四元组是否满足Diffie-Hellman条件</p><div class="table-container"><table><thead><tr><th>区别</th><th>DH</th><th>DDHP</th></tr></thead><tbody><tr><td>目的</td><td>用于密钥交换，建立安全通信</td><td>判断给定值是否符合Diffie-Hellman关系</td></tr><tr><td>功能</td><td>生成共享密钥</td><td>验证一个数值是否是由特定的私钥生成的</td></tr><tr><td>安全性基础</td><td>基于离散对数的困难性，安全性与密钥长度和生成元选择有关</td><td>直接依赖于离散对数问题的安全性，特别是在无法计算 $g^{ab}$ 的情况下</td></tr></tbody></table></div><h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><p>（有点草率，但是感觉思想很到位）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 假设我们已经有 A、B 和一个待验证的 C</span><br><span class="line">C = pow(g, a * b, p)  # 假设这是我们计算出来的 C</span><br><span class="line"></span><br><span class="line"># 验证DDHP</span><br><span class="line">def verify_ddhp(p, g, A, B, C):</span><br><span class="line">    # 计算 g^(ab) mod p</span><br><span class="line">    calculated_C = (pow(A, b, p))  # K = A^b mod p</span><br><span class="line">    return calculated_C == C</span><br><span class="line"></span><br><span class="line"># 输出验证结果</span><br><span class="line">is_valid = verify_ddhp(p, g, A, B, C)</span><br><span class="line">print(f&quot;Is C valid? &#123;is_valid&#125;&quot;)</span><br></pre></td></tr></table></figure><h3 id="结合双线性映射"><a href="#结合双线性映射" class="headerlink" title="结合双线性映射"></a>结合双线性映射</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定四个元素$(P,aP,bP,cP)$，其中：</p><p>$P$ 是群中的生成元</p><p>$aP$ 和 $bP$ 是两个通过标量乘法得到的公钥</p><p>$cP$ 是待验证的值</p><p>DDHP的目标是判断 $cP=abP$ 是否成立</p><h4 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h4><ol><li>计算双线性映射</li></ol><script type="math/tex; mode=display">\gamma_1=\hat{e}(P,cP)\\\gamma_2=\hat{e}(aP,bP)</script><ol><li><p>判断条件</p><p>若$\gamma_1=\gamma_2$，则可以确认 $cP$ 是有效的Diffie-Hellman四元组，即 $cP = abP$</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式初步学习</title>
      <link href="/2024/10/06/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/06/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>数年之前就听闻莫反，FFT，NTT等数论变换的名称，但是一直未学习相关知识</p><p>最近学习后量子密码学，遇到了类似数论变换，辄学习一下</p><span id="more"></span><h2 id="名词区分"><a href="#名词区分" class="headerlink" title="名词区分"></a>名词区分</h2><p>1、DFT(Discrete Fourier Transform)：离散傅立叶变换 $\rightarrow$ $O(n^2)$计算多项式乘法<br>2、FFT(Fast Fourier Teansformation)：快速傅立叶变换 $\rightarrow$ $O(nlogn)$计算多项式乘法<br>3、(F)NTT(Number Theoretic Transform)：（快速）数论变换 $\rightarrow$ 优化常数和误差，适用于整数域<br>4、MTT(any Module NTT)：NTT的扩展 $\rightarrow$ 任意模数</p><h2 id="离散傅里叶变换DFT"><a href="#离散傅里叶变换DFT" class="headerlink" title="离散傅里叶变换DFT"></a>离散傅里叶变换DFT</h2><p>这是一个朴素算法，用于将一个多项式在$O(n^2)$时间由系数表示法转化为点值表示法</p><p>原理：将一个用系数表示的多项式转化成它的点值表示的算法</p><p>对于一个$n-1$次的$n$项多项式$f(x)$可以表示为$f(x)=\sum_{i=0}^{n-1}a_ix^i$</p><p>系数表示法：$f(x)={a_0,a_1,…,a_{n-1}}$</p><p>点值表示法：$f(x)={(x_0,f(x_0)),(x_1,f(x_1)),…,(x_{n-1},f(x_{n-1}))}$</p><script type="math/tex; mode=display">求值：系数\rightarrow点值\\差值：点值\rightarrow系数</script><p>计算两个多项式相乘 $h(x)=f(x)*g(x)$</p><p>对于系数表示法，需要每一项和每一项的系数相乘，时间复杂度显然是$O(n^2)$</p><p>对于点值表示法——</p><p>$h(x)={(x_0,f(x_0)\cdot g(x_0)),(x_1,f(x_1)\cdot g(x_1)),…,(x_{n-1},f(x_{n-1})\cdot g(x_{n-1}))}$，时间复杂度是$O(n)$</p><p>已知 $n$ 个点值，可以唯一确定一个 $n-1$ 阶多项式</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>已知</p><script type="math/tex; mode=display">P(x_0)=p_0+p_1x_0+p_2x_0^2+\cdots+p_{n-1}x_0^{n-1}\\P(x_1)=p_0+p_1x_1+p_2x_1^2+\cdots+p_{n-1}x_1^{n-1}\\\vdots\\P(x_{n-1})=p_0+p_1x_{n-1}+p_2x_{n-1}^2+\cdots+p_{n-1}x_{n-1}^{n-1}\\</script><p>可以写成矩阵形式</p><script type="math/tex; mode=display">\begin{bmatrix}P(x_0)  \\P(x_1)  \\\vdots  \\P(x_{n-1}) \\\end{bmatrix}=\begin{bmatrix}1 & x_0 & x_0^2 & \cdots & x_0^{n-1}  \\1 & x_1 & x_1^2 & \cdots & x_1^{n-1}  \\\vdots & \vdots & \vdots & \ddots & \vdots  \\1 & x_{n-1} & x_{n-1}^2 & \cdots\ & x_{n-1}^{n-1}  \\\end{bmatrix}*\begin{bmatrix}p_0  \\p_1  \\\vdots  \\p_{n-1} \\\end{bmatrix}</script><p>中间的那列就是一个范德蒙行列式了，秩为1，所以$p_0,…,p_{n-1}$有且仅有一个解，即多项式的系数确定</p><p>证毕。</p><h3 id="利用单位圆进行转化"><a href="#利用单位圆进行转化" class="headerlink" title="利用单位圆进行转化"></a>利用单位圆进行转化</h3><p>将$n$向上填充为2的整数次幂，然后将单位圆平均取$n$个点</p><p><img src="image-20241007000846590.png" alt></p><p>在单位元上，我们定义$x_k=w_n^k=(cos\frac{k}{n}2\pi,sin\frac{k}{n}2\pi)$</p><p>对于点$x_k$​，$x_k=x_{k-i}*x_i(i\in[0,k])$​成立</p><p>此时，$x_1$即为该单位圆上的单位根（即该循环群中的单位元）</p><h4 id="单位根的性质"><a href="#单位根的性质" class="headerlink" title="单位根的性质"></a>单位根的性质</h4><h5 id="很有用的"><a href="#很有用的" class="headerlink" title="很有用的"></a>很有用的</h5><p>性质一（相消引理）：$w_{2n}^{2k}=w_n^k$ 这两个说的本质上是一个点</p><p>性质二（折半引理）：$w_n^{k+\frac{n}{2}}=-w_n^k$ 关于原点对称（向量等大反向）</p><h5 id="显而易见的"><a href="#显而易见的" class="headerlink" title="显而易见的"></a>显而易见的</h5><ol><li>$w_n^k=cos(2\pi\cdot\frac{k}{n})+isin(2\pi\cdot\frac{k}{n})$</li><li>$w_n^0=w_n^n=1$</li><li>$w_n^{n-i}=w_n^i$</li><li>$w_n^{n+i}=w_n^i$</li></ol><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>把多项式$A(x)$的离散傅里叶变换结果作为另一个多项式$B(x)$的系数，去单位根的倒数即$w_n^0,w_n^{-1},…,w_n^{-(n-1)}$作为$x$代入$B(x)$，得到的每个数再除以$n$，得到的是$A(x)$的各项系数</p><p>实现了傅里叶变换的逆变换——把点值表示转换成多项式系数表示</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>设$(y_0,y_1,y_2,…,y_{n−1})$为多项式$A(x)=a_0+a_1x+a_2x^2+…+a_{n−1}x^{n−1}$的离散傅里叶变换。</p><p>现在我们再设一个多项式$B(x)=y_0+y_1x+y_2x^2+…+y_{n−1}x^{n−1}$，现在我们把上面的$n$个单位根的倒数，即$ω^0_n,ω^{−1}_n,ω^{−2}_n,…,ω^{−(n−1)}_n$作为$x$代入$B(x)$, 得到一个新的离散傅里叶变换$(z_0,z_1,z_2,…,z_{n−1})$。</p><script type="math/tex; mode=display">\begin{align}z_k&=\sum_{i=0}^{n-1}y_i(w_n^{-k})^i\\&=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(w_n^i)^j)(w_n^{-k})^i\\&=\sum_{j=0}^{n-1}a_j(\sum_{i=0}^{n-1}(w_n^{j-k})^i)\end{align}</script><p>这个$\sum_{i=0}^{n-1}(w_n^{j-k})^i$是可求的：当 $j-k=0$ 时，原式=$n$；否则，通过等比数列求和可以得知</p><script type="math/tex; mode=display">\begin{align}\sum_{i=0}^{n-1}(w_n^{j-k})^i&=\frac{(w_n^{i-k})^n-1}{w_n^{i-k}-1}\\&=\frac{(w_n^n)^{i-k}-1}{w_n^{i-k}-1}\\&=\frac{1^{i-k}-1}{w_n^{i-k}-1}\\&=0\end{align}</script><p>故 $z_k=n\cdot a_k$</p><p>即 $a_i=\frac{z_i}{n}$</p><p>证毕</p><p>具体代码不做赘述，因为DFT和朴素算法的时间复杂度相同，在这里仅用于为FFT打基础</p><h2 id="快速傅里叶变化FFT"><a href="#快速傅里叶变化FFT" class="headerlink" title="快速傅里叶变化FFT"></a>快速傅里叶变化FFT</h2><p>用途：1.高精度乘法$O(n^2)\rightarrow O(nlogn)$ 2.分离正弦波</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>FFT和DFT的不同之处在于，傅里叶的时代并没有计算机，所以没有优化时间复杂度的需求；因而虽然DFT的计算是基于单位圆的，但是（求值和差值的）时间复杂度仍旧是$O(n^2)$；而FFT则采用了<strong>分治</strong>的思想，将求值和差值的时间复杂度降为$O(nlogn)$</p><p><img src="1928790-20220309154306366-190448235.png" alt></p><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>设 $A(x)=a_0+a_1x+a_2x^2+…+a_{n-1}x^{n-1}$，</p><p>按照下标奇偶性划分为两部分 </p><p>$A(x)=(a_0+a_2x^2+…+a_{n-2}x^{n-2})+(a_1x+a_3x^3+…+a_{n-1}x^{n-1})$</p><p>设 $A_1(x)=a_0+a_2x+…+a_{n-2}x^{\frac{n}{2}-1}\ A_2(x)=a_1x+a_3x+…+a_{n-1}x^{\frac{n}{2}-1}$（注意这里的次方数）</p><p>则 $A(x)=A_1(x^2)+xA_2(x^2)$</p><p>已知$x=w_n^k$，不妨设 $k&lt;\frac{n}{2}$，代入得到</p><script type="math/tex; mode=display">\begin{align}A(w_n^k)&= A_1(w_n^{2k})+w_n^kA_2(w_n^{2k}) \\&= A_1(w_\frac{n}{2}^{k})+w_n^kA_2(w_\frac{n}{2}^{k})\\\end{align}</script><p>对于$A(w_n^{k+\frac{n}{2}})$，有：</p><script type="math/tex; mode=display">\begin{align}A(w_n^{k+\frac{n}{2}})&=A_1(w_n^{2k+n})+w_n^{k+\frac{n}{2}}A_2(w_n^{2k+n})\\&=A_1(w_\frac{n}{2}^{k}\cdot w_n^n)+w_n^{k+\frac{n}{2}}A_2(w_\frac{n}{2}^{k}\cdot w_n^n)\\&=A_1(w_\frac{n}{2}^{k})-w_n^kA_2(w_\frac{n}{2}^{k})\end{align}</script><p>故只需要知道 $A_1(x)$ 和 $A_2(x)$ 分别在 $(w_\frac{n}{2}^0,w_\frac{n}{2}^1,…,w_\frac{n}{2}^{\frac{n}{2}-1})$ 的点值表示，就可以 $O(n)$ 计算 $A(x)$ 在 $(w_n^0,w_n^1,…,w_n^{n-1})$ 的点值表示</p><p>依此，就可以<strong>递归</strong>实现</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#这里的代码是ai给的，感觉不太靠谱的亚子</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def fft(a):</span><br><span class="line">    n = len(a)</span><br><span class="line">    if n &lt;= 1:</span><br><span class="line">        return a</span><br><span class="line">    even = fft(a[0::2])</span><br><span class="line">    odd = fft(a[1::2])</span><br><span class="line">    t = [np.exp(-2j * np.pi * k / n) * odd[k] for k in range(n // 2)]</span><br><span class="line">    return [even[k] + t[k] for k in range(n // 2)] + [even[k] - t[k] for k in range(n // 2)]</span><br><span class="line"></span><br><span class="line">def ifft(a):</span><br><span class="line">    n = len(a)</span><br><span class="line">    a_conj = [np.conjugate(x) for x in a]</span><br><span class="line">    y = fft(a_conj)</span><br><span class="line">    return [np.conjugate(x) / n for x in y]</span><br><span class="line"></span><br><span class="line">def polynomial_multiply(p, q):</span><br><span class="line">    n = len(p) + len(q) - 1</span><br><span class="line">    m = 1 &lt;&lt; (n - 1).bit_length()  # Next power of two</span><br><span class="line">    p += [0] * (m - len(p))</span><br><span class="line">    q += [0] * (m - len(q))</span><br><span class="line">    </span><br><span class="line">    fft_p = fft(p)</span><br><span class="line">    fft_q = fft(q)</span><br><span class="line">    fft_result = [fft_p[i] * fft_q[i] for i in range(m)]</span><br><span class="line">    result = ifft(fft_result)</span><br><span class="line">    </span><br><span class="line">    return [round(x.real) for x in result]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">p = [1, 2, 3]  # 1 + 2x + 3x^2</span><br><span class="line">q = [4, 5]     # 4 + 5x</span><br><span class="line">result = polynomial_multiply(p, q)</span><br><span class="line">print(result)  # 输出: [4, 13, 22, 15]</span><br></pre></td></tr></table></figure><h3 id="后续还有优化版FFT，插个眼，以后更新"><a href="#后续还有优化版FFT，插个眼，以后更新" class="headerlink" title="后续还有优化版FFT，插个眼，以后更新"></a>后续还有优化版FFT，插个眼，以后更新</h3><h2 id="（快速）数论变换-F-NTT"><a href="#（快速）数论变换-F-NTT" class="headerlink" title="（快速）数论变换 (F)NTT"></a>（快速）数论变换 (F)NTT</h2><p>好的，假设我学会了fft，可以开始学ntt了（大雾</p><div class="table-container"><table><thead><tr><th>不同点</th><th>FFT</th><th>NTT</th></tr></thead><tbody><tr><td>定义域</td><td>主要在复数域中进行，利用复数的旋转性质</td><td>使用复数的单位根，通常是复数的n次方根</td></tr><tr><td>根的选择</td><td>在有限域（通常是素数模数）中进行，适合用于整数运算</td><td>使用模p的原根，这些根在有限域中是整数</td></tr><tr><td>应用领域</td><td>信号处理、图像处理、数字滤波等</td><td>密码学、计算机代数和一些整数计算问题，如大数乘法等</td></tr><tr><td>计算方式</td><td>浮点数运算</td><td>完全整数</td></tr></tbody></table></div><p>对于质数$p=qn+1,(n=2^m)$，原根$g$满足$g^{qn}\equiv 1(\mod p)$</p><p>将$g_n\equiv g^q(\mod p)$看做$w_n$的等价，其满足相应的性质，如$g_n^n\equiv 1(\mod p),g_n^\frac{n}{2}\equiv -1(\mod p)$等</p><p>快速数论变化（FNTT），是数论变换（NTT）增加分治操作之后的快速算法，与快速傅里叶变换使用的分治办法完全一致</p><p>FFT中用到复数，需要使用$double$类型来计算，导致精度降低，所以需要使用原根来替代单位根</p><script type="math/tex; mode=display">g^\frac{p-1}{n}\equiv w_n\mod p</script><p>就像998244353,469762049,1004535809，它们的原根都是3</p><h2 id="任意模数NTT-MTT"><a href="#任意模数NTT-MTT" class="headerlink" title="任意模数NTT MTT"></a>任意模数NTT MTT</h2><p>如果模数不是以上几种，我们需要自己取模数</p><p>取一些模数$p_1,p_2,…,p_k$使得答案多项式的系数在<strong>取模之前</strong>不会超过 $\prod_{i=1}^{k}p_i$</p><p>一般而言取三个质数即可(998244353,469762049,1004535809)</p><p>先计算答案对每个 $p_i$ 取模的结果，利用中国剩余定理就可以求得答案对 $\prod_{i=1}^{k}p_i$ 取模的结果，这个结果就是答案，最后将这个答案对题目中的模数取一次模即可</p><p>例题：<a href="https://www.luogu.com.cn/problem/P4245">洛谷 P4245</a></p><p>一道MTT模板题</p><p><img src="image-20241008113031280.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define int long long</span><br><span class="line">int mod;</span><br><span class="line"></span><br><span class="line">// 这种写法我也第一次见，边写边学吧</span><br><span class="line">// 直接不开在全局std里了，单独一个Math</span><br><span class="line">namespace Math&#123;</span><br><span class="line">    inline int qpow( int base , int p , const int mod )&#123;</span><br><span class="line">        static int res;</span><br><span class="line">        for( res = 1 ; p ; p &gt;&gt;= 1 , base = base * base % mod )</span><br><span class="line">            if( p &amp; 1 ) </span><br><span class="line">                res = res * base % mod;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    inline int inv( int x , const int mod )&#123;</span><br><span class="line">        return qpow( x , mod-2 , mod );//费马小定理求逆元</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int mod1 = 998244353, mod2 = 1004535809, mod3 = 469762049, G = 3;</span><br><span class="line">const int mod_1_2 = mod1 * mod2;</span><br><span class="line">const int inv_1 = Math::inv(mod1, mod2), inv_2 = Math::inv(mod_1_2 % mod3, mod3);</span><br><span class="line"></span><br><span class="line">struct Int&#123;</span><br><span class="line">    int A , B , C;</span><br><span class="line">    // 空的默认构造函数</span><br><span class="line">    Int()&#123;&#125;</span><br><span class="line">    // 这个构造函数允许使用一个整数来初始化 A, B, C，它们都将被初始化为同一个值 __num</span><br><span class="line">    Int( int __num ): A(__num) , B(__num) , C(__num) &#123;&#125;</span><br><span class="line">    // 允许通过三个整数分别初始化 A, B, C</span><br><span class="line">    Int( int __A , int __B , int __C ): A(__A) , B(__B) , C(__C) &#123;&#125;</span><br><span class="line">    // 好神奇的操作，研究半天也没明白原理</span><br><span class="line">    // 只知道它可以做减法，出现负数就加上一个模数，只需要传入一个指针</span><br><span class="line">    static Int reduce( const Int &amp; x )&#123;</span><br><span class="line">        return Int( x.A + (x.A &gt;&gt; 31 &amp; mod1) , x.B + (x.B &gt;&gt; 31 &amp; mod2) , x.C + (x.C &gt;&gt; 31 &amp; mod3) );</span><br><span class="line">    &#125;</span><br><span class="line">    // 加减乘除的重载运算符，很精妙的写法</span><br><span class="line">    // 不太懂lhs和rhs是什么，只知道大概是两个input量，不像是数据结构里树的左孩子和右孩子</span><br><span class="line">    friend Int operator + ( const Int &amp;lhs , const Int &amp; rhs )&#123;</span><br><span class="line">        return reduce(Int(lhs.A + rhs.A - mod1, lhs.B + rhs.B - mod2, lhs.C + rhs.C - mod3));</span><br><span class="line">    &#125;</span><br><span class="line">    friend Int operator - ( const Int &amp;lhs , const Int &amp; rhs )&#123;</span><br><span class="line">        return reduce(Int(lhs.A - rhs.A, lhs.B - rhs.B, lhs.C - rhs.C));</span><br><span class="line">    &#125;</span><br><span class="line">    friend Int operator * ( const Int &amp;lhs , const Int &amp; rhs )&#123;</span><br><span class="line">        return Int( lhs.A * rhs.A % mod1 , lhs.B * rhs.B % mod2 , lhs.C * rhs.C % mod3 );</span><br><span class="line">    &#125;</span><br><span class="line">    int get()&#123;</span><br><span class="line">        int x = (B - A + mod2) % mod2 * inv_1 % mod2 * mod1 + A;</span><br><span class="line">        return ((C - x % mod3 + mod3) % mod3 * inv_2 % mod3 * (mod_1_2 % mod) % mod + x) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define maxn 200010 //maxn表示处理的最大元素数量</span><br><span class="line">namespace Poly&#123;</span><br><span class="line">    #define N (maxn &lt;&lt; 1) //N 定义为 maxn 的两倍，表示用于 NTT 的数组大小。</span><br><span class="line">    /*</span><br><span class="line">        lim：表示当前处理的长度，是最小的2的幂大于等于输入大小的值</span><br><span class="line">        s：记录 lim 的二进制位数</span><br><span class="line">        rev：用于存储每个索引的反转（bit-reversal）值</span><br><span class="line">        Wn：预计算的旋转因子（根单位元），用于 NTT 计算</span><br><span class="line">    */</span><br><span class="line">    int lim , s , rev[N];</span><br><span class="line">    Int Wn[N|1];</span><br><span class="line">    /*</span><br><span class="line">        初始化 NTT 相关参数</span><br><span class="line">        计算 lim 为不小于 n 的最小的2的幂</span><br><span class="line">        生成反转索引 rev，用于在 NTT 中重排数据</span><br><span class="line">        计算旋转因子 t，用于每个模数（mod1, mod2, mod3），通过幂函数 Math::pw 计算</span><br><span class="line">        初始化 Wn 数组，预计算旋转因子</span><br><span class="line">    */</span><br><span class="line">    void init( int n )&#123;</span><br><span class="line">        s = -1 , lim = 1;</span><br><span class="line">        while( lim &lt; n ) lim &lt;&lt;= 1 , s ++;//填充</span><br><span class="line">        for(int i = 1;i &lt; lim;i ++) rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | (i &amp; 1) &lt;&lt; s;</span><br><span class="line">        const Int t(Math::qpow(G, (mod1 - 1) / lim, mod1), Math::qpow(G, (mod2 - 1) / lim, mod2), Math::qpow(G, (mod3 - 1) / lim, mod3));</span><br><span class="line">        *Wn = Int(1); </span><br><span class="line">        for (Int *i = Wn; i != Wn + lim; ++i) *(i + 1) = *i * t;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">        执行 NTT 转换；首先进行反转操作，将数组 A 中的元素按 rev 数组重排</span><br><span class="line">        进行蝶形操作（butterfly operation），对数组进行逐层计算，利用预计算的旋转因子 Wn</span><br><span class="line">    */</span><br><span class="line">    inline void NTT(Int *A, const int op = 1) &#123;</span><br><span class="line">for (int i = 1; i &lt; lim; ++i) if (i &lt; rev[i]) std::swap(A[i], A[rev[i]]);</span><br><span class="line">for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123;</span><br><span class="line">const int t = lim / mid &gt;&gt; 1;</span><br><span class="line">for (int i = 0; i &lt; lim; i += mid &lt;&lt; 1) &#123;</span><br><span class="line">for (int j = 0; j &lt; mid; ++j) &#123;</span><br><span class="line">const Int W = op ? Wn[t * j] : Wn[lim - t * j];</span><br><span class="line">const Int X = A[i + j], Y = A[i + j + mid] * W;</span><br><span class="line">A[i + j] = X + Y, A[i + j + mid] = X - Y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        // 如果 op 为 0，表示是反向变换，则需要进行归一化，将结果除以 lim</span><br><span class="line">if (!op) &#123;</span><br><span class="line">const Int ilim(Math::inv(lim, mod1), Math::inv(lim, mod2), Math::inv(lim, mod3));</span><br><span class="line">for (Int *i = A; i != A + lim; ++i) *i = (*i) * ilim;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#undef N</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n , m , x;</span><br><span class="line">Int A[maxn &lt;&lt; 1], B[maxn &lt;&lt; 1], C[maxn &lt;&lt; 1];</span><br><span class="line">signed main() &#123;</span><br><span class="line">    scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;mod); ++n, ++m;//因为要考虑常数项，所以+1</span><br><span class="line">    for(int i = 0;i &lt; n;i ++) scanf(&quot;%lld&quot;, &amp;x), A[i] = Int(x % mod);</span><br><span class="line">    for(int i = 0;i &lt; m;i ++) scanf(&quot;%lld&quot;, &amp;x), B[i] = Int(x % mod);</span><br><span class="line">    Poly::init(n + m);</span><br><span class="line">    Poly::NTT(A), Poly::NTT(B);//系数转化为点值</span><br><span class="line">    for(int i = 0;i &lt; Poly::lim;i ++) C[i] = A[i] * B[i];//点值逐项相乘</span><br><span class="line">    Poly::NTT(C,0);//反向转化（即op=0），点值转回系数</span><br><span class="line">    for(int i = 0;i &lt; n+m-1;i ++) printf(&quot;%lld &quot;,C[i].get());</span><br><span class="line">    printf(&quot;\n&quot;);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考文档：</p><p>FFT的学习主要看的这篇<a href="https://www.cnblogs.com/RabbitHu/p/FFT.html">https://www.cnblogs.com/RabbitHu/p/FFT.html</a></p><p>写的很*，但是参考文献很好<a href="https://blog.csdn.net/Ciellee/article/details/108336914">https://blog.csdn.net/Ciellee/article/details/108336914</a></p><p>这篇是后续补充用的(fft)<a href="https://www.cnblogs.com/pam-sh/p/15976275.html">https://www.cnblogs.com/pam-sh/p/15976275.html</a></p><p>同上，不过这里是ntt了<a href="https://www.cnblogs.com/windymoon/p/17124857.html">https://www.cnblogs.com/windymoon/p/17124857.html</a></p><p><a href="https://www.cnblogs.com/xxeray/p/fast-fourier-transform.html">https://www.cnblogs.com/xxeray/p/fast-fourier-transform.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后量子学习笔记·其二</title>
      <link href="/2024/09/29/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%85%B6%E4%BA%8C/"/>
      <url>/2024/09/29/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%85%B6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="../../../../..//2024/09/21/撬开后量子的大门/">撬开后量子的大门</a> 一文中，我们初步学习了后量子密码学，本篇博客，力求对后量子密码学进行进一步学习</p><span id="more"></span><h3 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h3><p>我们通常说的量子计算就是通过量子逻辑门来操作处于叠加态的量子。比如Hadamard门，简称H门，他的一个主要功能就是通过计算基态产生等概率的叠加态。通过H门变换后的单量子叠加态为：</p><p>$H(|Φ_1⟩)=\frac{1}{\sqrt{2}}(|0⟩+|1⟩)$</p><p>两种基态的坍塌概率都为 $\frac{1}{\sqrt{2}}$，两个量子的H门得到的结果如下：</p><p>$H(|Φ_2⟩)=\frac{1}{\sqrt{2^2}}(|00⟩+|01⟩+|10⟩+|11⟩)$</p><p>每个态坍塌的概率 $\frac{1}{\sqrt{4}}$ ，对于n个量子的H门变换后：</p><p>$H(|Φ_n⟩)=\frac{1}{\sqrt{2^n}}∑_{i=0}^{2n−1}|i⟩$</p><hr><p>量子门及其对应的门矩阵如下图：</p><p><img src="300px-Quantum_Logic_Gates.png" alt></p><p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate">https://en.wikipedia.org/wiki/Quantum_logic_gate</a></p><p>挖个坑，这是另外一篇笔记的事情了</p><hr><p>还有一个比较重要的复合门是受控U(a,x)门：<a href="https://zhuanlan.zhihu.com/p/422428222">一只冰牙喵：4.2 受控操作</a></p><p>省流：受控U门可以用于计算以a为基底的幂，其一般用于生成指数函数值。</p><h3 id="量子如何做并行运算"><a href="#量子如何做并行运算" class="headerlink" title="量子如何做并行运算"></a>量子如何做并行运算</h3><p>量子计算正是有了数据的可叠加性和幺正变换，从而决定了一次操作即可改变多个数据</p><p>在经典计算中，并行性的核心思想是将一个计算任务分配给多个处理器同时运行，要快于使用一个处理器来运行。在理想的情况下，将工作分配给K个处理器就应该使计算时间缩短为原来的1/K</p><p>而对于量子计算机，将一个N 位量子寄存器中的 $2^N$ 个数据同时通过一次幺正变换（即进行一次运算）所需的时间定义为 $T_q$ ，而经典计算中对一个数据进行运算的时间为 $T_c$ ，因为一次量子计算就对所有的数据做了并行处理，所以量子计算加速能力可以表示为 $S=2^N\cdot\frac{T_c}{T_q}$</p><p>如果 $T_c=T_q$ ,那么加速能力 $S=2^N$,也就是说对量子计算机做一次运算，相当于对经典计算机做 $2^N$ 次运算</p><p>此外，一台量子计算机并不一定在所有计算任务上都比一台经典计算机做得好，比如乘法运算在一台量子计算机上执行就不如传统计算机上快。为了突出量子计算机的优越性，就需要开发量子并行效应能力的算法。</p><p>量子计算机是严重依赖于优秀的量子算法的实现，虽然通用量子计算机能做经典计算机的所有事情，但是只有在处理特定问题上量子计算才具有决定性的优势</p><h3 id="Shor算法分析"><a href="#Shor算法分析" class="headerlink" title="Shor算法分析"></a>Shor算法分析</h3><p>shor算法直接将质因子分解以及离散对数问题以指数级速度提升，这意味着可以利用同样算法思想来解决更为广泛的隐含子群问题。</p><p>RSA是经典计算机大数质因式分解的指数复杂度的困难的一种非对称加密算法，目前最优的因子分解算法（The Number Field Sieve）为指数复杂度 $O\left(\exp\left(\left(\frac{64}{9}\right)^{1/3} \cdot \log n^{2/3} \cdot \log \log n^{1/3}\right)\right)$ 。而通过shor量子算法可以以多项式复杂度完成大数因式分解，从而可以快速破解RSA算法。</p><p>Shor算法的核心依赖于 </p><ul><li>H变换</li><li>U变换</li><li>QFT(量子傅立叶)</li></ul><p>Shor算法量子实现线路简图：</p><p><img src="shor算法量子实现线路图.png" alt></p><h4 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h4><p>我们设RSA的公钥为 $(e,N)$ ，私钥为 $(d,N)$ ,那么生成公私钥的过程如下：</p><ol><li>生成两个足够大的素数 $p,q$，得到合数 $N=p<em>q$，则 $\phi(N)=(p-1)</em>(q-1)$</li><li>生成 $e$ ，使得 $e$ 和 $L$ 互质，且满足 $1&lt;e&lt;\phi(N)$</li><li>生成 $d$，使得 $d*e=1\mod \phi(N)$ 且 $1&lt;d&lt;\phi(N)$</li></ol><p>那么加密解密操作如下</p><script type="math/tex; mode=display">\begin{cases} c_i=m^e_i(mod\;N)&加密\\ m_i=c^d_i(mod\;N)&解密\\ \end{cases}\\</script><p>只要能够实现大数N的因子分解，就可以破解RSA</p><p>2、问题转化</p><p>没看完，改天接着看</p><p><a href="https://zhuanlan.zhihu.com/p/106923175">https://zhuanlan.zhihu.com/p/106923175</a></p><p><a href="https://qrunes-tutorial.readthedocs.io/en/latest/chapters/algorithms/shor_Algorithm.html">https://qrunes-tutorial.readthedocs.io/en/latest/chapters/algorithms/shor_Algorithm.html</a></p><p><a href="https://blog.csdn.net/bluepeople1/article/details/50015921">https://blog.csdn.net/bluepeople1/article/details/50015921</a></p><p><a href="https://www.cnblogs.com/zhuowangy2k/p/12245636.html">https://www.cnblogs.com/zhuowangy2k/p/12245636.html</a></p><p>首先我们需要将大数因子分解问题转化为以求待分解的合数N为模的函数 $f(x)=a^x(mod\;N)$ 的周期问题。</p><p>设周期函数 $f(x)=a^x\pmod N$ 的周期为r（这里a为小于N，且与N互质的整数），则有：f(x)=f(x+r) , 那么：</p><p>a^x=a^{x+r} \pmod N\ \Rightarrow a^r=1 \pmod N\ \Rightarrow (a^{r/2}+1)(a^{r/2}-1)=0 \pmod N\ \Rightarrow (a^{r/2}+1)(a^{r/2}-1)=kN \quad(k=0,1,2,…)\</p><p>设整数 x=a^{r/2} ，则</p><p>(x-1)(x+1)=kN\Rightarrow x-1=kN/(x+1),x-1&gt;1</p><p>那么 x-1， x+1 都能被 kN 整除，那么一定存在 gcd(x+1,N)&gt;1 或者 gcd(x-1,N)&gt;1 (gcd是一个用<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=辗转相除法&amp;zhida_source=entity">辗转相除法</a>求<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=公因子&amp;zhida_source=entity">公因子</a>的函数)，也就说与N存在一个大于1的公约数，这个公约数就是N的<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=分解因子&amp;zhida_source=entity">分解因子</a>。</p><p>例如：设 N=15，a=7 ,则：</p><p>\begin{array}{c|c} x &amp;0&amp;1&amp;2&amp;3&amp;4&amp;5 \ \hline 7^x&amp;1&amp;7&amp;49&amp;343&amp;2401&amp;16807\ f&amp;1&amp;7&amp;4&amp;13&amp;1&amp;7\ \end{array}\ r=4\Rightarrow a^2-1=48，a^2+1=50\ \Rightarrow gcd(48,15)=3，gcd(50,15)=5\</p><p>由此，我们只要求出f(x)的周期，就能轻而易举的分解合数了。而shor算法的精髓就是利用<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=量子特性&amp;zhida_source=entity">量子特性</a>来快速求解得到周期r.</p><p>3、通过Shor算法求周期r</p><p>设<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=量子比特&amp;zhida_source=entity">量子比特</a>长度为 L, 则总共可以表示的 q=2^L 个基态, 设N为要分解的合数，为了确保 2^L 长度内有足够的周期数，我们需要满足</p><p>N^2\leq2^L\leq2N^2 \</p><p>然后，我们利用<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=2&amp;q=Hadamard门&amp;zhida_source=entity">Hadamard门</a>来构造等概率的量子叠加态 \mathinner{|x \rangle} 存入寄存器reg1，然后利用U门来构造 \mathinner{|f(x) \rangle} 的叠加态存入寄存器reg2，且使这两个寄存器处于纠缠态。</p><p>\begin{cases} \mathinner{|\Phi_1 \rangle}=\frac{1}{\sqrt{2^L}}\sum_{x=0}^{2^L-1} \mathinner{|x \rangle}&amp;reg1\ \mathinner{|\Phi_2 \rangle}=\frac{1}{\sqrt{2^L}}\sum_{x=0}^{2^L-1} \mathinner{|x \rangle} \mathinner{|a^x(mod\;N) \rangle}&amp;reg1\oplus reg2 \end{cases}\</p><p>两个寄存器展开形式如下：</p><p>\begin{align}x&amp;=x_02^0+x_12^1+x_22^2+…+x_{L-1}2^{L-1}\ f(x)&amp;=a^x(mod\;N)=a_{x_0}^{2^0},a_{x_1}^{2^1},…a_{x_{L-1}}^{2^{L-1}}(mod\;N)\end{align}\</p><p>由于 f(x) 为周期函数，设周期为r，A为总长2^L中存在的周期数，则</p><p>A=\frac{2^L}{r}\tag{0}\</p><p>设l为小于一个周期内的x的值, x=l+Ar, 则整个系统的态实际为</p><p>\mathinner{|\Phi_2 \rangle}=( \mathinner{|l \rangle} \mathinner{|f(l) \rangle}+\mathinner{|l+r \rangle} \mathinner{|f(l+r) \rangle}+\mathinner{|l+3r \rangle} \mathinner{|f(l+3r) \rangle}+…+(\mathinner{|l+(A-1)r \rangle} \mathinner{|f(l+(A-1)r) \rangle})\</p><p>因此，x可以表示为</p><p>x=l,l+r,l+2r,l+3r,…l+(A-1)r\</p><p>然后对reg2进行计算基上的测量，设测量结果设为 Z ，测量Z在reg1中的投影变化为\begin{align}\mathinner{|\Phi_1 \rangle}&amp;=\frac{1}{\sqrt{A}}\sum_{j=0}^{A-1} \mathinner{|jr+l \rangle}\tag{1}\ &amp;=\frac{1}{\sqrt{\frac{2^L}{r}}}\sum_{j=0}^{\frac{2^L}{r}-1} \mathinner{|jr+l \rangle}\end{align}\</p><p>例如 N=15，a=7 ，测量后的整个系统的态为：</p><p>\mathinner{|\Phi_2 \rangle}=\frac{1}{\sqrt{2^L}}( \mathinner{|0 \rangle} \mathinner{|1 \rangle}+\mathinner{|1 \rangle} \mathinner{|7 \rangle}+\mathinner{|2 \rangle} \mathinner{|4 \rangle}+\mathinner{|3 \rangle} \mathinner{|13\rangle}+\mathinner{|4 \rangle} \mathinner{|1 \rangle}+\mathinner{|5 \rangle} \mathinner{|7 \rangle}+\mathinner{|6 \rangle} \mathinner{|4 \rangle}+\mathinner{|7 \rangle} \mathinner{|13 \rangle})\</p><p>经过投影后</p><p>\begin{array}{c|c} Z &amp;\text{测量后x的态}&amp;offset \ \hline 1&amp;(\mathinner{|0 \rangle}+\mathinner{|4 \rangle}+\mathinner{|8 \rangle}+…)\mathinner{|1 \rangle}&amp;0\ 4&amp;(\mathinner{|2 \rangle}+\mathinner{|6 \rangle}+\mathinner{|10 \rangle}+…)\mathinner{|4 \rangle}&amp;1\ 7&amp;(\mathinner{|1 \rangle}+\mathinner{|5 \rangle}+\mathinner{|9 \rangle}+…)\mathinner{|7 \rangle}&amp;2\ 13&amp;(\mathinner{|3 \rangle}+\mathinner{|7 \rangle}+\mathinner{|11 \rangle}+…)\mathinner{|13 \rangle}&amp;3\ \end{array}\</p><p>这里，当测量得到一个 \gamma 值后，由于寄存器reg1和寄存器reg2是处于纠缠态，所以Z值测量后寄存器reg1会塌陷为相同<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=2&amp;q=Z值&amp;zhida_source=entity">Z值</a>的 \mathinner{|x \rangle} 叠加态，如果reg2测量的值为1，那么reg1则处于 (\mathinner{|0 \rangle}+\mathinner{|4 \rangle}+\mathinner{|8 \rangle}+…) 的叠加态，那么周期 r 的信息就包含在reg1中，因此对reg1进行量子傅里叶变化：</p><p>QFT(\mathinner{|jr+l \rangle})=\frac{1}{\sqrt{2^L}}\sum_{\gamma=0}^{2^L-1}e^{2\pi i(jr+l)\gamma/2^L}\mathinner{|\gamma \rangle}\ QFT(\mathinner{|\Phi_{2} \rangle})=\frac{1}{\sqrt{A}}\sum_{j=0}^{A-1}QFT(\mathinner{|jr+l \rangle})\</p><p>上式可以变换为：</p><p>\begin{align} QFT(\mathinner{|\Phi_{2} \rangle})&amp;=\frac{1}{\sqrt{A}}\sum_{j=0}^{A-1}[\frac{1}{\sqrt{2^L}}\sum_{\gamma=0}^{2^L-1}e^{2\pi i(jr+l)\gamma/2^L}]\mathinner{|\gamma \rangle}\ &amp;=\sum_{\gamma=0}^{2^L-1}[\frac{\sqrt{r}}{2^L}\sum_{j=0}^{A-1}e^{2\pi i(jr+l)\gamma/2^L}]\mathinner{|\gamma \rangle} \end{align}\</p><p>这里为什么要这么变换，因为当测量Reg2时，Reg2坍塌为了r个值中的一个值，所以每一个值对应reg1中的A个叠加态。这里设：</p><p>C_\gamma=\frac{\sqrt{r}}{2^L}\sum_{j=0}^{A-1}e^{2\pi i(jr+l)\gamma/2^L}=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\sum_{j=0}^{A-1}e^{2\pi ijr\gamma/2^L}] \tag{2}\</p><p>这里，我们需要考虑两种情况，一种是 2^L 能够整除 r 的情况，也就是在 2^L 内刚好有整数个周期，一种是不能整除的情况。如果能够整除，那说明每个波峰刚好位于 \gamma=k2^L/r ，不能整除时，波峰位于非常接近波峰的两侧，因为波峰处的 \gamma 本应该为非整数，而我们测量得到 \gamma 只能是整数，所以这时候我们需要加入微调的参数。接下来我们分别对这两种情况进行分析。</p><p>A.<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=3&amp;q=整数周期&amp;zhida_source=entity">整数周期</a></p><p>在(2)式的[ ]中，在 \gamma 是 \frac{2^L}{r} 的整数倍情况下变成，出现相长干涉，求和后为 A=\frac{2^L}{r} ，如果不为整数，则为<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=相消干涉&amp;zhida_source=entity">相消干涉</a>，其值趋于0. 所以</p><p>C_\gamma=\begin{cases} \frac{1}{\sqrt{r}}e^{2\pi il\gamma/2^L}&amp;\gamma=k2^L/r\ 0&amp;\gamma\ne k2^L/r\ \end{cases}\</p><p>当 \gamma\ne k2^L/r 时，我们通过<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=等比数列&amp;zhida_source=entity">等比数列</a>转化得到：</p><p>C_\gamma=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\sum_{j=0}^{A-1}e^{2\pi ijr\gamma/2^L}]=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\frac{e^{2\pi iAr\gamma/2^L}-1}{e^{2\pi ir\gamma/2^L}-1}]\</p><p>带入（0）式得：</p><p>C_\gamma=\frac{\sqrt{r}}{2^L}e^{2\pi il\gamma/2^L}[\frac{e^{2\pi i\gamma}-1}{e^{2\pi ir\gamma/2^L}-1}]\</p><p>由于 e^{2\pi i\gamma}-1=0 ，也就是说，当 \gamma\ne k2^L/r ，也即不为整数，则为相消干涉，其值为0。</p><p>通过量子傅里叶变换后得到如下叠加态</p><p>\mathinner{|\Phi_{n} \rangle}=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}e^{2\pi ik/r}\mathinner{|\frac{k2^L}{r} \rangle}\ \rho(\mathinner{|\Phi_{n} \rangle})=|\frac{1}{\sqrt{r}}|^2=\frac{1}{r}</p><p>测量 \mathinner{|\gamma \rangle} 的值， 等概率 \frac{1}{r} 地选择出一个态。由 \gamma=\frac{k2^L}{r} 得：</p><p>\frac{\gamma}{2^L}=\frac{k}{r}\</p><p>如果有 gcd(k,r)=1\;(\rho[gcd(k,r)=1])=\frac{1}{log(r)}) , r 就可以从 \frac{\gamma}{2^L} 的<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=不可约分数&amp;zhida_source=entity">不可约分数</a>求出。</p><p>B. 非整数周期</p><p>2^L 不能整除 r 的情况下,那么在x值范围内的周期数A便不是整数，此时我们加入微调参数 \delta_k 稍作调整，使得 \gamma 为整数，设</p><p>\gamma=\gamma_k+\delta_k=k\frac{2^L}{r}+\delta_k\</p><p>因此(2)式的[ ]为：</p><p>\begin{align}\sum_{j=0}^{A-1}e^{2\pi ijr\gamma/2^L}&amp;=\sum_{j=0}^{A-1}e^{2\pi ijr(k\frac{2^L}{r}+\delta_k)/2^L}\ &amp;=\sum_{j=0}^{A-1}e^{2\pi ijk}\cdot e^{2\pi ijr\delta_k/2^L}\ &amp;=\sum_{j=0}^{A-1}e^{2\pi ijr\delta_k/2^L}\&amp;=\frac{e^{2\pi iAr\delta_k/2^L}-1}{e^{2\pi ir\delta_k/2^L}-1}\end{align}\tag{3}\</p><p>这里 \delta_k 的值极小，该值用于逼近函数的峰值，我们再令</p><p>\theta=\frac{2\pi r\delta_k}{2^L}\tag{4}</p><p>因此(3)式的平方表示为</p><p>|\frac{e^{iA\theta}-1}{e^{i\theta}-1}|^2=(\frac{cosA\theta+isinA\theta-1}{cos\theta+isin\theta-1})^2\</p><p>由于</p><p>\begin{align} cos\theta+isin\theta-1&amp;=1-2sin^2\frac{\theta}{2}+2isin\frac{\theta-1}{2}cos\frac{\theta-1}{2}-1\ &amp;=2sin\frac{\theta}{2}(sin\frac{\theta}{2}-icos\frac{\theta}{2})\ &amp;=2isin\frac{\theta}{2}(cos\frac{\theta}{2}+isin\frac{\theta}{2})\ &amp;=2isin\frac{\theta}{2}\cdot e^{\frac{i\theta}{2}} \end{align}\</p><p>因此</p><p>|\frac{e^{iA\theta}-1}{e^{i\theta}-1}|^2=|\frac{2isin\frac{A\theta}{2}\cdot e^{\frac{iA\theta}{2}}}{2isin\frac{\theta}{2}\cdot e^{\frac{i\theta}{2}}}|^2=\frac{sin^2\frac{A\theta}{2}\cdot e^{iA\theta}}{sin^2\frac{\theta}{2}\cdot e^{i\theta}}=\frac{sin^2\frac{A\theta}{2}}{sin^2\frac{\theta}{2} }\cdot e^{i(A-1)\theta/2}</p><p>所以得到 \gamma 的概率为</p><p>\rho(\mathinner{|\gamma \rangle})=(\frac{\sqrt{r}}{2^L})^2\frac{sin^2\frac{A\theta}{2}}{sin^2\frac{\theta}{2}}\ =\frac{r}{2^{2L}} \frac{sin^2\frac{A\theta}{2}}{sin^2\frac{\theta}{2} }\ =\frac{r}{2^{2L}} \frac{sin^2\pi rA\delta_k}{sin^2\pi r\delta_k }\</p><p>这里，为了严谨讨论，我们设 |\delta_k| 小于等于1/2（如果大于1/2，可以认为是下一个整数 z-(1-\delta) ），所以这是适用于所有情况的</p><p>|\delta_k|\leq\frac{1}{2}\tag{5}</p><p>由(4)(5)得：</p><p>|\theta|\leq\frac{2\pi \frac{r}{2}}{q}=\frac{\pi r}{q} \ \Rightarrow \frac{|A|}{2}|\theta|\leq\frac{\pi r}{q}\cdot \frac{A}{2}&lt;\frac{\pi r}{q}\cdot\frac{2^L}{2r}=\frac{2^{L-1}\pi}{q}=\frac{\pi}{2}\tag{13}</p><p>当 \alpha\in[0,\frac{\pi}{2}]， sin\alpha 必位于<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=原点&amp;zhida_source=entity">原点</a>与点 (\pi/2,1) 连线的上方，所以</p><p>sin(\frac{A}{2})\theta\geq\frac{2}{\pi}(\frac{A}{2})\theta\</p><p>而对于任意 \alpha ， |sin\alpha| 为<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=凸函数&amp;zhida_source=entity">凸函数</a>，有：</p><p>|sin(\frac{A}{2})\theta|\geq|\frac{2}{\pi}(\frac{A}{2})\theta|\</p><p>又因 sin\frac{\theta}{2}\leq\frac{\theta}{2} ,因此：</p><p>\frac{sin^2(\frac{A}{2}\theta)}{sin^2(\frac{\theta}{2})} \geq\frac{(\frac{2}{\pi}(\frac{A}{2}\theta))^2}{sin^2(\frac{\theta}{2})}\geq\frac{(\frac{2}{\pi}\frac{A}{2}\theta)^2}{(\frac{\theta}{2})^2}\ =\frac{\frac{2}{\pi}(\theta)^2}{(\frac{\theta}{2})^2}\cdot(\frac{A}{2})^2 =\frac{16}{\pi^2}\cdot(\frac{A}{2})^2</p><p>所以，测量 \mathinner{|\gamma \rangle} 的概率为</p><p>\rho(\mathinner{|\gamma \rangle})=|C_\gamma|^2\geq\frac{r}{2^{2L}}\cdot\frac{16}{\pi^2}(\frac{2^L}{2r})^2=\frac{4}{\pi^2r}\</p><p>最后，我们来讨论测量值 \gamma ,有</p><p>\gamma r=(k\frac{2^L}{r}+\delta_k)\cdot r\ =k2^L+\delta_kr\ \Rightarrow |\gamma r-k2^L|=|\delta r|\leq\frac{r}{2}\</p><p>所以</p><p>|\frac{\gamma}{2^L}-\frac{k}{r}|\leq\frac{r}{2}\cdot\frac{1}{2^Lr}=\frac{1}{2^{L+1}}\</p><p>这里 \gamma 已测得，这里严格存在一个分数 \frac{k}{r} ,可由 \frac{\gamma}{2^L} 的连分数展开求出（下一个节将通过实例说明），通过约分满足 gcd(k,r)=1 就可得到 r 的值，gcd算法的成功率为</p><p>\rho(gcd(k,r))&gt;\frac{1}{logr}\ \Rightarrow Prob[N]=Prob(gcd(k,r))\cdot Prob(\gamma)&gt;\frac{1}{logr}\cdot\frac{4}{\pi^2r}=\frac{4}{\pi^2rlogr}</p><p>也就是说我们能以大于 \frac{4}{\pi^2rlogr} 的<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=概率分解&amp;zhida_source=entity">概率分解</a>N的因子再加上量子傅里叶变换的复杂度为 O(n^2) ,所以shor算法的<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=时间复杂度&amp;zhida_source=entity">时间复杂度</a>为 O(n^2rlogr)</p><h3 id="三、实例分析"><a href="#三、实例分析" class="headerlink" title="三、实例分析"></a>三、实例分析</h3><p>虽然上面已经分析得很透彻了，但是估计还是有人觉得会太抽象，所以下面我以一个例子来进行<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=3&amp;q=实例分析&amp;zhida_source=entity">实例分析</a>，以帮助理解。</p><p>对于 f(x)=a^x(mod N) ，N=91，a=4，那么</p><p>f(1)=4,f(2)=16,f(3)=64,f(4)=74,f(5)=23,f(6)=1</p><p>所以周期为 r=6， N&lt;2^7 ,L=2\times 7=14，然后根据2，3式我们计算得到：</p><p>\begin{array}{c|c} k &amp;\gamma=k2^L/r&amp;最近整数&amp;\rho(\gamma)&amp;\gamma/2^L\ \hline 0&amp;0&amp;0&amp;0.167&amp;0\ \hline 1&amp;2730.67&amp;2731&amp;0.114&amp;0.166687\ \hline 2&amp;5461.33&amp;5461&amp;0.114&amp;0.333312\ \hline 3&amp;8192&amp;8192&amp;0.167&amp;0.500000\ \hline 4&amp;10922.67&amp;10923&amp;0.114&amp;0.666687\ \hline 5&amp;13653.33&amp;13653&amp;0.114&amp;0.833312\ \end{array}\</p><p>这里， \gamma 是我们测量得到值，如果这个值为0，那么对于我们求周期r是没有意义的，所以除开这种情况下，测得其他值的概率和为0.623。如果测量的值为13653，那么我们来计算0.833312的连分数。</p><p>1/0.833312=1.200031,</p><p>1/0.200031=4.999225,</p><p>1/0.999225=1.000775,</p><p>1/0.000775=1290.322580</p><p>这里遇到大数1290，我们就终止，最后我们得到连分数为</p><p>[0;1,4,1]=\frac{1}{1+\frac{1}{4+1}}=\frac{5}{6}\</p><p>那么我们就可以确定 k=5,r=6 了吗，那有没可能 k=10,r=12 呢，所以，我们不能单纯的通过一次测量来确定周期，我们来考察其他几项，我这里不再一一去展开了，懒人可以在这里去计算(<a href="https://link.zhihu.com/?target=http%3A//www.ab126.com/shuxue/2939.html">连分数计算 -连分数计算器-分数计算器</a>)。</p><p>\begin{array}{c|c} k &amp;\gamma最近整数&amp;\gamma最近整数/2^L&amp;连分数展开近似值\ \hline 0&amp;0&amp;0&amp;0\ \hline 1&amp;2731&amp;0.166687&amp;\frac{1}{6}\ \hline 2&amp;5461&amp;0.333312&amp;\frac{1}{3}\ \hline 3&amp;8192&amp;0.500000&amp;\frac{1}{2}\ \hline 4&amp;10923&amp;0.666687&amp;\frac{2}{3}\ \hline 5&amp;13653&amp;0.833312&amp;\frac{5}{6}\ \end{array}\</p><p>因此，如果我们将shor算法多执行几次，最后求出各个分母的最小公倍数，那么这个<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=3&amp;q=最小公倍数&amp;zhida_source=entity">最小公倍数</a>就是我们要找的周期r，有了周期r，我们就不难求出合数N的质数因子了，进而也能够比较容易破解RSA算法了。</p><h3 id="四、离散对数问题简析（不感兴趣可以略过，有时间补充）"><a href="#四、离散对数问题简析（不感兴趣可以略过，有时间补充）" class="headerlink" title="四、离散对数问题简析（不感兴趣可以略过，有时间补充）"></a>四、离散对数问题简析（不感兴趣可以略过，有时间补充）</h3><p>通过对shor算法原理的剖析，我们可以知道，对于任何具备转化为求周期函数的周期为目标的问题都可以用同样算法以指数加速来快速解决，比如离散对数(ElGamal), ECC之类的非对称加密算法都可以用同样的思想来解决。</p><p>离散对数多说两句，Shor在其原始论文中对于素域上的离散对数问题，给出了一个基于整数求阶量子计算算法求解算法,成功率为1/480。Shor指出在解决素域上的离散对数问题时，其实并没有利用到素域的特性，因而对有限域上的<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=8&amp;q=离散对数&amp;zhida_source=entity">离散对数</a>问题也同样成立。后来Eicher和Opku给出了一个在多 项式时间内以1/480的成功率攻击椭圆曲线离散对数问题的<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=2&amp;q=量子计算算法&amp;zhida_source=entity">量子计算算法</a></p><p>设一个阶为 p ,且生成器 为g 的群 G （ g\in G ）,如果 x=g^r(mod\; p)\in G ,那么对于部分 r\in \mathbb{Z}_p ,我们希望得到 r ,那么 r 就是离散对数 r=log_g(x) .</p><p>比如EIGamal加密，对于随机大大素数P,以及随机数x,满足y=g^x(mod\;P)\;1&lt;x&lt;P-1,g\in Z^*_P\</p><p>这里 (y,g,P) 为公钥， x 为私钥。我们将长度为 N，N&lt;log^P_2 的消息分组为</p><p>m_1m_2…m_t\</p><p>那么计算密文</p><p>\begin{cases} c_i=g^{r_i}(mod \;P)&amp; \c^{‘}_i=m_iy^{r_i}(mod \;P)&amp;\ \end{cases}1\leq i\leq t\</p><p>这里c1,c2为加密后的密文,那么解密过程如下：</p><p>m_i=\frac{c^{‘}_i}{c^x_i}(mod\;P)\;1\leq i\leq t\<br>简单推一下</p><p>\frac{c^{‘}_i}{c^x_i}=\frac{m_iy^{r_i}}{g^{xr_i}}=\frac{m_ig^{xr_i}}{g^{xr_i}}=m_i(m_i&lt;P)\</p><p>考虑abelian 群 \mathbb{Z}_p \times\mathbb{Z}_p (每一个因子对应于值的模加)。那么函数</p><p>f:\mathbb{Z}_p \times\mathbb{Z}_p\rightarrow G; f(a,b)=g^ax^{b}</p><p>这给我们呈现了一个abelian 隐含子群问题，同时可以看出映射 f 是一个<a href="https://zhida.zhihu.com/search?content_id=111891127&amp;content_type=Article&amp;match_order=1&amp;q=群同态&amp;zhida_source=entity">群同态</a>。kernel为 (r,1) 的倍数，所以如果我们能找到kernel，我们就能够找 r .</p><p>对于函数 f(a,b)=g^ax^b(mod\;p) ,设周期为 r_g 和 r_x ，那么</p><p>g^ax^b=g^{a+r_g}x^{b+r_x}=g^ax^b\cdot g^{r_g}x^{r_x}\ \Rightarrow g^{r_g}x^{r_x}=1(mod\;p)\ \Rightarrow g^{r_g}g^{rr_x}=g^{r_g+rr_x}=1(mod \;p)\</p><p>r_g+rr_x=0(mod\;q)\ r=-\frac{r_g}{r_x}\</p><p>因此，我们只要通过量子算法求得周期 r_g,r_x 就可以得到 r .使用量子算法处理离散子群问题，和我们前面讲解的方法非常类似，后续有时间再分析吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElGamal是个啥子玩意</title>
      <link href="/2024/09/28/ElGamal%E6%98%AF%E4%B8%AA%E5%95%A5%E5%AD%90%E7%8E%A9%E6%84%8F/"/>
      <url>/2024/09/28/ElGamal%E6%98%AF%E4%B8%AA%E5%95%A5%E5%AD%90%E7%8E%A9%E6%84%8F/</url>
      
        <content type="html"><![CDATA[<p>很早之前就听说ElGamal加密算法是一种公钥密码，但是具体实现和用途不甚了解，今天阅读了 <code>A PUBLIC KEY CRYPTOSYSTEM AND A SIGNATURE SCHEME BASED ON DISCRETE LOGARITHMS</code> 一文，故去了解了一下。特开此文，记录一下</p><span id="more"></span><p>省流：ElGamal是DH密钥交换的抵抗中间人攻击版本</p><hr><p><a href="https://zh.wikipedia.org/wiki/ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">ElGamal加密算法</a>是一个基于<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">DH密钥交换</a>的非对称算法，可以定义在任何循环群上，它的安全性取决于循环群上的离散对数难题</p><p>离散对数问题指的是：</p><ul><li>已知 $a,b,n$ ，计算$ a^b\mod n$ 是简单的。</li><li>已知 $a,(a^b\mod n),n$ ，计算 $b$ 是困难的。</li></ul><p>Diffie-Hellman 密钥交换过程：</p><ol><li>Alice 和 Bob选定一个素数 $p$ ，以及它的一个原根 $g$ </li><li>Alice 选择一个密钥 $a$ ，计算 $A=g^a\mod p$ ，发给 Bob </li><li>Bob 选择一个密钥 bb ，计算 $B=g^b\mod p$ ，发给 Alice </li><li>Alice 计算 $s=B^a\mod p$ ，Bob 计算 $s=A^b\mod p$<br>这样，Alice 和 Bob 就共享了一个密钥 $s=g^{ab}\mod p$ </li></ol><p>通俗理解：在调色板上将两种颜色混合容易，而将两种颜色分开是困难的。</p><p><img src="rU3aDS.png" style="zoom:33%;"></p><p>由于离散对数问题是一个数学困难问题，在选择了合适的 $p$ 和 $g$ 时，Diffie-Hellman 密钥交换协议被认为是 $\textcolor{red}{窃听安全}$ 的。攻击者 Eve 在已知 $p, g, (g^a\mod p), (g^b\mod p)$ 的情况下，难以计算出 $s=g^{ab}\mod p$</p><p> $\textcolor{red}{缺陷:无法抵抗中间人攻击}$ </p><p>DH 本身没有提供任何身份认证，因此容易遭受中间人攻击：</p><ul><li>中间人 Eve 假装自己是 Bob 与 Alice 通信 $s_1=g^{ac}\mod p$ </li><li>中间人 Eve 假装自己是 Alice 与 Bob 通信 $s_2=g^{bc}\mod p$ </li><li>Eve 将 Alice 发来的消息用 $s_1$ 解密，使用 $s_2$ 加密，发送给 Bob </li><li>Eve 将 Bob 发来的消息用 $s_2$ 解密，使用 $s_1$ 加密，发送给 Alice </li><li>Alice 和 Bob 对此一无所知，还无知地以为在与对方通信</li></ul><p>需要一种能验证通信双方身份的机制 (如签名) 来防止这类攻击</p><hr><p>ElGamal 加密算法：</p><p>本质上就是用 DH 获得一个密钥，然后用它加解密消息。</p><p>密钥生成：</p><ol><li>Alice 和 Bob 选定一个素数 $p$ ，以及它的一个原根 $g$</li><li>Alice 选择一个私钥 $X_A$ ，计算公钥 $Y_A=g^{X_A}\mod p$，公开</li><li>Bob 选择一个私钥 $X_B$ ，计算公钥 $Y_B=g^{X_B}\mod p$ ，公开</li></ol><p>假如 Bob 要给 Alice 发送一条消息 $m$ ，加密过程：</p><ol><li>Bob 计算密钥 $k=(Y_A)^{XB}\mod p=g^{X_AX_B}\mod p$ </li><li>Bob 发送 $c_1=Y_B, c_2=k\cdot m\mod p$</li></ol><p>Alice 收到密文，解密过程：</p><ol><li>Alice 计算密钥 $k=(c_1)^{X_A}\mod p=(Y_B)^{X_A}\mod p=g^{X_AY_A}\mod p$</li><li>Alice 解密消息 $m=(c_2\cdot k^{−1})\mod p$</li></ol><p>实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = None ; g = None</span><br><span class="line">pub = None#公钥也是公共可见的</span><br><span class="line">c = None#加密方加密后并传输给解密方的密文，这个也是可以被攻击者截获的</span><br><span class="line"></span><br><span class="line">#初始化，公共可见的大素数和生成元</span><br><span class="line">def init():</span><br><span class="line">    global p , g</span><br><span class="line">    p = getPrime(512)</span><br><span class="line">    g = 2</span><br><span class="line"></span><br><span class="line">#接收方(A)需要干的事情，即生成密钥（包括公钥和私钥</span><br><span class="line">def reciver_need_do():</span><br><span class="line">    global pub</span><br><span class="line">    a_pri = bytes_to_long(b&#x27;I am priviate key of A.&#x27;)</span><br><span class="line">    a_pub = pow( g , a_pri , p )</span><br><span class="line">    pub = a_pub</span><br><span class="line">    return a_pri</span><br><span class="line"></span><br><span class="line">#发送方(B)需要进行的加密操作，生成密文并</span><br><span class="line">def ElGamal_encode():</span><br><span class="line">    m = bytes_to_long(b&#x27;miao miao miao wo shi ming wen 233&#x27;)</span><br><span class="line">    k = getRandomInteger(10)</span><br><span class="line">    c1 = pow( g , k , p )</span><br><span class="line">    c2 = m * pow( pub , k , p ) % p</span><br><span class="line">    return c1 , c2</span><br><span class="line"></span><br><span class="line">#解密方需要进行的解密操作</span><br><span class="line">def ElGamal_decode( pri ):</span><br><span class="line">    global c</span><br><span class="line">    c1 , c2 = c</span><br><span class="line">    c1 = pow( c1 , p-2 , p )</span><br><span class="line">    m = c2 * pow( c1 , pri , p ) % p</span><br><span class="line">    return m</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    init()</span><br><span class="line">    a_pri = reciver_need_do()#返回接受者的私钥，a_pri只有接受者可以用</span><br><span class="line">    c = ElGamal_encode()#B将信息进行加密，然后传给A</span><br><span class="line">    m = ElGamal_decode( a_pri )#A使用自己的密钥，对信息进行解密</span><br><span class="line">    print( long_to_bytes(m) )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公钥密码学经典方案30篇 学习笔记（初次阅读）</title>
      <link href="/2024/09/27/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BB%8F%E5%85%B8%E6%96%B9%E6%A1%8830%E7%AF%87-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%88%9D%E6%AC%A1%E9%98%85%E8%AF%BB%EF%BC%89/"/>
      <url>/2024/09/27/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BB%8F%E5%85%B8%E6%96%B9%E6%A1%8830%E7%AF%87-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%88%9D%E6%AC%A1%E9%98%85%E8%AF%BB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文是 <a href="../../../../../2024/09/11/%E8%8D%94%E6%9E%9D%E6%A9%99%E5%91%B3%E6%8B%B1%E8%85%B0%E8%A7%85%E9%A9%AC%E7%B3%95%E5%AE%88/">荔枝橙味拱腰觅马糕守</a> 一文的后继，主要内容是对于 <code>方案构造学习</code> 一章中的 <code>尝试发现方案构造错误</code> 一节下的 30个<code>经典方案</code>的学习笔记</p><p>经过初次阅读尝试，发现笔者英文阅读能力较低，不足以在短暂时间内完成大量论文的阅读；故选择了在翻译器和人工智能的帮助下来进行阅读，以提升效率，并为第二次阅读打好基础</p><span id="more"></span><h2 id="1984-A-Public-Key-Cryptosystem-and-a-Signature-Scheme-Based-on-Discrete-Logarithms-34"><a href="#1984-A-Public-Key-Cryptosystem-and-a-Signature-Scheme-Based-on-Discrete-Logarithms-34" class="headerlink" title="1984, A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. [34]"></a>1984, A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. [34]</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>1976年，Diffie和Hellman首次提出了公钥密码的概念，并依赖离散对数问题和素数域上的计算复杂性来构造其密钥交换协议。ElGamal的工作正是基于这种思想，进一步提出了一个可以实现消息加密和解密的公钥加密系统，以及一个数字签名方案。</p><h3 id="公钥密码系统"><a href="#公钥密码系统" class="headerlink" title="公钥密码系统"></a>公钥密码系统</h3><p>公钥密码体制的基本思想是使用 <code>Diffie-Hellman</code> 密钥交换的基础</p><p>首先，通信双方选择一个大质数 $p$ 和生成元 $g$ ，这些参数都是公开的</p><p>然后双方分别选取自己的私钥（分别是 $x_A$ 和 $x_B$），并计算相应的公钥</p><script type="math/tex; mode=display">y_A=g^{x_A}\mod p\\y_B=g^{x_B}\mod p</script><p>然后就可以计算共享的公钥</p><p>$K=(y_A)^{x_B}\mod p=(y_B)^{x_A}\mod p$</p><p>这提供了一个安全的共享密钥，但计算此密钥的过程难度等同于计算离散对数。该系统的加密过程与Diffie-Hellman方案相关，但使用了随机数 $k$ 来加密每条消息，从而避免了密文重放攻击。解密过程中，接收方根据私钥恢复密钥并解密消息</p><h3 id="数字签名方案"><a href="#数字签名方案" class="headerlink" title="数字签名方案"></a>数字签名方案</h3><p>ElGamal提出的数字签名方案依赖于消息的签名和验证。具体来说，签名生成过程如下：</p><ol><li>发送方选择一个随机数 $k$ ，并保证 $k$ 与 $p-1$ 互质</li><li>计算 $r=g^k\mod p$</li><li>使用发送者的私钥 $x_A$ 来解决方程 $m=x_Ar+ks\mod(p-1)$，从而得到签名对 $(r,s)$</li></ol><p>验证方只需使用公钥 $y_A$ 和签名 $(r,s)$ 来验证以下等式：</p><p>$g^m\equiv y_A^rr^s\mod p$</p><p>签名方案的安全性依赖于离散对数问题的计算难度。ElGamal指出，攻击者试图伪造签名或推导私钥将面临离散对数问题的挑战。文章还讨论了在某些情况下可能的攻击方式，但大多无法打破系统的安全性</p><p>本质上就是用 DH 获得一个密钥，然后用它加解密消息。</p><p>详细代码见 <a href="../../../../../2024/09/28/ElGamal是个啥子玩意/">ElGamal是个啥子玩意</a>（和本篇论文内容不尽相同，但是殊途同归）</p><h3 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>文章详细探讨了针对签名方案的可能攻击方式，并指出这些攻击大多数情况下等价于计算离散对数问题。虽然尚未严格证明破解此签名方案与计算离散对数之间的等价性，但已知的攻击方式都未能有效破坏该系统。</p><ol><li>如果随机数 $k$ 被重复使用，攻击者可能通过解决线性方程组来推导出私钥。</li><li>攻击者可以尝试通过文档的多个签名来恢复私钥，但计算复杂性极高</li></ol><h3 id="系统特性及比较"><a href="#系统特性及比较" class="headerlink" title="系统特性及比较"></a>系统特性及比较</h3><p>与其他基于整数分解问题的公钥系统（如RSA）相比，ElGamal系统在某些方面有所不同。</p><ul><li>由于加密过程中的随机性，同一条消息的密文不会重复，有效地防止了已知明文攻击</li><li>虽然密文的大小是原消息的两倍，但由于解密只需要一次指数计算，故系统具有较好的计算效率</li></ul><p>ElGamal离散对数问题的算法复杂性与因子分解问题类似，都是次指数级的复杂度。因此系统的安全性与RSA类似，公共文件的大小相对较大，但这是可接受的</p><h2 id="1991-Efficient-Signature-Generation-by-Smart-Cards-35"><a href="#1991-Efficient-Signature-Generation-by-Smart-Cards-35" class="headerlink" title="1991, Efficient Signature Generation by Smart Cards. [35]"></a>1991, Efficient Signature Generation by Smart Cards. [35]</h2><h3 id="引言与背景"><a href="#引言与背景" class="headerlink" title="引言与背景"></a>引言与背景</h3><ul><li>公钥密码学的基本概念：公钥密码学利用一对密钥（公钥和私钥）来加密和解密信息。公钥可以公开，而私钥则保持秘密。</li><li>应用场景：公钥密码学广泛应用于安全通信、数字签名和身份验证等领域。</li></ul><h3 id="经典公钥密码方案"><a href="#经典公钥密码方案" class="headerlink" title="经典公钥密码方案"></a>经典公钥密码方案</h3><ul><li><p>RSA算法：</p><ul><li>构造方法：通过选择两个大素数 $ p $ 和 $ q $，计算 $ n = p \times q $。公钥是 $ (n, e) $，私钥是 $ (n, d) $，其中 $ d $ 是 $ e $ 的模 $ \phi(n) $ 的逆元。</li><li>安全性：基于大数分解问题的困难性。</li></ul></li><li><p>椭圆曲线密码学（ECC）：</p><ul><li>构造方法：在椭圆曲线上定义操作，利用点加法和标量乘法生成公钥和私钥。</li><li>安全性：基于椭圆曲线离散对数问题的困难性，ECC提供了更小的密钥长度而保持相同的安全性。</li></ul></li><li><p>ElGamal密码方案：</p><ul><li>构造方法：基于离散对数问题。生成一个大素数 $ p $ 和生成元 $ g $，然后选择一个私钥 $ x $ 计算公钥 $ y = g^x \mod p $。</li><li>安全性：依赖于离散对数问题的复杂性。</li></ul></li></ul><h3 id="安全证明"><a href="#安全证明" class="headerlink" title="安全证明"></a>安全证明</h3><ul><li><p>安全性定义：</p><ul><li>通常包括选择明文攻击（CPA）和选择密文攻击（CCA）的安全性。</li></ul></li><li><p>安全性证明方法：</p><ul><li>归约法：将密码方案的安全性归约到已知的难题上。例如，证明RSA的安全性可以归约到大数分解的难度。</li><li>随机预言机模型：假设存在一个理想的随机预言机，用于模拟加密和解密过程，从而分析方案的安全性。</li></ul></li></ul><h3 id="实例与应用"><a href="#实例与应用" class="headerlink" title="实例与应用"></a>实例与应用</h3><ul><li>应用实例：可以介绍一些实际应用，如SSL/TLS协议、PGP等，如何利用这些公钥方案确保数据传输的安全性。</li><li>最新研究进展：提到一些后量子密码学方案的发展，因为传统公钥方案可能面临量子计算威胁。</li></ul><h3 id="总结与未来方向"><a href="#总结与未来方向" class="headerlink" title="总结与未来方向"></a>总结与未来方向</h3><ul><li>总结：公钥密码方案在现代安全通信中至关重要，确保信息的机密性和完整性。</li><li>未来研究方向：研究如何提高现有公钥方案的效率，及其在新兴技术（如量子计算）下的安全性。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SM2椭圆曲线加密算法学习笔记</title>
      <link href="/2024/09/25/SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/25/SM2%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>此文章用于记录笔者对于SM2椭圆曲线加密算法的学习</p><span id="more"></span><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="ElGamal离散对数密码体制"><a href="#ElGamal离散对数密码体制" class="headerlink" title="ElGamal离散对数密码体制"></a>ElGamal离散对数密码体制</h3><ol><li><h4 id="公钥密钥生成"><a href="#公钥密钥生成" class="headerlink" title="公钥密钥生成"></a>公钥密钥生成</h4><ul><li><p>Alice首先构造一条椭圆曲线 $E$，在曲线上选择一点 $G$ 作为生成元，$n$ 为 $G$ 的阶（且 $n$ 必须为质数)。此时构成了一个循环群 $<G>$。</G></p></li><li><p>Alice选择一个私钥 $k (k &lt; n)$，生成公钥 $Q = kG$</p></li><li>Alice将公钥组 $(E,Q,G)$ 发送给Bob</li></ul></li><li><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><ul><li><p>Bob收到信息后，将明文编码为 $M$，$M$ 为曲线上一点，并选择一个随机数 $r$（$r &lt; n$，$n$ 为 $G$ 的阶）</p></li><li><p>Bob计算点 $Cipher_1$ 与 $Cipher_2$ 即两段密文，计算方法如下</p><p>$Cipher_1 = M + rQ\ Cipher_2 = rG$</p><ul><li>Bob把 $Cipher_1$ 和 $Cipher_2$ 发给Alice</li></ul></li></ul></li><li><h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><ul><li><p>Alice收到密文后，为了获得 $M$，只需要 $Cipher_1 - k · Cipher_2$，因为</p><p>$Cipher1 - k*Cipher2 = M + rQ - krG = M + rkG - krG = M$</p></li><li><p>将M解码即可</p></li></ul></li></ol><h2 id="SM2官方文档"><a href="#SM2官方文档" class="headerlink" title="SM2官方文档"></a>SM2官方文档</h2><p>标准文档链接：<a href="http://www.gmbz.org.cn/main/bzlb.html">国家商业密码标准</a></p><h4 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h4><ol><li>规定了椭圆曲线的系统参数以及验证方法</li><li>规定了椭圆曲线公钥的验证方法</li><li>附录中给出了椭圆曲线示例</li></ol><h4 id="第二部分-数字签名算法"><a href="#第二部分-数字签名算法" class="headerlink" title="第二部分 数字签名算法"></a>第二部分 数字签名算法</h4><h5 id="签名算法流程"><a href="#签名算法流程" class="headerlink" title="签名算法流程"></a>签名算法流程</h5><p>（一）置M’ = ZA || M M为待签名数据 ZA为A的可辨识标识、部分椭圆曲线系统参数和用户A的公钥的Hash值</p><p>（二）计算e = Hash(M’) 并将其转化为整数</p><p>（三）用随机数发生器生成随机数k (k&gt;1 k&lt; n-1) n 椭圆曲线的阶数 可以通过G计算出</p><p>（四）计算椭圆曲线点(x1,y1) = [k]G，并将其转化为整数 G为椭圆上一点 [k]G指椭圆乘法k倍G</p><p>（五）计算r= (e + x1)mod n，若r=0或r+k=n返回（三）</p><p>（六）计算s= ((1+da) ^(-1) <em> (k-r</em>da))mod n，若s=0则返回（三） da为用户A的私钥</p><p>（七）将r、s数据类型转化成字节串，消息M的签名为(r,s)</p><h5 id="验签算法流程"><a href="#验签算法流程" class="headerlink" title="验签算法流程"></a>验签算法流程</h5><p>（一）验证r&gt;1 r&lt;n-1</p><p>（二）验证s&gt;1 s&lt;n-1</p><p>（三）置M’ = ZA || M</p><p>（四）计算e = Hash(M’) 并将其转化为整数</p><p>（五）将r s数据类型转换为整数 计算 t= (r+s)mod n ，若t=0则验证不通过</p><p>（六）计算椭圆曲线点(x1,y1) = [s]G + [t]Pa Pa为A的公钥</p><p>（七） 将x1的数据类型转换成整数，计算R=(e+x1)mod n，验证R=r，成立则验证通过</p><h4 id="第三部分-密钥交换协议"><a href="#第三部分-密钥交换协议" class="headerlink" title="第三部分 密钥交换协议"></a>第三部分 密钥交换协议</h4><h5 id="密钥交换流程"><a href="#密钥交换流程" class="headerlink" title="密钥交换流程"></a>密钥交换流程</h5><h4 id="第四部分-公钥加密算法"><a href="#第四部分-公钥加密算法" class="headerlink" title="第四部分 公钥加密算法"></a>第四部分 公钥加密算法</h4><h5 id="加密算法流程"><a href="#加密算法流程" class="headerlink" title="加密算法流程"></a>加密算法流程</h5><p>（一）用随机数发生器产生随机数k (k&gt;1 k&lt;n-1)</p><p>（二）计算椭圆曲线点C1=[k]G=(x1,y1)，并将其转换为比特串（A的私钥生成公钥）</p><p>（三）计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出 h为n的余因子</p><p>（四）计算椭圆曲线点[k]Pb=(x2,y2)，并将其转换为比特串（A的私钥乘B的公钥）</p><p>（五）计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回（一） KDF为密钥派生函数</p><p>（六）计算C2=M⊕t</p><p>（七）计算C3=Hash(x2||M||y2)</p><p>（八）输出密文C=C1||C3||C2</p><h5 id="解密算法流程"><a href="#解密算法流程" class="headerlink" title="解密算法流程"></a>解密算法流程</h5><p>（一）从C中取出比特串C1，将其转换为椭圆曲线上的点，验证C1是否满足椭圆曲线方程</p><p>（二）计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出</p><p>（三）计算[db]C1=(x2,y2)，并将其转换为比特串 db B的公钥</p><p>（四）计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回（一） KDF为密钥派生函数</p><p>（五）从C中取出比特串C2,计算M=C2⊕t</p><p>（六）计算u=Hash(x2||M||y2)，从C中取出比特串C3，若u不等于C3，则报错并退出</p><p>（七）输出明文M</p><h4 id="第五部分-参数定义"><a href="#第五部分-参数定义" class="headerlink" title="第五部分 参数定义"></a>第五部分 参数定义</h4><p>给出了SM2使用素数域256位椭圆曲线参数</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuoj古典密码学wp</title>
      <link href="/2024/09/24/buuoj%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6wp/"/>
      <url>/2024/09/24/buuoj%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6wp/</url>
      
        <content type="html"><![CDATA[<p>此博客用于整理，之前做过的古典密码学题目</p><p>之前存储于本地，今天移植到博客中，后续不再在此页面更新</p><p>分级十分的混乱，之后有缘再改吧（逃</p><span id="more"></span><h1>古典密码学</h1><p>Linux python 很重要</p><p><a href="ctf.bugku.com/challenges">Bugku</a></p><p><a href="https://www.shiyanbar.com">实验吧（现在没了）</a></p><p><a href="cgctf.nuptsast.com">南邮网络攻防训练平台（现在也没了）</a></p><h3>密码学的三个阶段</h3><ol><li><p>古典密码（1949以前），复杂度不高，安全性地，具有艺术性</p></li><li><p>近代密码（1949-1975），计算机诞生，加密算法在复杂程度和安全性上得到了提升</p></li><li>现代密码（1976至今），美国密码学专家<code>Diffie</code>和<code>Hellman</code>在1976年提出公开密钥密码体制概念（非对称制加密），密码学有了全新的方向</li></ol><p>古典密码学：</p><ol><li>涉及数学问题较少</li><li>很容易被破解，但是设计原理和分析方法对理解设计分析现代密码有帮助</li><li>主要分为：替代和置换</li><li>强化python脚本编写能力，尽力讲大多数加密方法都能写出破解脚本</li><li>MD5暴力破解以及算法逆向</li></ol><h3>键盘加密</h3><h5>键盘布局加密</h5><p>通常给出一堆无意义的字符，但是在键盘上比划一下就能拼出相应的字符</p><p>可以划归脑洞题的范围</p><h5>键盘坐标加密</h5><p>bye 对应的密文是 35 16 13（或者相反）</p><p>字母行总共三行，数字行总共10行（在一些脑洞题中不一定）</p><p>如果小写不对，可能是大写的</p><h3>BF和Ook密码</h3><p>不需要探究原理，只需要能够识别出它</p><h5 id="BrainFuck密码"><a href="#BrainFuck密码" class="headerlink" title="BrainFuck密码"></a>BrainFuck密码</h5><p>用&lt;&gt;+-.,[]八种符号来替换c语言的各种语法和命令</p><h5 id="Ook密码"><a href="#Ook密码" class="headerlink" title="Ook密码"></a>Ook密码</h5><p>三种符号组成 Ook. Ook? Ook!（or short Ook,由.?!组成）</p><h5 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h5><p>使用PHP工具[Ook-masker][<a href="http://106.13.121.19/ook/]进行解密">http://106.13.121.19/ook/]进行解密</a></p><h3 id="替换密码"><a href="#替换密码" class="headerlink" title="替换密码"></a>替换密码</h3><p>替换表保存明文和密文之间的关系</p><p>隐藏明文但是不打乱顺序</p><h5 id="摩斯密码"><a href="#摩斯密码" class="headerlink" title="摩斯密码"></a>摩斯密码</h5><p>认出（有时表现为包括但不限于01序列的密码，可以使用记事本进行转化）</p><p>可以用Bugku的[在线工具][tool.bugku.com/mosi/]进行解密</p><p>或者本地工具<code>CTFCrackTools</code></p><h5 id="摩斯密码解密代码"><a href="#摩斯密码解密代码" class="headerlink" title="摩斯密码解密代码"></a>摩斯密码解密代码</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="built_in">input</span>().strip().split</span><br><span class="line"><span class="comment">#用空格分开</span></span><br><span class="line">key = &#123;<span class="string">&#x27;01&#x27;</span>: <span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;1000&#x27;</span>: <span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;1010&#x27;</span>: <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;100&#x27;</span>:<span class="string">&#x27;D&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;0010&#x27;</span>:<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;110&#x27;</span>: <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;0000&#x27;</span>: <span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;00&#x27;</span>: <span class="string">&#x27;I&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;0111&#x27;</span>:<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;101&#x27;</span>: <span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;0100&#x27;</span>: <span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;11&#x27;</span>: <span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;10&#x27;</span>: <span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;111&#x27;</span>: <span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;0110&#x27;</span>: <span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;1101&#x27;</span>: <span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;010&#x27;</span>: <span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;000&#x27;</span>: <span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;001&#x27;</span>: <span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;0001&#x27;</span>: <span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;011&#x27;</span>: <span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;1001&#x27;</span>: <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;1011&#x27;</span>: <span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;1100&#x27;</span>: <span class="string">&#x27;Z&#x27;</span>,<span class="string">&#x27;01111&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;00111&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;00011&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;00001&#x27;</span>: <span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;00000&#x27;</span>: <span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;10000&#x27;</span>: <span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;11000&#x27;</span>: <span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;11100&#x27;</span>: <span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;11110&#x27;</span>: <span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;11111&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;001100&#x27;</span>:<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;10010&#x27;</span>:<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;101101&#x27;</span>:<span class="string">&#x27;()&#x27;</span>,<span class="string">&#x27;100001&#x27;</span>:<span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;010101&#x27;</span>:<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;110011&#x27;</span>:<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;011010&#x27;</span>:<span class="string">&#x27;@&#x27;</span>,<span class="string">&#x27;111000&#x27;</span>:<span class="string">&#x27;:&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;101010&#x27;</span>:<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;10001&#x27;</span>:<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;011110&#x27;</span>:<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;101011&#x27;</span>:<span class="string">&#x27;!&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;001101&#x27;</span>:<span class="string">&#x27;!&#x27;</span>,<span class="string">&#x27;001101&#x27;</span>:<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;010010&#x27;</span>:<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;10110&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;1111011&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;111101&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> txt:</span><br><span class="line">    <span class="built_in">print</span>(key.get(i),end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#txt = </span></span><br><span class="line"><span class="comment">#table = &#x27;&#x27;.maketrans(&#x27;.-&#x27;,&#x27;01&#x27;)</span></span><br><span class="line"><span class="comment">#txt.translate(table)</span></span><br></pre></td></tr></table></figure><h5 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h5><p>只有25种可能的密钥（大小写不变），当年凯撒用的密钥是3</p><p>解码：<code>CTFCrackTools</code>或者自行编写脚本</p><p>加密：(x+k)%26 解密：(y-k)%26 （0~25来表示a~z）</p><h5 id="凯撒密码解密代码"><a href="#凯撒密码解密代码" class="headerlink" title="凯撒密码解密代码"></a>凯撒密码解密代码</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">    plain = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> txt:</span><br><span class="line">        <span class="keyword">if</span> j.islower():</span><br><span class="line">            plain = plain + <span class="built_in">chr</span>(<span class="number">97</span>+(<span class="built_in">ord</span>(j)-i-<span class="number">97</span>)%<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">elif</span> j.isupper():</span><br><span class="line">            plain = plain + <span class="built_in">chr</span>(<span class="number">65</span>+(<span class="built_in">ord</span>(j)-i-<span class="number">65</span>)%<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plain = plain + j</span><br><span class="line">    <span class="built_in">print</span>(plain)</span><br></pre></td></tr></table></figure><h5 id="plus版本"><a href="#plus版本" class="headerlink" title="plus版本"></a>plus版本</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="built_in">input</span>(<span class="string">&#x27;请输入密文： &#x27;</span>).strip()</span><br><span class="line">n = <span class="built_in">input</span>(<span class="string">&#x27;是否需要推荐明文(Y/N)&#x27;</span>).strip()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">    plain = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> txt:</span><br><span class="line">        <span class="keyword">if</span> j.islower():</span><br><span class="line">            plain = plain + <span class="built_in">chr</span>(<span class="number">97</span>+(<span class="built_in">ord</span>(j)-i-<span class="number">97</span>)%<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">elif</span> j.isupper():</span><br><span class="line">            plain = plain + <span class="built_in">chr</span>(<span class="number">65</span>+(<span class="built_in">ord</span>(j)-i-<span class="number">65</span>)%<span class="number">26</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plain = plain + j    </span><br><span class="line">    <span class="keyword">if</span> n.lower() == <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        key = (<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;ctf&#x27;</span>,<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;the&#x27;</span>,<span class="string">&#x27;is&#x27;</span>,<span class="string">&#x27;no&#x27;</span>,<span class="string">&#x27;for&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">in</span> plain:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;recomanding: &#x27;</span>+plain)</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> n.lower() == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(plain)</span><br><span class="line">                paint()</span><br></pre></td></tr></table></figure><h5 id="凯撒密码的另外一种思路"><a href="#凯撒密码的另外一种思路" class="headerlink" title="凯撒密码的另外一种思路"></a>凯撒密码的另外一种思路</h5><p>充分利用替换的方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="built_in">input</span>().strip()</span><br><span class="line">lower = <span class="string">&#x27;abcdefghigklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">upper = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span> , <span class="number">26</span> ):</span><br><span class="line">    xiao = lower[i:]+lower[:i]</span><br><span class="line">    da = upper[i:]+upper[:i]</span><br><span class="line">    plain = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    table = <span class="string">&#x27;&#x27;</span>.maketrans(xiao+da,lower+upper)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> txt:</span><br><span class="line">        plain = plain + j.translate(table)</span><br><span class="line">    <span class="built_in">print</span>(plain)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h5 id="一个很腻害的python库"><a href="#一个很腻害的python库" class="headerlink" title="一个很腻害的python库"></a>一个很腻害的python库</h5><p><code>pycipher</code> 包含大多数密码学工具</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pycipher.Caesar(<span class="number">3</span>).decipher(<span class="string">&#x27;LORYHSBWKRQ&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="ROT13密码"><a href="#ROT13密码" class="headerlink" title="ROT13密码"></a>ROT13密码</h5><p>凯撒密码的一种变体，移位数固定为13，即把明文中的每一个字母在字母表中向后移动13位，数字和非字母字符保持不变</p><p>实现的是26个字母前半段和后半段相互交换（又叫回旋13，因为明文和密文可以相互转化）</p><h5 id="ROT13加密解密"><a href="#ROT13加密解密" class="headerlink" title="ROT13加密解密"></a>ROT13加密解密</h5><p>PHP中的str_rot13()函数可以实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">str_rot13</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_rot13</span>(<span class="string">&#x27;O&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="comment"># php -r &quot;echo str_rot13(&#x27;heetian&#x27;);&quot;</span></span><br></pre></td></tr></table></figure><h5 id="凯撒密码的改进"><a href="#凯撒密码的改进" class="headerlink" title="凯撒密码的改进"></a>凯撒密码的改进</h5><p>移位密码是在凯撒密码的基础上发展而来的，常用ASCLL码表进行移位</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移位ASCLL凯撒</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> txt:</span><br><span class="line">    flag = flag + <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)+key)</span><br><span class="line">    key = key + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>末尾两个重复字符：可能是先base64后的凯撒加密，重复字符是<code>==</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#base64解码</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">base64.b64decode(flag.encode())</span><br></pre></td></tr></table></figure><h5 id="凯撒密码的再次改进"><a href="#凯撒密码的再次改进" class="headerlink" title="凯撒密码的再次改进"></a>凯撒密码的再次改进</h5><p>凯撒密码密钥只有25种，后来出现了单字母替换密码，即一一映射</p><p>密码空间的大小是 26！，大约4e26种密钥</p><h5 id="词频分析法"><a href="#词频分析法" class="headerlink" title="词频分析法"></a>词频分析法</h5><p>按照频率知道每个字母平均频率</p><p>对于单表替换密码的破解，标志着密码分析学的诞生</p><p>CTF题中，对于一串特别长的密文，可能通过词频分析的方法进行解题</p><h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><p><a href="https://quipqiup.com">在线解码</a></p><p>本地工具：WinDecrypto（专门进行词频分析的软件）</p><h5 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h5><p>密文只有a和b，每个明文由五个a和b组成长度为5的字符串</p><p><a href="https://tool.bugku.com/peigen/">bugku在线解码</a></p><p>常规密码表只有24个：i,j 、 u,v 对应的加密后的字符串相同</p><p>培根密码最大的特点是隐蔽性比较强，例如大小写，加粗字体</p><p><a href="http://rumkin.com/tools/cipher/baconian.php">功能强大的培根密码解密网站（不知道为什么用不了）</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提取大小写</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">if</span> i.isupper():</span><br><span class="line">        flag = flag +<span class="string">&#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> i.islower():</span><br><span class="line">        flag = flag +<span class="string">&#x27;B&#x27;</span>   </span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#互换AB</span></span><br><span class="line">table = <span class="string">&#x27;&#x27;</span>.maketrans(<span class="string">&#x27;AB&#x27;</span>,<span class="string">&#x27;BA&#x27;</span>)</span><br><span class="line">flag.translate(table)</span><br></pre></td></tr></table></figure><h5 id="解码代码"><a href="#解码代码" class="headerlink" title="解码代码"></a>解码代码</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一类培根密码</span></span><br><span class="line">txt = <span class="built_in">input</span>().lower()</span><br><span class="line">a = [<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaab&quot;</span>,<span class="string">&quot;aaaba&quot;</span>,<span class="string">&quot;aaabb&quot;</span>,<span class="string">&quot;aabaa&quot;</span>,<span class="string">&quot;aabab&quot;</span>,<span class="string">&quot;aaabba&quot;</span>,<span class="string">&quot;aaabbb&quot;</span>,<span class="string">&quot;abaaa&quot;</span>,<span class="string">&quot;abaab&quot;</span>,<span class="string">&quot;ababa&quot;</span>,<span class="string">&quot;ababb&quot;</span>,<span class="string">&quot;abbaa&quot;</span>,<span class="string">&quot;abbab&quot;</span>,<span class="string">&quot;abbba&quot;</span>,<span class="string">&quot;abbbbb&quot;</span>,<span class="string">&quot;baaaa&quot;</span>,<span class="string">&quot;baaab&quot;</span>,<span class="string">&quot;baaba&quot;</span>,<span class="string">&quot;baabb&quot;</span>,<span class="string">&quot;babaa&quot;</span>,<span class="string">&quot;babab&quot;</span>,<span class="string">&quot;babba&quot;</span>,<span class="string">&quot;babbb&quot;</span>,<span class="string">&quot;bbaaa&quot;</span>,<span class="string">&quot;bbaab&quot;</span>]</span><br><span class="line">b = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line"><span class="comment">#[chr(i) for i in range(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1)]</span></span><br><span class="line">key = <span class="built_in">dict</span>(<span class="built_in">zip</span>(a,b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(txt),<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(key.get(txt[i:i+<span class="number">5</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第二类培根密码</span></span><br><span class="line">txt = <span class="built_in">input</span>().lower()</span><br><span class="line">a = [<span class="string">&quot;aaaaa&quot;</span>,<span class="string">&quot;aaaab&quot;</span>,<span class="string">&quot;aaaba&quot;</span>,<span class="string">&quot;aaabb&quot;</span>,<span class="string">&quot;aabaa&quot;</span>,<span class="string">&quot;aabab&quot;</span>,<span class="string">&quot;aaabba&quot;</span>,<span class="string">&quot;aaabbb&quot;</span>,<span class="string">&quot;abaaa&quot;</span>,<span class="string">&quot;abaab&quot;</span>,<span class="string">&quot;ababa&quot;</span>,<span class="string">&quot;ababb&quot;</span>,<span class="string">&quot;abbaa&quot;</span>,<span class="string">&quot;abbab&quot;</span>,<span class="string">&quot;abbba&quot;</span>,<span class="string">&quot;abbbbb&quot;</span>,<span class="string">&quot;baaaa&quot;</span>,<span class="string">&quot;baaab&quot;</span>,<span class="string">&quot;baaba&quot;</span>,<span class="string">&quot;baabb&quot;</span>,<span class="string">&quot;babaa&quot;</span>,<span class="string">&quot;babab&quot;</span>,<span class="string">&quot;babba&quot;</span>,<span class="string">&quot;babbb&quot;</span>]</span><br><span class="line">b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;(ij)&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;(uv)&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">dirt = &#123;i:j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(cipher,plain)&#125;</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(txt),<span class="number">5</span>):</span><br><span class="line">    flag = flag + dirt.get(a[i:i+<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h5 id="仿射加密Affine"><a href="#仿射加密Affine" class="headerlink" title="仿射加密Affine"></a>仿射加密Affine</h5><ol><li><p>将26个英文字母用0~25表示</p></li><li><p>需要两个密钥，a和b，取值范围是[0,25]</p><p>要求a和26互质，即a的因数不包括2或13</p></li><li><p>x为明文，y为密文</p><p>加密公式 = （ax+b) mod 26</p></li></ol><p>解码：使用乘法逆元</p><p>假设用m表示a的乘法逆元，那么(a*m)mod 26 = 1</p><p>可以写一个简单的枚举代码来求m</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#枚举乘法逆元</span></span><br><span class="line">m = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> a*m%<span class="number">26</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    m = m + <span class="number">1</span></span><br><span class="line"><span class="comment">#逆向计算</span></span><br><span class="line">mi = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mi:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>+(<span class="built_in">ord</span>(i)-<span class="number">97</span>-b)*a%<span class="number">26</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#暴力破解</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mi:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span>(a*j+<span class="number">7</span>)%<span class="number">26</span> == <span class="built_in">ord</span>(i)-<span class="number">97</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>+j),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用pycipher库中的Affine类可以直接对仿射加密进行加解密</span></span><br><span class="line"><span class="comment">#加密</span></span><br><span class="line">pycipher.Affine(a,b).decipher(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line"><span class="comment">#解密</span></span><br><span class="line">pycipher.Affine(a,b).encipher(<span class="string">&#x27;queue&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h5><p>更多的是对应加密</p><p>可以使用CTFCrackTools进行解密</p><h4 id="单表替换的简单总结"><a href="#单表替换的简单总结" class="headerlink" title="单表替换的简单总结"></a>单表替换的简单总结</h4><ol><li>明文和密文一一对应</li><li>空间足够小则采用暴力破解；密文足够长则使用词频分析法</li><li>密钥空间足够大，密文长度足够短的情况下，破解较为困难</li></ol><h3 id="多表替换"><a href="#多表替换" class="headerlink" title="多表替换"></a>多表替换</h3><p>利用密钥的每一位分别加密每一位明文</p><h5 id="维基利亚密码"><a href="#维基利亚密码" class="headerlink" title="维基利亚密码"></a>维基利亚密码</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="built_in">input</span>()</span><br><span class="line">password = <span class="built_in">input</span>().lower()</span><br><span class="line">key = [<span class="built_in">ord</span>(i)-<span class="number">97</span> <span class="keyword">for</span> i <span class="keyword">in</span> password]*<span class="number">5</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(txt)):</span><br><span class="line">    <span class="keyword">if</span> txt[i].islower():</span><br><span class="line">        flag = flag + <span class="built_in">chr</span>(<span class="number">97</span>+<span class="built_in">ord</span>(txt[i])-<span class="number">97</span>-key[i]%<span class="number">26</span>)</span><br><span class="line">    <span class="keyword">elif</span> txt[i].isupper():</span><br><span class="line">        flag = flag + <span class="built_in">chr</span>(<span class="number">65</span>+<span class="built_in">ord</span>(txt[i])-<span class="number">65</span>-key[i]%<span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更优雅的写法</span></span><br><span class="line">txt = <span class="built_in">input</span>()</span><br><span class="line">password = <span class="built_in">input</span>().lower()</span><br><span class="line">key = [<span class="built_in">ord</span>(i)-<span class="number">97</span> <span class="keyword">for</span> i <span class="keyword">in</span> password]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(txt)):</span><br><span class="line">    <span class="keyword">if</span> txt[i].islower():</span><br><span class="line">        flag = flag + <span class="built_in">chr</span>(<span class="number">97</span>+<span class="built_in">ord</span>((txt[i])-<span class="number">97</span>-key[i%<span class="built_in">len</span>(key)])%<span class="number">26</span>)</span><br><span class="line">    <span class="keyword">elif</span> txt[i].isupper():</span><br><span class="line">        flag = flag + <span class="built_in">chr</span>(<span class="number">65</span>+<span class="built_in">ord</span>((txt[i])-<span class="number">65</span>-key[i%<span class="built_in">len</span>(key)])%<span class="number">26</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>利用pycipher库进行解码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pycipher.Vigenere(<span class="string">&#x27;密钥&#x27;</span>).encipher(<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">pycipher.Vigenere(<span class="string">&#x27;密钥&#x27;</span>).dncipher(<span class="string">&#x27;明码&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="费纳姆密码（二战中曾使用过）"><a href="#费纳姆密码（二战中曾使用过）" class="headerlink" title="费纳姆密码（二战中曾使用过）"></a>费纳姆密码（二战中曾使用过）</h5><p>明文^密钥=密文</p><p>密文^密钥=明文</p><p>解密时将密文七位一组，然后与密钥异或，再将结果转化为ASCLL即可（也可以直接一串二进制数）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把一串二进制数划分为七位一组</span></span><br><span class="line">txt = <span class="built_in">input</span>()</span><br><span class="line">mi = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(txt),<span class="number">7</span>):</span><br><span class="line">    mi.append(txt[i:i+<span class="number">7</span>])</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m,n <span class="keyword">in</span> <span class="built_in">zip</span>(mi,key):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">int</span>(m,<span class="number">2</span>)^<span class="built_in">ord</span>(n)),end=<span class="string">&#x27;&#x27;</span>) </span><br></pre></td></tr></table></figure><h5 id="杰斐逊转轮加密-tagged"><a href="#杰斐逊转轮加密-tagged" class="headerlink" title="杰斐逊转轮加密(tagged)"></a>杰斐逊转轮加密(tagged)</h5><p>36片同样大小的木质转轮，套在一根铁杆上，每个轮子有乱序26英文字母</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m,n <span class="keyword">in</span> <span class="built_in">zip</span>(mi,key):</span><br><span class="line">    flag.append(txt[m-<span class="number">1</span>][txt[m-<span class="number">1</span>].index(n):] + txt[m-<span class="number">1</span>][:txt[m-<span class="number">1</span>].index(n)])</span><br></pre></td></tr></table></figure><h3 id="置换密码"><a href="#置换密码" class="headerlink" title="置换密码"></a>置换密码</h3><p>明文不变，打乱排列顺序</p><h5 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h5><p>总共n个字符，分为m（n的因数）组，依次取出各组的第一、二······个字母</p><p>加密解密方法是可逆的，要求是两个因数之积为n</p><p>在线解密：bugku在线工具</p><p>本地解密：CTFCrackTools</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#寻找因数</span></span><br><span class="line">txt = <span class="built_in">input</span>()</span><br><span class="line">key = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rnage(<span class="number">2</span>,<span class="built_in">len</span>(txt)):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(txt) % i == <span class="number">0</span>:</span><br><span class="line">        key.append(i)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解密代码</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,key):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(m,<span class="built_in">len</span>(txt),key):</span><br><span class="line">        <span class="built_in">print</span>(txt[n],end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zhalan</span>(<span class="params">txt,key</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(key):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(m,<span class="built_in">len</span>(txt),key):</span><br><span class="line">            s = s + txt[n]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    txt = <span class="built_in">input</span>().strip()</span><br><span class="line">    key = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(txt)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(txt)%i == <span class="number">0</span>:</span><br><span class="line">            key.append(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> key:</span><br><span class="line">        flag = zhalan(txt,j)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;j&#125;</span>栏：<span class="subst">&#123;flag&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pychipher.Railfence(m).encipher(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">pychipher.Railfence(m).dncipher(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#翻转字符串</span></span><br><span class="line">s = txt[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>有可能出现题型，需要填充一定量的无关符号</p><h5 id="列置换"><a href="#列置换" class="headerlink" title="列置换"></a>列置换</h5><p>将明文填写在一个矩阵中，然后以预订的顺序按列读取得到密文</p><p>列置换的密钥通常会以一个单词的形式给出</p><p>如： nice      相当于4312</p><p>按照每个字符在字母表中的前后排列来排列</p><p>矩阵列数由密钥决定，列数=密钥长度</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#常规加密方法（不具备普遍性）</span></span><br><span class="line">pycipher.ColTrans(<span class="string">&#x27;key&#x27;</span>).encipher(<span class="string">&#x27;&#x27;</span>).lower()</span><br><span class="line">pycipher.ColTrans(<span class="string">&#x27;key&#x27;</span>).decipher(<span class="string">&#x27;&#x27;</span>).lower()</span><br></pre></td></tr></table></figure><h5 id="Polybius（波利比奥斯）密码"><a href="#Polybius（波利比奥斯）密码" class="headerlink" title="Polybius（波利比奥斯）密码"></a>Polybius（波利比奥斯）密码</h5><p>又称棋盘密码</p><p>把棋盘上的字符，对应到密码表上的坐标</p><p>很简单也很灵活，用法可能比较混乱</p><h5 id="ADFGX密码"><a href="#ADFGX密码" class="headerlink" title="ADFGX密码"></a>ADFGX密码</h5><p>波利比奥斯密码的升级版</p><p>用ADFGX五个字母代替了12345五个数字</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pycipher.ADFGX(<span class="string">&#x27;密码表&#x27;</span>,<span class="string">&#x27;密钥&#x27;</span>).encipher(<span class="string">&#x27;明文&#x27;</span>)</span><br><span class="line">pycipher.ADFGX(<span class="string">&#x27;密码表&#x27;</span>,<span class="string">&#x27;密钥&#x27;</span>).decipher(<span class="string">&#x27;密文&#x27;</span>)</span><br><span class="line"><span class="comment">#python默认自存密码表</span></span><br><span class="line"><span class="comment">#help(pycipher.ADFGX)</span></span><br><span class="line">pycipher.ADFGX(<span class="string">&#x27;密码表&#x27;</span>,<span class="string">&#x27; &#x27;</span>).decipher(<span class="string">&#x27;密文&#x27;</span>)<span class="comment">#不做列置换</span></span><br></pre></td></tr></table></figure><p>ADFGVX密码：六个字母表示6*6=36个字符</p><hr><h1 id="BUU密码学刷题WP"><a href="#BUU密码学刷题WP" class="headerlink" title="BUU密码学刷题WP"></a>BUU密码学刷题WP</h1><h2 id="一眼就解密"><a href="#一眼就解密" class="headerlink" title="一眼就解密"></a>一眼就解密</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64.b64decode(&quot;ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=&quot;)</span><br></pre></td></tr></table></figure><p>flag{THE_FLAG_OF_THIS_STRING}</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p><a href="https://www.somd5.com/">https://www.somd5.com/</a></p><p>flag{admin1}</p><h2 id="Url编码"><a href="#Url编码" class="headerlink" title="Url编码"></a>Url编码</h2><p><a href="https://tool.ip138.com/urlencode/">https://tool.ip138.com/urlencode/</a></p><p>flag{and 1=1}</p><h2 id="看我回旋踢"><a href="#看我回旋踢" class="headerlink" title="看我回旋踢"></a>看我回旋踢</h2><p><img src="image-20231030092802733.png" alt></p><p>flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1}</p><h2 id="摩丝"><a href="#摩丝" class="headerlink" title="摩丝"></a>摩丝</h2><p><img src="image-20231030101515467.png" alt></p><p>flag{ILOVEYOU}</p><h2 id="password"><a href="#password" class="headerlink" title="password"></a>password</h2><p>根据字符数猜测：密码=姓名+出生年月日</p><p>flag{zs19900315}</p><h2 id="变异凯撒"><a href="#变异凯撒" class="headerlink" title="变异凯撒"></a>变异凯撒</h2><p>移位凯撒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">txt = &quot;afZ_r9VYfScOeO_UL^RWUc&quot;.strip()</span><br><span class="line">plain = &#x27;&#x27;</span><br><span class="line">cnt = 4</span><br><span class="line">for i in txt:</span><br><span class="line">    cnt = cnt + 1</span><br><span class="line">    plain = plain + chr(ord(i)+cnt)</span><br><span class="line">print(plain)</span><br></pre></td></tr></table></figure><p>flag{Caesar_variation}</p><h2 id="Quoted-printable"><a href="#Quoted-printable" class="headerlink" title="Quoted-printable"></a>Quoted-printable</h2><p>Quoted-printable可译为“可打印字符引用编码”，编码常用在电子邮件中</p><p>考虑用python的quopri库进行解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quopri.decodestring(&#x27;=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6&#x27;)</span><br></pre></td></tr></table></figure><p>得到一串UTF-8密文</p><p><code>&#39;\xe9\x82\xa3\xe4\xbd\xa0\xe4\xb9\x9f\xe5\xbe\x88\xe6\xa3\x92\xe5\x93\xa6&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#x27;\xe9\x82\xa3\xe4\xbd\xa0\xe4\xb9\x9f\xe5\xbe\x88\xe6\xa3\x92\xe5\x93\xa6&#x27;</span><br><span class="line">ss = s.encode(&#x27;raw_unicode_escape&#x27;)#此str转化为bytes</span><br><span class="line">print(ss)</span><br><span class="line">sss = ss.decode()</span><br><span class="line">print(sss)</span><br></pre></td></tr></table></figure><p>flag{那你也很棒哦} </p><h2 id="Rabbit"><a href="#Rabbit" class="headerlink" title="Rabbit"></a>Rabbit</h2><p>Rabbit加密</p><p>AES、DES、RC4、Rabbit、Triple DES（3DES）这些算法都可以引入密钥</p><p>密文特征与Base64类似，明显区别是秘文里+比较多，并且经常出现/</p><p><a href="http://www.jsons.cn/rabbitencrypt/">http://www.jsons.cn/rabbitencrypt/</a></p><p>flag{Cute_Rabbit}</p><h2 id="篱笆墙的影子"><a href="#篱笆墙的影子" class="headerlink" title="篱笆墙的影子"></a>篱笆墙的影子</h2><p>栅栏密码，CTFCrackTool即可解码（python内置函数不好用）</p><p><img src="image-20231030112247454.png" alt></p><p>flag{wethinkwehavetheflag}</p><h2 id="丢失的MD5"><a href="#丢失的MD5" class="headerlink" title="丢失的MD5"></a>丢失的MD5</h2><p>把报错的代码改对</p><ol><li>print语法错误</li><li><code>TypeError: can&#39;t concat str to bytes</code>，字符类型错误；哈希之前必须对Unicode对象进行编码，应当在”update”函数之中所有的所有参数进行可选参数编码，默认编码为’utf-8’</li></ol><p>flag{e9032994dabac08080091151380478a2}</p><h2 id="Alice与Bob"><a href="#Alice与Bob" class="headerlink" title="Alice与Bob"></a>Alice与Bob</h2><p>使用在线工具分解质数</p><p><a href="https://zh.numberempire.com/numberfactorizer.php">https://zh.numberempire.com/numberfactorizer.php</a></p><p>进行MD5加密</p><p><a href="https://md5jiami.bmcx.com/">https://md5jiami.bmcx.com/</a></p><p>flag{d450209323a847c8d01c6be47c81811a}</p><h2 id="大帝的密码武器"><a href="#大帝的密码武器" class="headerlink" title="大帝的密码武器"></a>大帝的密码武器</h2><p><img src="image-20231030195452991.png" alt></p><p>偏移量是13</p><p><img src="image-20231030195913950.png" alt></p><p>记得改对大小写</p><p>flag{PbzrPuvan}</p><h2 id="Windows系统密码"><a href="#Windows系统密码" class="headerlink" title="Windows系统密码"></a>Windows系统密码</h2><p>使用在线工具，解码第二行第三组数据（为什么这个数据？因为第二行在admin下面，而前面那个数字解不出来）</p><p><img src="image-20231030200253314.png" alt></p><p>flag{good-luck}</p><h2 id="信息化时代的步伐"><a href="#信息化时代的步伐" class="headerlink" title="信息化时代的步伐"></a>信息化时代的步伐</h2><p>中文电码（misc题）</p><p><a href="http://code.mcdvisa.com/">http://code.mcdvisa.com/</a></p><p>flag{计算机要从娃娃抓起}</p><h2 id="凯撒？替换？呵呵"><a href="#凯撒？替换？呵呵" class="headerlink" title="凯撒？替换？呵呵!"></a>凯撒？替换？呵呵!</h2><p>试一试凯撒密码，发现不对</p><p>猜测是替换密码，选择传统的字典爆破思路</p><p><img src="image-20231031081349400.png" alt></p><p>去掉空格，改成小写即可</p><p><img src="image-20231031081518526.png" alt></p><h2 id="萌萌哒的八戒"><a href="#萌萌哒的八戒" class="headerlink" title="萌萌哒的八戒"></a>萌萌哒的八戒</h2><p>猪圈密码<a href="http://mmoersima.00cha.net/zhuquan.asp">http://mmoersima.00cha.net/zhuquan.asp</a></p><p><img src="image-20231030170925341.png" alt></p><p>flag{whenthepigwanttoeat} </p><h2 id="传统知识-古典密码"><a href="#传统知识-古典密码" class="headerlink" title="传统知识+古典密码"></a>传统知识+古典密码</h2><p><img src="image-20231031084921033.png" alt></p><p>根据所给条件一一映射，再都加60，转成ASCLL码</p><p><img src="image-20231031085841782.png" alt></p><p>之后是栅栏+凯撒，胡乱操作一番就可以找到一个像flag一样的东西</p><p><img src="image-20231031085915520.png" alt></p><p><img src="image-20231031085954428.png" alt></p><p>flag{SHUANGYU}</p><h2 id="权限获得第一步"><a href="#权限获得第一步" class="headerlink" title="权限获得第一步"></a>权限获得第一步</h2><p>上面有原题，一模一样</p><p><img src="image-20231031090257071.png" alt></p><p>flag{3617656}</p><h2 id="世上无难事"><a href="#世上无难事" class="headerlink" title="世上无难事"></a>世上无难事</h2><p>词频分析即可得到flag，记得改小写</p><p>flag{640e11012805f211b0ab24ff02a1ed09}</p><h2 id="old-fashion"><a href="#old-fashion" class="headerlink" title="old-fashion"></a>old-fashion</h2><p>如上题，需要将模式改为<code>Genetic,trust spaces</code></p><p>flag{n1_2hen-d3_hu1-mi-ma_a}</p><h2 id="Unencode"><a href="#Unencode" class="headerlink" title="Unencode"></a>Unencode</h2><p>在线解码网站<a href="http://www.hiencode.com/uu.html">http://www.hiencode.com/uu.html</a></p><p>类似于base64，只是后来被取代了</p><p>flag{dsdasdsa99877LLLKK}</p><h2 id="AFCTF2018-Morse"><a href="#AFCTF2018-Morse" class="headerlink" title="[AFCTF2018]Morse"></a>[AFCTF2018]Morse</h2><p>使用工具进行解码</p><p><img src="image-20231030183414451.png" alt></p><p>观察得到这一串最大是F，猜测是base16</p><p><img src="image-20231030183555161.png" alt></p><p>flag{1s’t_s0_345y}</p><h2 id="还原大师"><a href="#还原大师" class="headerlink" title="还原大师"></a>还原大师</h2><p>总共三个未知量，26^3个可能性，穷举所有可能即可</p><p>md5加密：<code>y = hashlib.md5(x.encode(&#39;utf-8&#39;)).hexdigest().upper()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">m = &#x27;TASC?O3RJMV?WDJKX?ZM&#x27;</span><br><span class="line"></span><br><span class="line">for i in range(26):</span><br><span class="line">    t1 = m.replace(&#x27;?&#x27;,str(chr(65+i)),1)</span><br><span class="line">    for j in range(26):</span><br><span class="line">        t2 = t1.replace(&#x27;?&#x27;,str(chr(65+j)),1)</span><br><span class="line">        for k in range(26):</span><br><span class="line">            t3 = t2.replace(&#x27;?&#x27;,str(chr(65+k)),1)</span><br><span class="line">            s = hashlib.md5(t3.encode(&#x27;utf-8&#x27;)).hexdigest().upper()</span><br><span class="line">            if s[:4] == &#x27;E903&#x27;:</span><br><span class="line">                print(s)</span><br></pre></td></tr></table></figure><p>flag{E9032994DABAC08080091151380478A2}</p><h2 id="异性相吸"><a href="#异性相吸" class="headerlink" title="异性相吸"></a>异性相吸</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key = open(&quot;key.txt&quot;, &#x27;rb&#x27;).read()</span><br><span class="line">cipher = open(&quot;密文.txt&quot;, &quot;rb&quot;).read()</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line">result = &quot;&quot;</span><br><span class="line">for i in range(len(key)):</span><br><span class="line">    flag.append(key[i] ^ cipher[i])</span><br><span class="line">    result += chr(flag[i])</span><br><span class="line">print(flag)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>flag{ea1bc0988992276b7f95b54a7435e89e}</p><h2 id="GXYCTF2019-CheckIn"><a href="#GXYCTF2019-CheckIn" class="headerlink" title="[GXYCTF2019]CheckIn"></a>[GXYCTF2019]CheckIn</h2><p><img src="image-20231031185645418.png" alt><br>ROT5、ROT13、ROT18、ROT47 编码是一种简单的码元位置顺序替换暗码；此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取，而不让其理解其意。</p><p>rot5只用于数字的替换，将当前数字往后移5位，范围是0~9</p><p>明文:  123456<br>密文:  678901</p><p>rot13只能用于字母的替换，将当前字母往后移13个位置(不改变字母大小写)，范围为a-z或者A-Z</p><p>明文：abcdefghijklmnopqrstuvwxyz<br>密文：nopqrstuvwxyzabcdefghijklm<br>明文：ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>密文：NOPQRSTUVWXYZABCDEFGHIJKLM</p><p>rot18就是13+5的合成，加密方法是rot5+rot13，对数字进行rot5加密，对字母进行rot13加密</p><p>明文：123456abcdefgHIJKLMN<br>密文：678901nopqrstUVWXYZA</p><p>rot47将每位数字/字母的ASCII值往<strong>前</strong>移动47位，比如”Z”对应的ASCII值是90，则90-47=43，对应是”+”</p><p>明文：ilo1ey0u<br>密文：:=@`6J_F<br>范围是可打印的字符，ASCII值为32-126</p><p>ROT47在线解码工具<a href="https://www.jisuan.mobi/YYA.html">https://www.jisuan.mobi/YYA.html</a></p><p>flag{Y0u_kNow_much_about_Rot}</p><h2 id="Cipher"><a href="#Cipher" class="headerlink" title="Cipher"></a>Cipher</h2><p>playfair密码，需要 <code>j -&gt; i</code></p><p>在线解密网站</p><p><a href="https://rumkin.com/tools/cipher/playfair/">https://rumkin.com/tools/cipher/playfair/</a></p><p><a href="http://www.hiencode.com/playfair.html">http://www.hiencode.com/playfair.html</a></p><p><img src="Users\coper\AppData\Roaming\Typora\typora-user-images\image-20231101090456313.png" alt="image-20231101090456313"></p><p>flag{itisnotaproblemhavefun}</p><h3 id="2024-1-8-星期一"><a href="#2024-1-8-星期一" class="headerlink" title="2024.1.8 星期一"></a>2024.1.8 星期一</h3><h3 id="BUUCTF-yxx"><a href="#BUUCTF-yxx" class="headerlink" title="[BUUCTF]yxx"></a>[BUUCTF]yxx</h3><p><img src="image-20240108103412640.png" alt></p><hr><p>给了两个文件，用二进制打开</p><p>粘下来进行二进制异或即可得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cipher = &quot;&quot; ; plain = &quot;&quot; ; flag = &quot;&quot;</span><br><span class="line">t = &quot;0A 03 17 02 56 01 15 11 0A 14 0E 0A 1E 30 0E 0A 1E 30 0E 0A 1E 30 14 0C 19 0D 1F 10 0E 06 03 18&quot;.split()</span><br><span class="line">for i in t:</span><br><span class="line">    cipher = cipher + str(bin(int( i , 16 )))[2::].zfill(8)</span><br><span class="line">t = &quot;6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65 6C 6F 76 65&quot;.split()</span><br><span class="line">for i in t:</span><br><span class="line">    plain = plain + str(bin(int( i , 16 )))[2::].zfill(8)</span><br><span class="line">for i in range(len( cipher )):</span><br><span class="line">    if cipher[i] == plain[i]:</span><br><span class="line">        flag = flag + &quot;0&quot;</span><br><span class="line">    else:</span><br><span class="line">        flag = flag + &quot;1&quot;</span><br><span class="line">print( flag )</span><br><span class="line">for i in range( 0 , len(flag) , 8 ):</span><br><span class="line">    t = &quot;&quot;</span><br><span class="line">    for j in range( i , i + 8 ):</span><br><span class="line">        t = t + str( flag[j] )</span><br><span class="line">    print( hex( int(t,2) )[2::] , end=&quot;&quot; )</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;xor_xor_xor_biubiubiu&#125;</code></p><h3 id="2024-1-9-星期二"><a href="#2024-1-9-星期二" class="headerlink" title="2024.1.9 星期二"></a>2024.1.9 星期二</h3><h3 id="CTFshow元旦水友赛-麻辣兔头又一锅"><a href="#CTFshow元旦水友赛-麻辣兔头又一锅" class="headerlink" title="[CTFshow元旦水友赛]麻辣兔头又一锅"></a>[CTFshow元旦水友赛]麻辣兔头又一锅</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">听说有人不喜欢短尾巴的兔兔？肿么可能？我也很疑惑呢。</span><br><span class="line">126292,165298,124522,116716,23623,21538,72802,90966,193480,77695,98618,127096,15893,65821,58966,163254,179952,134870,45821,21712,68316,87720,156070,16323,86266,148522,93678,110618,110445,136381,92706,129732,22416,177638,110110,4324,180608,3820,67750,134150,23116,116772,50573,149156,5292</span><br><span class="line">60144,146332,165671,109800,176885,65766,76908,147004,135068,182821,123107,77538,86482,88096,101725,16475,158935,123018,42322,144694,186769,176935,59296,134856,65813,131931,144283,95814,102191,185706,55744,67711,149076,108054,135112,100344,35434,121479,14506,145222,183989,17548,38904,27832,105943</span><br></pre></td></tr></table></figure><hr><p>“兔子”并不一定是栅栏密码，还有可能是<code>斐波那契数列</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2 </span><br><span class="line">a = &quot;126292,165298,124522,116716,23623,21538,72802,90966,193480,77695,98618,127096,15893,65821,58966,163254,179952,134870,45821,21712,68316,87720,156070,16323,86266,148522,93678,110618,110445,136381,92706,129732,22416,177638,110110,4324,180608,3820,67750,134150,23116,116772,50573,149156,5292&quot;.split(&quot;,&quot;)</span><br><span class="line">b = &quot;60144,146332,165671,109800,176885,65766,76908,147004,135068,182821,123107,77538,86482,88096,101725,16475,158935,123018,42322,144694,186769,176935,59296,134856,65813,131931,144283,95814,102191,185706,55744,67711,149076,108054,135112,100344,35434,121479,14506,145222,183989,17548,38904,27832,105943&quot;.split(&quot;,&quot;)</span><br><span class="line">for i in range( len( a ) ):</span><br><span class="line">    print(chr((gmpy2.fib(eval(a[i]))^gmpy2.fib(eval(b[i])))&amp;0xff),end=&#x27;&#x27; )</span><br></pre></td></tr></table></figure><p>我们需要计算出两行的斐波那契数然后异或，使用python的gmpy2.fib即可计算斐波那契数列的任意位</p><p>flag:<code>ctfshow&#123;6d83b2f1-1241-4b25-9c1c-0a4c218f6c5f&#125;</code></p><p>问题：这道题是如何构造的</p><p>全体正整数n和fib(n)构成单射，而非一一映射，出题人是如何构造的，是否可以根据指定的flag来构造密文</p><p>猜想：由于最终对Oxff进行与运算，故只需要考虑16进制下的最后两位；总共有255，如果是直接进行与运算，最劣情况下进行不超过65536次运算即可得到一个字母对应的斐波那契数；其序数可以进行暴力运算进行逆推；或者构造一组“最小剩余系”来表示所有需要的数，容量为256，进行组合即可</p><p>反驳：对于所有的已知数据，没有一个是重复的</p><p>回答：可以不是随机，每256个数就存在一个数符合预期要求；也不需要有重复的数字，python对于斐波那契数列的算力很强；故由一个flag，可以随机出一个a序列，然后暴力计算出b序列</p><h3 id="2024-1-10-星期三"><a href="#2024-1-10-星期三" class="headerlink" title="2024.1.10 星期三"></a>2024.1.10 星期三</h3><h3 id="BUUCTF·网鼎杯2020青龙组-boom"><a href="#BUUCTF·网鼎杯2020青龙组-boom" class="headerlink" title="[BUUCTF·网鼎杯2020青龙组]boom"></a>[BUUCTF·网鼎杯2020青龙组]boom</h3><p>获得到一个exe文件</p><p>一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first:this string md5:46e5efe6165a5afb361217446a2dbd01</span><br></pre></td></tr></table></figure><p>二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This time:Here are have some formulas</span><br><span class="line">3x-y+z=185</span><br><span class="line">2x+3y-z=321</span><br><span class="line">x+y+z=173</span><br><span class="line">input: x =</span><br></pre></td></tr></table></figure><p>三</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last time: Kill it</span><br><span class="line">x*x+x-7943722218936282=0</span><br><span class="line">input x:</span><br></pre></td></tr></table></figure><hr><p>使用cmd打开</p><p>一</p><p>使用<a href="https://www.somd5.com/解密得到`en5oy`">https://www.somd5.com/解密得到`en5oy`</a></p><p>二</p><p>可以使用高斯消元法<a href="https://www.luogu.com.cn/problem/P3389">https://www.luogu.com.cn/problem/P3389</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//2021-11-13</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 105;</span><br><span class="line">double a[N][N];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">for(int j = 1; j &lt;= n + 1; j ++)</span><br><span class="line">scanf(&quot;%lf&quot;, &amp;a[i][j]);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)&#123;</span><br><span class="line">int maxx = i;</span><br><span class="line">for(int j = i + 1; j &lt;= n; j ++)</span><br><span class="line">if( fabs(a[j][i]) &gt; fabs(a[maxx][i] ) )</span><br><span class="line">maxx = j;</span><br><span class="line">for(int j = 1; j &lt;= n + 1; j ++)</span><br><span class="line">swap( a[i][j], a[maxx][j] );</span><br><span class="line">if( !a[i][i] )&#123;</span><br><span class="line">cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">if(j != i)&#123;</span><br><span class="line">double temp = a[j][i] / a[i][i];</span><br><span class="line">for( int k = i + 1; k &lt;= n + 1; ++k)</span><br><span class="line">a[j][k] -= a[i][k] * temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">printf(&quot;%.2lf\n&quot;, a[i][n + 1] / a[i][i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">3</span><br><span class="line">3 -1 1 185</span><br><span class="line">2 3 -1 321</span><br><span class="line">1 1 1 173</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>也可以使用python自带库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sympy import*</span><br><span class="line">from sympy.abc import x,y,z</span><br><span class="line"></span><br><span class="line">ans = solve([3*x-y+z-185,2*x+3*y-z-321,x+y+z-173],[x,y,z])</span><br><span class="line">print( ans )</span><br></pre></td></tr></table></figure><p>解得：<code>x = 74, y = 68, z = 31</code></p><p>三</p><p>一元二次方程，可以用同样的方式去解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sympy import*</span><br><span class="line">from sympy.abc import x</span><br><span class="line"></span><br><span class="line">ans = solve([x*x+x-7943722218936282],[x])</span><br><span class="line">print( ans )</span><br></pre></td></tr></table></figure><p>解得：<code>x1 = 89127561 , x2 = -89127562</code></p><p>flag:<code>flag&#123;en5oy_746831_89127561&#125;</code></p><h3 id="isctf2023夹里夹气"><a href="#isctf2023夹里夹气" class="headerlink" title="isctf2023夹里夹气"></a>isctf2023夹里夹气</h3><p>观察发现是摩斯密码，将<code>ISCTF</code>摩斯密码加密得到<code>.-</code>串，发现原字符串，两个一组是<code>.</code>，三个一组是<code>-</code></p><p>自行增加<code>?</code>并替换，进行莫斯解密即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( s.replace(&quot;嘤嘤嘤&quot;,&quot;-&quot;).replace(&quot;嘤嘤？&quot;,&quot;.&quot;) )</span><br></pre></td></tr></table></figure><p>ISCTF{HSBDH_SFJ_JDNFJ_DJNFJDM}</p><h3 id="2024-1-19-星期五"><a href="#2024-1-19-星期五" class="headerlink" title="2024.1.19 星期五"></a>2024.1.19 星期五</h3><h3 id="BUUCTF·ACTF新生赛2020-crypto-classic0"><a href="#BUUCTF·ACTF新生赛2020-crypto-classic0" class="headerlink" title="[BUUCTF·ACTF新生赛2020]crypto-classic0"></a>[BUUCTF·ACTF新生赛2020]crypto-classic0</h3><p>有点像misc，是一个文件</p><hr><p>提示密码是生日，直接八位数字爆破，得到<code>19990306</code></p><p>直接解密即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">txt = &quot;Ygvdmq[lYate[elghqvakl&#125;&quot;</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line"></span><br><span class="line">for i in txt:</span><br><span class="line">    flag = flag + str(chr( (ord(i) ^ 0x7) + 3) )</span><br><span class="line">print( flag )</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;my_naive_encrytion&#125;</code></p><h3 id="2024-1-20-星期六"><a href="#2024-1-20-星期六" class="headerlink" title="2024.1.20 星期六"></a>2024.1.20 星期六</h3><h3 id="BUUCTF·WUSTCTF2020-B-se"><a href="#BUUCTF·WUSTCTF2020-B-se" class="headerlink" title="[BUUCTF·WUSTCTF2020]B@se"></a>[BUUCTF·WUSTCTF2020]B@se</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">密文：MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==</span><br><span class="line">JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/</span><br><span class="line"></span><br><span class="line">oh holy shit, something is missing...</span><br></pre></td></tr></table></figure><hr><p>查找缺失的密码表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import string</span><br><span class="line">table = &quot;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/&quot;</span><br><span class="line">cipher = &quot;MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==&quot;</span><br><span class="line"></span><br><span class="line">for i in string.ascii_letters+string.digits:</span><br><span class="line">    if i not in table:</span><br><span class="line">        print( i , end = &quot; &quot; )</span><br></pre></td></tr></table></figure><p><code>j u 3 4</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from itertools import *</span><br><span class="line">from binascii import *</span><br><span class="line">table = &quot;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/&quot;</span><br><span class="line">cipher = &quot;MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD&quot;</span><br><span class="line">s = [&#x27;j&#x27;,&#x27;u&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span><br><span class="line">for i in permutations( s , 4 ):</span><br><span class="line">    t = &quot;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs&quot;+&quot;&quot;.join(i)+&quot;kxyz012789+/&quot;</span><br><span class="line">    bins = &quot;&quot;</span><br><span class="line">    for j in cipher:</span><br><span class="line">      bins+=bin(t.index(j))[2:].zfill(6)</span><br><span class="line">    print(unhexlify(hex(eval(&quot;0b&quot;+bins))[2:-1]))</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;base64_1s_v3ry_e@sy_and_fuN&#125;</code></p><h3 id="2024-1-5星期五"><a href="#2024-1-5星期五" class="headerlink" title="2024.1.5星期五"></a>2024.1.5星期五</h3><h3 id="BUUCTF·MRCTF2020-vigenere"><a href="#BUUCTF·MRCTF2020-vigenere" class="headerlink" title="[BUUCTF·MRCTF2020]vigenere"></a>[BUUCTF·MRCTF2020]vigenere</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">g vjganxsymda ux ylt vtvjttajwsgt bl udfteyhfgt</span><br><span class="line">oe btlc ckjwc qnxdta </span><br><span class="line">vbbwwrbrtlx su gnw nrshylwmpy cgwps, lum bipee ynecgy gk jaryz frs fzwjp, x puej jgbs udfteyhfgt, gnw sil uuej su zofi. sc okzfpu bl lmi uhzmwi, x nyc dsj bl lmi enyl ys argnj yh nrgsi. nba swi cbz ojprbsw fqdam mx. cdh nsai cb ygaigroysxn jnwwi lr msylte.</span><br><span class="line">cw mekr tg jptpzwi kdikjsqtaz, ftv pek oj pxxkdd xd ugnj scr, yg n esqxwxw nba onxw au ywipgkj fyiuujnxn gnss xwnz onxw jnahl avhwwxn vzkjpu nrofch fvwfoh. v jwhppek lmi vyutfp hbiafp hcguj at nxw gyxyjask ib hw seihxsqpn vtvjttajwsx ds zzj xnegfsmtf egz wtrq lt mbcukj sc hy. qty wnbw ss bbxsq vxtnl ys ghrw zw cbx vt cdh vgxwtfy ssc brzzthh bl wsjdeiwricg cw mekr zjzi grgktr ib lwfv.</span><br><span class="line">vbbwwrbrtlx hteonj xwroj oyhg vgbigf ljtq iuk utrhrtl tj iuk ytztetwi. cdh nsai crolmig fudngxgkv ssg ekujmkrj gzvh. jk vnh cbz aszxgk qty. nba vt rdg qfta jf, tgw hd lum prdj umw aderv. hcqrxkuerr jgjw cbz dni lvzznr nbaj gsgqkjx. hd aul ylxaq lmei lum hec oaaqh xg, gk yldhmz nx lrxw f tjorah gdaylwyrgogs tgbpwhx. nba ufrcbz. ay mh nt shx ds tsyygr gfi mi txgbw xgywqj iuxgzkw baj hsaykuymkr guymday.</span><br><span class="line">qty wnbw ssi rtyfktq of tyg txwfx paj yfxwrxask rbtnjvhnzatr, cbx vnh nba uwipgk lmi lrgdyl ds umw qpeqwytaniwx. cdh jg ssi xtgb sje imqxjek, gzv tgnahw, de zzj ycjxayxta igiih gnsy eaeksic eeunnht baj xsrvkld qdek gwhte zzfr rbadi ft bhlfmcrj td ecl ux dsje oeushvzatrh.</span><br><span class="line">lum hppvs lmigr gjj tgbhdjqh nsgsk jf zzfx nba fjis gu ktpkr. egz yhr zznw rygar eh nt wcgjfk lt mcigvj sje vjjgxailx. qpae gk xwryw uvdorwrw sbt&#x27;l jbxfz. omigr zzjvt nxw wipy igsjavilx, awrxw yltek swi leuflw, lr caqp xqkfymul zzjq paj sihgryk yltz hq tyg zkssw. lr gjj jdesask dhx gbr hbiafp rbtlwerg. zznw vbbwwrpaiw bmay gjnwt niutvsvty ys iuk utrsvzatrh bl gzv lbxdi, rdg egzvh. baj bsgyj ax hxslwwicg.</span><br><span class="line">iqgigfvshi rbtknwif ux yvpayshxxbtk, wianzatrhuohx, ecq zztyvuz aywtyl, swvplkv qmzr g kyecqofl apik as xwr cwg su baj hsbzafngpgogsw. dhxk nw p jujqh iugl nw qbzz jzteeomigr gfi rdjnwwi, qhz ay mh aul bltek tthxry dnzt.</span><br><span class="line">jk swi reksymct g otvaq zzfx pyr efc tazww axgngzx eeonnpttk gw tgrpmimrr guhsgqkv gc gniw, jgdaueng ebcww, qxyolfvn sujhi, de ylfxxbt gk fxezz.</span><br><span class="line">bi pek uwipgofl e lbxdi awrxw frnbtw, frnjnwwi bne wctgryk mmh bx zjv qrrajjh, au efxirx zta hvtyzppe, cayldhz xjeg bl tjmct igjvrrj asxd fodjrrr uj hscsujrmil.</span><br><span class="line">egzv armsq gdaiwuxh bl hwserxld, imcxwxwxbt, aiicgold, qdikejri, ntv hscgkpy hd aul fteye lt yh. gnwd egr gdq fpfkv tr bnzljv, paj lmigr ok ss bnzljv wrxw.</span><br><span class="line">tyg vjwsxxgowx lpik ft fdqowx, wd, htdnot lum, bi rntftx dozsnr dejww fn cnqxmrnr utigpogs. at okdnikr zzfx ueue jxwvik, jravmzyicrj kjpu-vtljvtfz, ssh iuk utqbbtojea, baj lskrxffrrr caqp tzkjli. dhx aiicgolnih zgq gi svylwmqhzwi ereukx qpae gk cdhx bzvxfjahxxbtk. ylt btdd ppj zzfx pyr gzv rbtkymihkfy gjyzmwih jumqh vrtwweaye jjgdttaei xf zzj kdyjws vjyk. oj ldck oj axyr tj eqyk lt fjvrv tyg cgjymrhrsw wdyalnscf uf ylpg hsxmh. oal bi rntftx ppiwux iuk ktpjgogsw nba swi pgzwrtivty ys xzvgxi.</span><br><span class="line">xa zzj ycvzwi winzwx, cdh nsai ibjsd ggrgljh p ygo, ylt gkdjgdzsmsmrnzatrh ekxtvb nil, blxpn jjtjqosyih lumw sla igswivzmymda gfi mcfadyw iuk vwipzy gk ntslwwwda, csxlxamltr, bvrd, resvygs, htguizikvrdj, ecq hjfrsrok. yltfk vwipzy ezwi auo gi qbxf frtj of zw.</span><br><span class="line">nba swi irxjnjxrj gk cdhx gbr ruodivta, yasgt gnwd egr tsymkry as e lbxdi awrxw dsj jodq eajgqx ft vsenkgntlx. ftpgmxi nba xjeg gnwr, cdh kfyvjfz qtyg oajjejpxshmtf cayl iuk hfvtazsq vtfvgswxoodnxxry qty pek lts rbcswhal zg hscsxgsx nbajxiaikk. nr dhx otvaq, gdq xwr ywsxxzkfyw paj wctgryknscf ux mybntayc, ueue ylt qktfwxam lt xwr gfliavi, swi enxlx su n ywfqaryk bldyk, lmi vyutfp rbtnjvhnzatr ds hayw. lr issrdg ywuegnzw ylt noj ylpg iztotf ljtq iuk snv jcuf blxpn onrvf hwfx.</span><br><span class="line">xa iznrp, tkjrecl, ljfrrr, xmxwxn, yaskpcujj, minrq frs gnw zrxgkv xxpgkk, dsj nxw yvnvty ys lnxv tju gnw amghy gk pxokjyc ql kjjgivty lypej htwif gl ylt sxgsxxrxk tj rlhwwweniw. yltfk efc zrkh tyi gnw hscggynsc suj f wbnrd ymbr, hmy xwre onpa aul bsgx of f aderv ylpg caqp hbuf gi qygfpiirj as fxg-hwfvxam ejhxn.</span><br><span class="line">egzv xaijjehvtyqc doygqiir ofksgzglnsc vtvzwieowx adhrv uigcklzeir zzjqhrrnjw ql vjttdfofl ppjy, as ebrxahe paj wqwtjnwwi, iugl hppvs lt sla yhjiru olxias zzwsjtngzx iuk otvaq. zzjwt ygox adhrv iirygjj msrgk ys qr gftxwrx ashjfzjnea cxgiyrg, tg rsgr tggpt gnss txt ojtr. xa umw aderv, blpgknjv iuk zzqpa sash bne uwipgk ufr qr xwuvdqaujh paj vnwieotzxtq ofkmcvzwqc pg tg hshg. zzj kabhsq gdabwdecpk gk xwbaymx cb rgskte xwvyxekk dsje lshxdeowx xd niutqeyokm.</span><br><span class="line">xwryw nrreksxmctrq mshgodj ecq igqscvgd ripfajjw eyguj yh vt lmi hnsw ushvzatr pf zztwt cxwamdhy dtztey gk jgrkvtq paj kjpu-qkljvbvtsymda czt lpq zg wiyril ylt nalmsgvzajw ds jaxxpaz, msmcsujris cuojvh. jk ezwi qkuqegr umw zxezmfp hrrnjw xzsmsi ib egzv hbbwwixttld, ikrt sx at pufymchk lt gdaywsx ib egzv ghrw tzte umw fdqowx. at jodq weeksi sjeywqztf guwshf zzj tantwy wd gnsy rd btw hec nxjjwi baj yldhmzyw.</span><br><span class="line">lr caqp reksyi p ponnpxmglnsc bl lmi bvtv nr rlhwwweniw. ren vz tj qdek zzqpak ssh unoj ylpa zzj aderv dsje mgaigaswsxh ugnj qpqk tjjdek.</span><br><span class="line">xqev vy ewgis balicrxw hvnczg hvppq efr, eyksxi pqj mshteyutvt ntv hygye twerry.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/python3</span><br><span class="line">from ctf import source_text, key_string</span><br><span class="line"></span><br><span class="line">getdiff = lambda char: ord(char)-ord(&#x27;a&#x27;)</span><br><span class="line">getchar = lambda num: chr(ord(&#x27;a&#x27;)+num)</span><br><span class="line"></span><br><span class="line">def vigenere(src: chr, key: chr) -&gt; chr:</span><br><span class="line">    assert(src.isalpha() and key.isalpha())</span><br><span class="line">    return(getchar((getdiff(src) + getdiff(key) + 1) % 26))</span><br><span class="line"></span><br><span class="line">src = source_text.lower()</span><br><span class="line">count = 0</span><br><span class="line">assert(len(key_string) &gt; 5 and len(key_string) &lt; 10)</span><br><span class="line">for i in src:</span><br><span class="line">    if(i.isalpha()):</span><br><span class="line">        print(vigenere(i, key_string[count % len(key_string)]), end=&#x27;&#x27;)</span><br><span class="line">        count+=1</span><br><span class="line">    else:</span><br><span class="line">        print(i, end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>对于这段加密代码，这是gpt给出的解释</p><p><img src="image-20240105084101201.png" alt></p><p>对于网络上的wp，一般是给出这个在线网站进行破解（还挺快）<a href="https://www.guballa.de/vigenere-solver">https://www.guballa.de/vigenere-solver</a></p><p><img src="image-20240105084330499.png" alt></p><p>flag:<code>flag&#123;vigenere_crypto_crack_man&#125;</code></p><h3 id="BUUCTF·MRCTF2020-keyboard"><a href="#BUUCTF·MRCTF2020-keyboard" class="headerlink" title="[BUUCTF·MRCTF2020]keyboard"></a>[BUUCTF·MRCTF2020]keyboard</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">得到的flag用</span><br><span class="line">MRCTF&#123;xxxxxx&#125;形式上叫</span><br><span class="line">都为小写字母</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">666</span><br><span class="line">22</span><br><span class="line">444</span><br><span class="line">555</span><br><span class="line">33</span><br><span class="line">7</span><br><span class="line">44</span><br><span class="line">666</span><br><span class="line">66</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>通过九键键盘加密</p><p><img src="image-20240105092700375.png" alt></p><p>可以直接手搓，搓出<code>mobilephond</code></p><p>提交发现不对，调用英语知识把d改成e就对了</p><p>对于大量数据的解码脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txt = &#x27;6 666 22 444 555 33 7 44 666 66 3&#x27;.split()</span><br><span class="line">jiujian = [&#x27;&#x27;,&#x27;&#x27;,&#x27;abc&#x27;,&#x27;def&#x27;,&#x27;ghi&#x27;,&#x27;jkl&#x27;,&#x27;mno&#x27;,&#x27;pqrs&#x27;,&#x27;tuv&#x27;,&#x27;wxyz&#x27;]</span><br><span class="line">for i in txt:</span><br><span class="line">    print(jiujian[int(i[0])][len(i)-1],end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;mobilephone&#125;</code></p><h3 id="BUUCTF·AFCTF2018-Vigenere"><a href="#BUUCTF·AFCTF2018-Vigenere" class="headerlink" title="[BUUCTF·AFCTF2018]Vigenère"></a>[BUUCTF·AFCTF2018]Vigenère</h3><p><img src="image-20240105144839575.png" alt></p><p><img src="Users\coper\AppData\Roaming\Typora\typora-user-images\image-20240105145056831.png" alt="image-20240105145056831"></p><p>又是未知密钥的维吉尼亚密码，在线网站一把唆<a href="https://www.guballa.de/vigenere-solver">https://www.guballa.de/vigenere-solver</a></p><p><img src="image-20240105145226418.png" alt></p><p>flag:<code>flag&#123;Whooooooo_U_Gotcha!&#125;</code></p><h2 id="密码学的心声"><a href="#密码学的心声" class="headerlink" title="密码学的心声"></a>密码学的心声</h2><ol><li>数字三位一组分组，形成多组八进制数</li><li>转成十进制，也是三个数一组</li><li>每组转化为相应的ASCLL码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str = &#x27;111 114 157 166 145 123 145 143 165 162 151 164 171 126 145 162 171 115 165 143 150&#x27;</span><br><span class="line">str = str.split(&#x27; &#x27;)</span><br><span class="line">flag = []</span><br><span class="line">for i in range(len(str)):</span><br><span class="line">    flag.append( str[i] )</span><br><span class="line">result = &#x27;&#x27;</span><br><span class="line">for i in flag:</span><br><span class="line">    result += chr(int(i,8))</span><br><span class="line">print( result )</span><br></pre></td></tr></table></figure><p>flag{ILoveSecurityVeryMuch}</p><h2 id="robomunication"><a href="#robomunication" class="headerlink" title="robomunication"></a>robomunication</h2><p>是一段音频，摩斯密码，转码后即可得到flag</p><p>flag{BOOPBEEP}</p><h2 id="BJDCTF2020-这是base-undone"><a href="#BJDCTF2020-这是base-undone" class="headerlink" title="[BJDCTF2020]这是base??(undone)"></a>[BJDCTF2020]这是base??(undone)</h2><p>前置知识：base64</p><h2 id="达芬奇密码-undone"><a href="#达芬奇密码-undone" class="headerlink" title="达芬奇密码(undone)"></a>达芬奇密码(undone)</h2><h2 id="WUSTCTF2020-佛说：只能四天"><a href="#WUSTCTF2020-佛说：只能四天" class="headerlink" title="[WUSTCTF2020]佛说：只能四天"></a>[WUSTCTF2020]佛说：只能四天</h2><p><a href="http://hi.pcmoe.net/buddha.html">http://hi.pcmoe.net/buddha.html</a></p><p><img src="image-20231107144309827.png" alt></p><p><a href="https://atool.vip/corevalue/">https://atool.vip/corevalue/</a></p><p><img src="image-20231107144340292.png" alt></p><p><img src="image-20231107144405119.png" alt></p><p>传统的凯撒密码偏移量是3</p><p><img src="image-20231107150248459.png" alt></p><p>base32由A~Z，2~7组成（还有”=”）</p><p><img src="image-20231107150412903.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">def caesarCrack(c, n):</span><br><span class="line">    alpha = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line">    c = c.upper()</span><br><span class="line">    m = &quot;&quot;</span><br><span class="line">    for i in c:</span><br><span class="line">        index = alpha.find(i)</span><br><span class="line">        if index != -1:</span><br><span class="line">            index = (index + n) % 26</span><br><span class="line">            m += alpha[index]</span><br><span class="line">        else:</span><br><span class="line">            m += i</span><br><span class="line">    return m</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    c = &quot;R5UALCUVJDCGD63RQISZTBOSO54JVBORP5SAT2OEQCWY6CGEO53Z67L&quot;</span><br><span class="line">    # 用&#x27;=&#x27;填充字符串使其长度为8的倍数, 方便后序进行Base32解密</span><br><span class="line">    lenPadding = 8 - (len(c) % 8)</span><br><span class="line">    c += lenPadding * &quot;=&quot;</span><br><span class="line">    for i in range(1, 26):</span><br><span class="line">        ca = caesarCrack(c, i)</span><br><span class="line">        m = base64.b32decode(ca)</span><br><span class="line">        try:</span><br><span class="line">            m = m.decode()</span><br><span class="line">            print(m)</span><br><span class="line">        except UnicodeDecodeError:</span><br><span class="line">            continue</span><br></pre></td></tr></table></figure><p>flag{ni_hao_xiang_xiang_da_wo}</p><h2 id="MRCTF2020-古典密码知多少"><a href="#MRCTF2020-古典密码知多少" class="headerlink" title="[MRCTF2020]古典密码知多少"></a>[MRCTF2020]古典密码知多少</h2><p>猪圈密码+圣堂武士密码+标准银河字母密码</p><p>然后根据提示，使用栅栏密码</p><p>flag{CRYPTOFUN}</p><h2 id="rot"><a href="#rot" class="headerlink" title="rot"></a>rot</h2><p><img src="image-20231108090104867.png" alt></p><p>需要暴力枚举后四位，根据md5判断正误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">txt = &#x27;flag&#123;www_shiyanbar_com_is_very_good_&#x27;</span><br><span class="line">md5 = &#x27;38e4c352809e150186920aac37190cbc&#x27;</span><br><span class="line">for i in range(33,128):</span><br><span class="line">    for j in range(33,128):</span><br><span class="line">        for k in range(33,128):</span><br><span class="line">            for o in range(33,128):</span><br><span class="line">                flag = txt+chr(i)+chr(j)+chr(k)+chr(o)+&#x27;&#125;&#x27;</span><br><span class="line">                hsh = hashlib.md5(flag.encode()).hexdigest()</span><br><span class="line">                if( hsh == md5 ):</span><br><span class="line">                    print( flag )</span><br></pre></td></tr></table></figure><p>flag{www_shiyanbar_com_is_very_good_@8Mu}</p><h2 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么"></a>这是什么</h2><p>这是什么？这不是雪豹，这是jsfuck密码</p><p>拖到010editor中，得到一串这样的符号，使用<a href="https://www.bugku.com/tools/jsfuck/#解码">https://www.bugku.com/tools/jsfuck/#解码</a></p><p><img src="image-20231108095153414.png" alt></p><p>flag{a0448fd730b62c13ca80200c4529daa2}</p><h2 id="NCTF2019-Keyboard"><a href="#NCTF2019-Keyboard" class="headerlink" title="[NCTF2019]Keyboard"></a>[NCTF2019]Keyboard</h2><p>电脑键盘第一行的从W到O八个字母 -&gt; 手机九键输入法的八个字母</p><p>出现频率表示第几个</p><p>flag{youaresosmartthatthisisjustapieceofcake}</p><h2 id="MRCTF2020-天干地支-甲子"><a href="#MRCTF2020-天干地支-甲子" class="headerlink" title="[MRCTF2020]天干地支+甲子"></a>[MRCTF2020]天干地支+甲子</h2><p><img src="c683c9393fe4ab9629d651cdc6f0828a.png" alt></p><p>一甲子=60</p><p>将每个干支转化成对应的数字，再+60，转化成ASCLL码即可</p><p>flag{Goodjob}</p><h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><p>16进制转字符串即可</p><p><img src="image-20231108110850581.png" alt></p><p>flag{We1c0me_t4_BJDCTF}</p><h2 id="一张谍报"><a href="#一张谍报" class="headerlink" title="一张谍报"></a>一张谍报</h2><p>有两段长度相同的文段，局部文字相同，二者不相同的内容形成多组映射，形成密码本</p><p>依据此密码本对右下角密文进行解密即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;今天上午，朝歌区梆子公司决定，在每天三更天不亮免费在各大小区门口设卡为全城提供二次震耳欲聋的敲更提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的符号是前进。为此，全区老人都蹲在该公司东边树丛合力抵制，不给公司人员放行，场面混乱。李罗鹰住进朝歌区五十年了，人称老鹰头，几年孙子李虎南刚从东北当猎户回来，每月还寄回来几块鼹鼠干。李罗鹰当年遇到的老婆是朝歌一枝花，所以李南虎是长得非常秀气的一个汉子。李罗鹰表示：无论梆子公司做的对错，反正不能打扰他孙子睡觉，子曰：‘睡觉乃人之常情’。梆子公司这是连菩萨睡觉都不放过啊。李南虎表示：梆子公司智商捉急，小心居民猴急跳墙！这三伏天都不给睡觉，这不扯淡么！到了中午人群仍未离散，更有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李南虎仍旧表示爷爷年纪大了，睡不好对身体不好。&quot;</span><br><span class="line">str2 = &quot;喵天上午，汪歌区哞叽公司决定，在每天八哇天不全免费在各大小区门脑设卡为全城提供双次震耳欲聋的敲哇提醒，呼吁大家早睡早起，不要因为贪睡断送大好人生，时代的编号是前进。为此，全区眠人都足在该公司流边草丛合力抵制，不给公司人员放行，场面混乱。李罗鸟住进汪歌区五十年了，人称眠鸟顶，几年孙叽李熬值刚从流北当屁户回来，每月还寄回来几块报信干。李罗鸟当年遇到的眠婆是汪歌一枝花，所以李值熬是长得非常秀气的一个汉叽。李罗鸟表示：无论哞叽公司做的对错，反正不能打扰他孙叽睡觉，叽叶：‘睡觉乃人之常情’。哞叽公司这是连衣服睡觉都不放过啊。李值熬表示：哞叽公司智商捉急，小心居民猴急跳墙！这八伏天都不给睡觉，这不扯淡么！到了中午人群仍未离散，哇有人提议要烧掉这个公司，公司高层似乎恨不得找个洞钻进去。直到治安人员出现才疏散人群归家，但是李值熬仍旧表示爷爷年纪大了，睡不好对身体不好。&quot;</span><br><span class="line">str3 = &quot;喵汪哞叽双哇顶，眠鸟足屁流脑，八哇报信断流脑全叽，眠鸟进北脑上草，八枝遇孙叽，孙叽对熬编叶：值天衣服放鸟捉猴顶。鸟对：北汪罗汉伏熬乱天门。合编放行，卡编扯呼。人离烧草，报信归洞，孙叽找爷爷。&quot;</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for i in range( len(str3) ):</span><br><span class="line">    for j in range( len(str2) ):</span><br><span class="line">        if str3[i] == str2[j]:</span><br><span class="line">            flag = flag + str1[j]</span><br><span class="line">            break</span><br><span class="line">print( flag )</span><br></pre></td></tr></table></figure><p><img src="image-20231108214853780.png" alt></p><p>flag{南天菩萨放鹰捉猴头}</p><h2 id="NPUCTF2020-这是什么觅🐎"><a href="#NPUCTF2020-这是什么觅🐎" class="headerlink" title="[NPUCTF2020]这是什么觅🐎"></a>[NPUCTF2020]这是什么觅🐎</h2><p>得到一个无拓展名的文件，用010editor打开，发现有’jpg’，拓展名改成’jpg’，打开失败，疑似是压缩包，改成zip解压获得图片</p><p>字母和数字确定一个数字，其中T1为TUE，T2为THU；S1为SAT，S2为SUN</p><p>对应的数字：3 1 12 5 7/14 4 1 18</p><p>对应的字母：C A L E G/N D A R</p><p>flag{calendar}</p><h2 id="极客大挑战-proof-of-work"><a href="#极客大挑战-proof-of-work" class="headerlink" title="[极客大挑战]proof_of_work"></a>[极客大挑战]proof_of_work</h2><p>题目链接：nc 59.110.20.54:5526 Build your own function to solve proof_of_work!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">txt = &quot;&quot;</span><br><span class="line">cnt = 0</span><br><span class="line"></span><br><span class="line">for i in range( 32 , 127 ):</span><br><span class="line">    for j in range( 32 , 127 ):</span><br><span class="line">        for k in range( 32 , 127 ):</span><br><span class="line">            for o in range( 32 , 127 ):</span><br><span class="line">                txt = chr(i)+chr(j)+chr(k)+chr(o)+&quot;CwO1X7uNTpovKiWE&quot;</span><br><span class="line">                if hashlib.sha256(txt.encode(&#x27;utf-8&#x27;)).hexdigest() == &quot;c88bbfe56a7638ca6bf9428a5ce583d55a8376d1c77512518bd5a40d0600da26&quot;:</span><br><span class="line">                    print(txt)</span><br><span class="line">                    assert 0</span><br><span class="line">                cnt += 1</span><br><span class="line">                if( cnt == 500000 ):</span><br><span class="line">                    print( txt , hashlib.sha256(txt.encode(&#x27;utf-8&#x27;)).hexdigest() )</span><br><span class="line">                    cnt = 0;</span><br><span class="line">print(&quot;end&quot;)</span><br></pre></td></tr></table></figure><h2 id="BUUCTF-BJDCTF2020-这是base"><a href="#BUUCTF-BJDCTF2020-这是base" class="headerlink" title="[BUUCTF][BJDCTF2020]这是base??"></a>[BUUCTF][BJDCTF2020]这是base??</h2><p>base64原理：用64个可打印字符表示二进制所有数据方式。2^6=64，所以可以用每六个位元为一个单元，对应某个可打印字符。三个字节长度为24个位元，对应4个base64单元；即三个字节需要用四个base64可打印字符表示</p><p><img src="Center.png" alt></p><p>转换时每次取3byte的数据，放进24bite的缓冲区，先进为高位，数据不足24bite则用0补齐</p><p>然后每次取6bit，按照对照表的编码输出，加密后的数据量是原来的4/3</p><p>这道题相当于base64更换密码表，加密原理相同</p><p>txt.find(‘c’) 在列表中找到’c’字符，返回下标</p><p>b’010101’[2:].zfill(‘num’) 从第三位开始取，返回长度为’num’的字符串，原字符串右对齐，前面填充0。（舍弃前2位，是因为二进制数前面有前缀’0b’）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c=&quot;JKLMNOxyUVzABCDEFGH789PQIabcdefghijklmWXYZ0123456RSTnopqrstuvw+/=&quot;</span><br><span class="line">txt=&quot;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw&quot;</span><br><span class="line"></span><br><span class="line">end=&quot;&quot;</span><br><span class="line">for i in txt:</span><br><span class="line">    end+=bin(c.find(i))[2:].zfill(6)</span><br><span class="line">    </span><br><span class="line">x=&quot;&quot;</span><br><span class="line">for i in range(0,len(end),8):</span><br><span class="line">    x+=chr(int(end[i:i+8],2))</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>flag{D0_Y0u_kNoW_Th1s_b4se_map}</p><h2 id="BUUCTF-达芬奇密码"><a href="#BUUCTF-达芬奇密码" class="headerlink" title="[BUUCTF]达芬奇密码"></a>[BUUCTF]达芬奇密码</h2><p>观察发现数字列是一串打乱顺序的斐波那契数列</p><p>生成一个正常顺序的斐波那契</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 1</span><br><span class="line">print( &quot;1 1 &quot;,end = &#x27;&#x27; )</span><br><span class="line">for i in range( 1 , 40 ):</span><br><span class="line">    c = a + b</span><br><span class="line">    print( c , end = &#x27; &#x27; )</span><br><span class="line">    a = b</span><br><span class="line">    b = c</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = &#x27;0 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309&#x27;</span><br><span class="line">b = &#x27;0 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711&#x27;</span><br><span class="line">a = a.split(&quot; &quot;)</span><br><span class="line">b = b.split(&quot; &quot;)</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line">m = &#x27;36968853882116725547342176952286&#x27;</span><br><span class="line"></span><br><span class="line">for i in range( len(a) ):</span><br><span class="line">    for j in range( len(b) ):</span><br><span class="line">        if a[i] == b[j]:</span><br><span class="line">            flag.append(m[j])</span><br><span class="line">            break</span><br><span class="line">print( &#x27;&#x27;.join(flag) )</span><br></pre></td></tr></table></figure><p>flag{37995588256861228614165223347687}</p><p>发现的细节：</p><p><img src="image-20231117095517438.png" alt></p><p>如果字符串最后有一个空格，split()操作后会多一个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;requirment</span><br><span class="line">a = []</span><br><span class="line">a.append(1)</span><br><span class="line">a.append(1)</span><br><span class="line">print( &quot;1 1 &quot;,end = &#x27;&#x27; )</span><br><span class="line">for i in range( 3 , 30 ):</span><br><span class="line">    a.append( a[i-1] + a[i-2] )</span><br><span class="line">    print( a[i] , end = &#x27; &#x27; )</span><br><span class="line"></span><br><span class="line">a = 1</span><br><span class="line">b = 1</span><br><span class="line">print( &quot;1 1 &quot;,end = &#x27;&#x27; )</span><br><span class="line">for i in range( 1 , 40 ):</span><br><span class="line">    c = a + b</span><br><span class="line">    print( c , end = &#x27; &#x27; )</span><br><span class="line">    a = b</span><br><span class="line">    b = c</span><br><span class="line">#add_requirment:为什么要把第一位的1都改成0</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="AFCTF2018-Single"><a href="#AFCTF2018-Single" class="headerlink" title="[AFCTF2018]Single"></a>[AFCTF2018]Single</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;Plain.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">freopen(&quot;Cipher.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">map&lt;char, char&gt; f;</span><br><span class="line">int arr[26];</span><br><span class="line">for(int i=0;i&lt;26;++i)&#123;</span><br><span class="line">arr[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">random_shuffle(arr,arr+26);</span><br><span class="line">for(int i=0;i&lt;26;++i)&#123;</span><br><span class="line">f[&#x27;a&#x27;+i]=&#x27;a&#x27;+arr[i];</span><br><span class="line">f[&#x27;A&#x27;+i]=&#x27;A&#x27;+arr[i];</span><br><span class="line">&#125;</span><br><span class="line">char ch;</span><br><span class="line">while((ch=getchar())!=EOF)&#123;</span><br><span class="line">if(f.count(ch))&#123;</span><br><span class="line">putchar(f[ch]);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">putchar(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Jmqrida rva Lfmz (JRL) eu m uqajemf seny xl enlxdomrexn uajiderc jxoqarerexnu. Rvada mda rvdaa jxooxn rcqau xl JRLu: Paxqmdyc, Mrrmjs-Yalanja mny oekay.</span><br><span class="line"></span><br><span class="line">Paxqmdyc-urcfa JRLu vmu m jxiqfa xl giaurexnu (rmusu) en dmnza xl jmrazxdeau. Lxd akmoqfa, Wab, Lxdanuej, Jdcqrx, Benmdc xd uxoarvenz afua. Ramo jmn zmen uxoa qxenru lxd atadc uxftay rmus. Oxda qxenru lxd oxda jxoqfejmray rmusu iuimffc. Rva nakr rmus en jvmen jmn ba xqanay xnfc mlrad uxoa ramo uxfta qdatexiu rmus. Rvan rva zmoa reoa eu xtad uio xl qxenru uvxwu cxi m JRL wenad. Lmoxiu akmoqfa xl uijv JRL eu Yaljxn JRL gimfu.</span><br><span class="line"></span><br><span class="line">Waff, mrrmjs-yalanja eu mnxrvad enradaurenz seny xl jxoqarerexnu. Vada atadc ramo vmu xwn narwxds(xd xnfc xna vxur) werv tifnmdmbfa uadtejau. Cxid ramo vmu reoa lxd qmrjvenz cxid uadtejau mny yatafxqenz akqfxeru iuimffc. Ux, rvan xdzmnehadu jxnnajru qmdrejeqmnru xl jxoqarerexn mny rva wmdzmoa urmdru! Cxi uvxify qdxrajr xwn uadtejau lxd yalanja qxenru mny vmjs xqqxnanru lxd mrrmjs qxenru. Veurxdejmffc rveu eu m ledur rcqa xl JRLu, atadcbxyc snxwu mbxir YAL JXN JRL - uxoarvenz fesa m Wxdfy Jiq xl mff xrvad jxoqarerexnu.</span><br><span class="line"></span><br><span class="line">Oekay jxoqarerexnu omc tmdc qxuuebfa lxdomru. Er omc ba uxoarvenz fesa wmdzmoa werv uqajemf reoa lxd rmus-bmuay afaoanru (a.z. IJUB eJRL).</span><br><span class="line"></span><br><span class="line">JRL zmoau xlran rxijv xn omnc xrvad muqajru xl enlxdomrexn uajiderc: jdcqrxzdmqvc, urazx, benmdc mnmfcueu, datadua anzanaadenz, oxbefa uajiderc mny xrvadu. Zxxy ramou zanadmffc vmta urdxnz useffu mny akqadeanja en mff rvaua euuiau.</span><br><span class="line"></span><br><span class="line">Iuimffc, lfmz eu uxoa urdenz xl dmnyxo ymrm xd rakr en uxoa lxdomr. Akmoqfa mljrl&#123;Xv_I_lxiny_er_neja_rDc&#125;</span><br></pre></td></tr></table></figure><hr><p>词频分析即可得到flag</p><p><img src="image-20240127111855777.png" alt></p><p>flag:<code>flag&#123;Oh_U_found_it_nice_tRy&#125;</code></p><h3 id="鸡藕椒盐味"><a href="#鸡藕椒盐味" class="headerlink" title="鸡藕椒盐味"></a>鸡藕椒盐味</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">公司食堂最新出了一种小吃，叫鸡藕椒盐味汉堡，售价八块钱，为了促销，上面有一个验证码，输入后可以再换取一个汉堡。但是问题是每个验证码几乎都有错误,而且打印的时候倒了一下。小明买到了一个汉堡，准备还原验证码，因为一个吃不饱啊验证码如下：1100 1010 0000 ,而且打印的时候倒了一下。把答案哈希一下就可以提交了。(答案为正确值(不包括数字之间的空格)的32位md5值的小写形式) 注意：得到的 flag 请包上 flag&#123;&#125; 提交</span><br></pre></td></tr></table></figure><hr><p>奇校验：所有位（包括数据位和校验位）共含1个数为奇数</p><p>偶校验：所有位共含1个数为偶数</p><p>奇偶校验码能发现奇数个错误</p><p>海明校验码：校验位在 $2^n$ 的地方</p><p>可以算出密文是<code>110110100000</code></p><p>进行md5加密得到答案</p><p>flag:<code>flag&#123;d14084c7ceca6359eaac6df3c234dd3b&#125;</code></p><h3 id="ACTF新生赛2020-crypto-classic1"><a href="#ACTF新生赛2020-crypto-classic1" class="headerlink" title="[ACTF新生赛2020]crypto-classic1"></a>[ACTF新生赛2020]crypto-classic1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哇，这里有压缩包的密码哦，于是我低下了头，看向了我的双手，试图从中找到某些规律</span><br><span class="line">xdfv ujko98 edft54 xdfv pok,.; wsdr43</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRLU&#123;LZPL_S_UASHKXUPD_NXYTFTJT&#125;</span><br></pre></td></tr></table></figure><hr><p>第一层是传统脑洞题，键盘密码的一种</p><p>circle</p><p>第二层提示是维吉尼亚密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c=&#x27;SRLU&#123;LZPL_S_UASHKXUPD_NXYTFTJT&#125;&#x27;</span><br><span class="line">m=&#x27;ACTF&#123;&#x27;</span><br><span class="line">a=[]</span><br><span class="line">for i in range(4):</span><br><span class="line">    a.append(str(ord(c[i])-ord(m[i])))</span><br><span class="line">print(m,end=&#x27;&#x27;)</span><br><span class="line">for i in range(5,len(c)):</span><br><span class="line">    if &#x27;A&#x27;&lt;= c[i]&lt;= &#x27;Z&#x27;:</span><br><span class="line">        print(chr((ord(c[i])-int(a[i%4])-ord(&#x27;A&#x27;))%26+ord(&#x27;A&#x27;)),end=&#x27;&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(c[i],end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;what_a_classical_vigenere&#125;</code></p><h3 id="AFCTF2018-BASE"><a href="#AFCTF2018-BASE" class="headerlink" title="[AFCTF2018]BASE"></a>[AFCTF2018]BASE</h3><p>一个很大很大的文件</p><hr><p>读取文件，进行base系列自动解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import re, base64</span><br><span class="line">s = open(&#x27;flag_encode.txt&#x27;, &#x27;rb&#x27;).read()</span><br><span class="line">base16_dic = r&#x27;^[A-F0-9=]*$&#x27;</span><br><span class="line">base32_dic = r&#x27;^[A-Z2-7=]*$&#x27;</span><br><span class="line">base64_dic = r&#x27;^[A-Za-z0-9/+=]*$&#x27;</span><br><span class="line">n= 0</span><br><span class="line">while True:</span><br><span class="line">    n += 1</span><br><span class="line">    t = s.decode()</span><br><span class="line">    if &#x27;&#123;&#x27; in t:</span><br><span class="line">        print(t)</span><br><span class="line">        break</span><br><span class="line">    elif re.match(base16_dic, t):</span><br><span class="line">        s = base64.b16decode(s)</span><br><span class="line">        print(str(n) + &#x27; base16&#x27;)</span><br><span class="line">    elif re.match(base32_dic, t):</span><br><span class="line">        s = base64.b32decode(s)</span><br><span class="line">        print(str(n) + &#x27; base32&#x27;)</span><br><span class="line">    elif re.match(base64_dic, t):</span><br><span class="line">        s = base64.b64decode(s)</span><br><span class="line">        print(str(n) + &#x27; base64&#x27;)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;U_5h0u1d_Us3_T00l5&#125;</code></p><h3 id="UTCTF2020-basic-crypto"><a href="#UTCTF2020-basic-crypto" class="headerlink" title="[UTCTF2020]basic-crypto"></a>[UTCTF2020]basic-crypto</h3><p>很多二进制数，空格隔开</p><hr><p>二进制ascll码转字符得到</p><p><img src="image-20240127203144559.png" alt="image-20240127203144559" style="zoom:50%;"></p><p>之后解base64</p><p><img src="image-20240127203429627.png" alt="image-20240127203429627" style="zoom:50%;"></p><p>然后是凯撒密码</p><p><img src="image-20240127203611366.png" alt></p><p>对最后一段进行词频分析得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">congratulations! you have finished the beginner cryptography challenge. here is a flag for all your hard efforts: utflag&#123;n0w_th4ts_wh4t_i_c4ll_crypt0&#125;. you will find that a lot of cryptography is just building off this sort of basic knowledge, and it really is not so bad after all. hope you enjoyed the challenge!</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;n0w_th4ts_wh4t_i_c4ll_crypt0&#125;</code></p><h3 id="WUSTCTF2020-情书"><a href="#WUSTCTF2020-情书" class="headerlink" title="[WUSTCTF2020]情书"></a>[WUSTCTF2020]情书</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Premise: Enumerate the alphabet by 0、1、2、.....  、25</span><br><span class="line">Using the RSA system </span><br><span class="line">Encryption:0156 0821 1616 0041 0140 2130 1616 0793</span><br><span class="line">Public Key:2537 and 13</span><br><span class="line">Private Key:2537 and 937</span><br><span class="line"></span><br><span class="line">flag: wctf2020&#123;Decryption&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">c = &quot;0156 0821 1616 0041 0140 2130 1616 0793&quot;.split(&quot; &quot;)</span><br><span class="line"></span><br><span class="line">p = 43 ; q = 59</span><br><span class="line">e = 13 ; d = 937</span><br><span class="line">n = p * q ; phi = (p-1)*(q-1)</span><br><span class="line"></span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for i in c:</span><br><span class="line">    flag = flag + a[pow(int(i),d,n)]</span><br><span class="line"></span><br><span class="line">print (&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;iloveyou&#125;</code></p><h3 id="GUET-CTF2019-NO-SOS"><a href="#GUET-CTF2019-NO-SOS" class="headerlink" title="[GUET-CTF2019]NO SOS"></a>[GUET-CTF2019]NO SOS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..-.-.-.–…….–..-…-..-…–.-.-….-..-..–.-.-..-.-..—-</span><br></pre></td></tr></table></figure><hr><p>略加修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..-.-.-.--.......--..-...-..-...--.-.-....-..-..--.-.-..-.-..----</span><br></pre></td></tr></table></figure><p>解密得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aababababbaaaaaaabbaabaaabaabaaabbababaaaabaabaabbababaababaabbbb</span><br></pre></td></tr></table></figure><p>培根密码解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagisguetkkp</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;guetkkp&#125;</code></p><h3 id="UTCTF2020-zero"><a href="#UTCTF2020-zero" class="headerlink" title="[UTCTF2020]zero"></a>[UTCTF2020]zero</h3><p>一个文档</p><hr><p>零宽字符隐写<a href="https://330k.github.io/misc_tools/unicode_steganography.html">https://330k.github.io/misc_tools/unicode_steganography.html</a></p><p><img src="image-20240127221556092.png" alt></p><p>flag:<code>flag&#123;whyNOT@sc11_4927aajbqk14&#125;</code></p><h3 id="NPUCTF2020-Classical-Cipher"><a href="#NPUCTF2020-Classical-Cipher" class="headerlink" title="[NPUCTF2020]Classical Cipher"></a>[NPUCTF2020]Classical Cipher</h3><p>一个文件</p><hr><p>使用<a href="https://quipqiup.com/爆破密码">https://quipqiup.com/爆破密码</a></p><p>密码：<code>the_key_is_atbash</code></p><p><img src="image-20240127213243685.png" alt></p><p>猪圈密码+古埃及象形文字<a href="http://news.558idc.com/291134.html">http://news.558idc.com/291134.html</a></p><p><img src="image-20240127213313022.png" alt="image-20240127213313022" style="zoom:33%;"></p><p><img src="image-20240127213358381.png" alt="image-20240127213358381" style="zoom:33%;"></p><p><img src="image-20240127213419878.png" alt="image-20240127213419878" style="zoom:33%;"></p><p>flag:<code>flag&#123;classicalcode&#125;</code></p><h3 id="四面八方"><a href="#四面八方" class="headerlink" title="四面八方"></a>四面八方</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key1:security</span><br><span class="line">key2:information</span><br><span class="line"></span><br><span class="line">密文啊这是，骚年加油：zhnjinhoopcfcuktlj</span><br></pre></td></tr></table></figure><hr><p>四方密码<a href="http://www.hiencode.com/four.html">http://www.hiencode.com/four.html</a></p><p>flag:<code>flag&#123;yaungandsuccessful&#125;</code></p><h3 id="BJDCTF2020-Polybius"><a href="#BJDCTF2020-Polybius" class="headerlink" title="[BJDCTF2020]Polybius"></a>[BJDCTF2020]Polybius</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密文：ouauuuoooeeaaiaeauieuooeeiea</span><br><span class="line">hint：VGhlIGxlbmd0aCBvZiB0aGlzIHBsYWludGV4dDogMTQ=</span><br><span class="line">flag:解出明文后，请加上BJD&#123;&#125;</span><br></pre></td></tr></table></figure><hr><p>波利比奥斯密码</p><p>根据提示，长度是14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">s=&quot;aeoiu&quot;</span><br><span class="line">sumresult=[] ; numsumresult=[]</span><br><span class="line">ciper=&quot;ouauuuoooeeaaiaeauieuooeeiea&quot;</span><br><span class="line">for i in itertools.permutations(s,5):</span><br><span class="line">    sumresult.append(&quot;&quot;.join(i))</span><br><span class="line">for i in sumresult:</span><br><span class="line">    temp=&quot;&quot;</span><br><span class="line">    for j in ciper:</span><br><span class="line">        temp+=str(i.index(j)+1)</span><br><span class="line">    numsumresult.append(temp)</span><br><span class="line">for i in numsumresult:</span><br><span class="line">    flag=&quot;&quot;</span><br><span class="line">    for j in range(0, len(i),2):</span><br><span class="line">        xx=(int(i[j])-1)*5+int(i[j+1])+96</span><br><span class="line">        if xx&gt;ord(&#x27;i&#x27;):</span><br><span class="line">            xx+=1</span><br><span class="line">        flag+=chr(xx)</span><br><span class="line">    print( flag )</span><br></pre></td></tr></table></figure><p>得到<code>flagispolybius</code></p><p>flag:<code>flag&#123;flagispolybius&#125;</code></p><h1 id="救世捷径"><a href="#救世捷径" class="headerlink" title="救世捷径"></a>救世捷径</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">一个名叫CPU的神秘大陆有26个国家，有些国家之间会有一条无向路，每条路径都有不同的长度和一段神秘代码，救世主尼奥要从国家1出发，赶往国家26拯救大陆，请你帮助救世主选择最短路径，而走过的路的神秘代码连接起来便是flag。 以下是数行数据，每行第一个，第二个数字代表这条路的两个端点国家，第三个数字代表路途长度，最后一个字符串便是神秘代码。路在附件中~ 帮助救世主尼奥吧，他快被吓尿了。。。 注意：得到的 flag 请包上 flag&#123;&#125; 提交</span><br><span class="line">1 2 100 FLAG&#123;</span><br><span class="line">2 3 87 AFQWE</span><br><span class="line">2 4 57 ETKLS</span><br><span class="line">2 5 50 WEIVK</span><br><span class="line">2 6 51 AWEIW</span><br><span class="line">3 7 94 QIECJF</span><br><span class="line">3 8 78 QSXKE</span><br><span class="line">3 9 85 QWEIH</span><br><span class="line">4 13 54 WQOJF</span><br><span class="line">4 14 47 KDNVE</span><br><span class="line">4 15 98 QISNV</span><br><span class="line">5 10 43 AEWJV</span><br><span class="line">5 11 32 QWKXF</span><br><span class="line">5 12 44 ASJVL</span><br><span class="line">6 16 59 ASJXJ</span><br><span class="line">6 17 92 QJXNV</span><br><span class="line">6 18 39 SCJJF</span><br><span class="line">6 23 99 SJVHF</span><br><span class="line">7 19 99 WJCNF</span><br><span class="line">8 20 96 SKCNG</span><br><span class="line">9 20 86 SJXHF</span><br><span class="line">10 21 60 SJJCH</span><br><span class="line">11 21 57 SJHGG</span><br><span class="line">12 22 47 SJCHF</span><br><span class="line">14 10 55 EJFHG</span><br><span class="line">16 17 59 ASJVH</span><br><span class="line">18 12 53 SJFHG</span><br><span class="line">18 24 93 SHFVG</span><br><span class="line">21 22 33 SJFHB</span><br><span class="line">19 25 88 ASHHF</span><br><span class="line">20 25 96 SJVHG</span><br><span class="line">22 25 23 SJVHJ</span><br><span class="line">25 26 75 SDEV&#125;</span><br></pre></td></tr></table></figure><hr><p>最短路问题 <a href="https://www.luogu.com.cn/problem/P4779">洛谷·P4779 【模板】单源最短路径（标准版）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">g = []</span><br><span class="line">for i in range( 27 ):</span><br><span class="line">    g.append([])</span><br><span class="line">for i in range( 27 ):</span><br><span class="line">    for j in range( 27 ):</span><br><span class="line">        g[i].append( 1000000 )</span><br><span class="line">f = open( &#x27;c.txt&#x27; , &#x27;r&#x27; ).readlines()</span><br><span class="line">l = []</span><br><span class="line">for i in f:</span><br><span class="line">    l.append(i.strip().split(&#x27; &#x27;))</span><br><span class="line">print( l )</span><br><span class="line">for i in l:</span><br><span class="line">    print( i )</span><br><span class="line">    g[int(i[0])][int(i[1])] = int( i[2] )</span><br><span class="line">    g[int(i[1])][int(i[0])] = int( i[2] )</span><br><span class="line"></span><br><span class="line">def dij():</span><br><span class="line">    dv = [1000000 for i in range(27)]</span><br><span class="line">    route = [1 for i in range(27)]</span><br><span class="line">    vis = [0 for i in range(27)]</span><br><span class="line">    for i in range( 2 , 27 ):</span><br><span class="line">        dv[i] = g[i][1]</span><br><span class="line">    dv[1] = 0</span><br><span class="line">    vis[1] = 1</span><br><span class="line">    for i in range(26):</span><br><span class="line">        minn = 1000000</span><br><span class="line">        tmp = -1</span><br><span class="line">        for j in range( 2 , 27 ):</span><br><span class="line">            if vis[j] == 0 and minn &gt; dv[j]:</span><br><span class="line">                minn = dv[j]</span><br><span class="line">                tmp = j</span><br><span class="line">        vis[tmp] = 1</span><br><span class="line">        for j in range( 2 , 27 ):</span><br><span class="line">            if dv[j] &gt; dv[tmp] + g[tmp][j]:</span><br><span class="line">                dv[j] = dv[tmp] + g[tmp][j]</span><br><span class="line">                route[j] = tmp</span><br><span class="line">    return ( route , dv )</span><br><span class="line"></span><br><span class="line">route , dv = dij()</span><br><span class="line">y = 26</span><br><span class="line">while y!=1:</span><br><span class="line">    print( y )</span><br><span class="line">    y = route[y]</span><br></pre></td></tr></table></figure><p>得到路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">25</span><br><span class="line">22</span><br><span class="line">12</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>得到flag</p><p>flag:<code>flag&#123;WEIVKASJVLSJCHFSJVHJSDEV&#125;</code></p><h2 id="坏蛋是雷宾"><a href="#坏蛋是雷宾" class="headerlink" title="坏蛋是雷宾"></a>坏蛋是雷宾</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">老牌刺客之王混进了女王的住所。一天，女王得到了一个匿名举报，说她的侍卫里有一个刺客，叫做Rabin，而他的信息就在一份文件里，文件中有附带一个Pk，是523798549，密文是162853095，校验码二进制值是110001，根据说明是放在明文后一起加密的，明文与密文长度相同。加密算法和这位老牌刺客同名。快拯救女王，答案是求得的明文，进行32位md5小写哈希字符串，提交即可。 注意：得到的 flag 请包上 flag&#123;&#125; 提交</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">import hashlib</span><br><span class="line">n=523798549</span><br><span class="line">p=10663</span><br><span class="line">q=49123</span><br><span class="line">e=2</span><br><span class="line">c=162853095</span><br><span class="line">inv_p = invert(p, q)</span><br><span class="line">inv_q = invert(q, p)</span><br><span class="line"></span><br><span class="line">mp = powmod(c, (p + 1) // 4, p)</span><br><span class="line">mq = powmod(c, (q + 1) // 4, q)</span><br><span class="line"></span><br><span class="line">a = (inv_p * p * mq + inv_q * q * mp) % n</span><br><span class="line">b = n - int(a)</span><br><span class="line">c = (inv_p * p * mq - inv_q * q * mp) % n</span><br><span class="line">d = n - int(c)</span><br><span class="line"></span><br><span class="line">for i in (a, b, c, d):</span><br><span class="line">    print(bin(i)[2:])</span><br><span class="line">    </span><br><span class="line">m=&#x27;10010011100100100101010&#x27;</span><br><span class="line">mc=str(int(m,2))</span><br><span class="line">md=hashlib.md5()</span><br><span class="line">md.update(mc.encode(&quot;utf8&quot;))</span><br><span class="line">print( md.hexdigest() )</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;ca5cec442b2734735406d78c88e90f35&#125;</code></p><h2 id="BJDCTF2020-编码与调制"><a href="#BJDCTF2020-编码与调制" class="headerlink" title="[BJDCTF2020]编码与调制"></a>[BJDCTF2020]编码与调制</h2><p>tag：差分曼彻斯特编码</p><p><img src="image-20240208182640371.png" alt="image-20240208182640371" style="zoom:33%;"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密文：2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6</span><br></pre></td></tr></table></figure><hr><p>（好像从哪里见过，而且这道题更简单一点）见代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">txt = &quot;2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6&quot;</span><br><span class="line">txt = bin(int( txt , 16 ))[2:]</span><br><span class="line">m = &quot;&quot;</span><br><span class="line"></span><br><span class="line">for i in range( 0,len(str(txt)),2 ):</span><br><span class="line">    if txt[i] == &quot;0&quot;:</span><br><span class="line">        m += &quot;0&quot;</span><br><span class="line">    else:</span><br><span class="line">        m += &quot;1&quot;</span><br><span class="line"></span><br><span class="line">print( long_to_bytes(int(m,2)) )</span><br></pre></td></tr></table></figure><p>flag:<code>BJD&#123;DifManchestercode&#125;</code></p><h2 id="EasyProgram"><a href="#EasyProgram" class="headerlink" title="EasyProgram"></a>EasyProgram</h2><p>tag:misc</p><p><img src="image-20240208214801863.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">get buf unsign s[256]</span><br><span class="line">get buf t[256]</span><br><span class="line">we have key:whoami</span><br><span class="line">we have flag:????????????????????????????????</span><br><span class="line"></span><br><span class="line">for i:0 to 256</span><br><span class="line">    set s[i]:i</span><br><span class="line"></span><br><span class="line">for i:0 to 256</span><br><span class="line">    set t[i]:key[(i)mod(key.lenth)]</span><br><span class="line"></span><br><span class="line">for i:0 to 256</span><br><span class="line">    set j:(j+s[i]+t[i])mod(256)</span><br><span class="line">        swap:s[i],s[j]</span><br><span class="line"></span><br><span class="line">for m:0 to 38</span><br><span class="line">    set i:(i + 1)mod(256)</span><br><span class="line">    set j:(j + S[i])mod(256)</span><br><span class="line">    swap:s[i],s[j]</span><br><span class="line">    set x:(s[i] + (s[j]mod(256))mod(256))</span><br><span class="line">    set flag[m]:flag[m]^s[x]</span><br><span class="line"></span><br><span class="line">fprint flagx to file</span><br></pre></td></tr></table></figure><hr><p>因为和flag相关的只有异或操作，可逆，故加密和解密过程代码相同</p><p>伪代码不初始化默认为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">txt = &quot; 00 BA 8F 11 2B 22 9F 51 A1 2F AB B7 4B D7 3F EF E1 B5 13 BE C4 D4 5D 03 D9 00 7A CA 1D 51 A4 73 B5 EF 3D 9B 31 B3&quot;.replace(&quot; &quot;,&quot; 0x&quot;).split(&quot; &quot;)[1:]</span><br><span class="line">key = &quot;whoami&quot;</span><br><span class="line"></span><br><span class="line">s = []</span><br><span class="line">t = []</span><br><span class="line">for i in range( 256 ):</span><br><span class="line">    s.append(i)</span><br><span class="line">for i in range( 256 ):</span><br><span class="line">    t.append(key[i%len(key)])</span><br><span class="line"></span><br><span class="line">j = 0</span><br><span class="line">for i in range( 256 ):</span><br><span class="line">    j = ( j + s[i] + ord( t[i] ) ) % 256</span><br><span class="line">    s[i] , s[j] = s[j] , s[i]</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">j = 0</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for m in range( 38 ):</span><br><span class="line">    i = ( i + 1 ) % 256</span><br><span class="line">    j = ( j + s[i] ) % 256</span><br><span class="line">    s[i] , s[j] = s[j] , s[i]</span><br><span class="line">    x = ( s[i] + ( s[j] % 256 ) ) % 256</span><br><span class="line">    flag += chr( int(txt[m],16) ^ s[x] )</span><br><span class="line"></span><br><span class="line">print( flag )</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;f238yu28323uf28u2yef2ud8uf289euf&#125;</code></p><h2 id="UTCTF2020-hill"><a href="#UTCTF2020-hill" class="headerlink" title="[UTCTF2020]hill"></a>[UTCTF2020]hill</h2><p>tag:线性代数 | 希尔密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wznqca&#123;d4uqop0fk_q1nwofDbzg_eu&#125;</span><br></pre></td></tr></table></figure><hr><p>希尔密码：左乘一个密钥矩阵进行加密</p><p>flag前六位为：<code>utflag</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m = &quot;wznqca&quot;</span><br><span class="line">c = &quot;utflag&quot;</span><br><span class="line"></span><br><span class="line">for i in m:</span><br><span class="line">    if ord(i)&gt;=ord(&#x27;a&#x27;) and ord(i)&lt;=ord(&#x27;z&#x27;):</span><br><span class="line">        print( ord(i) - ord(&#x27;a&#x27;) , end = &quot; &quot; )</span><br><span class="line">print()</span><br><span class="line">for i in c:</span><br><span class="line">    if ord(i)&gt;=ord(&#x27;a&#x27;) and ord(i)&lt;=ord(&#x27;z&#x27;):</span><br><span class="line">        print( ord(i) - ord(&#x27;a&#x27;) , end = &quot; &quot; )</span><br></pre></td></tr></table></figure><p>得到 $K^{-1}*M=C \ mod \ 26$</p><p><img src="fsadhjgnbsfegrdthf.jpg" alt></p><p>有两种方式，一种是暴力搜索，另一种是解方程（翻译：手搓），这里我们只写第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line">M = mat([[22,13,2],[25,16,0]])</span><br><span class="line">C = mat([[20,5,0],[19,11,6]])</span><br><span class="line"></span><br><span class="line">for a in range( 100 ):</span><br><span class="line">    for b in range( 100 ):</span><br><span class="line">        for c in range( 100 ):</span><br><span class="line">            for d in range( 100 ):</span><br><span class="line">                K = mat([[a,b],[c,d]])</span><br><span class="line">                if ((K*C)%26==M).all():</span><br><span class="line">                    print( K )</span><br><span class="line">                    assert 0</span><br></pre></td></tr></table></figure><p>得到$K$的一个解是<code>[[ 1 22],[11 13]]</code></p><p>有了密钥，使用<a href="http://practicalcryptography.com/ciphers/hill-cipher/">在线工具</a>即可得到flag</p><p><img src="image-20240209150414038.png" alt="image-20240209150414038" style="zoom:50%;"></p><p>填回其他字符，修正大小写即可</p><p>flag:<code>utflag&#123;d4nger0us_c1pherText_qq&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SM9的属性基在线离线签名方案 论文阅读总结</title>
      <link href="/2024/09/24/%E5%9F%BA%E4%BA%8ESM9%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%88-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2024/09/24/%E5%9F%BA%E4%BA%8ESM9%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%88-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文用于记录 <a href="https://crad.ict.ac.cn/article/doi/10.7544/issn1000-1239.202220530">本篇论文</a> 的阅读和知识总结与学习</p><span id="more"></span><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>SM9;在线/离线签名;属性基签名;随机谕言机模型;q-SDH 问题</p><h4 id="SM9算法"><a href="#SM9算法" class="headerlink" title="SM9算法"></a><a href="https://openstd.samr.gov.cn/bzgk/gb/std_list?p.p1=0&amp;p.p90=circulation_date&amp;p.p91=desc&amp;p.p2=sm9">SM9算法</a></h4><p>基于双线性对，可以实现属性基加密签名</p><p>相对而言，SM2基于椭圆曲线，无属性基相关属性</p><h4 id="在线-离线签名"><a href="#在线-离线签名" class="headerlink" title="在线/离线签名"></a><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=e8e24b884e1004dbf28e5af58a2532fa3576d370">在线/离线签名</a></h4><p>在线签名在服务器（可信的）等设备上进行，离线签名在轻量级设备上；离线签名在在线签名的基础上进行签名，可以减少轻量级设备的运算开销</p><h4 id="随机谕言机模型"><a href="#随机谕言机模型" class="headerlink" title="随机谕言机模型"></a>随机谕言机模型</h4><p>可以视为一个安全的哈希函数</p><h4 id="q-SDH-问题"><a href="#q-SDH-问题" class="headerlink" title="q-SDH 问题"></a><a href="https://eprint.iacr.org/2010/215.pdf">q-SDH 问题</a></h4><p>多个参与者的DH密钥交换，而且更强，而且抗量子</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="双线性映射"><a href="#双线性映射" class="headerlink" title="双线性映射"></a>双线性映射</h4><p>给定安全系数 <a href="#kappa">$\kappa$</a>，生成一个双线性元组 $BP=(G_1,G_2,G_T,e,p)$ </p><p>令 $P$ 是 $G_1$ 的一个<a href="#生成元">生成元</a>，令 $Q$ 是 $G_2$ 的一个生成元，一个双线性映射 $e:G_1\times G_2\rightarrow G_T$ 有：<a href="#三个性质">双线性 非退化性 可计算性</a> 三个性质</p><p>此外，在 $G_1$ 和 $G_2$ 之间存在一个能有效且能公开计算的<a href="#同构映射">同构映射</a> $\psi:G_2\rightarrow G_1$ ，即 $\psi(Q)=P$</p><h4 id="q-SDH-q-strong-Diffie-Hellman-困难问题和困难问题假设"><a href="#q-SDH-q-strong-Diffie-Hellman-困难问题和困难问题假设" class="headerlink" title="q-SDH(q-strong Diffie-Hellman) 困难问题和困难问题假设"></a>q-SDH(q-strong Diffie-Hellman) 困难问题和困难问题假设</h4><p>q-SDH困难问题，令 $P,Q$ 分别为 $G_1,G_2$ 的生成元，在 $(G_1,G_2)$ 群上的 q-SDH 问题可以表述为：给定 $q+2$ 个元素的元组 $(P,Q,aQ,a^2Q,…,a^qQ)$ ，找到一堆元素 $(c,\frac{1}{c+a}P)$ ，其中 $c\in \mathbb{Z}_p^*$</p><p>$(t,\varepsilon)-$q-SDH 困难问题假设：若不存在概率多项式时间 $t$ 的算法至少以不可忽略的概率 $\varepsilon$ 解决 $(G_1,G_2)$ 上的 q-SDH 问题，则称 q-SDH 问题在 $(G_1,G_2)$ 是 $(t,\varepsilon)$ 困难的</p><p><code>q-strong</code> 指的是 $q$ 个用户，而不是量子<code>quantum</code>的意思</p><h4 id="分叉引理"><a href="#分叉引理" class="headerlink" title="分叉引理"></a><a href="#分叉引理">分叉引理</a></h4><p>看不懂一点，暂时跳过</p><h2 id="形式化定义和安全模型"><a href="#形式化定义和安全模型" class="headerlink" title="形式化定义和安全模型"></a>形式化定义和安全模型</h2><p><img src="image-20240925143622469.png" alt></p><h4 id="ABOOS方案的形式化定义"><a href="#ABOOS方案的形式化定义" class="headerlink" title="ABOOS方案的形式化定义"></a>ABOOS方案的形式化定义</h4><h4 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h4><h2 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h4 id="kappa"><a href="#kappa" class="headerlink" title="$\kappa$"></a>$\kappa$<span id="kappa"></span></h4><p>安全系数 $\kappa$，LaTex写作 <code>kappa</code>，通常用来量化密码系统抵抗攻击的强度</p><p>它表示安全性级别，通常与密钥长度、加密算法的复杂性等因素相关。较大的 $\kappa$ 值意味着更强的安全性，抵御暴力破解和其他攻击的能力更强。</p><p>一个经典的例子是基于双线性映射的身份基加密（IBE）。在IBE中，用户的公钥可以是其身份信息（如电子邮件地址），而私钥由一个私钥生成中心生成。假设安全系数 $\kappa$ 为 128 位，这意味着攻击者需要消耗大约 $2^{128}$ 次操作才能成功破解密钥。通过双线性映射，公钥和私钥的生成、加密和解密操作可以高效完成，同时保持与 $\kappa$ 相关的安全性。</p><h4 id="生成元"><a href="#生成元" class="headerlink" title="生成元"></a>生成元<span id="生成元"></span></h4><p>一个元素 $g$ 称为群 $G$ 的生成元，如果对于群 $G$ 中的任意元素 $x$，存在一个整数 $k$ 使得 $x = g^k$。换句话说，生成元是通过其幂（或反复运算）可以生成群中所有元素的元素。</p><h4 id="双线性-非退化性-可计算性"><a href="#双线性-非退化性-可计算性" class="headerlink" title="双线性 非退化性 可计算性"></a>双线性 非退化性 可计算性<span id="三个性质"></span></h4><ul><li>双线性 $e(aP,bQ)=e(P,Q)^{ab}$</li></ul><p>具体的，如果 $a=2,b=3$，那么 $e(2P, 3Q) = e(P, Q)^{2 \times 3} = e(P, Q)^6$。</p><ul><li>非退化性 任意 $P\in G_1,Q\in G_2$，有 \neq 1$</li></ul><p>只要 $P$ 和 $Q$ 同时是有效的点，则 $e(P,Q)$ 必然不等于 $1$</p><ul><li>可计算性 任意 $P\in G_1,Q\in G_2$，有 $e(P,Q)$ 可以被有效计算</li></ul><p>映射 $e(P, Q)$ 应能在多项式时间内计算。如果你有 $P$ 和 $Q$ 的坐标，可以通过预先定义的双线性映射算法快速计算出 $e(P, Q)$。</p><h4 id="同构映射"><a href="#同构映射" class="headerlink" title="同构映射"></a>同构映射<span id="同构映射"></span></h4><p>对于两个群，一个映射 $\psi:G_2\rightarrow G_1$，需要满足：</p><ol><li>一一对应 $a,b\in G_2$，如果 $\psi(a)=\psi(b)$，则 $a=b$</li><li>运算保持 $a,b\in G_2$，都有 $\psi(a\cdot b)=\psi(a)\cdot\psi(b)$</li></ol><p>同构映射是可逆的</p><h4 id="分叉引理-1"><a href="#分叉引理-1" class="headerlink" title="分叉引理"></a>分叉引理<span id="分叉引理"></span></h4><p>若攻击者能够成功生成有效的签名，即使在有限的查询次数后，我们可以利用这一点来构造另一个有效签名，这通常通过一种“分叉”的方式实现。</p><ol><li><p>输入与图灵机：</p><ul><li>令 $A$ 为一个输入仅包含公共信息的概率多项式时间的图灵机。这意味着 $A$ 是一个能在多项式时间内运行的算法，且其输入不包含秘密信息（例如签名密钥）。</li></ul></li><li><p>签名查询与随机谕言机：</p><ul><li>$A$ 进行 $n$ 次签名查询和 $m$ 次随机谕言机查询。签名查询是指 $A$ 请求生成某个消息的签名，而随机谕言机查询则是指 $A$ 请求随机数或其它公用信息。</li></ul></li><li><p>生成有效签名元组：</p><ul><li>敌手 $A$ 可以在概率多项式时间内，以 $\epsilon$ 的概率产生一个有效的消息签名元组 $(m, \sigma)$，其中 $m$ 是消息，$\sigma$ 是该消息的签名，且 $H(m)$ 表示与消息 $m$ 相关的哈希值。</li></ul></li><li><p>不可区分的分布：</p><ul><li>如果这个签名元组可以在不知道签名密钥的情况下以不可区分的分布概率进行模拟，意味着攻击者 $A$ 的行为与一个理想模型中没有秘密信息的情况没有显著差异。</li></ul></li><li><p>构造另一台图灵机：</p><ul><li>根据分叉引理，如果存在这样一个模拟，那么就存在另一台概率多项式时间的图灵机 $B$，它可以在理想情况下，通过控制攻击者 $A$ 的模拟与签名者的交互，生成两个有效的消息签名元组 $(m_1, \sigma_1)$ 和 $(m_2, \sigma_2)$，使得这两个签名都是有效的，并且 $H(m_1) = H(m_2)$。</li></ul></li></ol><p>通过分叉引理，证明了即使攻击者 $A$ 能够生成有效的签名，我们仍然可以利用这一过程来找到两个不同的消息的签名，使得它们具有相同的哈希值，从而说明签名方案的安全性是值得怀疑的。这通常意味着该方案不满足抗重放攻击或抗伪造攻击的要求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于维纳攻击的学习总结</title>
      <link href="/2024/09/23/%E5%85%B3%E4%BA%8E%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2024/09/23/%E5%85%B3%E4%BA%8E%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>嘻嘻，还没开始写</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/400818185">https://zhuanlan.zhihu.com/p/400818185</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo新建博客但是要求输入第二行</title>
      <link href="/2024/09/21/hexo%E6%96%B0%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BD%86%E6%98%AF%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E7%AC%AC%E4%BA%8C%E8%A1%8C/"/>
      <url>/2024/09/21/hexo%E6%96%B0%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%BD%86%E6%98%AF%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E7%AC%AC%E4%BA%8C%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>今天遇到了以下问题</p><p><img src="image-20240921214332499.png" alt></p><p>解决方案：引号输入改为英文（字体太小了没看到（悲</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>撬开后量子的大门</title>
      <link href="/2024/09/21/%E6%92%AC%E5%BC%80%E5%90%8E%E9%87%8F%E5%AD%90%E7%9A%84%E5%A4%A7%E9%97%A8/"/>
      <url>/2024/09/21/%E6%92%AC%E5%BC%80%E5%90%8E%E9%87%8F%E5%AD%90%E7%9A%84%E5%A4%A7%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>笔者刚开始接触后量子，这里是学习笔记</p><span id="more"></span><h2 id="量子力学基础"><a href="#量子力学基础" class="headerlink" title="量子力学基础"></a>量子力学基础</h2><h3 id="量子叠加原理"><a href="#量子叠加原理" class="headerlink" title="量子叠加原理"></a>量子叠加原理</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>一个量子系统可以同时处于多个可能状态的叠加状态，而不是像经典物理中那样只能处于一个确定的状态。这意味着，一个量子比特（qubit）可以同时表示0和1两种状态的叠加态，而不仅仅是0或1。这种量子叠加为量子计算提供了并行计算的能力，使得量子计算机能够在某些问题上比传统计算机更快地得出答案。</p><p>叠加原理可以用一个简单的例子来说明。假设我们有一个量子比特，它是一个自旋向上的电子和一个自旋向下的电子的叠加态。根据量子叠加原理，这个量子比特可以同时表示自旋向上和自旋向下的状态。当我们对这个量子比特进行测量时，它只会塌缩到一个确定的状态，即自旋向上或自旋向下，但测量前的状态是两者同时存在的。</p><h4 id="数学表示："><a href="#数学表示：" class="headerlink" title="数学表示："></a>数学表示：</h4><p>假设一个量子比特有两个状态，记为 $|0\rangle$ 和 $|1\rangle$。量子叠加态可以用一个线性组合来表示：</p><p>$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$</p><p>其中 $\alpha$ 和 $\beta$ 是复数，并且满足：</p><p>$|\alpha|^2 + |\beta|^2 = 1$</p><p>这是因为测量的概率必须等于1，$|\alpha|^2$ 和 $|\beta|^2$ 分别表示测量结果为 $|0\rangle$ 和 $|1\rangle$ 的概率。</p><h3 id="量子纠缠原理"><a href="#量子纠缠原理" class="headerlink" title="量子纠缠原理"></a>量子纠缠原理</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>量子纠缠是一种特殊的量子态，其中多个量子比特的状态是相互关联的，不能单独描述一个量子比特的状态。</p><p>纠缠态不能用独立的量子比特描述，纠缠的特性是量子信息传递中的重要资源，如量子通信和量子密钥分发（QKD）。</p><h4 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h4><p>对于两个量子比特系统，一个典型的纠缠态是<strong>Bell态</strong><a href="#Bell态">$^{(1)}$</a>，如：</p><p>$|\psi\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$</p><p>这意味着两个量子比特的状态是共同决定的，如果测量第一个比特为0，那么第二个比特也必然是0，反之亦然。两者之间的状态是完全纠缠的。</p><h3 id="量子测量"><a href="#量子测量" class="headerlink" title="量子测量"></a>量子测量</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>量子测量是指对量子态进行观测，测量会导致量子态的坍缩（collapse），即量子系统从叠加态“坍缩”到一个确定的状态。</p><p>量子测量的不可预测性是量子力学的本质特性之一，测量后系统的叠加态消失，转变为经典状态。</p><h4 id="数学表示-1"><a href="#数学表示-1" class="headerlink" title="数学表示"></a>数学表示</h4><p>如果一个量子比特处于叠加态 $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$，测量后系统会以概率 $|\alpha|^2$ 得到结果 $|0\rangle$，以概率 $|\beta|^2$ 得到结果 $|1\rangle$，测量会使系统坍缩到测量所得的状态。</p><hr><h3 id="量子态"><a href="#量子态" class="headerlink" title="量子态"></a>量子态</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>量子态是描述量子系统的完整信息，可以是单个粒子的状态，也可以是多个粒子的联合状态。</p><h4 id="数学表示-2"><a href="#数学表示-2" class="headerlink" title="数学表示"></a>数学表示</h4><p>单个量子比特的量子态如 $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$。多个量子比特的量子态则是张量积，比如两个量子比特的状态可以表示为：</p><p>$|\psi\rangle = (\alpha_1|0\rangle + \beta_1|1\rangle) \otimes (\alpha_2|0\rangle + \beta_2|1\rangle)$</p><p>张量积是构建多比特系统的重要工具。</p><h3 id="量子比特（qubit）"><a href="#量子比特（qubit）" class="headerlink" title="量子比特（qubit）"></a>量子比特（qubit）</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>量子比特是量子计算的基本单位，类似于经典计算中的比特。不同之处在于量子比特可以处于 $|0\rangle$、$|1\rangle$ 或两者的叠加状态。</p><p>量子比特可以通过叠加、纠缠、操作等多种方式处理信息，具有比经典比特更强大的信息表达和处理能力。</p><h4 id="数学表示-3"><a href="#数学表示-3" class="headerlink" title="数学表示"></a>数学表示</h4><p>量子比特的状态 $|\psi\rangle$ 可以表示为：</p><p>$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$</p><p>其中 $\alpha$ 和 $\beta$ 是满足 $|\alpha|^2 + |\beta|^2 = 1$ 的复数。</p><h3 id="量子门操作"><a href="#量子门操作" class="headerlink" title="量子门操作"></a>量子门操作</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>量子门是对量子态进行操作的基本单元，类似于经典计算中的逻辑门。量子门操作是可逆的，并且可以用矩阵来表示。</p><p>量子门可以实现各种量子态操作，是构建量子电路和量子算法的基础。</p><h4 id="常见的量子门操作"><a href="#常见的量子门操作" class="headerlink" title="常见的量子门操作"></a>常见的量子门操作</h4><ol><li><p>Hadamard门（H门）：将一个量子比特从经典态转变为叠加态：</p><p>$H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 &amp; 1 \ 1 &amp; -1 \end{pmatrix}$</p><p>对状态 $|0\rangle$ 和 $|1\rangle$ 的作用为：</p><p>$H|0\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle), \quad H|1\rangle = \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$</p></li><li><p>Pauli门（X、Y、Z门）：</p><ul><li><p>$X$ 门类似于经典的NOT门，交换 $|0\rangle$ 和 $|1\rangle$：</p><p>$X = \begin{pmatrix} 0 &amp; 1 \ 1 &amp; 0 \end{pmatrix}$</p></li><li><p>$Y$ 和 $Z$ 门分别进行不同的相位操作：</p><p>$Y = \begin{pmatrix} 0 &amp; -i \ i &amp; 0 \end{pmatrix}, \quad Z = \begin{pmatrix} 1 &amp; 0 \ 0 &amp; -1 \end{pmatrix}$</p></li></ul></li><li><p>CNOT门（控制非门）：一个两比特门，作用是翻转目标比特的状态，但仅当控制比特为 $|1\rangle$ 时才翻转：</p><p>$CNOT = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 \ 0 &amp; 0 &amp; 1 &amp; 0 \end{pmatrix}$</p></li></ol><h2 id="量子计算原理"><a href="#量子计算原理" class="headerlink" title="量子计算原理"></a>量子计算原理</h2><h3 id="shor算法"><a href="#shor算法" class="headerlink" title="shor算法"></a>shor算法</h3><p>Shor算法的高效性在于其量子部分能在多项式时间内找到周期，而这个周期信息又能用来找到大整数的因子。正因如此，Shor算法被视为量子计算对现有公钥密码体制（如RSA）的威胁。</p><p>目标：用于因式分解大整数，破解基于大数分解难题的公钥密码（如RSA）。</p><p>工作原理：</p><ol><li><p>选择随机数：选择一个随机整数 $a$，使其小于待分解的整数 $N$（即 $1 &lt; a &lt; N$）。</p></li><li><p>计算最大公约数：计算 $\text{gcd}(a, N)$，如果结果大于1，则找到了一个因子。这一步可以使用欧几里得算法在经典计算机上完成。</p></li><li><p>量子周期性：如果 $\text{gcd}(a, N) = 1$，则继续执行以下步骤：</p><ul><li>找到一个周期 $r$，使得 $a^r \equiv 1 \mod N$</li><li>这意味着 $a$ 的 $r$ 次幂模 $N$ 为1。</li></ul></li><li><p>使用量子计算找周期：利用量子傅里叶变换（QFT）找到周期 $r$。具体步骤：</p><ul><li>初始化量子位：准备一个包含 $2n$ 个量子位的系统，$n$ 是 $N$ 的位数。</li><li>超位置态：将量子位置于超位置态，表示所有可能的结果。</li><li>应用oracle：通过一个oracle函数来实现对 $a^x \mod N$ 的计算，从而编码周期信息。</li><li>量子傅里叶变换（QFT）：对量子位（一个周期函数）进行量子傅里叶变换，提取周期的信息，周期与整数因式相关联。</li></ul></li><li><p>测量和计算：</p><ul><li>测量量子态，得到的结果可以用于估计周期 $r$（即解决离散对数问题）</li><li>使用继续的经典算法，验证找到的 $r$ 是否符合 $a^r \equiv 1 \mod N$。</li></ul></li><li><p>找到因子：</p><ul><li><p>确定 $r$ 后，检查 $r$ 是否为偶数。</p></li><li><p>如果 $a^{r/2} \not\equiv -1 \mod N$，则：</p><p>$\text{factor1} = \text{gcd}(a^{r/2} - 1, N)$</p><p>$\text{factor2} = \text{gcd}(a^{r/2} + 1, N)$</p></li><li><p>如果这两个因子不等于1和$N$，则它们即为 $N$ 的非平凡因子。</p></li></ul></li></ol><h3 id="Grover算法"><a href="#Grover算法" class="headerlink" title="Grover算法"></a>Grover算法</h3><ol><li><p>目的：通过量子叠加和干涉，加速无结构（无序）数据库的搜索，常用于破解对称加密，可将搜索时间从 $O(N)$ 降低到 $O(\sqrt{N})$。</p></li><li><p>叠加态初始化：（将所有可能的候选解放入量子叠加态）</p><ul><li><p>准备 $n$ 个量子位，表示 $N = 2^n$ 个可能的解的超位置态：</p><p>$\frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} |x\rangle$</p></li></ul></li><li><p>Oracle：</p><ul><li><p>定义一个oracle函数 $O_f$，用于标记正确解 $x_0$。对于任意输入 $x$，oracle的作用为：</p><script type="math/tex; mode=display">O_f |x\rangle = \begin{cases}-|x\rangle & \text{if } x = x_0 \\|x\rangle & \text{otherwise}\end{cases}</script></li><li><p>这意味着，如果输入是正确解，输出的相位会反转。</p></li></ul></li><li><p>振幅增强：</p><ul><li><p>使用Grover的扩展步骤，通过应用两个操作增强标记解的概率幅度：</p><ol><li><p>应用oracle：对所有量子位应用oracle $O_f$。</p></li><li><p>振幅增强：执行反射操作 $R$，通过以下步骤：</p><p>$R = 2|\psi\rangle\langle\psi| - I$</p><p>其中 $|\psi\rangle$ 是当前的量子态，$I$ 是单位算符。</p></li></ol><ul><li>这个步骤使得标记解的幅度增加。（逐步放大正确解的概率幅度）</li></ul></li></ul></li><li><p>重复步骤：</p><ul><li>重复执行oracle和振幅增强的过程 $O(\sqrt{N})$ 次。</li></ul></li><li><p>测量：</p><ul><li>最后，测量量子态，得到的结果会更倾向于正确解 $x_0$，以概率接近1。</li></ul></li></ol><h3 id="量子计算与经典计算的区别"><a href="#量子计算与经典计算的区别" class="headerlink" title="量子计算与经典计算的区别"></a>量子计算与经典计算的区别</h3><p>经典计算使用经典比特，经典比特只能是0或1；量子计算使用量子比特（qubits），每个量子比特可以处于 $|0\rangle$ 和 $|1\rangle$ 的叠加态。</p><ul><li><p>叠加（Superposition）：量子比特可以同时处于多个状态的叠加态，允许量子计算并行处理多个计算路径。而经典比特只能处于确定的状态 $0$ 或 $1$。</p><ul><li>经典比特：单一状态，例如 $0$ 或 $1$。</li><li>量子比特：叠加态，例如 $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$。</li></ul></li><li><p>量子纠缠（Entanglement）：多个量子比特之间可以处于纠缠态，导致它们的状态是相互关联的。即使这些比特相距很远，测量一个比特的状态会影响另一个比特的状态。在经典计算中，位之间没有这种关联性。</p><ul><li>经典比特：独立的状态。</li><li>量子比特：关联的纠缠态。</li></ul></li><li><p>量子干涉（Quantum Interference）：量子计算通过干涉效应增强正确解的概率幅度，抑制错误解的幅度。这是如Grover算法中用于加速搜索的关键原理。</p><ul><li>经典算法：没有干涉现象。</li><li>量子算法：通过干涉增强正确解的概率。</li></ul></li><li><p>测量与坍缩（Measurement &amp; Collapse）：量子计算在执行时，量子比特可以处于叠加态或纠缠态，但一旦测量就会坍缩到某个确定的状态。经典计算中的比特始终处于确定的状态。</p><ul><li>经典比特：一直是确定值。</li><li>量子比特：测量时随机坍缩到一个状态，概率受叠加态系数控制。</li></ul></li><li><p>并行计算能力：量子计算可以并行执行多个计算路径（通过叠加态），从而显著提升某些问题的求解效率。</p><ul><li>经典计算模拟量子计算需要指数级的资源。</li></ul></li><li><p>量子算法的效率：量子算法可以提供指数或平方加速。例如，Shor算法对于因数分解问题的加速是指数级的，Grover算法对于无结构搜索问题的加速是平方级的。</p><ul><li>Shor算法：经典复杂度为指数级，量子复杂度为多项式级。</li><li>Grover算法：经典复杂度为 $O(N)$，量子复杂度为 $O(\sqrt{N})$。</li></ul></li></ul><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><p>略</p><h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><p>略</p><h2 id="后量子密码学概念"><a href="#后量子密码学概念" class="headerlink" title="后量子密码学概念"></a>后量子密码学概念</h2><p>本篇文章只是简单了解，具体实现见下一篇博客</p><h3 id="后量子密码学的核心算法设计"><a href="#后量子密码学的核心算法设计" class="headerlink" title="后量子密码学的核心算法设计"></a>后量子密码学的核心算法设计</h3><h4 id="基于格的密码（Lattice-based-Cryptography）"><a href="#基于格的密码（Lattice-based-Cryptography）" class="headerlink" title="基于格的密码（Lattice-based Cryptography）"></a>基于格的密码（Lattice-based Cryptography）</h4><ul><li>原理：基于格理论中的困难问题，如最短向量问题（SVP）和最接近向量问题（CVP）。</li><li>特点：<ul><li>即使在量子计算机上，求解这些问题仍然非常困难。</li><li>可以支持丰富的密码学功能，如全同态加密（Fully Homomorphic Encryption）和数字签名。</li></ul></li><li>常见算法：<ul><li>NTRU加密算法：一种基于格的公钥加密方案，抗量子攻击。</li><li>LWE（Learning With Errors）：基于格的加密和签名方案，广泛应用于后量子密码学。</li></ul></li><li>优势：具有较强的抗量子攻击能力，并且可以高效实现。</li><li>挑战：密钥和签名较大，效率与经典算法相比仍需优化。</li></ul><h4 id="代码密码（Code-based-Cryptography）"><a href="#代码密码（Code-based-Cryptography）" class="headerlink" title="代码密码（Code-based Cryptography）"></a>代码密码（Code-based Cryptography）</h4><ul><li>原理：基于纠错码的困难问题，如广义辛德尔（Goppa）码的解码问题。</li><li>特点：<ul><li>主要基于解码随机线性码的难题，类似于求解高维空间中的矢量错误纠正问题。</li><li>经典的McEliece公钥加密方案就是一种基于代码的密码。</li></ul></li><li>常见算法：<ul><li>McEliece加密算法：基于纠错码，提出于1978年，至今未被破解。</li><li>Niederreiter加密算法：McEliece的变体，效率更高。</li></ul></li><li>优势：公钥加密方案历史悠久，具有极高的安全性。</li><li>挑战：公钥非常大，使得在存储和传输上需要较多资源。</li></ul><h4 id="基于多变量多项式的密码（Multivariate-Quadratic-Cryptography）"><a href="#基于多变量多项式的密码（Multivariate-Quadratic-Cryptography）" class="headerlink" title="基于多变量多项式的密码（Multivariate Quadratic Cryptography）"></a>基于多变量多项式的密码（Multivariate Quadratic Cryptography）</h4><ul><li>原理：基于多变量二次方程（MQ）问题的求解困难性，这在量子计算机上仍然是困难的。</li><li>特点：<ul><li>主要用于数字签名方案，解决方程组中的未知数是NP困难问题。</li></ul></li><li>常见算法：<ul><li>Unbalanced Oil and Vinegar（UOV）：一种多变量的数字签名算法。</li></ul></li><li>优势：签名过程非常快。</li><li>挑战：公钥较大，且可能面临更高效的攻击手段。</li></ul><h4 id="哈希签名（Hash-based-Cryptography）"><a href="#哈希签名（Hash-based-Cryptography）" class="headerlink" title="哈希签名（Hash-based Cryptography）"></a>哈希签名（Hash-based Cryptography）</h4><ul><li>原理：基于哈希函数的安全性。</li><li>特点：<ul><li>主要用于构建数字签名方案，依赖于现有的哈希函数安全性。</li><li>由于哈希函数在量子计算下的安全性较好，因此可以通过扩展哈希长度来提高安全性。</li></ul></li><li>常见算法：<ul><li>Lamport签名：一种经典的哈希签名方案。</li><li>XMSS（eXtended Merkle Signature Scheme）：一种高效的哈希签名方案，已经标准化。</li></ul></li><li>优势：可以使用现有的哈希函数构建，结构简单且易于实现。</li><li>挑战：签名方案的使用次数有限。</li></ul><h4 id="基于同源映射的密码（Isogeny-based-Cryptography）"><a href="#基于同源映射的密码（Isogeny-based-Cryptography）" class="headerlink" title="基于同源映射的密码（Isogeny-based Cryptography）"></a>基于同源映射的密码（Isogeny-based Cryptography）</h4><ul><li>原理：基于椭圆曲线同源映射问题的困难性。</li><li>特点：<ul><li>量子计算机在求解同源映射时没有明显优势，这使其成为一种抗量子攻击的潜在方案。</li></ul></li><li>常见算法：<ul><li>SIDH（Supersingular Isogeny Diffie-Hellman）：一种基于同源映射的密钥交换协议。</li></ul></li><li>优势：密钥非常小，适用于需要高效传输的场景。</li><li>挑战：计算复杂性较高，仍然需要进一步研究其安全性。</li></ul><hr><h3 id="设计抵抗量子攻击的安全协议"><a href="#设计抵抗量子攻击的安全协议" class="headerlink" title="设计抵抗量子攻击的安全协议"></a>设计抵抗量子攻击的安全协议</h3><h4 id="量子攻击的威胁"><a href="#量子攻击的威胁" class="headerlink" title="量子攻击的威胁"></a>量子攻击的威胁</h4><p>量子计算主要依赖两种算法对现有加密协议构成威胁：</p><ul><li>Shor算法：能高效解决大数分解和离散对数问题，威胁到RSA、ECC等基于这些问题的非对称加密方案。</li><li>Grover算法：能够加速无结构搜索任务，影响对称加密和哈希函数，但其影响相对较小。</li></ul><h4 id="后量子安全协议设计"><a href="#后量子安全协议设计" class="headerlink" title="后量子安全协议设计"></a>后量子安全协议设计</h4><p>在设计安全协议时，必须确保协议能够抵御量子计算攻击，这包括以下方面：</p><ul><li><p>密钥交换协议：</p><ul><li>经典方案的脆弱性：如DH密钥交换（基于离散对数问题）和RSA密钥交换（基于大数分解问题）都会被Shor算法破坏。</li><li>后量子方案：可以使用基于格的加密方案（如Kyber）或基于同源映射的协议（如SIDH）来代替。</li></ul></li><li><p>数字签名协议：</p><ul><li>经典方案的脆弱性：RSA和ECDSA签名会被量子计算机破坏。</li><li>后量子方案：哈希签名（如XMSS）或基于格的签名方案（如Dilithium）可用于构建安全的数字签名。</li></ul></li><li><p>对称加密：</p><ul><li>经典方案的安全性：对称加密算法（如AES）在量子攻击下的安全性会下降一半（通过Grover算法），例如AES-128的安全性会等效于AES-64。</li><li>应对方案：通过增加密钥长度（如使用AES-256）来抵御量子攻击。</li></ul></li><li><p>混合方案：</p><ul><li>过渡方案：由于当前的量子计算机还不成熟，可以采用“混合”加密方案，即将现有的经典加密算法与后量子加密算法结合使用。这使得在量子计算技术未完全成熟前，依然可以保证协议的安全性。</li></ul></li></ul><h4 id="协议设计原则"><a href="#协议设计原则" class="headerlink" title="协议设计原则"></a>协议设计原则</h4><ul><li>安全性证明：设计基于难解数学问题的算法时，必须提供强有力的安全性证明。对于后量子密码学，安全性通常是基于现有的NP困难问题，且这些问题在量子计算机下仍然保持难解。</li><li>效率考虑：后量子加密算法的效率往往低于经典算法，设计时应兼顾安全性和性能。例如，格密码虽然安全性高，但在实际应用中需要优化以减少密钥和签名的大小。</li><li>灵活性与可扩展性：随着量子计算技术的进步，协议设计应具有灵活性，以便可以在未来采用新的、更安全的算法。</li></ul><h2 id="如何学习并模拟量子攻击"><a href="#如何学习并模拟量子攻击" class="headerlink" title="如何学习并模拟量子攻击"></a>如何学习并模拟量子攻击</h2><ul><li><p>量子计算模拟器：使用量子计算模拟器（如Qiskit、Cirq或Microsoft Quantum Development Kit）来模拟Shor算法和Grover算法的执行。这可以帮助研究人员理解量子算法如何对特定的加密方案（如RSA或对称加密算法）构成威胁。</p></li><li><p>后量子密码学库：使用后量子密码学算法（如Lattice-based、Code-based、Multivariate等）进行对比，评估这些算法在量子攻击下的安全性。这可以通过对比量子算法与后量子算法在攻击成功率和计算复杂度上的差异。</p></li><li><p>量子硬件：在可用的情况下，可以在真实的量子计算机上运行实验，比如IBM Q Experience。通过量子硬件，可以直接测试某些攻击场景，验证量子算法的实际效果。</p></li><li><p>安全性分析工具：使用专门的安全性分析工具（如CryptoVerif、ProVerif等）来评估量子计算对现有加密协议的威胁。这些工具可以帮助研究人员分析加密协议在量子攻击下的脆弱性。</p></li><li><p>公开挑战：参与量子密码学领域的公开挑战，如NIST的后量子密码学标准化项目，了解不同算法的竞争和实际应用情况。</p></li></ul><hr><h2 id="addition"><a href="#addition" class="headerlink" title="addition"></a>addition</h2><p><span id="Bell态"></span></p><h3 id="1-Bell态"><a href="#1-Bell态" class="headerlink" title="(1) Bell态"></a>(1) Bell态</h3><p>Bell态（Bell state）是两量子比特纠缠态的特定形式，是量子纠缠的经典示例。Bell态描述了一对量子比特的状态，这些量子比特之间存在极强的量子关联，无论它们相距多远，测量其中一个比特的状态都会影响另一个比特的状态。这种现象体现了量子纠缠的本质。</p><p>有四种Bell态，通常写为 $|\Phi^{\pm}\rangle$ 和 $|\Psi^{\pm}\rangle$，它们的定义如下：</p><ol><li><p>$|\Phi^+\rangle$： $|\Phi^+\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)$</p><p>这表示两个比特要么同时是 $|0\rangle$，要么同时是 $|1\rangle$，两种状态以相等的概率叠加。</p></li><li><p>$|\Phi^-\rangle$： $|\Phi^-\rangle = \frac{1}{\sqrt{2}} (|00\rangle - |11\rangle)$</p><p>与 $|\Phi^+\rangle$ 类似，但两个状态之间存在相位差（负号）。</p></li><li><p>$|\Psi^+\rangle$： $|\Psi^+\rangle = \frac{1}{\sqrt{2}} (|01\rangle + |10\rangle)$</p><p>这表示一个比特是 $|0\rangle$ 而另一个比特是 $|1\rangle$，或者反之，且两者叠加。</p></li><li><p>$|\Psi^-\rangle$： $|\Psi^-\rangle = \frac{1}{\sqrt{2}} (|01\rangle - |10\rangle)$</p><p>与 $|\Psi^+\rangle$ 类似，但在两个状态之间有相位差（负号）。</p></li></ol><h4 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h4><ul><li>Bell态是一种最大纠缠态，这意味着两个量子比特的状态是完全相关的，不能用单独的量子态来描述每个比特。</li><li>如果我们测量其中一个量子比特并得到 $|0\rangle$，另一个量子比特立刻处于对应的状态（即 $|0\rangle$ 或 $|1\rangle$），即使它们相距很远。这种关联是量子纠缠的独特表现，爱因斯坦称之为“幽灵般的远距作用”。</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>量子隐形传态（Quantum Teleportation）：通过纠缠态和经典通信将量子信息从一个地方传送到另一个地方。</li><li>量子密钥分发（QKD）：如BB84协议，使用Bell态的量子纠缠特性来保证通信的安全性。</li><li>量子纠错：纠缠态在量子纠错码中可以用来检测和修正量子系统中的错误。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一道考研数学-关于三角函数的极限</title>
      <link href="/2024/09/21/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6-%E5%85%B3%E4%BA%8E%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90/"/>
      <url>/2024/09/21/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6-%E5%85%B3%E4%BA%8E%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>题目：$lim_{n\rightarrow \infty}n\pi sin(n\pi)=?$</p><span id="more"></span><p>因为是填空题，所以一眼能看出来得 $0$ </p><p>为什么是零呢？因为感觉不是正数也不是负数（对偶性），所以只能是 $0$</p><p>学长的讲解：</p><p>当 $n \to \infty$ 时，可以把问题理解为一个数列的极限，也就是趋于正无穷的实数。但是，直接看 $n \pi \sin(n \pi)$ 的极限是行不通的，因为这个表达式相当于 $0 \times \infty$ 的形式。在这种情况下，你可能想把 $0$ 单独拿出来处理，但根据乘法运算的规则，只有当两个乘数都存在时，才能进行这样的操作。</p><p>所以我们先不要直接看极限，而是先看表达式 $n \pi \sin(n \pi)$ 本身。在 $n$ 为实数的情况下，$\sin(n \pi)$ 总是 $0$，因此这个表达式无论 $n$ 是多少，都是 $0$。即使把极限带入，结果也是 $0$。尽管你可能会觉得这种形式是“无穷小乘无穷大”，不一定是 $0$，但实际上这是 $0$ 乘以任何数，结果必然是 $0$。</p><p>无穷小和 $0$ 是不同的，$0$ 是无穷小的一种特殊情况。虽然无穷小乘无穷大的结果并不总是 $0$，但在这里，表达式的极限确实是 $0$。</p><hr><p>但是我的问题在于，随着 $n$ 的增大（只考虑趋向于正无穷大），函数值高速震荡，感觉不像是有界的</p><p><img src="image-20240921201843743.png" alt></p><p>之后发现它确实是有界的，因为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在判别函数的有界性时，我们需要先知道以下两个重要结论，即： 如果f（x）在闭区间［a，b］上连续，那么f（x）在闭区间［a，b］上有界。 如果f（x）在开区间（a，b）上连续且函数的极限存在于其端点处，则f（x）在开区间（a，b）上有界。</span><br></pre></td></tr></table></figure><p>这个函数包连续的，所以理所当然的有界</p><p>既然都有界了，那么极限存在</p><hr><p>后记：</p><p>结合网上的说法和gpt4o给出的答案，$\lim_{n \to \infty} n \pi \sin(n \pi)$ 不存在</p><p>当且仅当 $n\in N^*$ 时，$\lim_{n \to \infty} n \pi \sin(n \pi)=0$</p><p>如果 $n$ 是非整数实数，$\sin(n \pi)$ 会在 $[-1, 1]$ 之间振荡。而由于 $n \pi$ 趋向无穷大，乘积 $n \pi \sin(n \pi)$ 是一个无穷大乘以振荡的值，无法直接确定这个极限。</p><p>因此，严格来说，$\lim_{n \to \infty} n \pi \sin(n \pi)$ 是发散的，并不存在一个简单的极限值。如果我们只考虑 $n$ 为整数的情况，则结果为 $0$，否则该极限无法求出。</p><p> $\lim_{n \to \infty} n \pi \sin(n \pi)$ 存在，当且仅当 $\lim_{x \to \infty} \sin(x)$ 存在；众所周知的，$f(x)=\sin(x)$ 既不收敛也不发散（在讨论整个序列时，极限存在与收敛实际上是等价的），故极限不存在</p>]]></content>
      
      
      
        <tags>
            
            <tag> mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.9.20南洋理工密码学报告 观后总结</title>
      <link href="/2024/09/20/2024-9-20%E5%8D%97%E6%B4%8B%E7%90%86%E5%B7%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%A5%E5%91%8A-%E8%A7%82%E5%90%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2024/09/20/2024-9-20%E5%8D%97%E6%B4%8B%E7%90%86%E5%B7%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%A5%E5%91%8A-%E8%A7%82%E5%90%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b2eadc2bc0e6f1edfc7773f75bfee55a60d08531f083c3c0f7e363a825a413aa">7b22b1899bb4d215751e07a80f0d88de055a65958d0c135d9dfb3cf670e20830146cd7e756c05d5ad3c67ee1eb7e2c3e81b8182e354a5a8d8fcb20a51bb66205a40d307ce0943a4da73921a2e9a666e1804f25337b6def6e5a22369804cdd5e40503a8dca1e63c22a6a843eaa62eefa348402a7d6fe247897a502529e8619919fa448389f3a6bfc8f54441fefd6c88e4a8c1b1f73f84b8f189e7f9206a6249ca2b345289d566da5ca0626e89cf51d0b835bc2635e242ed77e37030ca4e57b869052ffe5e1deb5ee14a02ab72291faebc3061f35d5569438cc0eecdd0be7c0772ff79563875122db926928d7b583ed258a4b7a8ac28bf6694923c7c9c8ffc8210edcd6c7e101f9505591e65b73897b19a39c3514100c66e2060ef1a85ac6dd7014129b0400f88d0332a06e66c941e7fdf7651ee0573fce533207954fc9e47de7dc4befcfdff79587497c392961ed9645d735a1b2a4af4e73158b4f9e7c1d0196c5e1b31b73c4119bbdaca25effab6c31d0aa1fa8d04991ae55a33305cf98c93ca788ba2a56cce3fd64b0b1f058efbde5bc1050d3a1eaad6a61c3fa04d89092a5ecd90eeb4870620650f3d3957211714978e1f48c575c5902bade0d2673b43b68e75161c479df3947686654d7039140f183ed10518c6954b18aad7d41533bcf035d13378a8515528fb1bb0e45da004eb9699704ecdd73eccd2131d2968c1e0253e5fee99c4266a5c9a919a99710b984dda0ab4365bf4f4384c603ebf77b4d7438502be264902b4e23474aed8282e3cc780300607691f956a4ab8b607c04b455ba856c01c2cbbf06fd0f63f2f2e4d0e59d2e37bc59429f82973448d4c497101c9089704952c6971afdc650dfe0a1bcb32011d973212027c71606a666f8fcd127e6ef3b893e58bbf4a5e3c832cf8c576330a4faad195a09c871b85144f811ccf016dd3f1a71c8a922e19ccbf350092cd7d17bf4450ac321c3208427617b7466a29ed8b5e733dcd25a58c5bfaa8aac78be72d63b31649ff0fb7d851df3d8210b75d7f2671ffd4b254a494f66076cc2a689888a149cd72f2cc268190b32eb601b7f50d6c5c5071eecfc2657f1b17242dc5e969fb567bd5b42e541a3e6b6f707352e1781f993e247bc72f220093f072791b8fae3e3101f80079ff9f419da8bdc924d2b3bd451dee84f86191225f4620709241cf8d0ce9cd2c1fdb22549dc84b1c976e80693343fc473e20eae11fbd898e01fdaabb4a2a19159e6ca4303ed1cfe62f79ec8877eb26f542482f0687753989c72f666cfb5e2a216b8bcbcee278c146db647f6b9e941428b8de019efefbad2ef12df11a6bbfe9edb246a52f7d11cea6d0b98b0e61bf400c7f99788b96b147c79cccb6f14dda65666d2036fc5408ca22ae0d3fe1eb22e16944ec82b06f27b97d5ed25b7b9050004cac24c6beff0b075b50ed575f33b1faa3a19e72b1e5314cef9ebe9d0e92d0b4994310ae031ef86cec90c4b77788e9edf5b9ba55c0d494d006229379a392b221d7ecd1f99a09806b0cce8a17ff395caeba2f6cf46d62f4b73e7b8ef4f83e0fa6db8bb70bb7d06dc9b45abd76eda47f8327015ad05162d0352d928f105176900571bd07505453a92ad57ef45c5f95860ecadc1f50d5bc14af441919d9d1c36fe77c54bd2d47f6ffb81c209ca20831a561101373fbdf8cbe898b203d4daa87def53e7bf23ce1b0c927e7a9e6c56193dd14d47271b6b1fb65a1492d0cf94f7eaa86b713137f51190bae5f83b730fb682367288e870d62e57c55d98a8bcb4973bc39c4375c5854907bd361e36b11ccfac2885f2bef8b09df5b2d88e422e9b373eceb06b32df30bde61f8e4c46929096bb1b962c0f17d83e579e7df668ad62d49f3b0ed13a4053686684308e38a2c2046f4d6b72e4630d07871edb87e73164eef2e80a49bcc4152c3666f780629c4140afd715df67f17da688d6f278d95ca2657640623846aed7c7eb24117708620c0d63dd895dae9902777385d81ae7a41a7d2a80655977651ec23b5b95cac14c590299a8bc03a67a88f903668fbfb555058fe3a9ed088054d2f6291d2794cac1f22a39b69b864d564f6a1e86495d3e6bd350b9b811150e22cb47dc69ccc5e0561d8aa6cadef53722e50dd43743729ee83f5b8328b32b277b3ada26c669a511cfcf1bad8567f82bfd21a124e9b5b102768b73c646448542661953d01f1dd638e86dcd7e119d6d447358cb012534454d9e262b77b7043a58b618ea6fa2f8ab585c2cad05687ca32bf243ace756c4dc7e6a96d36c0bb649a27d46a1810d00c86e5a4a17c42e9d95f2d9702a39d44a57c35e9d5c3cc330f72d0f02247ecf9e6a093e9754e7c6d2bd19e53e31c2a98166ede6c9fba2e44374ec34ba50b481ebf6c165f66cfdf1174a062b3e091bf3e036065aaa00c495997a3883db9997f16add2a7c297e6c88e01fe48a5d2c8e845bda4f5df6614238dac9f1bff9810e0232b474024bc4a6fa186ef3c45872c273aa54d039039b70f2241d67fe88b56360b289168ed4e1c7682aa4c800492e53fa7064a291f7f1412db077b3934b7b2904dde197c2569161cc7fe33da1fba9b1831a4826451210d255346fbcce1864048c2263d31aa5ccab5177ad167b9937d2802002d03f3204bbdeeb66ec25f1ed2e073bbe3fe1970465f41e0348a4b499ab753ad664770f511d5603805c9758c9b799b14c774fee2bf4b2e5e7469ec22be2bc42278738a333a21248c81e5648c2b250cad383b3ea06609de4e426cf6c3c0a08aed01c4d22c91d98689881dcd208f5ae2722ca7c135a17a2e2c34987ce43d017ccea35beb029756fb211129bfbc46f7f1930d78e876be3491e1d80eb7d3c329d65d5a9156d15177af0e121bbaaa727a70f213ab680fa82071e9e5a857bc6b0db3c231375bd5b1a5ddb065fed739c4f610c8a6c6750d0bbdcffbc4cc29b51a29c6e27a936fd87da1a9d273e2098e50def6d588d78f9e497524520e1b460c98326b8afe64e9cbc56a5357bbc71dd775135e39cc52b659faf4a248ef8571fcd60014c4f27746e830704159ea7151dba648ea6566255132e7fb64a532b4589b8566a18ff62f162433e877aebb60c3f56d4eef7033c9ae23300a50bc3acbea87abf3cdc00e1a42338c82113831cbb1f47c67ed4e8f26388f89acbb2f597586a652b3c7c5d074572e2139a3f96a079ef42e853dc86bc9176dea40cbb2c5a9448e24d116afdc60ba96630c0372ae2f2590bc7eaa4db53a35143f1c0185860923f060a8b086596e5a1ecedf71fa12ec0247ef4bd7a11a77d01d19d06bdcc54794a594a4f1cb07f437a3a510585ef30503a379092feb3bf730428deabb607fd5a271b8a73cf53177e7c5e0c7cc30ddc3e68d9efbe3da178221079d0e6121e673f721dfb85bbf8b1e8dbd21bab97fda541352e5bb39b4cc1ca62f9d352c670c3c25e33c80bca953a497388bec6df9b021a621742c81819fd83844b84ef3976df1b2aa141a980a47c8a5e853b28c93e515d314afc2aa9af71a0972506468e7ae39cdcd92b681dab47103b62f8a4bf536c92f6fe6ca8aa23b14b6147983b682aef10ee10ff5dd0c362592c4eeb2cfe6aa8157a693f40e54e218910c6ac3b2acf365637d8125385d39c51fabe57769afae11090cf43215aa263801ec5f207b9799fe480afa66233183e6e5ca7906a8f11b312b45370e4b15299ae301e79cfb672775017dd99c44a7e39f0f5eed9723c83f78247d53ce5cd1f33faa9fb00099798bb2b2d5f2308f1421b94533750f15f34ec1ed5accbf4062e569b2b3e91a3cf512195dd13b61324503a50da6dce92f8e0f46dad5fccc578279bb80b8cfd9d80698c7a30c20090c6c92a1c2f1c817267c99aa52d6c515421653182777810f09335c111f575cd2749ea7efca7778a91b2214fefc7815c19d77fa791a973fc036e0e9c8d6aad1c5962bb1addb7bb48e70ac220b53b161713620d8be5af889ddd7f9a0cb285d756abecbd245ff623de5762822467e26d8a75b680cb820cb2cfca491f8fa4032205c471ed9d0eaa4cfd644966e9cbe312109722cdc09b35fce318f2ec5847eec43d5445ef91b1b40a4fd23d1c17bc2690ed32e9846d839c8db9805bde917d74e92c683066342f4e407dc2c51e4beb91d610066b6c6418393a177fe48f3931e91643b1f4d3b71617752da6a115d62746da7f061a110538f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> meetings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学论文分类</title>
      <link href="/2024/09/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%AE%BA%E6%96%87%E5%88%86%E7%B1%BB/"/>
      <url>/2024/09/19/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%AE%BA%E6%96%87%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>三大顶会与信息安全四大顶会</p><p>密码学三大顶会是指CRYPTO (美密) 、EUROCRYPT (欧密) 、ASIACRYPT (亚密) 。</p><p>Big4上的隐私计算文章一般离应用更近一些，而三大密有可能是纯理论的结果。</p><p>Crypto会议主要关注密码学理论和实践的最新发展，EUROCRYPT和ASIACRYPT则更加侧重于密码学的应用和实现。</p><span id="more"></span><p>J Cryptol 比密码学三大顶会更牛，35 年以来中国大陆作为第一单位和第一作者仅有 8 篇文章 <a href="https://www.view.sdu.edu.cn/info/1021/163402.htm">[信息来源]</a> 。</p><p>很离谱中科院竟把 <code>Journal of Cryptology</code> 分到 3 区（大概是直接按影响因子排序然后划分分区）</p><p><a href="https://iacr.org/fellows/">IACR Fellows</a> 华人只有姚期智 (Andrew Yao, 2010 当选) 和王小云 (Xiaoyun Wang, 2019 当选)</p><p>信息安全四大顶会则是指CCS、NDSS、IEEE S&amp;P和USENIX Security。这些会议是信息安全领域最具影响力的学术会议之一，涵盖了网络安全、系统安全、应用安全等方面的研究。CCS和NDSS更加关注网络和系统安全，IEEE S&amp;P则更加关注安全协议和标准，而USENIX Security则更加关注应用安全和隐私保护。</p><p>在网络与信息安全领域，CCF（中国计算机学会）推荐了一些重要的会议和期刊。在2022年，CCF推荐的A类会议包括IEEE S&amp;P、USENIX Security、CCS和NDSS等，而推荐的A类期刊则包括IEEE TDSC、IEEE TIFS、ACM/IEEE TACoS等。这些会议和期刊都是网络与信息安全领域的重要学术交流平台，为学者们提供了分享研究成果、交流学术思想的机会。</p><p>综上所述，密码学三大顶会和信息安全四大顶会是密码学和信息安全领域最权威的学术会议之一。在网络与信息安全领域，CCF推荐的A类会议和期刊也是重要的学术交流平台。参加这些会议和期刊可以促进学术交流，推动密码学和信息安全领域的发展。同时，了解这些会议和期刊的投稿要求和流程，对于想要发表研究成果的学者来说也是非常重要的。</p><p>信息安全四大顶会</p><p>一、<a href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions">USENIX Security</a></p><ol><li>介绍：USENIX 是一个计算机类会议的总称，而USENIX Security只是USENIX中的安全会议，并且USENIX Security会议涵盖的安全领域也非常多，包含：二进制安全、固件安全、取证分析、Web安全、隐私保护、恶意分析等。</li><li>论文下载：<br>会议的论文直接在官网提供下载，有很多格式(PDF、EPUB、MOBI)。</li></ol><p>二、<a href="http://www.ieee-security.org/TC/SP-Index.html">S&amp;P：IEEE Symposium on Security and Privacy</a></p><ol><li>介绍：S&amp;P又分为两类：SP Conference Information、SP Workshops Information。</li><li>论文下载：<ul><li>这个会议的演讲论文在主页以及每个会议的首页(需要点击进入每个会议网页哈)都有下载。</li><li>若学校有购买IEEE论文数据库，可以通过IEEE的会议搜索进行会议搜索。</li></ul></li></ol><p>三、<a href="http://www.sigsac.org/ccs.html">CCS：ACM Conference on Computer and Communications Security</a></p><ol><li>介绍：始于1993年。</li><li>论文下载：<br>会议的论文可以通过网站的链接看到历年的论文记录,当然这个论文库是在acm数据库，或者使用dblp数据库进行搜索，一般都可以搜到PDF。</li></ol><p>四、<a href="[https://www.ndss-symposium.org">NDSS： Network and Distributed System Security Symposium</a></p><ol><li>介绍：<br>网络和分布式系统安全研讨会（NDSS）促进了网络和分布式系统安全的研究人员和从业者之间的信息交流。 目标受众包括那些对网络和分布式系统安全的实际方面感兴趣的人，重点是实际的系统设计和实现。 主要目标是鼓励并使互联网社区能够应用，部署和推进可用安全技术的状态。</li><li>论文下载：万能的google<br>参考链接：<ul><li><a href="http://blog.ourren.com/2015/01/20/top_security_conference/">http://blog.ourren.com/2015/01/20/top_security_conference/</a></li><li><a href="https://www.jianshu.com/p/b97077272323">https://www.jianshu.com/p/b97077272323</a></li></ul></li></ol><div class="table-container"><table><thead><tr><th>类别</th><th>简称</th><th>全称</th><th>周期</th><th><a href="https://www.ccf.org.cn/Academic_Evaluation/NIS/">CCF类别</a></th></tr></thead><tbody><tr><td>期刊</td><td><a href="https://www.letpub.com.cn/index.php?page=journalapp&amp;view=detail&amp;journalid=4395">J Cryptol</a></td><td><a href="https://www.iacr.org/jofc/">Journal of Cryptology</a></td><td>月</td><td>安全-A</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/293">CRYPTO</a></td><td><a href="https://www.iacr.org/meetings/crypto/">International Cryptology Conference</a></td><td>年</td><td>安全-A</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/294">EUROCRYPT</a></td><td><a href="https://www.iacr.org/meetings/eurocrypt/">European Cryptology Conference</a></td><td>年</td><td>安全-A</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/299">ASIACRYPT</a></td><td><a href="https://www.iacr.org/meetings/asiacrypt/">Annual International Conference on the Theory and Application of Cryptology and Information Security</a></td><td>年</td><td>安全-B</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/298">TCC</a></td><td><a href="https://tcc.iacr.org/">Theory of Cryptography Conference</a></td><td>年</td><td>安全-B</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/560">CHES</a></td><td><a href="https://www.iacr.org/meetings/ches/">The Conference on Cryptographic Hardware and Embedded Systems</a></td><td>年</td><td>安全-B</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/585">FSE</a></td><td><a href="https://www.iacr.org/meetings/fse/">The Conference on Fast Software Encryption</a></td><td>年</td><td>安全-B</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/300">PKC</a></td><td><a href="https://www.iacr.org/meetings/pkc/">International Conference on Practice and Theory in Public Key Cryptography</a></td><td>年</td><td>安全-B</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/966">FC</a></td><td><a href="http://www.ifca.ai/">Financial Cryptography and Data Security</a></td><td>年</td><td>安全-C</td></tr><tr><td>会议</td><td><a href="https://www.myhuiban.com/conference/588">CT-RSA</a></td><td><a href="https://ct-rsa-2023.eecs.oregonstate.edu/">The Cryptographer’s Track at RSA Conference</a></td><td>年</td><td>安全-C</td></tr></tbody></table></div><p>每天看的论文，应当分为精读和泛读</p><p>精读论文一般看A类会议（选择同方向的）</p><p>泛读论文一般看大致方向的（bigford，三大密，和其他安全相关的）</p><p>看论文一般看AB类会议，A刊（A刊也有水的，但是可以快速入门）</p><p>例如《Identity-Based Chameleon Hash  and Applications》这篇文章，就是变色龙哈希方向比较好的论文；自从区块链火了之后，变得很难投了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.9.18组会</title>
      <link href="/2024/09/19/2024.9.18%E7%BB%84%E4%BC%9A/"/>
      <url>/2024/09/19/2024.9.18%E7%BB%84%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="36acf50bdc832db27f837ec7c65ad89460b79c120ecaa1b19c4bc7c2c8f64286">7b22b1899bb4d215751e07a80f0d88deb19e3a2bf4efd24e816d4e33bff4379def16261ea3be9e3ce1358a249e21448bf46da3c31892d87a95ecd3a4164f2273a0243be5d8677e2d4b5697275e6fab040f4b1f32b4bb94bd3156dda8d03ced86bf4b8e111dd0984937dc69790d37f27712ac32d379ed82292f523be970fd48be48a20044112e033b542dd6be34fecaf5032c699df269954f804b8a10e136350c7b6fd21dcd839c688f53f1cfe09051c5570e9fe4a27a2dbc8f97a3fb0c8b35adec2f488fbd07c4462142db2a3c6790f2941653880829f0c0bc7ae060dcb4ee51f0561b779d6b86db8247b8f6c2f76d7763dc58178a3cd7ce7215a29a27c748e270e989bc7a1ed9cf56bc677d3ecde7756434174198b4524c8c5c9d1241050aa851960614f0c8ae7ea014a2e582f7359af00ec589136f8b733e8c1cfd6a2bbccb0e8c3d32c92ac88437c8f5c9405c81ab80ece007e1c258876c3f0c8e3974910f19dce3d6e4edccc2f7b4bb2f2f1d21ee1c7dce95dbce4bb66b25b2c6e0647a8217a2d7445075a40abbf5688798b53e451fdcc6d7e034511211985c5fbe244d1b00e3c9061b9a242d9e2246e8e9881178d1423d6e2534881f5a3773d021a2ca377e63388ac31f4441d90144c1885348885cfe0912e16a612ee61aadfaa477e9b5828ea1328667b44363110fdb14d0055dc5297d50676d2798a09e199eea0902d9d68c9be17b3009999097004ad8a0d8094efd4e6c116ff0344ebd1b8fa1cde74f95e4f909aa9b05150f0758c746cb2652008043906aee8cc4b120a1af03230a4f6da8656e128e18fcd6c264fb9371eaf72ffe7e9af8b59378d370dbc30d3d0777fc3ad96a6293dc8ed8d6d53febf5688b09f8a6911022a678d627bd6f963d379a8bf10fde1580eab351c49f5ef4672946a5a21f91b1b50760a9dd79b92ea938f687141484d4685e7e2238d3990c06ab1d9e1bc75920207e9d9b7409812f1135685076be640f73814afd46c016ebf8a6fc5c8c0b9759709fd2eb589e1c93421c14fa1ce9f9a871fb4ada01e80b7e4aea17e509fe9b1243c511edc77a0589a4d16c9ea1092a2b3f0c2085ac8b4adb8c78ac35f635b70f991824ca94287e70220485fe386110f5f1d78dac48008c2f2ab7877ba538a6fa9d300f1b835286826a42c8e4c0ccdcd864825a7697f257eb1ee9428ed50367c6a9b061cfd381e3d833d8c09b4c5df67d9b56da47e7a9406d511502f67cbcc96ea100cc5f50a4fffa2764a33241440d65fe8972ec0133fea94e9e36a832a3c87477a49b78e49cf847ba7a5b0974d3d54ec0fdabd40fd149abfde4168f54416002fd8bc4951132b464737f87c5d6ccbc638eca76806b6ba5f21bed2714b4c7b6fdec890459e56393ea9f711e3bdaecc8eaaec1b3d4ab10f579d7b82cd8e7cf6502cd656484bdcc817fe2150c29d186b173d714238283b8ac6ba1a09b472e0aa885309fbe51827c72ea92ae4f3525484fcfb572cb8e1dbdc841e6f21d88a6062a7620fd50b7a53e4f595c8a8ec879587494ef46cd5a46e9b5b1e62cbe3d82d16860c18177ab2cb078242dc59654efe08db01482999ddc3c01778ae12f06ec5ca66d4d005e328209f0a3e0530155b2d758ed8f7aadec05886bdbe9764ec10498a214493bab63f624f24358e72014d7193515d0bdaab88bebcc765f10bb7a7ce3037cc4623aa5359f824236398308e66c664d0b111744b4e75228e826f990ad57362084dcbb1474953a7e1e1ec43d149991e0364f427cd76636ffa6640a34585984267c2c12702e1994cf8685fc78239cedff388eee6a352432e188c4f04cff39c999c0e0a55681fc4ac70d3518995a07228b6e95f6b23b1bd4a263b19c175753c3ef33b5c4eb7f6747f03ff38ef538e4d9d1159ca3055f21001a8e26bea62f78b4d67e80b71c4f450e13b4812b7d709244ed66a610d25f547c5711c398247c93f82c53656606365d753d9a4ab3e9fcafd9747233a9d622481e8a925130b18e0c77f79e75cf4de1a6fc6bfebf1a1555b138c456fa411ecdffd03bc9db4a4bccaad777605e07f3c9aa767103d975783f9682b60fc4448288fcc96002c19440b593f56b6dc34064c5324a57be3cca7cf362006d64a4dad8278a18b8f17a5fd162ea68d67f1517a100a42659ded39de64422e1208819a36f6cb52f423d179ed1a095f387289bf51bf1f21d6ed16049639cbcd7f0cb057c77d4eb4276478d88c13fe7a52307ee4df9f60c98724ad7ff920925d356973b1d6bf5307b734295a1d23d85d09b6fb16d52f7a24b3934be5c620108bcd947ec0c52bf22f2d63df438a7025bbb98506a923a945e11190cfe5c3f18529738c4222e0224762a06a5b3605c79d70b5f4a024bc749609297b7fc4b2b50a12937e0537691e4adb5360d34f44173d2814d847c2186dc72e498c934b589e7ad0d23c2c2f163906f011db2a5b5bab9ead6cd748c05ef4c8230ff930300289e60bcf91e89ef661f491344df1e61795d30c97629fcfaaeda5d9c4eaa47a86f2408c2a9834a7eae66cc1206401524b4a97b282fa9ca96c9857bc2c9a1aa9829000e4f7aad9a6953989b761d682f1c977d361f20aa3bfbe8e6537b6f880fe34e90bda13214e8bbf9eadaeb4ce1dc4c15f9aa8df3a45e1d0d64973db80131d6ba9988bf2036e0a64cb6fb9d0d89c4a5b30810083aeea67bfc24cecf92e7f0366eb4d3a70f07a498a592040613d719b4c240ac77e61708c66194d9a5bb75d3ddb5c52a67e8eab737d7ce656e2e18ef41f1c6c8c360a76698746b00aed00eba347bd9215939ac7162de6b7feb2947dbb31f6a3e2fb7b4a68b18b74242536313f10576f978cddb07f7e21bc96586c35a8250e33ee1a6d15eac093887127e413a7c668c5886cdfd1dbcb58fa7131245da05345417ed2319ab3f84d888406f18c09b3db6cfe966a855ab9ffc453941f96bee8a1037799888987215c772dfa42879e6a21b34771901e39f7481952d881b843f9c4a25e3627187752321d6533f13ba976438cbaf939e3795b23a75f795628684ac3274c74740cbfa01b5df4dfbf08ba62e5294a5ccdc79f4ceb03bcb6d001ce576fa8cd321468ebe9f734213d8ba419e4617d7e686ff521611a423d3f4f5d577</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> meetings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年9月16日到9月22日周总结清单</title>
      <link href="/2024/09/18/2024%E5%B9%B49%E6%9C%8816%E6%97%A5%E5%88%B09%E6%9C%8822%E6%97%A5%E5%91%A8%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95/"/>
      <url>/2024/09/18/2024%E5%B9%B49%E6%9C%8816%E6%97%A5%E5%88%B09%E6%9C%8822%E6%97%A5%E5%91%A8%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="47127839909179c7a60ca0814cd384eb4a69dae26d0d1528e71338360ad6b255">7b22b1899bb4d215751e07a80f0d88de16933033ae19b391949c74dcef436d0c5b80c1104e8012a505401d83bdeb9353f14c5c9d398d48d98c534cb40f724fbf917700047c1e9f103b0f5c3e8203242d525d8f52f8707c87b6be5d94eba27099d629869925e5ab80bfe51adf959a6b3f75d7fb78cfd67142af658daa9c3b9ecf7ca644bb0e1b615bf6e49d41a8244d27c2ce87335a9ef31ce6adb0d2368b3e1c61861c6db853dde06aa5d245cf222f059a9b4224445bf5ba75f52aabc7849725488ab3681c349ebc11a67edb6e65223c602e48e4f4b2f8c33756da16f075da3120139ff56695e55f12564fc22041922f6c1e2b5016a51dae2045e347bb5ea156fec7d57f7092929050743e9e1149ed33e2e2d98a390118e38a7e39640bba4b2130ede1aba12e4e5c3105fcd0eab1860d088f9dbbc0802e84248ddb5bc4c40cba38a639ddd7df9498de53a804834a3054428b904bbb6c6bfcc1bbe9a88dbbefc0e34d3cd11a9ee2e791e1a9889bc85cac54fdb7c4bbc2e0d0c72ebd101ae57fc2e3cba5b14ed1dd0b3ca7c194ddd0843b0604d0b79b2338492c5fb32d4bacde821d89cc257d81a4057f49b04ae23ba038a3d065a6934f2c9b91e10157eda470690c6820432cc1fff2a919aac865ae2151b43dcb9b19c3e065684341b630267d4d56b99f6f1009d33a14dc2091feedea35442bd0499c777a6903eb7b544fb6a79fd6f2c74086307b730f00db634f601cdc4a991850866f51a076072fa24b507e6e5ad6137341a3c84196cfe965a75dfd1fe5f70cb020cb6fbc922d321525ecc9a489429f2f782908d7a150da5b008b955ff4fc550d184965dc7b3fa0ff6ce54e0387c9f2eca967c655759a4b61312c3a70bab492eff5c3ea87246106fd0de8e0a2f1ff5558128a831acce2883ffa1dea7de903f869360a6b2046e81faf3a430902df51a9960d57f79ae55551ad06afea2ca48308fb5430334cb5002e95a2f187a126d508be10751a29e1c1ef5ae89cec4ca1e6073f82ca5ce18c99dec31478c6b88bd2f1b83a8b2a2d99920ef37d6df67b31b57ec9512e3088b67cd9e05f42c877a20bc3e6da34a21731bb3fe5b5fc0ae96980c134eb0279cee4cb63118e59045474b38c5f8f605cea2072546388edb3a771757bc96dfa73d11e96272c2d5062bd6d79d80cf6eb6f3bea69c5d6553516ab529ce710632463d89db45ed30c64a283039618a8345b3ffe5859ed74cd21e6ff669b70fb347a7e982a27c7124edf5768ed4b71833d29fabf979e538d4dbdfcb926ff1b0be9b7aae5908ccf18bf6f9fffd8cb944a967eb433ff5e84044c1608f1069d228d31bd2489d248b90eeb59e0e795065f0bd25ffa6b6e183ae04533e1b3856e07bc635efca9ccec07c49385376f51c151c319e5ee236fd5b8b77b3ce83cff4d9eb0102ce4fcf093fd1d6f9f8cdcca76448f1bd12f3ac9d85bca151aeb2772d31680dbca8a619932e2894514bf597be09cb9ebb76eb7147677d1a9e35095413cffb70a3036b01e06684767a617197e11532bc9377f93465db666f1b64ab020faeb23fc627b32a4ad1a9a97bf006cbff91b4954b7ec050524dca41e16bfbb77f9c786c36081d77f4b0b35ce024f0a97eea4ac7975aa4d40c7117bdbaa3b24dd7972d33a308a9471fcd31929bb3f9bf6a2f1d2abe62e1796af7af48a235e87ffd379d3eaefd7e4e6b93755effff45fa34403e7c0e4f91d572aff6dfbc81c4faabeb0db5fa83f0e7a9e7dbf088116a69cf2a83df6487415e1dddce38011977cefd57d90a63851cc858bd364cba2c44c816eb5565bb2585eae74989d309e91711c600330d3b3a71b2228386379259eecb139c4304e3a9a25e138f83c22cf77f36cb30b498af2f946836cc504aabb82b67d178cfeea7d1f8a036614b20b43956fcf540ce8bab31136b59817d664a2039caa761bc2c6646dd9a5d73e8543035c66914df4477373b24fba91515dbc6fd7fd25726be40d1b787b1ef28f73fcc640332c5801e855f1b6e00688264b226eb94c71fb5b67700fcec22722c30749ca35b49ed814e919a1229aed7d236274628719c6b8c9ab4e5e9ba8eecd15a024202b915f0898ddfb1d78fbb4399a2474304da71e8227f76d5a607839cd0dc2a6d0dfa8bc5ec92eb739b3917d2a0194a36409d14c9527bc119b7b8fba523d85b271ddc3f577d5a675de90f1a2a426610f92311639ff3d5047df04ffbb8293df713f216686d17f6b60aeb539e83a665d9c3c98cb7fa98c36aa060feb47fc6466ef61b26b1fb1e972b782527c17219afac45d98d60e48cd17b725ba4430403e4ff80320ff9d8bea634d12741abad550568e95a785e83e77d29b1abf422aa39583156386d4d0bbc44ea8adc842237f132b604e818d9307f682678dcfffac215ecf052deabb554a198d2d902109dee46f000169642e5d25cc7e0321d971f039a9d9b84f4348da83b93cdb7af73c94fb012c567032a560e01007994e887674ba93321c63f621c4cbc5052abfa2e584cd1c59871c647d686b1feece2b89adec1cc0ca0c983dd8d203fc1e4d9e115133245f8ceb787d6c86d4e9596d344f02395f232508eae66f454065d8b970b97c26b124aa01803ef37b08c35da1947b07336e0576aacb9fcca0ccc5fa94e8db4ad3f00559fb5cc9d8e97f61c6ae5b4476a4f7cc3dfcafd9fd97bbfa89a0fd720f74cf8aa9e7de9650f8dc4274a15fce7ce4d3a0025f58c682125ac5b07f381d7f216a1dbd79ae21f60e51a3a0690249eca7ec29700ddb159ed7f23978840a87aeb287b5e763e0aaab02facfe4fb7288c6dd3b8d4f44e3e60ab0a4b22bc2fcde4392374ec0715ffe1ba9b916282f59b5ae379cadd9576073251b45c3a192b837138314657f4b374d0d4b5b7b599ec8700f1994e4bbf921d97a7b49ce6c5b018dd1cd47aee80e80b280</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ctf卷王排行榜的项目说明</title>
      <link href="/2024/09/17/%E5%85%B3%E4%BA%8Ectf%E5%8D%B7%E7%8E%8B%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/09/17/%E5%85%B3%E4%BA%8Ectf%E5%8D%B7%E7%8E%8B%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/coperlm/ctf_juanwangbang">开源网址</a></p><span id="more"></span><p>版本1.0</p><p>本程序的大致原理是，使用cookie进行登录并发送GET请求，获取响应文本然后提取，得到指定用户的指定方向（categories）做题数量</p><p>程序主体分为三个部分：</p><ul><li><p>文件读写的函数（控制台的输出数据仅供调试使用）</p></li><li><p>获取用户的做题数量，此部分需要使用者自行输入api</p></li><li>通过已知的uid，返回对应的用户名，用于生成榜单</li></ul><p>后续需要做的事情：</p><ul><li>优化代码看起来奇奇怪怪的部分（</li><li>cookie登录存在弊端</li><li>优化前端设计并实现榜单生成部分</li><li>按周或者按天计算刷题量（可能比较好做，但是这是另一项工作了，暂时束之高阁）</li><li>实现自动化生成榜单</li><li>下次不能把一个zip直接扔进仓库里去了</li></ul><p>后续版本的更新日志见 <code>README.md</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录typora+hexo+next使用圆圈数字和多行latex</title>
      <link href="/2024/09/16/%E8%AE%B0%E5%BD%95typora-hexo-next%E4%BD%BF%E7%94%A8%E5%9C%86%E5%9C%88%E6%95%B0%E5%AD%97%E5%92%8C%E5%A4%9A%E8%A1%8Clatex/"/>
      <url>/2024/09/16/%E8%AE%B0%E5%BD%95typora-hexo-next%E4%BD%BF%E7%94%A8%E5%9C%86%E5%9C%88%E6%95%B0%E5%AD%97%E5%92%8C%E5%A4%9A%E8%A1%8Clatex/</url>
      
        <content type="html"><![CDATA[<p>在编辑 <a href="https://coperlm.github.io/2024/09/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E9%A2%98/">这篇博客</a>，遇到了两个问题</p><span id="more"></span><ol><li>如何展示圆圈里面数字</li></ol><p>看了一下网上教程，一般是更改平台导入宏包或者使用<code>\textcircled</code>语法，但是前者可能出现更多的问题 后者我这边本地不凑效</p><p>然后看了 <a href="https://blog.csdn.net/wait_for_eva/article/details/111300723">这篇博客</a> 学习到了一个切实可行的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\enclose&#123;circle&#125;&#123;1&#125; \\</span><br><span class="line">\enclose&#123;circle&#125;[mathcolor=&quot;red&quot;]&#123;2&#125; \\</span><br><span class="line">\enclose&#123;box&#125;&#123;3&#125; \\</span><br><span class="line">\enclose&#123;circle,box&#125;&#123;4&#125; \\</span><br><span class="line">\enclose&#123;circle&#125;&#123;\enclose&#123;box&#125;&#123;5&#125;&#125; \\</span><br><span class="line">\enclose&#123;box&#125;&#123;\enclose&#123;circle&#125;&#123;6&#125;&#125; \\</span><br><span class="line">\enclose&#123;circle&#125;&#123;\enclose&#123;circle&#125;&#123;7&#125;&#125; \\</span><br><span class="line">\enclose&#123;box&#125;&#123;\enclose&#123;box&#125;&#123;8&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果：</p><script type="math/tex; mode=display">\enclose{circle}{1} \\\enclose{circle}[mathcolor="red"]{2} \\\enclose{box}{3} \\\enclose{circle,box}{4} \\\enclose{circle}{\enclose{box}{5}} \\\enclose{box}{\enclose{circle}{6}} \\\enclose{circle}{\enclose{circle}{7}} \\\enclose{box}{\enclose{box}{8}}</script><p>补充：我安装了的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ npm list --depth=0</span><br><span class="line">hexo-site@0.0.0 C:\Users\coper\Desktop\myblog</span><br><span class="line">├── hexo-asset-image@0.0.5</span><br><span class="line">├── hexo-asset-img@1.1.0</span><br><span class="line">├── hexo-blog-encrypt@3.1.9</span><br><span class="line">├── hexo-deployer-git@4.0.0</span><br><span class="line">├── hexo-filter-mathjax@0.9.0</span><br><span class="line">├── hexo-generator-archive@2.0.0</span><br><span class="line">├── hexo-generator-category@2.0.0</span><br><span class="line">├── hexo-generator-index@4.0.0</span><br><span class="line">├── hexo-generator-searchdb@1.4.1</span><br><span class="line">├── hexo-generator-tag@2.0.0</span><br><span class="line">├── hexo-math@5.0.0</span><br><span class="line">├── hexo-renderer-ejs@2.0.0</span><br><span class="line">├── hexo-renderer-kramed@0.1.4</span><br><span class="line">├── hexo-renderer-pandoc@0.4.0</span><br><span class="line">├── hexo-renderer-stylus@3.0.1</span><br><span class="line">├── hexo-server@3.0.0</span><br><span class="line">├── hexo-theme-landscape@1.0.0</span><br><span class="line">├── hexo-wordcount@6.0.1</span><br><span class="line">└── hexo@7.3.0</span><br></pre></td></tr></table></figure><hr><p>多行latex中，会出现多出来一对 $$$$</p><p>举个例子：</p><p>原文：<img src="image-20240916145615417.png" alt></p><p>实际：</p><p><img src="image-20240916145629909.png" alt></p><p>经过F12调试发现，格式和正常的也不太对</p><p>然后一通摸索之后发现，把这个去掉就可以了</p><p><img src="image-20240916145713065.png" alt></p><p>然后恢复正常</p><p><img src="image-20240916145755297.png" alt></p><p>（一开始还以为是直接使用字符的数字圆圈导致的显示不正常，才去搞基于latex的数字圆圈，后来才知道是因为我多打换行了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一道泰勒公式相关的考研数学题</title>
      <link href="/2024/09/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
      <url>/2024/09/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天，有个学长（烤盐糕守）发给了我一道树穴题（据说是刚出锅的热乎题）</p><p>问题：极限 $lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{x^2-sin^2xcosx}=?$</p><span id="more"></span><p>方法一：洛！</p><p>计算量巨大，不做展开</p><p>方法二：泰勒</p><p>先放答案：</p><script type="math/tex; mode=display">\begin{align*}      &\ \ \ \ \ lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{x^2-sin^2xcosx}\enclose{circle}{1}\\    &= lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{x^2-(x-\frac{1}{6}x^3)^2(1-\frac{x^2}{2})}\enclose{circle}{2}\\    &= lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{\frac{5}{6}x^4}\enclose{circle}{3}\\    &= lim_{x\rightarrow 0}\dfrac{(x-(x-\frac{x^2}{2}))\frac{x^2}{2}}{\frac{5}{6}x^4}\enclose{circle}{4}\\    &= \frac{3}{10}\enclose{circle}{5}\end{align*}</script><ol><li>分母（式①到式②）怎么来的？</li></ol><p>因为无穷小的运算法则：$o(x^n)+o(x^m)=o(x^{min(n,m)})$，低阶（无穷小）相应的更大，而分母的泰勒展开是直接要最小项的（无穷小的运算法则让它展开为最小项），所以要用更大的那个无穷小去算</p><p>对于分母 ${x^2-sin^2xcosx}$，cos的阶数是 平方，所以取 $x^4$ 作为实质的最小项（$x^2$ 消掉了）</p><script type="math/tex; mode=display">\begin{align*}      &\ \ \ \ \ lim_{x\rightarrow 0}\ {x^2-sin^2xcosx}\\    &= lim_{x\rightarrow 0}\ x^2-(x-\frac{1}{6}x^3)^2(1-\frac{x^2}{2})\\    &= lim_{x\rightarrow 0}\ x^2-(x^2-\frac{1}{3}x^4+\frac{1}{36}x^6)(1-\frac{x^2}{2})\\    &容易观察到，x^2项全消了，所以最小项就是x^4\\    &= lim_{x\rightarrow 0}\ \frac{1}{3}x^4 * 1 + x^2 * \frac{x^2}{2} \\    &= lim_{x\rightarrow 0} \frac{5}{6}x^4\end{align*} \\</script><p>如果只取sin的第一项：</p><script type="math/tex; mode=display">(错误示范)\\\begin{align*}      &\ \ \ \ \ lim_{x\rightarrow 0}\ {x^2-sin^2xcosx}\\    &= lim_{x\rightarrow 0}\ x^2-x^2(1-\frac{x^2}{2})\\    &= lim_{x\rightarrow 0}\ \frac{x^4}{2}\end{align*} \\</script><p>显然是不完整的，有一部分的 $x^4$ 未考虑</p><p>综上所述：分母的泰勒展开是直接要最小项的，但是不是只取最终项，要完整的求出最小项（如本题中，是 $x^4$ ），根据如何得到最小项来判断泰勒展开需要多少项（其实展开多了也没事，反正不会是最小项）</p><ol><li>分子（式③到式④）怎么来的？</li></ol><p>分子泰勒展开，展开<del>到和分母一样的阶数</del>即可⑤</p><p>式子 $lim_{x\rightarrow 0}\dfrac{(x-ln(1+x))(1-cosx)}{\frac{5}{6}x^4}$ 中，<del>分母是四次方，所以分子也要展开到四次方</del>（见后文，删除线中的内容和因果关系是错误的，但是本题中确实是展开到四次方）</p><script type="math/tex; mode=display">\begin{align*}      &\ \ \ \ \ lim_{x\rightarrow 0}\ (x-ln(1+x))(1-cosx) \\    &= lim_{x\rightarrow 0}\ (x-(x-\frac{1}{2}x^2))\frac{x^2}{2} \\    &= lim_{x\rightarrow 0}\ \frac{x^4}{4}\end{align*}</script><p>相关例题：</p><p>试计算 $lim_{x\rightarrow 0}\ \frac{x-sinx}{x^3}$</p><p>解：</p><script type="math/tex; mode=display">\begin{align*}      &\ \ \ \ \ lim_{x\rightarrow 0}\ \frac{x-sinx}{x^3}\\      &\ \ \ \ \ 因为分母的最高项是三次方，故这里sinx也展开到三次方(这句话也是错误的，见下文 \\    &= lim_{x\rightarrow 0}\ \frac{x-(x-\frac{1}{6}x^3)}{x^3}\\    &= lim_{x\rightarrow 0}\ \frac{x-(x-\frac{1}{6}x^3)}{x^3}\\    &= lim_{x\rightarrow 0}\ \frac{\frac{1}{6}x^3}{x^3}\\    &= \frac{1}{6}\end{align*} \\</script><ol><li>为什么分子分母要等阶（⑤）？</li></ol><p>高阶无穷小+低阶无穷小=低阶无穷小</p><p>所以无论展开几项都是一样的，都会只有最低阶（即展开后较靠前的部分）对于极限的计算有影响</p><p>故 <strong>无论分子分母，只需要展开到最低阶</strong>（即最终式子剩下的最低阶）</p><p>无需证明是否在极限值附近有界，只需要分子分母分别展开即可（这也是上文中删除线中句子错误的原因）</p><ol><li>总结</li></ol><p>计算此类题目（无法使用等价无穷小），只需要将分子分母中可以展开的项分别展开（目的是为了消项），展开到保留（最终结果的）最小项，再进行运算比较即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用wifi发射模块串通网络的debug过程</title>
      <link href="/2024/09/13/%E4%BD%BF%E7%94%A8wifi%E5%8F%91%E5%B0%84%E6%A8%A1%E5%9D%97%E4%B8%B2%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84debug%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/09/13/%E4%BD%BF%E7%94%A8wifi%E5%8F%91%E5%B0%84%E6%A8%A1%E5%9D%97%E4%B8%B2%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84debug%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>之前尝试连接内网，实现任意两点的数据传输和互联网的访问，采取了网线和蓝牙的方式，最终以失败告终。今天新买的wifi接收/发射模块到货了，插上试了一下</p><span id="more"></span><p>前置知识 <code>win+R</code> ，输入 <code>ncpa.cpl</code> 打开 <code>网络连接</code></p><p>刚插上会多一个这个图标</p><p><img src="image-20240913194954282.png" alt></p><p>打开热点会多一个这个图标</p><p><img src="image-20240913194857209.png" alt></p><p>使用第二台设备直接连接，会出现 <code>正在搜索ip</code> 等字样</p><p>百度一下，发现需要打开共享</p><p>右键需要共享的网络点击属性</p><p><img src="image-20240913200303258.png" alt></p><p>点击允许共享，<code>家庭网络连接</code>填写 <strong>发送</strong> 热点信号的网络（模块）</p><p><img src="image-20240913201038762.png" alt></p><p><strong>如果没有这个选项</strong>，需要用其他奇技淫巧来解决（别问我怎么知道的）</p><p>咱买的wifi模块，不是也能发射也能接收嘛</p><p>你先别用有线网（以太网）线连接电脑，先开一下手机热点，连上电脑</p><p>然后（我这台电脑）在 <code>WLAN</code> 里就出现了 <code>本地连接* 11</code> 的选项</p><p>不要断，立即切换到以太网，然后就成功了</p><p>这个是最终的效果</p><p><img src="image-20240913201351937.png" alt></p><p>重新启动了电脑，依旧可以正常连接（学计算机的不会真的有人关电脑吧（bushi））</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.9.11组会</title>
      <link href="/2024/09/11/2024.9.11%E7%BB%84%E4%BC%9A/"/>
      <url>/2024/09/11/2024.9.11%E7%BB%84%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e14e86521c77f5ec9ec8b58e6ed540507fee5331941fda82f07c7dcd164eb471">7b22b1899bb4d215751e07a80f0d88de7ac43174b2bb1ad06a11d61b739ea0073709999a7abd32e45bb6e9a37adb7657ceb36495f5c55a980bd4fb92793294a46c56fee9c2e0f25deca538e36c8e329d72963c09166eda1479d2acc20b4d7f28b0264000ba8ecf58060a5d37424302eeb71e65dc390d166624d53f53c9f29d95de84b9cf88abba066824834fd2bcee6cc77efe36bf9aa4835b6c8480b4a689d0859a5ba8b9647d58b39e618e53fe21696b730341183dee80b4600369c1546341da8a38272c47c38e8febfbc754224d3ef173e4366f687d60fb2ebd1f5ca7fbc7e907da4c78389cff266a4deaf02d0b249ee69e3a129b1d616cefb7aaee350bb3036e4aca4144d8e8444d00700ad0da9c85dfbf6ed7091d584a65f8c4ba5d6c99da0ec37221fd1b28ef51d63fd55a30a5feb4ea47cfb9e0e3c46596815fa78e2c39b4ce37e12c2424b18b0b6602bd85c2534d0073b79a4e0cfe9d555c91cc46863a08fdde2818ddc791b19ccc12cffbedcc22340af32c0a8713d9a86a5e62037133ef7d1bfa8cd323ea77e8b4fdf5a71832e078102bf481ccac5d361ed1324a86ca46bd276c208be41cd04197be4ecb48623814784202540d793081d1bd0af4459f755b571506b6f58fb716f39c9c1631182797dca2e88c1d2754e943ab57dd3f13a85d7540ad8b12719f60988116c6404f36b1729e02357721a2a522d8943cb8404419b4f9d3aeb1b3872e2675d5f06ea5bd058845b05c517f0890cddf2b23b4aff2cdfdadab8ee46c439917d0aeaf94c61a4e50454419a79c7e959133091d384a0849db745a1f27bc60b85b1cc0e105d9bc4d0588c646adc1a082513779440855d0c36d9e513d46f76b71fbc3d677706fabc7126d2a0685f28c41bd3465d2a8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> meetings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读paper</title>
      <link href="/2024/09/11/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBpaper/"/>
      <url>/2024/09/11/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBpaper/</url>
      
        <content type="html"><![CDATA[<p>2024.11.06二编</p><p>多读解决一切问题~</p><hr><p>2024.9.6下午，我开始干啃《Chameleon Hashing and Signature》这篇文章；十分钟之后，感觉头顶冒烟了~</p><p>如果单单阅读 Abstract 和 Introduction 部分，虽然可以快速领会文章的大意，但是其内容对读者的提升同样巨大</p><p>故总结了几篇高推荐文章，作为今后论文阅读的指导</p><span id="more"></span><p>论文获取：</p><ul><li>询问导师和同门</li><li>Google Scholar运用合适的关键词收集30篇左右论文（高引用量论文优先收集）</li><li>高引论文的参考文献</li></ul><p>论文如何阅读：</p><p>一篇期刊论文，主要分成三个部分。</p><ol><li>Abstract：</li></ol><p>这篇论文的：主要贡献、方法特色与主要内容。</p><p>只看 Abstract 和 Introduction 判断篇论文的重点和你的研究有没有直接关联，从而决定要不要把它给读完</p><ol><li>Introduction：</li></ol><p>功能：介绍问题的背景和起源，交代前人在这个题目上已经有过的主要贡献，说清楚前人留下来的问题，以及在这个背景下这篇论文想解决的问题和它的意义。</p><p>对初学的学生而言，从这里可以了解以前研究的概况。先把跟你题目可能相关的论文收集个 30～40篇，每篇都只读Abstract 和 Introduction，而不要读 Main Body（本文），只在必要时稍微参考一下后面的 Illustrative examples和 Conclusions，直到你能回答下面这四个问题：</p><ul><li>（2A）在这领域内最常被引述的方法有哪些？</li><li>（2B）这些方法可以分成哪些主要派别？</li><li>（2C）每个派别的主要特色（含优点和缺点）是什么？</li><li>（2D）这个领域内大家认为重要的关键问题有哪些？有哪些特性是大家重视的优点？有哪些特性是大家在意的缺点？这些优点与缺点通常在哪些应用场合时会比较被重视？在哪些应用场合时比较不会被重视？</li></ul><p>问题是，你怎么去找到这最初的30～40篇论文？有一种期刊论文叫做review paper，专门在一个题目下面整理出所有相关的论文，并且做简单的回顾。你可以在搜寻 Compendex 时在 keywords 中加一个review而筛选出这类论文。然后从相关的数篇review paper 开始，从中根据 title 与 Abstract 找出你认为跟你研究题目较相关的30～40篇论文。</p><p>通常只要你反复读过该领域内30～40篇论文的Abstract 和 Introduction，你就应该可以从Introduction的评论中回答（2A）和（2B）这两个问题。尤其要记得，当你阅读的目的是要回答（2A）和（2B）这两个问题时，你一定要先挑那些 Introduction写得比较有观念的论文念（很多论文的Introduction 写得像流水帐，没有观念，这种论文刚开始时不要去读它）。假如你读过30～40篇论文的 Abstract 和 Introduction之后，还是回答不了（2C），先做下述的工作。</p><p>你先根据（2A）的答案，把这领域内最常被引述的论文找齐，再把他们根据（2B）的答案分成派别，每个派别按日期先后次序排好。然后，你每次只重新读一派的 Abstract 和 Introduction（必要时简略参考内文，但目的只是读懂Introduction内与这派有关的陈述，而不需要真的看懂所有内文），照日期先后读 ，读的时候只企图回答一个问题：这一派的创意与主要诉求是什么？这样，你逐派逐派地把每一派的Abstract 和 Introduction 给读完，总结出这一派主要的诉求 、方法特色和优点（每一篇论文都会说出自己的优点，仔细读就不会漏掉）。</p><p>其次，你再把这些论文拿出来，但是只读Introduction，认真回答下述问题：每篇论文对其它派别有什么批评？然后你把读到的重点逐一记录到各派别的“缺点”栏内。</p><p>通过以上程序，你就应该可以掌握到（2A）、（2B）和（2C）三个问题的答案。这时你对该领域内主要方法、文献之间的关系算是相当熟稔了，但是你还是只仔细读完Abstract 和 Introduction而已，内文则只是笼统读过。</p><p>这时候，你已经掌握到这领域主要的论文，你可以用这些论文测试看看你用来搜寻这领域论文的 keywords 到底恰不恰当，并且用修正过的 keywords 再搜寻一次论文，把这领域的主要文献补齐，也把原来30～40篇论文中后来发现关系较远的论文给筛选掉，只保留大概20篇左右确定跟你关系较近的文献。如果有把握，可以甚至删除一两个你不想用的派别（要有充分的理由），只保留两、三个派别（也要有充分的理由）继续做完以下工作。</p><p>然后你应该利用（2C）的答案，再进一步回答一个问题（2D）：</p><ul><li><strong>这个领域内大家认为重要的关键问题有哪些？</strong></li><li><strong>有哪些特性是大家重视的优点？</strong></li><li><strong>有哪些特性是大家在意的缺点？</strong></li><li><strong>这些优点与缺点通常在哪些应用场合时会比较被重视？</strong></li><li><strong>在哪些应用场合时比较不会被重视？</strong></li></ul><p>然后，你就可以整理出这个领域（研究题目）主要的应用场合，以及这些应用场合上该注意的事项。</p><p>最后，在你真正开始念论文的 main body 之前，你应该要先根据（2A）和（2C）的答案，把各派别内的论文整理在同一个档案夹里，并照时间先后次序排好。然后依照这些派别与你的研究方向的关系远近，一个派别一个派别地逐一把各派一次念完一派的 main bodies。</p><ol><li>Main body（含simulation and/or experimental examples）：</li></ol><p>在你第一次有系统地念某派别的论文 main bodies 时，你只需要念懂：</p><ul><li>（3A）这篇论文的主要假设是什么（在什么条件下它是有效的），并且评估一下这些假设在现实条件下有多容易（或多难）成立。愈难成立的假设，愈不好用，参考价值也愈低。</li><li>（3B）在这些假设下，这篇论文主要有什么好处。</li><li>（3C）这些好处主要表现在哪些公式的哪些项目的简化上。至于整篇论文详细的推导过程，你不需要懂。除了三、五个关键的公式（最后在应用上要使用的公式，你可以从这里评估出这个方法使用上的方便程度或计算效率，以及在非理想情境下这些公式使用起来的可靠度或稳定性）之外，其它公式都不懂也没关系，公式之间的恒等式推导过程可以完全略过去。假如你要看公式，重点是看公式推导过程中引入的假设条件，而不是恒等式的转换。</li><li>（3D）这一派主要的缺点有哪些。</li></ul><p>但是，在你开始根据前述问题念论文之前，你应该先把这派别所有的论文都拿出来，逐篇粗略地浏览过去（不要勉强自己每篇或每行都弄到懂，而是轻松地读，能懂就懂，不懂就不懂），从中挑出容易念懂的 papers，以及经常被引述的论文。然后把这些论文按照时间先后次序依序念下去。记得：你念的时候只要回答（3A）、（ 3B）、（3C）三个问题就好，不要念太细。</p><p>这样念完以后，你应该把这一派的主要发展过程，主要假设、主要理论依据、以及主要的成果做一个完整的整理。其次，你还要在根据（2D）的答案以及这一派的主要假设，进一步回答下一个问题：（3D）这一派主要的缺点有哪些。最后，根据（ 3A）、（3B）、（3C）、（3D）的答案综合整理出：这一派最适合什么时候使用，最不适合什么场合使用。　　</p><p>当你是生手的时候，你要评估一个方法的优缺点时，往往必须要参考它Examples。但是，要记得：老练的论文写作高手会故意只 present 成功的案例而遮掩失败的案例。所以，simulation examples and/or experiments 很棒不一定表示这方法真的很好。你必须要回到这个方法的基本假设上去，以及他在应用时所使用的主要公式（resultant equations）去，凭自己的思考能力， 并且参考（2C）和（2D）的答案，自己问问看：当某某假设在某些实用场合上无法成立时，这个方法会不会出什么状况？猜一猜，预测一下这个方法应该会在哪些条件下（应用场合）表现优异，又会在哪些条件下（应用场合）出状况？根据这个猜测再检验一次simulation examples and/or experiments，看它的长处与短处是不是确实在这些examples 中充分被检验，且充分表现出来。</p><p>那么，你什么时候才需要弄懂一篇论文所有的恒等式推导过程，或者把整篇论文细细读完？<strong>NEVER！</strong>你只需要把确定会用到的部分给完全搞懂就好，不确定会不会用到的部分，只需要了解它主要的点子就够了。</p><hr><p>Reference:</p><p><a href="https://www.jiqizhixin.com/articles/2019-02-22-5">一文教你如何快速高效阅读Paper（硕士生版）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荔枝橙味拱腰觅马糕守</title>
      <link href="/2024/09/11/%E8%8D%94%E6%9E%9D%E6%A9%99%E5%91%B3%E6%8B%B1%E8%85%B0%E8%A7%85%E9%A9%AC%E7%B3%95%E5%AE%88/"/>
      <url>/2024/09/11/%E8%8D%94%E6%9E%9D%E6%A9%99%E5%91%B3%E6%8B%B1%E8%85%B0%E8%A7%85%E9%A9%AC%E7%B3%95%E5%AE%88/</url>
      
        <content type="html"><![CDATA[<p>本篇文章旨在记录笔者阅读《公钥密码方案构造及安全证明的知识要点和方法论》的学习总结和收获</p><span id="more"></span><p><img src="公钥密码方案构造及安全证明的知识要点和方法论.png" alt></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p>归纳总结了构造可证明安全的公钥密码方案所需掌握的知识要点</p><ul><li><p>基本概念</p></li><li><p>数学基础</p></li><li><p>简单问题和困难问题</p></li><li><p>算法</p></li><li><p>安全规约证明</p></li><li><p>-&gt; 学习方案构造以及安全证明不可或缺的基础部分 需要最先掌握</p></li></ul></li><li><p>学习构造可证明安全的公钥密码方案的方法</p><ul><li><p>方案构造学习（如何学习方案构造）</p><ul><li><p>算法定义和安全模型定义</p></li><li><p>经典方案推荐</p></li><li><p>尝试发现方案构造错误</p></li><li><p>-&gt; 使读者具备构造方案的基本能力</p></li><li><p>-&gt; 方案的构造与方案的安全证明相互影响，在缺乏安全证明的学习下，读者尚无能力构造可证明安全的方案</p></li></ul></li><li><p>安全证明学习（如何学习安全证明，规约相关）</p><ul><li><p>概念学习</p></li><li><p>证明训练</p></li><li><p>经典方案推荐</p></li><li><p>尝试发现证明错误</p></li></ul></li><li><p>构造可证明安全密码方案（对构造可证明安全密码的方案方法的建议）</p><ul><li><p>文献阅读</p></li><li><p>尝试方案构造和安全证明</p></li></ul></li></ul></li><li><p>30个经典方案及其证明用于该阶段的练习</p></li></ul><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><p>两本书籍《Modern Cryptography: Theory and Practice》，《INTRODUCTION TO  MODERN CRYPTOGRAPHY》</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>复杂性理论</p><ul><li><p>时间复杂度</p><ul><li>L-notation(Landau Notation)：也成为渐进符号，主要用于描述算法的时间和空间复杂度的增长趋势；包括 $O()\ \Omega()\ \Theta()$，分别表示算法在 最坏、最好和平均情况下的时间或空间复杂度；$\Omega()$ 表示算法的 下界，$\Theta()$ 表示算法的 精确界。</li><li>Probabilistic Polynomial Time (PPT)：指可以在多项式时间内通过概率算法解决的问题。概率算法在某些情况下可能会给出错误的答案，但运行时间是多项式级别的。如：蒙特卡洛算法。</li><li>Sub-exponential Time：亚指数时间，指的是算法的运行时间比指数增长慢但比多项式时间快，通常表示为 $2^{o(n)}$，是介于多项式时间和指数时间之间的复杂度。如：$n^{log\ n}$是亚指数时间，但 $2^n$ 是指数时间。</li><li>Exponential Time：指数时间，指算法的运行时间随着输入规模 $n$ 的增加呈指数增长，常用形式如 $O(2^n)$ 或 $O(c^n)$ （其中$ c&gt;1$）。这类算法运行时间增长非常快。如：旅行商问题 $O(n!)$。</li></ul></li><li><p>计算复杂性</p><ul><li><p>P (Polynomial Time)：多项式时间类。所有能够在多项式时间内解决的问题的集合。如：快速排序和归并排序。</p></li><li><p>NP (Nondeterministic Polynomial Time)：非确定性多项式时间类。可以容易验证解是否正确，但难以找解。如：子集和问题，如果给定一个可能的解，可以快速验证它是否正确，但找到该解的过程可能非常耗时。如：起点到终点是否有至少一条小于100个单位长度的路线。（所有P类问题都是NP问题）</p></li><li><p>NPC (NP-Complete)：NP 完全问题。这是一类最难的 NP 问题，所有 NP 问题都可以通过多项式时间归约到这类问题。如：旅行商问题（判定版本）、3-SAT 问题</p></li><li><p>NP-Hard ：NP难问题至少和NP问题一样难，可能更难；NP难问题不一定是NP问题，也就是说，它们的解不一定能够在多项式时间内验证。如：旅行商问题、停止问题（Halting Problem）（给定一个程序和输入，判断程序在这个输入上是否会停止）</p></li></ul></li><li><p>计算模型相关术语</p><ul><li>Computation Model (计算模型)：这是定义如何进行计算的理论框架，用于定义什么可以被计算和如何计算。如“”模型包括图灵机、随机存取机（RAM）和有限状态自动机等。</li><li>Turing Machine (图灵机)：由计算理论之父艾伦·图灵提出的抽象计算模型。由一个无限长的纸带（表示内存）和一个读写头组成。图灵机的每一步计算由状态和符号决定，能够通过改变符号和移动读写头来执行计算。图灵机是复杂性理论中用于定义可计算性和时间复杂度的基础模型。</li></ul></li></ul></li><li><p>攻击</p><ul><li><p>Birthday Attack（生日攻击）</p><ul><li>攻击对象：哈希函数</li><li>攻击目标：找到两个不同的输入具有相同的哈希值（哈希碰撞）。</li><li>例子：对 MD5 哈希函数进行生日攻击，攻击者可能找到两个不同的消息产生相同的哈希值，从而进行数字签名伪造或文件篡改。</li></ul></li><li><p>Man-in-the-middle Attack (中间人攻击)</p><ul><li>攻击对象：通信协议（特别是缺乏认证的加密协议）</li><li>攻击目标：拦截并篡改双方之间的通信，而通信双方并不察觉。</li><li>例子：攻击者在 Alice 和 Bob 之间建立两个独立的加密会话，拦截并解密他们发送的消息，然后篡改内容再发送给对方。</li></ul></li><li><p>Brute-force Attack (暴力破解攻击)</p><ul><li>攻击对象：密码或加密密钥</li><li>攻击目标：通过穷举所有可能的组合找到密码或密钥。</li><li>例子：对使用短位数密码（如 4 位数字 PIN）的系统，攻击者可以尝试所有 10000 种可能的组合，直到找到正确的密码。</li></ul></li><li><p>Eavesdropping Attack (窃听攻击)</p><ul><li>攻击对象：未加密或不安全的通信</li><li>攻击目标：窃听通信内容，获得敏感信息。</li><li>例子：攻击者在未加密的 Wi-Fi 网络上捕获用户发送的明文密码或信用卡号。</li></ul></li><li><p>Meet-in-the-middle Attack</p><ul><li>攻击对象：双重加密系统（如 2DES）</li><li>攻击目标：通过分别攻击加密的前半部分和后半部分，减少破解加密所需的时间。</li><li>例子：攻击 2DES，攻击者使用一个中间状态同时攻击加密的前半部分（第一轮加密）和后半部分（第二轮加密），从而减少暴力破解的时间复杂度。</li></ul></li><li><p>Collusion Attack (共谋攻击)</p><ul><li>攻击对象：多方协议或共享资源的系统</li><li>攻击目标：多个恶意方合作以欺骗系统或窃取信息。</li><li>例子：在分布式投票系统中，多方共谋可以合谋修改投票结果或操纵选举。</li></ul></li><li><p>Side-channel Attack (旁道攻击)</p><ul><li>攻击对象：硬件实现的加密算法</li><li>攻击目标：通过观察硬件泄露的信息（如电磁辐射、功耗、运行时间）来推测密钥或加密数据。</li><li>例子：攻击者通过测量加密设备的功耗，推测出设备运行不同指令时的耗电差异，从而推测出加密密钥。</li></ul></li><li><p>Statistical Attack (统计攻击)</p><ul><li>攻击对象：加密算法或协议</li><li>攻击目标：通过分析加密文本或通信中不同部分的统计特性来破译密文或找到加密弱点。</li><li>例子：攻击者通过分析加密文本中字符的频率，破译简单替换密码，因为某些字母（如英文中的 “e”）出现频率较高。</li></ul></li><li><p>Replay Attack (重放攻击)</p><ul><li>攻击对象：认证协议或通信协议</li><li>攻击目标：通过截获和重放有效的数据包来伪装合法用户。</li><li>例子：攻击者截获并重放用户登录系统时发送的认证请求，从而在不知晓密码的情况下再次登录。</li></ul></li><li><p>Rainbow Attack (彩虹表攻击)</p><ul><li>攻击对象：加密的密码或哈希值</li><li>攻击目标：通过使用预先计算的哈希表（彩虹表）来反向查找密码。</li><li>例子：攻击者使用彩虹表匹配存储的 MD5 哈希值，找到对应的明文密码，从而绕过系统的哈希加密机制。</li></ul></li></ul></li><li><p>基本工具</p><ul><li>单向函数 (One-way Function)</li><li><p>输入：任意大小的输入值（通常是整数或比特串）。</p></li><li><p>输出：固定长度或与输入长度相关的输出值。</p></li><li><p>输入输出关系：单向函数易于从输入计算输出，但从输出反推出输入非常困难（计算上不可行）。</p></li><li><p>应用场景：单向函数是许多密码学协议（如哈希函数、数字签名、密码算法）的基础。常见应用包括：</p><ul><li>密码散列<ul><li>认证机制中的口令验证</li></ul></li><li>零知识证明中的承诺方案</li></ul></li></ul></li><li><p>陷门单向函数 (Trapdoor One-way Function)</p><ul><li><p>输入：任意大小的输入值和一个“陷门”信息（通常是密钥）。</p></li><li><p>输出： 固定长度或与输入相关的输出值。</p></li><li><p>输入输出关系：在没有陷门信息的情况下，从输出推回输入非常困难；而有陷门信息时，可以有效地反推出输入。</p></li><li><p>应用场景：陷门单向函数广泛应用于公钥加密和数字签名。例如：</p><ul><li>RSA加密：只有拥有私钥的用户能够轻松解密用公钥加密的消息。</li><li>数字签名：签名者使用私钥进行签名，验证者使用公钥验证签名。</li></ul></li></ul></li><li><p>伪随机函数 (Pseudo-random Function, PRF)</p><ul><li>输入：一个密钥和一个输入值（通常是比特串）。<ul><li>输出：一个伪随机的输出值，类似于随机数生成器的输出。</li></ul></li><li>输入输出关系：PRF 生成的输出看起来像随机的，但它是确定的，即对于同一个密钥和输入，输出总是相同的。只有拥有密钥的用户能够区分伪随机输出和真实随机输出。<ul><li>应用场景：PRF 被广泛用于对称密钥加密、消息验证码 (MAC)、伪随机数生成、以及密钥派生函数 (KDF) 中。</li></ul></li></ul></li><li><p>哈希函数 (Hash Function)</p><ul><li><p>输入：任意长度的输入数据。</p><ul><li><p>输出： 固定长度的哈希值。</p></li><li><p>输入输出关系：哈希函数将任意长度的输入映射到固定长度的输出。理想的哈希函数具有抗碰撞性，即找到两个不同输入映射到同一输出的概率应该非常低。</p></li><li><p>应用场景：</p><ul><li>数据完整性：用于校验数据是否被篡改（如SHA-256用于数字签名）。</li></ul></li><li>密码存储：存储用户密码的哈希值，而不是明文密码。<ul><li>区块链：用来确保区块内容的不可篡改性。</li></ul></li></ul></li><li><p>硬核谓词 (Hard-core Predicates)</p></li><li>输入：单向函数的输入值和输出值。<ul><li>输出： 比特值（0或1）。</li></ul></li><li><p>输入输出关系：对于给定的单向函数 $f$ 和输入 $x$，计算 $f(x)$ 很容易，但对于某些特殊比特（称为硬核谓词），即使知道$f(x)$，要猜出该比特的值也非常困难。</p><ul><li>应用场景：硬核谓词用于设计更加安全的加密协议，如流密码生成器中的位选择机制。常见的硬核谓词包括 Blum-Micali 伪随机生成器中的二次剩余判定。</li></ul></li><li><p>熵函数 (Entropy Function)</p><ul><li>输入：概率分布或随机变量。</li></ul></li><li><p>输出：熵值（衡量随机变量的不确定性或信息量，通常以比特为单位）。</p></li><li><p>输入输出关系：熵函数给出输入随机变量的不确定性度量，熵越大，信息越难预测；熵越小，信息越确定。</p><ul><li><p>应用场景：</p><ul><li>密码安全性评估：用于评估随机数生成器的质量。</li></ul></li><li>信息论：熵函数用于分析通信系统中传递信息的有效性。<ul><li>数据压缩：根据数据的熵来决定最佳的压缩算法，如Huffman编码。</li></ul></li></ul></li></ul></li><li><p>认证</p></li><li><p>加密</p></li><li><p>模型</p><ul><li><p>Random Oracle Model（随机预言机模型）</p><ul><li>概念：将哈希函数视为一个理想化的随机预言机，即每次查询哈希函数时都会返回一个随机值，不考虑实际哈希函数的实现细节。</li><li>应用场景：这个模型通常用于证明密码方案的安全性，尤其是在设计签名算法、加密方案或零知识证明时，随机预言机模型简化了安全分析。例如，很多实际使用的加密方案，如RSA-OAEP和HMAC，在这个模型下被证明是安全的。</li><li>优点：可以简化安全性证明并提供很强的安全性保证。</li><li>局限性：实际中的哈希函数并不是理想的随机预言机，因此在现实中可能存在攻击漏洞。</li></ul></li><li><p>Standard Model（标准模型）</p><ul><li>概念：不依赖随机预言机等理想化的假设，而是依赖于基于已知的数学问题（如离散对数、因数分解等）的假设进行安全性证明。</li><li>应用场景：标准模型下的安全性证明更接近现实，通常用于密码学协议的严格安全性分析。例如，基于困难数学问题（如RSA、Diffie-Hellman）的加密和签名方案，通常在标准模型下证明其安全性。</li><li>优点：提供更为现实的安全性保证，避免使用理想化的假设。</li><li>局限性：安全性证明往往更复杂，并且可能导致效率低下的方案。</li></ul></li><li><p>Common Reference String Model（公共参考字符串模型）</p><ul><li>概念：在这种模型中，所有参与方在协议开始之前都会共享一个公共的随机字符串，该字符串由一个可信方生成。</li><li>应用场景：该模型经常用于零知识证明系统和多方安全计算（MPC）中。公共参考字符串用于保证协议的正确性和安全性。例如，Groth-Sahai证明系统就依赖于这个模型。</li><li>优点：简化了复杂密码协议的设计，并提供强大的安全性。</li><li>局限性：公共参考字符串需要由一个可信第三方生成，如果其生成过程不安全，整个系统的安全性将受到威胁。</li></ul></li><li><p>Security Model（安全模型）</p><ul><li>概念：安全模型是用来定义密码协议在特定攻击场景下的安全性。常见的安全模型包括选择密文攻击（CCA）安全模型、选择明文攻击（CPA）安全模型、完全前向安全模型等。</li><li>应用场景：不同的安全模型适用于不同类型的密码协议。例如，针对加密协议的选择密文攻击（CCA）安全模型广泛应用于分析公共密钥加密方案的安全性，如RSA、ElGamal等。选择明文攻击（CPA）模型则用于较弱的攻击假设下的分析。</li><li>优点：通过不同的攻击模型，研究者可以更精细地评估协议在不同攻击情境下的安全性。</li><li>局限性：模型之间的安全性可能不一致，需要针对特定的威胁模型进行全面分析。</li></ul></li><li><p>Generic Group Model（通用群模型）</p><ul><li>概念：假设在这个模型中，攻击者不能直接操作群元素，只能通过一个黑盒进行群运算。这种模型假设攻击者无法利用群的具体结构信息，而只能使用通用的群操作。</li><li>应用场景：通用群模型通常用于证明基于群的密码协议（如椭圆曲线密码学、Diffie-Hellman等）的安全性。这个模型对分析与离散对数问题相关的加密方案（如Diffie-Hellman协议）特别有用。</li><li>优点：简化了分析过程，并能提供对基于群的方案的广泛适用性。</li><li>局限性：在现实中，攻击者可能能够利用群结构的具体性质，从而使得通用群模型中的安全性证明无法完全反映实际的安全性。</li></ul></li></ul></li><li><p>第三方实体</p><ul><li><p>Key Distribution Center (KDC) — 密钥分发中心</p><ul><li>功能：KDC 负责在网络中的各方之间分发对称密钥。它生成并安全地传输会话密钥，确保各方能够使用对称加密进行安全通信。KDC 通常是可信的中心实体，负责管理密钥的分发和更新。</li><li>应用场景：主要用于对称密钥加密系统中，尤其是在需要多个用户之间进行安全通信的环境下，如：<ul><li>Kerberos 协议：KDC 在 Kerberos 协议中生成会话密钥并分发给通信双方，以便实现身份验证和加密通信。</li><li>企业内部网络安全：KDC 用于集中管理员工设备之间的加密通信。</li></ul></li><li>优势：减少了各方之间建立安全通信时需要直接共享密钥的风险。</li><li>局限性：KDC 成为单点故障，如果被破坏或泄露，整个网络的安全将受到威胁。</li></ul></li><li><p>Key Generation Center (KGC) — 密钥生成中心</p><ul><li>功能：KGC 是负责生成公钥和私钥对的中心实体，通常用于基于身份的加密（Identity-Based Encryption, IBE）系统中。KGC 基于用户的身份信息（如电子邮件地址）生成私钥，并分发给用户。</li><li>应用场景：主要用于基于身份的加密系统，特别是在分布式和多用户环境中，如：<ul><li>电子邮件加密：用户通过其电子邮件地址作为公钥进行加密，KGC 提供私钥解密信息。</li><li>无需证书的加密系统：KGC 的存在消除了使用传统公钥基础设施（PKI）系统中对证书的需求。</li></ul></li><li>优势：无需管理公钥证书，简化了加密系统的管理。</li><li>局限性：KGC 必须完全可信，因为它能生成所有用户的私钥，可能导致潜在的隐私和安全问题。</li></ul></li><li><p>Private-Key Generator (PKG) — 私钥生成器</p><ul><li>功能：PKG 是类似于 KGC 的实体，负责生成用户的私钥。它主要用于基于身份的加密系统中，用户的私钥是由 PKG 根据用户的身份信息生成的。PKG 通常也会生成公钥，但这些公钥是基于用户的身份生成的，而不需要显式地存储或分发。</li><li>应用场景：用于身份加密系统和签名方案，如：<ul><li>Shamir 的身份加密系统：PKG 为用户生成私钥，用户身份作为公钥。</li><li>Pairing-based Cryptography：在基于双线性对的密码学系统中，PKG 负责生成和管理密钥。</li></ul></li><li>优势：消除传统 PKI 系统对证书管理的需求，简化了密钥管理过程。</li><li>局限性：与 KGC 相同，PKG 必须是完全可信的，否则会导致整个系统的安全性崩溃。</li></ul></li><li><p>Certificate Authority (CA) — 证书颁发机构</p><ul><li>功能：CA 是公钥基础设施（PKI）中的核心实体，负责验证用户的身份并颁发数字证书。数字证书包含用户的公钥及其身份信息，并由 CA 签名，以证明该公钥确实属于该用户。CA 还负责吊销证书、更新证书和维护证书的有效性。</li><li>应用场景：CA 广泛应用于互联网安全、身份验证和加密通信场景中，如：<ul><li>HTTPS/TLS 协议：CA 颁发 SSL/TLS 证书，确保用户访问的网站是可信的。</li><li>电子邮件加密（如 S/MIME）：CA 颁发数字证书用于电子邮件加密和签名，确保通信的真实性和机密性。</li></ul></li><li>优势：通过数字证书验证公钥的真实性，确保用户之间可以安全通信。</li><li>局限性：如果 CA 被攻击或误发不安全的证书，整个系统的信任链条会被打破。此外，CA 通常是高度集中化的，这可能导致管理和成本问题。</li></ul></li><li><p>Trust Third Party (TTP) — 可信第三方</p><ul><li>功能：TTP 是一种在通信双方之间建立信任的第三方实体，通常负责验证双方身份并促进安全通信。TTP 可以用于密钥分发、身份验证、数字签名认证等场景。</li><li>应用场景：TTP 常用于分布式系统、电子商务、合同签署等场景中，如：<ul><li>电子合同签名：TTP 验证各方签署的数字签名，并确保合同的真实性和有效性。</li><li>在线身份验证：TTP 在用户和服务器之间充当中介，帮助进行身份验证。</li></ul></li><li>优势：通过引入一个可信的第三方，简化了安全通信的流程，减少了直接信任的需求。</li><li>局限性：TTP 是一个集中化的实体，如果它被破坏或失去信任，整个系统的安全性都会受到影响。</li></ul></li></ul></li><li><p>协议</p><ul><li><p>Key Exchange Protocol — 密钥交换协议</p><ul><li>应用场景：当 Alice 和 Bob 需要安全通信时，他们需要协商出一个共享密钥，其他第三方无法得知此密钥。典型的例子包括 Diffie-Hellman 密钥交换和 ECDH（椭圆曲线 Diffie-Hellman）。</li><li>解决的问题：<ul><li>安全共享密钥：协议确保参与方协商出一个共享密钥，用于后续加密通信。</li><li>防止中间人攻击：通过认证机制（如公钥基础设施）防止恶意第三方伪装成通信参与者。</li></ul></li><li>示例：Alice 和 Bob 在一个不安全的网络上协商生成共同的密钥，双方使用密钥进行后续加密通信，避免第三方窃听。</li></ul></li><li><p>Fair Exchange Protocol — 公平交换协议</p><ul><li>应用场景：公平交换用于确保两方在协议中公平交换某种数字资产或信息，比如数字签名、加密货币、合同等。典型的应用场景包括电子商务中的支付协议和数字签名的公平交换。</li><li>解决的问题：<ul><li>确保交易公平：如果 Alice 提供了她的签名或信息，Bob 也必须在相同条件下提供他的。</li><li>防止单方违约：保证交易的一方无法单方面获得他人的资产或信息而不履行自己的部分。</li></ul></li><li>示例：在数字合同签署中，Alice 和 Bob 可以使用公平交换协议确保签署过程公平，即 Alice 和 Bob 都签署合同或都不能签署。</li></ul></li><li><p>Secret Sharing Protocol — 秘密共享协议</p><ul><li>应用场景：当一个秘密需要在多个参与方之间分配并保密时使用，通常应用于分布式系统、银行加密、文件恢复等场景。Shamir’s Secret Sharing 是其中的经典协议。</li><li>解决的问题：<ul><li>安全存储秘密：允许将秘密分成多个部分，每个参与者只拥有一部分，只有足够多的参与者联合才能恢复秘密。</li><li>容错性：即使部分参与者失去密钥，秘密仍然可以恢复。</li></ul></li><li>示例：一个公司董事会需要投票决策，他们可以使用秘密共享协议将密钥分发给多名董事，只有达成多数票数后才能解密决策结果。</li></ul></li><li><p>Oblivious Transfer Protocol — 遗忘传输协议</p><ul><li>应用场景：当一方希望从另一方获取部分信息，但不希望让另一方知道他选择了哪部分信息时使用。常见于隐私保护机制、密码学应用和安全多方计算中。</li><li>解决的问题：<ul><li>隐私保护：在 Alice 从 Bob 获取信息的过程中，Bob 无法知道 Alice 选择了哪些信息。</li><li>防止过多泄露：确保 Alice 只获取了她请求的部分信息，而不是 Bob 所有的信息。</li></ul></li><li>示例：Alice 想从 Bob 那里选择一本书的某一页内容，但 Bob 不知道 Alice 想要哪一页，Alice 也不会看到除她选择之外的其他页。</li></ul></li><li><p>Commitment Protocol — 承诺协议</p><ul><li>应用场景：承诺协议用于在信息未公开之前确保其不可更改，常用于加密签名、选举系统、博弈论等场景。</li><li>解决的问题：<ul><li>防篡改：承诺的值在揭示之前不能更改。</li><li>保密性：承诺值在揭示之前是保密的，不被他人知道。</li></ul></li><li>示例：在电子投票系统中，Alice 对她的投票进行承诺，在投票结束后再揭示，这样她无法在投票期间更改票选。</li></ul></li><li><p>Multi-party Computation (MPC) — 多方计算协议</p><ul><li>应用场景：MPC 允许多个参与方在不暴露其输入的情况下，联合计算某一函数的结果。常见应用包括隐私保护数据分析、分布式系统和财务分析。</li><li>解决的问题：<ul><li>隐私计算：参与者可以合作完成计算而不暴露各自的输入数据。</li><li>公平性：即使有恶意参与者，也能保证计算结果正确。</li></ul></li><li>示例：多家银行可以在不分享客户数据的情况下，通过 MPC 计算某个统计数据，例如总交易额。</li></ul></li><li><p>Zero-Knowledge Proof (ZKP) — 零知识证明</p><ul><li>应用场景：ZKP 允许一方（证明者）向另一方（验证者）证明她知道某个秘密信息，但不会泄露该信息本身。ZKP 常用于身份验证、加密货币、区块链技术中。</li><li>解决的问题：<ul><li>安全验证：证明者可以证明她知道某个秘密或满足某个条件，而无需泄露秘密。</li><li>隐私保护：在身份验证或认证过程中，敏感信息不会泄露。</li></ul></li><li>示例：Alice 可以通过 ZKP 向 Bob 证明她知道一个密码，而无需告诉 Bob 这个密码是什么。</li></ul></li></ul></li><li><p>技术方法</p><ul><li><p>Accumulator</p><ul><li>基本原理：Accumulator 是一种将多个元素“累积”成一个单一值的数据结构，并允许验证某个元素是否包含在该累积值中的过程。Accumulator 的一个重要特性是它可以在不存储所有元素的情况下进行验证。</li><li>应用场景：<ul><li>数字签名和零知识证明：Accumulator 常用于密码学协议中，如零知识证明和数字签名中，用于高效的集合成员身份验证。</li><li>区块链：Accumulator 可以用于验证某个交易或数据是否存在于一个更大的数据集（如区块链中的交易集）。</li></ul></li></ul></li><li><p>Bloom Filter</p><ul><li>基本原理：Bloom Filter 是一种空间高效的数据结构，用于测试一个元素是否在一个集合中。它允许有一定的错误率（假阳性），但不会出现假阴性。这意味着某个元素可能被错误地判断为在集合中，但如果 Bloom Filter 判断某个元素不在集合中，那么该判断一定是正确的。</li><li>应用场景：<ul><li>数据库查询：在大规模数据查询系统中用于加速查询过程，快速判断某个元素是否在数据库中。</li><li>网络缓存：在内容分发网络（CDN）中，Bloom Filter 用于高效判断是否需要缓存某些内容。</li></ul></li></ul></li><li><p>Hash Chain</p><ul><li>基本原理：Hash Chain 是通过反复对一个初始值进行哈希运算生成的一系列哈希值链。每个链中的值通过对前一个值进行哈希运算获得。其性质是前面的哈希值很容易计算，但无法从后面的哈希值推断前面的哈希值。</li><li>应用场景：<ul><li>一次性密码：在身份验证系统中使用 Hash Chain 生成一次性密码（OTP），每个密码只能使用一次，增强安全性。</li><li>区块链：Hash Chain 用于区块链中数据的不可篡改性，通过链式的哈希保证数据的完整性和安全性。</li></ul></li></ul></li><li><p>Hash Tree (Merkle Tree, Binary Hash Tree)</p><ul><li>基本原理：Hash Tree（哈希树）是一种树形结构，其中每个叶节点是数据的哈希值，非叶节点是其子节点的哈希值。Merkle Tree 是一种常见的哈希树，用于验证大规模数据集的完整性。通过树的结构，可以快速验证某个特定数据是否在大集合中。</li><li>应用场景：<ul><li>区块链：Merkle Tree 被广泛应用于区块链中，用于验证块中交易的完整性，允许节点高效验证交易是否包含在区块中。</li><li>文件系统：用于大文件或分布式文件系统中，通过 Hash Tree 验证文件的完整性，确保数据没有被篡改。</li></ul></li></ul></li><li><p>Chameleon Hash Function</p><ul><li>基本原理：Chameleon Hash 是一种特殊的哈希函数，它具有碰撞可控的特性。即在给定某个初始值的情况下，攻击者可以找到另一个值使得两者哈希结果相同。Chameleon Hash 的这一特性允许某些场景下的灵活性，同时仍保持数据的不可篡改性。</li><li>应用场景：<ul><li>可撤回的数字签名：在某些数字签名应用中，可以使用 Chameleon Hash 允许签名者撤回签名或改变内容，但这种修改是可控且可验证的。</li><li>区块链：Chameleon Hash 可以用于区块链的隐私保护或可修改的智能合约，允许在一定条件下对某些数据进行修改而不破坏系统的整体完整性。</li></ul></li></ul></li></ul></li></ul><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><p>需要专门阅读书目去学习，此章节待更新</p><h3 id="简单问题和困难问题"><a href="#简单问题和困难问题" class="headerlink" title="简单问题和困难问题"></a>简单问题和困难问题</h3><h4 id="简单问题"><a href="#简单问题" class="headerlink" title="简单问题"></a>简单问题</h4><p>能在多项式时间内解决的计算问题</p><p>存在一个概率算法，将简单问题的一个例子作为算法的输入，改算法可以在多项式时间内以一个不可忽略的<a href="#优势">优势</a>输出该例子的正确答案。例如：<span id="优势_back"></span></p><ul><li>给定 $(g,g^a)\in \mathbb{G}$，计算 $(g^s,g^{\frac{1}{a+s}})$，其中 $s\in\mathbb{Z}_p$ 任意值</li></ul><h4 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h4><p>不能在多项式时间内解决的计算问题</p><p>不存在这样一个概率算法，将困难问题的一个例子作为输入，该算法可以在多项式时间内以一个不可忽略的优势输出正确的答案</p><ul><li>给定 $(g,g^a)\in \mathbb{G}$，计算 $(s,g^{\frac{1}{a+s}})$，其中 $s\in\mathbb{Z}_p$ 任意值</li></ul><h4 id="128个困难问题"><a href="#128个困难问题" class="headerlink" title="128个困难问题"></a>128个困难问题</h4><p>《Final Report on Main Computational Assumption in Cryptography》[9]</p><p>内容</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势<span id="优势"></span></h4><p>用于评估攻击者相对于随机猜测或最坏情况下的表现有多大提升，描述攻击者的成功概率与基准成功概率之间的差异。</p><p>定义：攻击者的优势通常被定义为攻击者成功概率与随机猜测或标准概率之间的差。</p><p>$Advantage=P_{attack\ success}−P_{baseline(random\ guess)}$</p><p>例子：如果一个密码算法的密钥长度为 $128$ 位，攻击者随机猜中密钥的概率是 $\frac{1}{2^{128}}$。假设攻击者利用某种方法攻击，成功的概率为 $\frac{1}{2^{120}}$，那么攻击者的优势就是：</p><p>$\text{Advantage} = \frac{1}{2^{120}} - \frac{1}{2^{128}} \approx \frac{1}{2^{120}}$</p><p><a href="#优势_back">返回</a></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法指用给定的输入以某种计算方式产生对应的输出</p><p>算法包括具体的输入参数、输出参数和计算过程，而算法定义只描述了输入和输出的参数对象</p><h4 id="数字签名的算法定义"><a href="#数字签名的算法定义" class="headerlink" title="数字签名的算法定义"></a>数字签名的算法定义</h4><p>$SysGen$，目的是生成系统公共参数，由权威机构运行；$KeyGen$，目的是生成公私钥对，由签名者运行；$Sign$，目的是对消息签名，由签名者运行；$Verify$，目的是验证签名，由验证者运行。</p><ul><li>$SysGen:(1^\lambda)\rightarrow SP$，其中，$\lambda$ 表示系统安全参数，$SP$ 表示系统公共参数</li><li>$KeyGen:(SP)\rightarrow(pk,sk)$，其中，$pk$ 是签名者的公钥，$sk$是签名者的私钥</li><li>$Sign:(SP,sk,M)\rightarrow\sigma_M$，其中，$M$ 是消息，$\sigma_M$ 是签名者对消息 $M$ 的签名</li><li>$Verify:(SP,pk,M,\sigma_M)\rightarrow1/0$，其中，$1$ 代表 $\sigma_M$ 是 $M$ 的合法签名，$0$ 表示签名错误</li></ul><h4 id="公钥加密的算法定义"><a href="#公钥加密的算法定义" class="headerlink" title="公钥加密的算法定义"></a>公钥加密的算法定义</h4><p>$SysGen$，目的是生成系统公共参数，由权威机构运行；$KeyGen$，目的是生成公私钥对，由解密者运行；$Encrypt$，目的是对消息加密，由加密者运行；$Decrypt$，目的是解密密文，由解密者运行。</p><ul><li>$SysGen:(1^\lambda)\rightarrow SP$，其中，$\lambda$ 表示系统安全参数，$SP$ 表示系统公共参数</li><li>$KeyGen:(SP)\rightarrow(pk,sk)$，其中，$pk$ 是签名者的公钥，$sk$是签名者的私钥</li><li>$Encrypt:(SP,sk,M)\rightarrow CT$，其中，$M$ 是消息，$CT$ 是加密者对 $M$ 加密后的密文</li><li>$Decrypt:(SP,pk,M,CT)\rightarrow M/\perp$，其中，$\perp$ 代表解密失败</li></ul><h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p>安全模型里只涉及到算法的输入参数和输出参数</p><p>一个密码概念可能有多个不同的安全需求, 而每一个安全需求对应一个安全模型</p><ul><li>初始化</li><li>询问</li><li>攻击</li><li>优势</li></ul><p>常见安全模型中的组成部分</p><ul><li>数字签名</li><li>公钥加密</li></ul><h3 id="安全规约证明"><a href="#安全规约证明" class="headerlink" title="安全规约证明"></a>安全规约证明</h3><ul><li>模拟</li><li>解决困难问题</li><li>分析</li></ul><h2 id="方案构造学习"><a href="#方案构造学习" class="headerlink" title="方案构造学习"></a>方案构造学习</h2><h3 id="算法定义和安全模型定义"><a href="#算法定义和安全模型定义" class="headerlink" title="算法定义和安全模型定义"></a>算法定义和安全模型定义</h3><h4 id="密码概念"><a href="#密码概念" class="headerlink" title="密码概念"></a>密码概念</h4><h4 id="安全模型概念"><a href="#安全模型概念" class="headerlink" title="安全模型概念"></a>安全模型概念</h4><ol><li>安全模型 (Security Model)</li></ol><p>安全模型是用于定义和分析密码系统安全性的框架。在安全模型中，我们规定了攻击者的能力、目标、以及系统的反应，以便评估系统在各种攻击情景下的表现。</p><p> 形式化分析：安全模型通常基于数学模型，通过明确攻击者的能力（比如能够访问某些信息、对系统某部分做出操作等）来分析系统的安全性。<br> 目标：设计一个安全模型是为了证明加密方案在某些假设下是安全的（或不安全的）。</p><p>常见的安全模型有 随机预言模型、标准模型 等。</p><ol><li>挑战者 (Challenger)</li></ol><p>挑战者是在安全模型中负责与攻击者互动的一方，通常代表加密方案或协议的实例。在安全性分析过程中，挑战者模拟加密方案的行为，并根据攻击者的查询作出响应。</p><p> 角色：挑战者充当系统的实现者，负责加密、解密、响应查询等。<br> 目的：攻击者通过与挑战者互动，试图破坏协议的安全性。</p><ol><li>攻击者/对手 (Adversary)</li></ol><p>攻击者（Adversary） 是安全模型中的对立方，其目标是试图破坏系统的安全性。攻击者拥有一定的能力，如访问密文、发送查询请求，甚至可能控制系统部分资源。</p><p> 角色：攻击者通过利用安全模型中允许的能力和资源，试图破译密文、伪造签名或进行其他形式的攻击。<br> 目标：获取未经授权的信息，或使协议失效。</p><ol><li>查询 (Query)</li></ol><p>查询是攻击者与挑战者互动的手段。攻击者向挑战者提出请求（查询），以尝试获取信息或影响加密方案的行为。</p><p> 常见类型的查询：<br>   密文查询：攻击者请求挑战者提供某个消息的密文。<br>   解密查询：攻击者请求对某个密文进行解密。<br>   签名查询：攻击者请求某个消息的签名。</p><ol><li>响应 (Response)</li></ol><p>响应是挑战者对攻击者查询的回复。根据攻击者的查询，挑战者会返回相应的结果，如密文、解密后的消息或签名。</p><p> 目的是：使攻击者能够根据这些响应试图破坏系统的安全性。</p><ol><li>获胜 (Win)</li></ol><p>获胜（Win）指的是攻击者在安全模型中成功破坏了系统的安全性。成功的标准由安全模型定义，比如攻击者能够区分密文、伪造签名等。</p><p> 具体例子：<br>   在 不可区分加密 模型中，攻击者能够通过与挑战者交互，成功区分出不同的密文，表明系统不安全。<br>   在 不可伪造性 的签名方案中，攻击者能够伪造一个有效的签名。</p><ol><li>自适应攻击 (Adaptive Attack)</li></ol><p>自适应攻击是一类攻击，其中攻击者根据之前与挑战者交互过程中获得的信息来调整其后续查询或攻击策略。换句话说，攻击者的行为可以随着与系统互动的结果动态变化。</p><p> 自适应性增强了攻击的有效性，因为攻击者能够根据已有信息做出更有针对性的查询和攻击。<br> 例子：攻击者可以先进行一系列查询，从这些查询的响应中学习有用的信息，然后发起一个更具针对性的攻击。</p><ol><li>平凡攻击 (Trivial Attack)</li></ol><p>平凡攻击是指那些无需任何复杂分析或特殊技巧就能够轻易破坏系统安全的攻击。通常是由于设计中的明显漏洞造成的，属于显而易见的攻击方式。</p><p> 示例：假如加密方案没有密钥保护，攻击者直接读取密钥即可解密密文，这就属于平凡攻击。</p><ol><li>优势 (Advantage)</li></ol><p>优势（Advantage）是量化攻击者成功率的一个指标。它衡量了攻击者比随机猜测更有多少机会成功攻击系统。</p><p> 定义：在密码学中，攻击者的优势通常定义为攻击者成功破坏系统的概率与随机猜测成功概率的差值。<br> 形式化表示：如果攻击者能以 ( p ) 的概率破坏系统，而随机猜测的成功概率是 $\frac{1}{2}$，则攻击者的优势是  $\text{Adv}=p-\frac{1}{2}$。</p><ol><li>强安全模型 (Strong Security Model)</li></ol><p>强安全模型是在攻击者能力或资源非常强大的情况下定义的安全模型。加密方案在强安全模型下证明安全，意味着即使攻击者能力极大，方案依旧能够抵御攻击。</p><p> 例子：在强安全模型中，攻击者可能有能力进行自适应查询或对抗密钥泄露等场景。</p><ol><li>弱安全模型 (Weak Security Model)</li></ol><p>弱安全模型是一种对攻击者能力作出较多限制的安全模型。在这种模型下，攻击者的能力较弱，方案只在特定条件下能抵御攻击。</p><p> 例子：攻击者只能进行固定的查询，不能根据结果调整策略。</p><ol><li>标准安全模型 (Standard Security Model)</li></ol><p>标准安全模型是基于现实中的假设（如计算困难性）和不依赖额外理想假设的安全模型。与随机预言模型不同，标准安全模型只依赖广泛接受的数学假设。</p><p> 现实性：标准安全模型更贴近实际应用环境，不依赖于不切实际的假设（如理想哈希函数）。</p><h3 id="经典方案推荐-amp-尝试发现方案构造错误"><a href="#经典方案推荐-amp-尝试发现方案构造错误" class="headerlink" title="经典方案推荐&amp;尝试发现方案构造错误"></a>经典方案推荐&amp;尝试发现方案构造错误</h3><p>篇幅过多，详见文章 <a href="../../../../../2024/09/27/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%BB%8F%E5%85%B8%E6%96%B9%E6%A1%8830%E7%AF%87-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">公钥密码学经典方案30篇 学习笔记</a></p><h2 id="安全证明学习"><a href="#安全证明学习" class="headerlink" title="安全证明学习"></a>安全证明学习</h2><h3 id="归约相关概念学习"><a href="#归约相关概念学习" class="headerlink" title="归约相关概念学习"></a>归约相关概念学习</h3><h3 id="证明训练"><a href="#证明训练" class="headerlink" title="证明训练"></a>证明训练</h3><h2 id="文献阅读"><a href="#文献阅读" class="headerlink" title="文献阅读"></a>文献阅读</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 常驻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号书写规范</title>
      <link href="/2024/09/09/%E6%8B%AC%E5%8F%B7%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
      <url>/2024/09/09/%E6%8B%AC%E5%8F%B7%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>今天记笔记，遇到一段话，中英夹杂不知道应当如何使用括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 新方案：提出基于变色龙哈希的支付协议——变色龙哈希时间锁定合约（Chameleon Hash Time-Lock Contract, CHTLC），解决支付路径泄露问题</span><br><span class="line">- 优势：使用多层变色龙哈希函数来确保没有用户可以修复支付路径（条件：至少有一个中间支付节点是诚实的）</span><br><span class="line">- 比较：对于相同的支付路径，与 Multi-hop Hash Time-Lock Contract(MHTLC)相比，CHTLC支付初始化速度快了五倍，通信所需带宽从17000KB降到7.7KB</span><br></pre></td></tr></table></figure><span id="more"></span><p>询问<code>gpt</code>未果</p><p><img src="image-20240909130005620.png" alt></p><p><img src="image-20240909130017955.png" alt></p><p>两次询问，得到了不同的结果</p><p>后来，在<a href="http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113092346124.pdf">国家教育部官网</a>上找到了一种使用方法</p><p><img src="image-20240909172337348.png" alt></p><p>非正式地说，主要内容是中文就用中文括号，主要内容是英文就用英文括号</p><p>更改后的文段如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 新方案：提出基于变色龙哈希的支付协议——变色龙哈希时间锁定合约（Chameleon Hash Time-Lock Contract, CHTLC），解决支付路径泄露问题</span><br><span class="line">- 优势：使用多层变色龙哈希函数来确保没有用户可以修复支付路径（条件：至少有一个中间支付节点是诚实的）</span><br><span class="line">- 比较：对于相同的支付路径，与 Multi-hop Hash Time-Lock Contract（MHTLC）相比，CHTLC支付初始化速度快了五倍，通信所需带宽从17000KB降到7.7KB</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora生成思维导图</title>
      <link href="/2024/09/09/typora%E7%94%9F%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/2024/09/09/typora%E7%94%9F%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[公钥密码方案构造及安全证明的知识要点和方法论]</span><br><span class="line">B[归纳总结了构造可证明安全的公钥密码方案所需掌握的知识要点]</span><br><span class="line">C[-&gt; 学习方案构造以及安全证明不可或缺的基础部分 需要最先掌握]</span><br><span class="line">A--&gt;B--&gt;C</span><br></pre></td></tr></table></figure><p>后记：此方法可以在<code>typora</code>中显示思维导图，但是在<code>hexo</code>生成的博客中显示的还是原文件格式，所以目前的解决方案依旧是 幕布+图片插入</p><p>记得格式改为<code>mermaid</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chameleon Hashing and Signatures阅读笔记</title>
      <link href="/2024/09/07/Chameleon%20Hashing%20and%20Signatures%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/07/Chameleon%20Hashing%20and%20Signatures%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="文献简介"><a href="#文献简介" class="headerlink" title="文献简介"></a>文献简介</h3><p>标题：Chameleon Hash and Signatures</p><p>作者：Hugo Krawczyk , Tal Rabin</p><span id="more"></span><p>期刊：无</p><p>年份：1998</p><p>重要程度：4</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>引入变色龙签名，提供不可抵赖签名（和常规数字签名一样）</li><li>不允许接收方在未经允许的情况下向第三方披露明文（和不可抵赖签名相关，但是算法简单和高效实现）</li><li>本质上不交互，不涉及零知识证明的设计和复杂性（传统不可抵赖签名基于零知识证明）。哈希函数的产生通过标准的<code>hash then sign</code></li><li>此哈希函数 对签名者是抗碰撞的，但是对于接收者是碰撞可控的</li><li>构造变色龙哈希函数，可以基于很多标准密码学假设（数学困难问题）</li></ul><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h5 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h5><ul><li></li></ul><h5 id="研究的目的和意义（课题开展的原因）"><a href="#研究的目的和意义（课题开展的原因）" class="headerlink" title="研究的目的和意义（课题开展的原因）"></a>研究的目的和意义（课题开展的原因）</h5><ul><li><h5 id="重要结果-结论"><a href="#重要结果-结论" class="headerlink" title="重要结果/结论"></a>重要结果/结论</h5></li><li></li></ul><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><h5 id="作者新发现"><a href="#作者新发现" class="headerlink" title="作者新发现"></a>作者新发现</h5><ul><li><h5 id="作者研究对象"><a href="#作者研究对象" class="headerlink" title="作者研究对象"></a>作者研究对象</h5></li><li></li></ul><h3 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h3><h5 id="理论价值"><a href="#理论价值" class="headerlink" title="理论价值"></a>理论价值</h5><ul><li><h5 id="应用价值"><a href="#应用价值" class="headerlink" title="应用价值"></a>应用价值</h5></li><li></li></ul><h5 id="能解决的难题"><a href="#能解决的难题" class="headerlink" title="能解决的难题"></a>能解决的难题</h5><ul><li><h3 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h3></li></ul><h5 id="作者使用的方法"><a href="#作者使用的方法" class="headerlink" title="作者使用的方法"></a>作者使用的方法</h5><ul><li><h5 id="有没有更好的方法"><a href="#有没有更好的方法" class="headerlink" title="有没有更好的方法"></a>有没有更好的方法</h5></li><li></li></ul><h5 id="哪些是我还需要学习的"><a href="#哪些是我还需要学习的" class="headerlink" title="哪些是我还需要学习的"></a>哪些是我还需要学习的</h5><ul><li><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3></li></ul><h5 id="对我的课题有什么启发"><a href="#对我的课题有什么启发" class="headerlink" title="对我的课题有什么启发"></a>对我的课题有什么启发</h5><ul><li><h5 id="作者是怎样做到比前人好的"><a href="#作者是怎样做到比前人好的" class="headerlink" title="作者是怎样做到比前人好的"></a>作者是怎样做到比前人好的</h5></li><li></li></ul><h5 id="能否想到其他方法能达到和作者一样或更好的的效果"><a href="#能否想到其他方法能达到和作者一样或更好的的效果" class="headerlink" title="能否想到其他方法能达到和作者一样或更好的的效果"></a>能否想到其他方法能达到和作者一样或更好的的效果</h5><ul><li><h3 id="总结（思维导图）"><a href="#总结（思维导图）" class="headerlink" title="总结（思维导图）"></a>总结（思维导图）</h3></li></ul><p>文章关键词/年份/期刊</p><ul><li>标题Title<ul><li>网络连接</li></ul></li><li>背景Background<ul><li>What’s known</li><li>What’s news<ul><li>虽然之前研究证明了……，但是……还没被研究过/存在争议</li></ul></li><li>What’s are the implication</li></ul></li><li>实验方法Methods</li><li>实验结果Results<ul><li>逻辑重点：这一部分为了验证什么假设——研究结果</li><li></li></ul></li><li><p>启示Inspirations</p><ul><li><p>边读 边思考 边补充</p><ul><li><p>“不允许接收方在未经允许的情况下向第三方披露明文”，其中disclose指的是“披露并证明”</p><p>接收方即便知道消息和相应的哈希值，他们依然无法向第三方证明或验证消息，因为他们没有生成碰撞的能力。这意味着接收方无法凭借手中的消息和哈希值向第三方揭露原始消息的真伪。</p><p>更进一步，如果接收方试图向第三方泄露消息和哈希值，生成者可以在拥有私钥的情况下创建一个新的碰撞消息，使得第三方无法确定哪个消息是真实的。因此，即使接收方试图透露明文，也会被生成者的碰撞消息所混淆，从而使明文的真实性存疑。</p></li><li><p>读的时候不懂的需要请教他人先记下来</p></li><li>对自己的论文选题头脑风暴</li><li>对自己的研究有启发（如图片好看可以借鉴，行文逻辑可以借鉴为模板，研究思路需要再琢磨下）</li></ul></li><li>回过头思考和复盘<ul><li>这篇文章最大的亮点是什么</li><li>为什么他们可以发刊</li><li>对于我的研究课题/科研思路有何借鉴</li><li>挑挑毛病</li></ul></li></ul></li></ul><hr><p>在精读每一篇密码学论文时，以下问题可以帮助你深入理解论文的内容，并确保你对论文有全面的把握：</p><ul><li><p><strong>研究的主要问题是什么？</strong></p><ul><li><p>论文试图解决的核心问题或挑战是什么？</p><p>该论文研究了如何将基于身份的加密应用于变色龙哈希函数，并介绍了第一个基于身份的变色龙哈希方案。主要解决的问题是密钥分发的复杂性及其在变色龙签名中的应用。</p></li></ul></li><li><p><strong>该论文的主要贡献是什么？</strong></p><ul><li>论文提出了首个基于身份的变色龙哈希函数，解决了公钥拥有者不需要检索关联的秘密密钥的问题。该哈希方案用于构建基于身份的变色龙签名，还应用于一个鲁棒且通信高效的密封投标拍卖方案。提出了哪些新方法、新算法或新协议？</li></ul></li><li><p><strong>现有的解决方案有哪些不足？</strong></p><ul><li>传统的变色龙签名方案要求接收者管理复杂的公钥基础设施（PKI）和密钥分发。而基于身份的加密消除了对证书和密钥分发中心的依赖，简化了操作。</li></ul></li><li><p><strong>论文采用了哪些理论工具或模型？</strong></p><ul><li>论文使用了基于身份的密码学（如Shamir提出的方案）和变色龙哈希函数，结合了哈希-签名范式。还使用了RSA签名等经典加密工具来验证哈希函数的安全性。</li></ul></li><li><p><strong>研究方法和技术细节是什么？</strong></p><ul><li>研究提出了一种新的ID-based变色龙哈希方案，并详细介绍了其哈希算法、伪造算法及其安全性分析。该方案采用公开的身份字符串生成公钥，避免了复杂的密钥管理流程。</li></ul></li><li><p><strong>论文的假设条件是什么？</strong></p><ul><li>假设用户的身份可以由公开的、唯一的身份字符串描述，如电子邮件地址，且信任的第三方可以安全生成并管理密钥。安全性依赖于RSA签名的不可伪造性。</li></ul></li><li><p><strong>论文的结果和结论是什么？</strong></p><ul><li>论文验证了该基于身份的变色龙哈希方案的安全性，并成功应用于密封投标拍卖中，展示了其在实际应用中的高效性和鲁棒性。</li></ul></li><li><p><strong>该研究有哪些局限性？</strong></p><ul><li>论文未深入探讨其方案在多方协作环境中的扩展性和潜在的安全风险，比如当多个实体共享同一身份字符串时，可能会面临身份冲突问题。</li></ul></li><li><p><strong>参考文献中是否有关键文献？</strong></p><ul><li>论文引用了关于变色龙签名和基于身份加密的基础性研究，如Krawczyk和Rabin提出的变色龙签名和Shamir提出的基于身份的密码学等。</li></ul></li><li><p><strong>未来的研究方向是什么？</strong></p><ul><li>未来研究可以进一步优化该方案在其他应用场景中的适用性，例如多方计算或其他安全协议中，同时探讨如何提升该方案的隐私保护性能。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后量子密码-LWE问题</title>
      <link href="/2024/09/04/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-LWE%E9%97%AE%E9%A2%98/"/>
      <url>/2024/09/04/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81-LWE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>LWE(Learning With Errors)问题，基于格</p><span id="more"></span><p>问题简化：</p><ol><li>密码向量：设一个位置的秘密向量 $s\in\mathbb{Z}_q^n$ （$\mathbb{Z}_q^n$是模 $q$ 的整数环，$n$ 是向量的维度）</li><li>线性方程组：给定一系列的线性方程 $ai⋅s+ei\ (\mod q\ )$，其中 $a_i\in\mathbb{Z}_q^n$ 是已知的随机向量，$e_i$ 是从某个噪声分布中抽取的小整数噪声。</li><li>目标：给定这些方程（即给定多个 $a_i,b_i=a_i\cdot s+e_i$  对），求解秘密向量 $s$。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> unfixed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.9.4组会</title>
      <link href="/2024/09/02/2024.9.4%E7%BB%84%E4%BC%9A/"/>
      <url>/2024/09/02/2024.9.4%E7%BB%84%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="bf22bb0e24e93d7e17a3afbef0fd59083d55fa076c086aa4382d1ca2d539a925">7b22b1899bb4d215751e07a80f0d88de92ad2560fe55b7df0907fe8f65e151c4f966058b06bb0993b51554888ee09baa363f38e7e8a9582a46b0ddbf6ac336d456de408ec3ef598e0e125845657ab9b998344110f1a1004a4c153cad5880f567ee849d3d1f35c80f2a03d103986ac4c8aa2db69bba9d9dc1e4821c4a1113cd35e76532a7a1cf548b063dc46076181c34218a466c994d91e7e63a327e6085dd31b5ee97252844fd23d29d78c8c1859da1dd9848f47a531548fc00b0e0fa369488ae05ab8a23878b37af2a56edba3af9c605ff423e0f5b8fe07b5051ef2444f2232eb9539938825570887e1fead2c5eafc289f07f862a430013dec2025225d3ae2d61b43c9c748deb89a4a6306afb1ae02b7af4c30c83826a89528c529f035be834e6a29f7b21e193c67efc7df21a410ce3de9a795caf2e05aa4f747dce7d1aaca2791ce8fbda95ab7677499fb52744732e342cfdeb01fe3280eebe0cd05049323dee839d13d5cd789162ff6648a755ea9bede7b098261d4f81d83327893371ccf253289557c4769781d8490caffcd3b1384550723cf2da9aa1bec246bca51cd82165e8c5be4c694ba50bb128a0c8e98fee248eace180a2f1e1428c560e890aa0eae996851a37faeb717d9f00406ddd3ab72cfbadd130082d64d066ab4ed97eb37462a31d108d694212cf7f83b066b16ceb32c1616d75e6d0283406a1d67f528ed779a514f53fce66745b6402fcf376f2cd60c80e23c3186cf8240b5f1598178d2973f2fe574e6bdeedbe7b7c05be0aed3ba57d2f63c90da1c7c033652af313b91fbfc83f8305ef42b1144a64c321a26df5de159a8e2a62230d13ac6634794be4a18f8b1d76cfcf9bfaa18e877593007ca65c1a3729a27e5606b673c33769223a4a1d1a75dae84107ed3c94b60509eeb30a062cd39e9e9e0a10f53f5523e4fa4b3334385cd8adaa527c05a9619a57134f5222a657d31a04f1bdb76247d0cc30650cdb9ddd64c42fc3e9c25660fffbb838f1d832e00e0591ccc8e3b19db3f832be0b3633fd8938e5dcfe04a2f4baeb042eec14811d0af59e3984e0bfd5ec0789cafafdf69fc601142f88af67f56b62c0942a7a139e7359c25b33546841879ac22d5072f67dd65f2056073f728bef0866cefe6e1f93aa06f9ba3a8fddccbf4812fdf79406c5dfe6738bd0587e1950cfc9494c77945491ea93b6a598ac7b309128a5092d984823b6cc9e49be77385d53cfc41acf411b3c4ccaedef695134ffafc8329cdee1cea6811dcf22f1228c3807c61a9715750ef2d697df277e9de76f570434f7396fd0309e69319b6dafdf01b215fd78b9403fac1ff0d7a7c9a9ea43caf8e87444ee8dcf9c26a3496e7a1ef226857f4b1f344a89c13eac2a9aa30982097b7f4dda9faaab0b68bfe89b75df25d8a45d2dca985f6d2fd48fd2e4a2e6ff1af177e8b5559e6c22ca930fb2c5361fb809be82199626090bad661646314f3cee16b6b9342629dd1b55516592bdb61ae0dfe223db19b1dea8a1fe6fc02499d6c217d8cf5d5620269c3c1c2762e0a54653f5262550637f5a32ba9b0b4f552e4d6b8b39ee2cca563e0df3814b0ad6956021615e62b59fc1d8bed2e6cead27c0a7e1ccef8e05729a3f0466a70768ea93f3bf17080e9af6a7aa52466f3d7831988563f47cc2d44b3e074b332876a15c8a51c81c72f65ede33b64f30fb18a8ad9074382aa2065399083a9f0820d1adf63139ba6d40b7f2872ef81fd3ced0e8cbf1627829cb2fe6a0198cdccca2fe1828c23727a783de95b818b11cf22169a4716b2dbbca02f539e90a8745385152f4f5cd1f6b6d77c771158901e35d19dd75b03e595c36b447118b9ba0ddc06c5c79249764c6d407f2ab2f6f4aa4c7670e239e22f68f30c3dad0c72bbca3972b9ae0132279da97061f5e32ff79e4e8308dfe3d90dac86876e27a163f7389a5725f2542eb234696e7173776ba1986ec68f879ace316eaa3f26f320c6a9ded41369d3bbc3870f22f7aae1ced060b32ff991c3bf87f46e1113a0a4e60cfef358fd1d9a3d25a5173bc47fffebf8387f41022be0b948f886d3a3647cb92aaf17e1f53f3c38267ca5ab9fc3b8706ccaab4fbff7443d990c57e84acfa8e856641289b3bcf054b1e2a145a29aaa2b8fe793bd7f34d1fc6016b68f35ee3c958ad20ebc2b39f511477b207620a989bd1f62d2705d20d751ee30f40b529f621c661c5003fa010c96ae3a3ce4e820b00687e688a8e0ce4101a6d3981e3364d63ef03f578f60941dd10add450697fdc0b4d4f66de1e80fcdc197c90c45c357c850940ee4161d57601762a3a2ac81c49aa178727773bd43eb05b74769e27387268eca2457af9543f710514b62e3d78ea4db3cef7d9b6960c8efbbe1747c3100a8e11d6060dd0063aecffede174c7a846cdd74c7fb4ed2a47ff5977ab92ebaa395635d6130dc13bb11f5132f7c71fcdc0d688e02ae14cf47ccb2d7828ec7335516f348ab3f715873d0f99f9691dad4494fe6516ba903f178389a67231169b11e46fcfc7680884e9e06640907984b879c4dca446bfa4619fd254b31b2bbb2fdbcfda62dacea028e613ca0c01eb3388b48620688cf72fb45efdd85a925a2898da93df639203cb3888dcafb5958a04e112026272dab6cfa224292ffdcbfbf792dd71f343a9f26f67386c1464ce53483c74c895e9f81ab85bec79c2d8cb7d7c9953bc1e00c95e8534d9ccf75edcf3ace3d6c0ab23cf65575edfc5c8459c4b73370325a83af020dcc92474791a2ea277211a5386cc163ad91e865b2f1257cf3f1f0a43dfd2b69151ab030daa287354f987e64d18801ac2866ddf6a4bc8ba9ba43c2f3034eb4922e6a494a715013803968f1e4b1131d9602360be88f49981d80126ee8bf4b24d76ab6b4d936bd1872c4f7e1a4b35a1b038db37fe8b107ac34eda8b2f25552dd03f7dc5d29801a3b918c91a3a09b025e94ce58d3e858fd72c43d55e809fe741796733fce7fd50f357c81cca70c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> meetings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XFlow安装教程</title>
      <link href="/2024/08/23/XFlow%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2024/08/23/XFlow%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>XFlow是仿真流体动力学的软件</p><p>正版软件好贵贵，然后我下载了整整一个下午的破解版</p><p>按顺序阅读了以下三篇博客，最终成功打开XFlow</p><span id="more"></span><p><a href="https://www.xqu5.com/thread-2105-1-1.html">https://www.xqu5.com/thread-2105-1-1.html</a></p><p><a href="https://www.ittel.cn/archives/13613.html">https://www.ittel.cn/archives/13613.html</a></p><p><a href="https://blog.csdn.net/weixin_39461079/article/details/127909834">https://blog.csdn.net/weixin_39461079/article/details/127909834</a></p><p>我也不知道为什么能成功打开的，好奇怪</p>]]></content>
      
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024青工会 南航飞镖内容总结</title>
      <link href="/2024/08/23/2024%E9%9D%92%E5%B7%A5%E4%BC%9A-%E5%8D%97%E8%88%AA%E9%A3%9E%E9%95%96%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2024/08/23/2024%E9%9D%92%E5%B7%A5%E4%BC%9A-%E5%8D%97%E8%88%AA%E9%A3%9E%E9%95%96%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2024.11.06二次编辑</p><p>没时间回来看了，直接着手做吧，有问题再回来找经验</p><span id="more"></span><ul><li>官方镖头设计的不是很好，但是阻力可以接受</li><li>弹道解算，有控镖和无控镖都可以使用</li></ul><ul><li>迫击炮/摩擦轮型，把重量拉满，可以增加抗扰性</li><li>对碳板前缘倒圆角，升力提高阻力减小（小迎角可行，大迎角雷诺数较高进而失真）</li><li>官方镖头对升力系数影响不大，对阻力影响较大</li></ul><p><img src="image-20240823133633513.png" alt></p><ul><li>增加边条翼，可以调节气动中心</li></ul><p><img src="image-20240823133813225.png" alt></p><ul><li>相对抽象的设计</li></ul><p><img src="image-20240823133959553.png" alt></p><p>好处：有充足的升力</p><p>坏处：容易坏</p><p><img src="image-20240823134138862.png" alt></p><p>机翼经过特殊设计，升阻比能到6以上</p><p>很耐摔</p><p>两个舵机用来控制</p><ul><li>飞镖的雷诺数值比昆虫大一点，比鸟小</li></ul><p>所以不针对该雷诺数进行翼型设计，或者特殊处理，将会很容易失速</p><ul><li>对称翼型容易失速，越厚越容易失速</li></ul><p><img src="image-20240823134624814.png" alt></p><p>NACA0002这种类似平板，反而更不容易分离</p><p>如果分离，会变得非线性</p><ul><li>增加一个后掠，在前缘拉出一个脱体涡来延缓分离</li></ul><p><img src="image-20240823135040506.png" alt></p><p>后掠角越大，可用引脚越大</p><p><img src="image-20240823135139885.png" alt></p><p>S翼在0力矩（俯仰力矩为零）的时候是有升力的</p><ul><li>快速加速，陀螺仪可能会</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoeCTF2024wp</title>
      <link href="/2024/08/21/MoeCTF2024wp/"/>
      <url>/2024/08/21/MoeCTF2024wp/</url>
      
        <content type="html"><![CDATA[<h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><span id="more"></span><h3 id="现代密码学入门指北"><a href="#现代密码学入门指北" class="headerlink" title="现代密码学入门指北"></a>现代密码学入门指北</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import bytes_to_long, getPrime</span><br><span class="line">from secret import flag</span><br><span class="line">p = getPrime(128)</span><br><span class="line">q = getPrime(128)</span><br><span class="line">n = p*q</span><br><span class="line">e = 65537</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(f&quot;n = &#123;n&#125;&quot;)</span><br><span class="line">print(f&quot;p = &#123;p&#125;&quot;)</span><br><span class="line">print(f&quot;q = &#123;q&#125;&quot;)</span><br><span class="line">print(f&quot;c = &#123;c&#125;&quot;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 40600296529065757616876034307502386207424439675894291036278463517602256790833</span><br><span class="line">p = 197380555956482914197022424175976066223</span><br><span class="line">q = 205695522197318297682903544013139543071</span><br><span class="line">c = 36450632910287169149899281952743051320560762944710752155402435752196566406306</span><br><span class="line">```</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">n = 40600296529065757616876034307502386207424439675894291036278463517602256790833</span><br><span class="line">p = 197380555956482914197022424175976066223</span><br><span class="line">q = 205695522197318297682903544013139543071</span><br><span class="line">c = 36450632910287169149899281952743051320560762944710752155402435752196566406306</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = gmpy2.invert( e , phi )</span><br><span class="line">m = pow( c , d , n )</span><br><span class="line">print( long_to_bytes(m) )</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;the_way_to_crypto&#125;</code></p><h3 id="Signin"><a href="#Signin" class="headerlink" title="Signin"></a>Signin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import*</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n = p*q</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">pq = (p-1)*(q-2)</span><br><span class="line">qp = (q-1)*(p-2)</span><br><span class="line">p_q = p + q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(f&quot;&#123;c = &#125;&quot;)</span><br><span class="line">print(f&quot;&#123;pq = &#125;&quot;)</span><br><span class="line">print(f&quot;&#123;qp = &#125;&quot;)</span><br><span class="line">print(f&quot;&#123;n = &#125;&quot;)</span><br><span class="line">print(f&quot;&#123;p_q = &#125;&quot;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c = 5654386228732582062836480859915557858019553457231956237167652323191768422394980061906028416785155458721240012614551996577092521454960121688179565370052222983096211611352630963027300416387011219744891121506834201808533675072141450111382372702075488292867077512403293072053681315714857246273046785264966933854754543533442866929316042885151966997466549713023923528666038905359773392516627983694351534177829247262148749867874156066768643169675380054673701641774814655290118723774060082161615682005335103074445205806731112430609256580951996554318845128022415956933291151825345962528562570998777860222407032989708801549746</span><br><span class="line">pq = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687154230787854196153067547938936776488741864214499155892870610823979739278296501074632962069426593691194105670021035337609896886690049677222778251559566664735419100459953672218523709852732976706321086266274840999100037702428847290063111455101343033924136386513077951516363739936487970952511422443500922412450462</span><br><span class="line">qp = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687077087914198877794354459669808240133383828356379423767736753506794441545506312066344576298453957064590180141648690226266236642320508613544047037110363523129966437840660693885863331837516125853621802358973786440314619135781324447765480391038912783714312479080029167695447650048419230865326299964671353746764860</span><br><span class="line">n = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687534959910892789661065614807265825078942931717855566686073463382398417205648946713373617006449901977718981043020664616841303517708207413215548110294271101267236070252015782044263961319221848136717220979435486850254298686692230935985442120369913666939804135884857831857184001072678312992442792825575636200505903</span><br><span class="line">p_q = 279533706577501791569740668595544511920056954944184570513187478007551195831693428589898548339751066551225424790534556602157835468618845221423643972870671556362200734472399328046960316064864571163851111207448753697980178391430044714097464866523838747053135392202848167518870720149808055682621080992998747265496</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><hr><p>设  $q_p = p - q$</p><p>因为  $pq=(p-1)<em>(q-2)\ qp = (q-1)</em>(p-2)$</p><p>即  $pq=p<em>q-2</em>p-1<em>q+2\ qp = p</em>q-1<em>p-2</em>q+2$</p><p>两式相减得到  $pq-qp=-p+q$ ，即  $q_p=-p+q$</p><p>又已知  $p_q = p + q$</p><p>只需解方程二元一次方程  $\left{\begin{array}{<strong>lr</strong>}q_p=-p+q\p_q = p + q\end{array}\right.$  ，其中 $q_p , p_q$ 为已知量，$p,q$为未知量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import*</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line">pq = </span><br><span class="line">qp = </span><br><span class="line">n = </span><br><span class="line">p_q = </span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">q_p = pq - qp</span><br><span class="line"></span><br><span class="line">p = (p_q + q_p)//2</span><br><span class="line">q = (p_q - q_p)//2</span><br><span class="line"></span><br><span class="line">assert p*q==n</span><br><span class="line"></span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = gmpy2.invert( e , phi )</span><br><span class="line">m = pow( c , d , n )</span><br><span class="line">print( long_to_bytes(m) )</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;Just_4_signin_ch4ll3ng3_for_y0u&#125;</code></p><h3 id="ez-hash"><a href="#ez-hash" class="headerlink" title="ez_hash"></a>ez_hash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from hashlib import sha256</span><br><span class="line">from secret import flag, secrets</span><br><span class="line"></span><br><span class="line">assert flag == b&#x27;moectf&#123;&#x27; + secrets + b&#x27;&#125;&#x27;</span><br><span class="line">assert secrets[:4] == b&#x27;2100&#x27; and len(secrets) == 10</span><br><span class="line">hash_value = sha256(secrets).hexdigest()</span><br><span class="line">print(f&quot;&#123;hash_value = &#125;&quot;)</span><br><span class="line"># hash_value = &#x27;3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a&#x27;</span><br></pre></td></tr></table></figure><hr><p>已知密文前四位（共10位）和sha256后的结果，爆破剩余6位即可得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from hashlib import sha256</span><br><span class="line"></span><br><span class="line">secrets = b&#x27;2100&#x27;</span><br><span class="line">for i in range( 1000000 ):</span><br><span class="line">    tmp = secrets + str(i).encode()</span><br><span class="line">    # print( tmp )</span><br><span class="line">    hash_value = sha256(tmp).hexdigest()</span><br><span class="line">    #print( tmp , hash_value )</span><br><span class="line">    if hash_value == &#x27;3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a&#x27;:</span><br><span class="line">        print( tmp )</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;2100360168&#125;</code></p><h3 id="Big-and-small"><a href="#Big-and-small" class="headerlink" title="Big and small"></a>Big and small</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import*</span><br><span class="line">m = long_to_bytes(flag)</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n = p*q</span><br><span class="line">e = 3</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c = 150409620528288093947185249913242033500530715593845912018225648212915478065982806112747164334970339684262757</span><br><span class="line">e = 3</span><br><span class="line">n = 20279309983698966932589436610174513524888616098014944133902125993694471293062261713076591251054086174169670848598415548609375570643330808663804049384020949389856831520202461767497906977295453545771698220639545101966866003886108320987081153619862170206953817850993602202650467676163476075276351519648193219850062278314841385459627485588891326899019745457679891867632849975694274064320723175687748633644074614068978098629566677125696150343248924059801632081514235975357906763251498042129457546586971828204136347260818828746304688911632041538714834683709493303900837361850396599138626509382069186433843547745480160634787</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><hr><p>低密度指数攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import*</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line">e = 3</span><br><span class="line">n = </span><br><span class="line"></span><br><span class="line">for i in range( 100 ):</span><br><span class="line">    if gmpy2.iroot( c+n*i , e )[1] == True:</span><br><span class="line">        m = gmpy2.iroot( c+n*i , e )[0]</span><br><span class="line">        print( long_to_bytes(m) )</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;xt&gt;is&gt;s&gt;b&#125;</code></p><h3 id="baby-equation"><a href="#baby-equation" class="headerlink" title="baby_equation"></a>baby_equation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = len(flag)</span><br><span class="line">m1, m2 = flag[:l//2], flag[l//2:]</span><br><span class="line">a = bytes_to_long(m1)</span><br><span class="line">b = bytes_to_long(m2)</span><br><span class="line">k = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40</span><br><span class="line">assert ((a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1)) == 4*(k + a*b)</span><br></pre></td></tr></table></figure><hr><p>这一组题里最难的一题</p><p>已知 <code>((a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1)) == 4*(k + a*b)</code></p><p>可以使用python自带库来解方程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sympy import symbols, Eq, solve</span><br><span class="line">k = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40</span><br><span class="line">a , b = symbols(&#x27;a b&#x27;)</span><br><span class="line">eq1 = Eq( (a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1) - 4*(k + a*b) , 0 )</span><br><span class="line">solution = solve( eq1 , (a,b) )</span><br><span class="line">print( solution )</span><br></pre></td></tr></table></figure><p>得到结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[((8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260593 - b)/(b - 1), b), ((-b - 8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260591)/(b - 1), b)]</span><br></pre></td></tr></table></figure><p>我们先只看前半段</p><p><code>((8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260593 - b)/(b - 1), b)</code></p><p>设 <code>t=8699621268124163273600280057569065643071518478496234908779966583664908604557271908267773859706827828901385412151814796018448555312901260593</code></p><p>故有  $((t-b)/(b-1),b)$</p><p>设  $a=((t-b)/(b-1),b)$</p><p>移项得到  $t=a*b-a+b$</p><p>上式等价于  $t-1=(a+1)*(b-1)$</p><p>使用 <code>yafu-x64</code>即可分解 <code>t-1</code>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">***factors found***</span><br><span class="line"></span><br><span class="line">P1 = 2</span><br><span class="line">P1 = 2</span><br><span class="line">P1 = 2</span><br><span class="line">P1 = 2</span><br><span class="line">P1 = 3</span><br><span class="line">P1 = 3</span><br><span class="line">P2 = 31</span><br><span class="line">P2 = 61</span><br><span class="line">P3 = 223</span><br><span class="line">P4 = 4013</span><br><span class="line">P6 = 281317</span><br><span class="line">P7 = 4151351</span><br><span class="line">P13 = 5404604441993</span><br><span class="line">P9 = 370523737</span><br><span class="line">P9 = 339386329</span><br><span class="line">P14 = 26798471753993</span><br><span class="line">P29 = 25866088332911027256931479223</span><br><span class="line">P44 = 64889106213996537255229963986303510188999911</span><br><span class="line"></span><br><span class="line">ans = 1</span><br></pre></td></tr></table></figure><p>也就是说，以上十八个数字分成两组，这两组数分别的乘积就是 $a+1$ 和 $b-1$，而且这两组数的乘积相差较小（即 $a$ 和 $b$ 的相差较小）；我们不妨设答案的解是相差<strong>最小</strong>的一组</p><p>考虑一个长度为 <code>18</code> 的 <strong>01串</strong>，<code>0</code>表示分到一组，<code>1</code>表示分到另一组，依次可以编写代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def generate_binary_strings(n, current_string=&#x27;&#x27;, index=0):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    递归生成所有长度为n的01串，并计算两个子集的乘积。</span><br><span class="line">    </span><br><span class="line">    :param n: 01串的长度</span><br><span class="line">    :param current_string: 当前构建的01串</span><br><span class="line">    :param index: 当前构建01串的位置</span><br><span class="line">    :return: 最小的乘积差值和对应的两个子集的乘积</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if index == n:</span><br><span class="line">        # 当生成了一个完整的01串时，计算两个子集的乘积</span><br><span class="line">        subset1_product = 1</span><br><span class="line">        subset2_product = 1</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if current_string[i] == &#x27;1&#x27;:</span><br><span class="line">                subset1_product *= numbers[i]</span><br><span class="line">            else:</span><br><span class="line">                subset2_product *= numbers[i]</span><br><span class="line">        </span><br><span class="line">        # 计算两个子集乘积的差值</span><br><span class="line">        diff = abs(subset1_product - subset2_product)</span><br><span class="line">        return diff, (subset1_product, subset2_product)</span><br><span class="line">    </span><br><span class="line">    # 递归生成下一个位为0的情况</span><br><span class="line">    diff_0, result_0 = generate_binary_strings(n, current_string + &#x27;0&#x27;, index + 1)</span><br><span class="line">    </span><br><span class="line">    # 递归生成下一个位为1的情况</span><br><span class="line">    diff_1, result_1 = generate_binary_strings(n, current_string + &#x27;1&#x27;, index + 1)</span><br><span class="line">    </span><br><span class="line">    # 返回乘积差更小的那个情况</span><br><span class="line">    if diff_0 &lt; diff_1:</span><br><span class="line">        return diff_0, result_0</span><br><span class="line">    else:</span><br><span class="line">        return diff_1, result_1</span><br><span class="line"></span><br><span class="line">numbers = [2,2,2,2,3,3,31,61,223,4013,281317,4151351,339386329,370523737,5404604441993,26798471753993,25866088332911027256931479223,64889106213996537255229963986303510188999911]</span><br><span class="line">diff, (product1, product2) = generate_binary_strings(len(numbers))</span><br><span class="line">print(f&quot;最小差距是&#123;diff&#125;&quot;)</span><br><span class="line">print(f&quot;a=&#123;product1&#125;&quot;)</span><br><span class="line">print(f&quot;b=&#123;product2&#125;&quot;)</span><br></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最小差距是1706794914313264370032744337649343424996898390647397437784379904184</span><br><span class="line">a=2948658764987911698882278955266869405625105496652193856947916257370492</span><br><span class="line">b=2950365559902224963252311699604518749050102395042841254385700637274676</span><br></pre></td></tr></table></figure><p>计算 $a+1$ 和 $b-1$ 即可得到 flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">a = 2948658764987911698882278955266869405625105496652193856947916257370492 + 1</span><br><span class="line">b = 2950365559902224963252311699604518749050102395042841254385700637274676 - 1</span><br><span class="line">print( long_to_bytes(b) + long_to_bytes(a)  )</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;7he_Fund4m3nt4l_th30r3m_0f_4rithm3tic_i5_p0w4rful!&#125;</code></p><h3 id="大白兔"><a href="#大白兔" class="headerlink" title="大白兔"></a>大白兔</h3><h3 id="More-secure-RSA"><a href="#More-secure-RSA" class="headerlink" title="More_secure_RSA"></a>More_secure_RSA</h3><h3 id="ezlegendre"><a href="#ezlegendre" class="headerlink" title="ezlegendre"></a>ezlegendre</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from sympy import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">a = 288260533169915</span><br><span class="line">p = 1007621497415251</span><br><span class="line"></span><br><span class="line">FLAG = b&#x27;moectf&#123;xxxxxxxxxxxxxxxxxxxxx&#125;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt_flag(flag):</span><br><span class="line">    ciphertext = []</span><br><span class="line">    plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag])</span><br><span class="line">    for b in plaintext:</span><br><span class="line">        e = randprime(2, p)</span><br><span class="line">        if b == &#x27;1&#x27;:</span><br><span class="line">            n = pow(a, -e, p)</span><br><span class="line">            ciphertext.append(n)</span><br><span class="line">        else:</span><br><span class="line">            n = pow(-a, e ,p)</span><br><span class="line">            ciphertext.append(n)</span><br><span class="line">    return ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(encrypt_flag(FLAG))</span><br></pre></td></tr></table></figure><hr><p>离散对数的题还挺爱出</p><p>此题和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DASCTF Sept X 浙江工业大学秋季挑战赛]签到</span><br><span class="line">2020网鼎杯——you_raise_me_up wp</span><br></pre></td></tr></table></figure><p>这两道题考点一致</p><p>直接出代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from sympy import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">a = 288260533169915</span><br><span class="line">p = 1007621497415251</span><br><span class="line"></span><br><span class="line">def decode_flag( ciphertext ):</span><br><span class="line">    plaintext = &quot;&quot;</span><br><span class="line">    for i in ciphertext:</span><br><span class="line">        try:</span><br><span class="line">            e_temp = discrete_log( p , i , a )</span><br><span class="line">        except:</span><br><span class="line">            plaintext += &quot;0&quot;</span><br><span class="line">        else:</span><br><span class="line">            plaintext += &quot;1&quot;</span><br><span class="line">        if len(plaintext) == 8:</span><br><span class="line">            print( chr(int(plaintext,2)) , end=&quot;&quot; )</span><br><span class="line">            plaintext = &quot;&quot;</span><br><span class="line"></span><br><span class="line">Ciphertext = []</span><br><span class="line">print(decode_flag(Ciphertext))</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;minus_one_1s_n0t_qu4dr4tic_r4sidu4_when_p_mod_f0ur_equ41_to_thr33&#125;</code></p><h3 id="new-system"><a href="#new-system" class="headerlink" title="new_system"></a>new_system</h3><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h3 id="逆向工程入门指北"><a href="#逆向工程入门指北" class="headerlink" title="逆向工程入门指北"></a>逆向工程入门指北</h3><p>直接运行题目给的脚本即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char password_enc[] = &#123;</span><br><span class="line">123, 121, 115, 117, 98, 112, 109, 100, 37, 96, 37, 100, 101, 37, 73, 39,</span><br><span class="line">101, 73, 119, 73, 122, 121, 120, 113, 73, 122, 121, 120, 113, 73, 97, 119,</span><br><span class="line">111, 73, 98, 121, 73, 115, 110, 102, 122, 121, 100, 115, 107, 22 &#125;;</span><br><span class="line">// 因为a^b=c时, b^c=a, 所以我们可以这样还原数据:</span><br><span class="line">char password[47];</span><br><span class="line">for (int i = 0; i &lt; 46; i++) &#123;</span><br><span class="line">password[i] = password_enc[i] ^ 22;</span><br><span class="line">&#125;</span><br><span class="line">password[46] = 0; // 使用0字符来截断掉%s的无尽输出..</span><br><span class="line">printf(&quot;%s\n&quot;, password); // 哈哈，这就是本题的f l a g，自己运行一下交上去吧！</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;r3v3rs3_1s_a_long_long_way_to_explore&#125;</code></p><h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><p>打开IDA，F5</p><p><img src="image-20240813013534437.png" alt></p><p>双击<code>byte_1400022B8</code>进入</p><p><img src="image-20240813013709130.png" alt></p><p>这一串异或上<code>0x24</code>就是flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;49h, 4Bh, 41h, 47h, 50h, 42h, 5Fh, 41h, 1Ch, 16h, 46h , 10h, 13h, 1Ch, 40h, 9, 42h, 16h, 46h, 1Ch, 9, 10h, 10h, 42h, 1Dh, 9, 46h, 15h, 14h, 14h, 9, 17h, 16h, 14h, 41h, 40h , 40h , 16h, 14h, 47h, 12h, 40h, 14h, 59h , 0&quot;</span><br><span class="line"></span><br><span class="line">s = s.replace(&quot;h&quot;,&quot;&quot;).replace(&quot; &quot;,&quot;&quot;).split(&quot;,&quot;)</span><br><span class="line"></span><br><span class="line">print( s )</span><br><span class="line"></span><br><span class="line">for i in s:</span><br><span class="line">    t = int(i,16)</span><br><span class="line">    print( chr(t^0x24) , end=&quot;&quot; )</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;e82b478d-f2b8-44f9-b100-320edd20c6d0&#125;</code></p><h3 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h3><p>64位无壳，拖进IDA F5一下</p><p><img src="image-20240813162141504.png" alt></p><p>根据题目给出信息，倒过来就是decode代码了；需要注意运算的数域，这里我们直接使用cpp就可以省去手动取模</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">unsigned int v4 , v5;</span><br><span class="line">int v3;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    v4 = 676078132;</span><br><span class="line">    v5 = 957400408;</span><br><span class="line">    v3 = 0;</span><br><span class="line">    for(int i = 0;i &lt; 32;i ++)&#123;</span><br><span class="line">        v3 -= 1640531527;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0;i &lt; 32;i ++)&#123;</span><br><span class="line">        v5 -= (v4 + v3) ^ (16 * v4 + 1634038898) ^ ((v4 &gt;&gt; 5) + 1634038904);</span><br><span class="line">        v4 -= (v5 + v3) ^ (16 * v5 + 1702060386) ^ ((v5 &gt;&gt; 5) + 1870148662);</span><br><span class="line">        v3 += 1640531527;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v4 &lt;&lt; &quot; &quot; &lt;&lt; v5 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到<code>2204193701 2382383549</code></p><p>然后转用python分离就可以了；需要注意这里是16进制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v4 = 2204193701</span><br><span class="line">v5 = 2382383549</span><br><span class="line"></span><br><span class="line">v10 = v4</span><br><span class="line">v9 = int(bin(v5)[18:34],2)</span><br><span class="line">v11 = int(bin(v5)[2:18],2)</span><br><span class="line"></span><br><span class="line">print( hex(v4) , hex(v11) , hex(v9) )</span><br></pre></td></tr></table></figure><p>输出<code>0x836153a5 0x8e00 0x49bd</code></p><p>得到的就是flag</p><p><img src="image-20240813162502951.png" alt></p><p>flag:<code>moectf&#123;836153a5-8e00-49bd-9c42-caf30620caaf&#125;</code></p><h3 id="逆向工程进阶之北"><a href="#逆向工程进阶之北" class="headerlink" title="逆向工程进阶之北"></a>逆向工程进阶之北</h3><p>给出这样一段代码</p><p><img src="image-20240813165701429.png" alt></p><p>关键是这一行</p><p><img src="image-20240813165731665.png" alt></p><p>直接加法变减法，乘法变逆元，异或变异或即可</p><p>值得注意的是，加法的优先级高于异或运算，并且需要在 <code>0xffffffff+1</code> 域下进行运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">l = [0xb5073388 , 0xf58ea46f , 0x8cd2d760 , 0x7fc56cda , 0x52bc07da , 0x29054b48 , 0x42d74750 , 0x11297e95 , 0x5cf2821b , 0x747970da , 0x64793c81]</span><br><span class="line">p = 0xffffffff+1</span><br><span class="line">for i in l:</span><br><span class="line">    temp = ((i^0xdeadbeef+0xd3906)-0xdeadc0de)*gmpy2.invert( 0xccffbbbb , p ) % p</span><br><span class="line">    temp = str(hex(temp))[2:]</span><br><span class="line">    flag = &quot;&quot;</span><br><span class="line">    for j in range(0,len(temp),2):</span><br><span class="line">        flag += chr(int(temp[j] + temp[j+1],16))</span><br><span class="line">    print( flag[::-1] , end=&quot;&quot; )</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;c5f44c32-cbb9-444e-aef4-c0fa7c7a6b7a&#125;</code></p><h3 id="SecretModule"><a href="#SecretModule" class="headerlink" title="SecretModule"></a>SecretModule</h3><p>给了一个zip，解压得到几个文件</p><p>用记事本打开 <code>customize.sh</code> 文件，得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> eval   &quot;$(     printf &#x27;QlpoOTFBWSZTWZspxEUAAfxfgFAwdef/6zfHz6D/79/uQAJSu07tCQ1BI09E9Q0DINA9TQA2oAAA0NAlCFPRpM0mjSNR+hIaek0AHqaGj1PUNNMeqDSEJ6gNBo0NNAAZNGjI0NBoAAlEjEo8ppp6NPVGCaaNNMR6g9EBoPUGgPAecJO66TH6u4xdFeH8fRdR4OSNOqLoVm2I39FZSS/irDMIJmggh2EyQovQos26HmeniQH4iRSw0JeeVV2C9E8NkJh+VZwioAZj5QpGcdTmdOSMoYLaiaaa8oZEhIRgQbKjP7VIopzl53axe+MJxXTyrg/duKuBYecUVQUUTMptuykt+JqZZmJSM0dQ/YaHpifbwN3wN0NYRAEYC0tkI6uE4GkS9r1eFB9zyCBef6dnGYwKo8BylS24xNYsXSUXIYpZC3fzxlQKVBUwrBawin+AaDPkLwbCSQNge45QjrBfoNLEJSWk8C0ajKPu8NORzYlfqGgjOQOQQ0YG7gCRaWFD6wkguEqEUi6bSFTxLE4Y3+pziYRKFVet5X1CrnXc2jLN+9tMTJ8beC0ED5k1K7n22efCha1ci53zQHgQBUKLg1Q3hPZoMCAp0g48QN02037Qy891pyxa+vZU5msKnsJryCXKyBdrCrWXljrC/S6i3MBzRikY4kZzLw7v8aL7oOYKGRkUCWxelwUWFKIOQyImQVnIKicgYFqJYjeY1CMSgaiR4dqQ7MomJ6LdpOEtDOvfhjsEplnGTvSo3NV1KnALfTTYMeOUngApQKa8IExBIGZhafHgZZjI0HAKg6bcV5QwiUHCoorQaSWUvNMLgejbZ/QJA9QFWitiup+KyAU5uTergMVuJ5jj/xdyRThQkJspxEU=&#x27;   | base64   -d   |   bunzip2  -c    )&quot;   </span><br></pre></td></tr></table></figure><p>编写相应的解码代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">import bz2</span><br><span class="line"></span><br><span class="line"># 这是原始的 Base64 编码字符串</span><br><span class="line">encoded_str = &#x27;QlpoOTFBWSZTWZspxEUAAfxfgFAwdef/6zfHz6D/79/uQAJSu07tCQ1BI09E9Q0DINA9TQA2oAAA0NAlCFPRpM0mjSNR+hIaek0AHqaGj1PUNNMeqDSEJ6gNBo0NNAAZNGjI0NBoAAlEjEo8ppp6NPVGCaaNNMR6g9EBoPUGgPAecJO66TH6u4xdFeH8fRdR4OSNOqLoVm2I39FZSS/irDMIJmggh2EyQovQos26HmeniQH4iRSw0JeeVV2C9E8NkJh+VZwioAZj5QpGcdTmdOSMoYLaiaaa8oZEhIRgQbKjP7VIopzl53axe+MJxXTyrg/duKuBYecUVQUUTMptuykt+JqZZmJSM0dQ/YaHpifbwN3wN0NYRAEYC0tkI6uE4GkS9r1eFB9zyCBef6dnGYwKo8BylS24xNYsXSUXIYpZC3fzxlQKVBUwrBawin+AaDPkLwbCSQNge45QjrBfoNLEJSWk8C0ajKPu8NORzYlfqGgjOQOQQ0YG7gCRaWFD6wkguEqEUi6bSFTxLE4Y3+pziYRKFVet5X1CrnXc2jLN+9tMTJ8beC0ED5k1K7n22efCha1ci53zQHgQBUKLg1Q3hPZoMCAp0g48QN02037Qy891pyxa+vZU5msKnsJryCXKyBdrCrWXljrC/S6i3MBzRikY4kZzLw7v8aL7oOYKGRkUCWxelwUWFKIOQyImQVnIKicgYFqJYjeY1CMSgaiR4dqQ7MomJ6LdpOEtDOvfhjsEplnGTvSo3NV1KnALfTTYMeOUngApQKa8IExBIGZhafHgZZjI0HAKg6bcV5QwiUHCoorQaSWUvNMLgejbZ/QJA9QFWitiup+KyAU5uTergMVuJ5jj/xdyRThQkJspxEU=&#x27;</span><br><span class="line"></span><br><span class="line"># Base64 解码</span><br><span class="line">decoded_data = base64.b64decode(encoded_str)</span><br><span class="line"></span><br><span class="line"># BZ2 解压</span><br><span class="line">decompressed_data = bz2.decompress(decoded_data)</span><br><span class="line"></span><br><span class="line"># 打印解压后的内容</span><br><span class="line">print(decompressed_data.decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure><p>得到输出内容，代码大致意思是使用<code>114514</code>和<code>1919810</code>来碰撞给定的MD5，编写脚本即可枚举</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line"># Possible results of choose()</span><br><span class="line">options = [&quot;114514&quot;, &quot;1919810&quot;]</span><br><span class="line"></span><br><span class="line"># Target MD5 hash</span><br><span class="line">target_hash = &quot;77a58d62b2c0870132bfe8e8ea3ad7f1&quot;</span><br><span class="line"></span><br><span class="line"># Brute force all possible combinations</span><br><span class="line">for combination in itertools.product(options, repeat=7):</span><br><span class="line">    concatenated = &#x27;&#x27;.join(combination)</span><br><span class="line">    generated_hash = hashlib.md5(concatenated.encode()).hexdigest()</span><br><span class="line">    if generated_hash == target_hash:</span><br><span class="line">        print(f&quot;Correct sequence: &#123;combination&#125;&quot;)</span><br><span class="line">        print(f&quot;Flag: moectf&#123;&#123;&#123;concatenated&#125;&#125;&#125;&quot;)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>flag:<code>moectf&#123;114514114514191981011451411451419198101919810&#125;</code></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h3 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h3><p>按照题目要求，只给 <code>luo</code> 记缺勤，其他人都代签即可</p><p>flag:<code>moectf&#123;Thanks_For_You_signing_in_4ND_W3l0c0me_T0_M0ecTf_2024!!!&#125;</code></p><h3 id="罗小黑战记"><a href="#罗小黑战记" class="headerlink" title="罗小黑战记"></a>罗小黑战记</h3><p>得到一张gif，使用stegsolve进行分解，发现第110张图片中有二维码，扫描二维码得到flag</p><p>flag:<code>moectf&#123;y0uu6r3th3m0st3r1nth1sf13ld&#125;</code></p><h3 id="杂项入门指北"><a href="#杂项入门指北" class="headerlink" title="杂项入门指北"></a>杂项入门指北</h3><p>右侧有一列<code>.-</code>，是摩斯密码</p><p><code>.... ....- ...- . ..--.- .- ..--.- --. ----- ----- -.. ..--.- - .---- -- .</code></p><p>flag:<code>moectf&#123;H4VE_A_G00D_T1ME&#125;</code></p><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h3 id="Web渗透测试与审计入门指北"><a href="#Web渗透测试与审计入门指北" class="headerlink" title="Web渗透测试与审计入门指北"></a>Web渗透测试与审计入门指北</h3><p>题目给了一个服务器的文件，要求自行搭建服务器</p><p>查看文件，是php语言加密之后的内容</p><p>打开<code>PHPstudy Pro</code>，点击<code>Nginx</code>的启动</p><p><img src="image-20240821155311822.png" alt></p><p>点击<code>网站-管理-打开根目录</code>，将题目给的文件拖进去即可</p><p>访问<code>http://localhost:80</code>即可得到flag</p><p><img src="image-20240821163245875.png" alt></p><p>flag:<code>moectf&#123;H3r3&#39;5_@_flYinG_kIss_f0r_yoU!&#125;</code></p><h3 id="弗拉格之地的入口"><a href="#弗拉格之地的入口" class="headerlink" title="弗拉格之地的入口"></a>弗拉格之地的入口</h3><p><img src="image-20240821164405545.png" alt></p><p>爬虫？写了个爬虫，什么额外的东西都没有爬下来</p><p>问问ai，他说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在运行爬虫前，请务必检查目标网站的robots.txt文件，确保您的行为符合该网站的规定。此外，频繁的请求可能会对网站服务器造成负担，因此在实际应用中应考虑添加适当的延时或其他更复杂的逻辑来避免被封禁。</span><br></pre></td></tr></table></figure><p>那我们检查一下<code>robots.txt</code>，发现里面提到了一个文件</p><p><img src="image-20240821164600594.png" alt></p><p>我们直接访问一下<code>/webtutorEntry.php</code>，然后就得到了flag</p><p><img src="image-20240821164640135.png" alt></p><p>flag:<code>moectf&#123;c0nGRATU14TiOn_f0r_kN0WlNg-R0BoT5_Txta02b&#125;</code></p><h3 id="垫刀之路01-MoeCTF？启动！"><a href="#垫刀之路01-MoeCTF？启动！" class="headerlink" title="垫刀之路01: MoeCTF？启动！"></a>垫刀之路01: MoeCTF？启动！</h3><p>回到根目录，看到一个flag文件，打开</p><p><img src="image-20240821165625544.png" alt></p><p>得到提示检查环境变量</p><p><img src="image-20240821165715268.png" alt></p><p>输入<code>env</code>检测环境变量，得到flag</p><p><img src="image-20240821165807674.png" alt></p><p>flag:<code>moectf&#123;w31CoME_TO-moEctF-4nd-r0@Dl_5T4RtuP-bY-sXrHHH5e&#125;</code></p><h3 id="ez-http"><a href="#ez-http" class="headerlink" title="ez_http"></a>ez_http</h3><h3 id="ProveYourLove"><a href="#ProveYourLove" class="headerlink" title="ProveYourLove"></a>ProveYourLove</h3><h3 id="弗拉格之地的挑战"><a href="#弗拉格之地的挑战" class="headerlink" title="弗拉格之地的挑战"></a>弗拉格之地的挑战</h3><p><img src="image-20240821173635106.png" alt></p><p>直接访问<code>http://127.0.0.1:53846/flag1ab.html</code></p><p>点击<code>F12</code>得到第一段flag</p><p><img src="image-20240821173737969.png" alt></p><p><code>flag1: bW9lY3Rm</code></p><p>然后访问<code>http://127.0.0.1:53846/flag2hh.php</code></p><p><code>服务器通过网络传输过来的，除了这个页面，还有什么？</code>，F12打开<code>网络</code>在响应标头找到flag2</p><p><code>flag2：e0FmdEV</code></p><p>然后访问<code>http://127.0.0.1:53846/flag3cad.php</code></p><p><img src="image-20240821200554497.png" alt></p><p>使用hackbar传入</p><p><img src="image-20240821200709136.png" alt></p><p>然后传入b参数</p><p><img src="image-20240821200855227.png" alt></p><p>元素页面有提示<code>你知道 cookie 吗？</code></p><p><img src="image-20240821201104980.png" alt></p><p>然后就不知道怎么做了</p><h3 id="ImageCloud前置"><a href="#ImageCloud前置" class="headerlink" title="ImageCloud前置"></a>ImageCloud前置</h3><h3 id="垫刀之路02-普通的文件上传"><a href="#垫刀之路02-普通的文件上传" class="headerlink" title="垫刀之路02: 普通的文件上传"></a>垫刀之路02: 普通的文件上传</h3>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次关于hexo+next图片显示部分出错的debug过程</title>
      <link href="/2024/08/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8Ehexo-next%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E5%87%BA%E9%94%99%E7%9A%84debug%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/08/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8Ehexo-next%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%83%A8%E5%88%86%E5%87%BA%E9%94%99%E7%9A%84debug%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>今天看自己的博客，发现有的图片显示正常，有些不正常</p><span id="more"></span><p><img src="image-20240820224255118.png" alt></p><p>有的内容多一层路径，有的图片就正常显示</p><p>经过多次对比发现是把<code>\</code>打成<code>/</code></p><p>二者在typora中是都可以显示的，但是在生成博客时，如果没有使用反斜就会出错</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF Web wp</title>
      <link href="/2024/08/16/BUUCTF-Web-wp/"/>
      <url>/2024/08/16/BUUCTF-Web-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="ACTF2020-新生赛-Exec"><a href="#ACTF2020-新生赛-Exec" class="headerlink" title="[ACTF2020 新生赛]Exec"></a>[ACTF2020 新生赛]Exec</h3><span id="more"></span><p>输入<code>127.0.0.1;ls</code></p><p><img src="image-20240816141656487.png" alt></p><p>发现真的把 <code>index.php</code>（也就是<code>ls</code>的操作结果）真的输出了，说明没有过滤分号</p><p>最终在<code>127.0.0.1;cd ../../../;ls</code>找到了flag文件</p><p><img src="image-20240816141854210.png" alt></p><p>输入<code>127.0.0.1;cd ../../../;ls</code>得到flag</p><p><img src="image-20240816141948311.png" alt></p><p>flag:<code>flag&#123;4e3b851f-9a72-42c9-a57a-d6698548cdc0&#125;</code></p><h3 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h3><p>发现有一个<code>/?ip=</code></p><p>根据上一题的经验，我们输入<code>/?ip=127.0.0.1;ls</code>，得到</p><p><img src="image-20240816165534905.png" alt></p><p>得知不能输入空格</p><p><img src="image-20240816165620729.png" alt></p><p>所以我们需要绕过空格使用一下平替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$&#123;IFS&#125;$9</span><br><span class="line">&#123;IFS&#125;</span><br><span class="line">$IFS</span><br><span class="line">$&#123;IFS&#125;</span><br><span class="line">$IFS$1 //$1改成$加其他数字貌似都行</span><br><span class="line">IFS</span><br><span class="line">&lt; </span><br><span class="line">&lt;&gt; </span><br><span class="line">&#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来</span><br><span class="line">%20   (space)</span><br><span class="line">%09   (tab)</span><br><span class="line">X=$&#x27;cat\x09./flag.php&#x27;;$X       （\x09表示tab，也可以用\x20）</span><br></pre></td></tr></table></figure><p>输入<code>/?ip=127.0.0.1;cat$IFS1flag.php</code></p><p><img src="image-20240816170242335.png" alt></p><p>我们查看index.php</p><p><img src="image-20240816171040850.png" alt></p><p>使用 <code>/?ip=127.0.0.1;e=g;cat$IFS$1fla$e.php</code></p><p>F12即可得到flag</p><p><img src="image-20240816171951521.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;     前面的执行完执行后面的</span><br><span class="line">|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         </span><br><span class="line">||    当前面的执行出错时（为假）执行后面的</span><br><span class="line">&amp;     将任务置于后台执行</span><br><span class="line">&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真</span><br><span class="line">%0a  （换行）</span><br><span class="line">%0d  （回车）</span><br><span class="line">---</span><br><span class="line">ps:有时会禁用cat:</span><br><span class="line">解决方法是使用tac反向输出命令：</span><br><span class="line">linux命令中可以加\，所以甚至可以ca\t /fl\ag</span><br><span class="line">---</span><br><span class="line">?ip=127.0.0.1;cat$IFS$9`ls`</span><br><span class="line">$IFS在Linux下表示为空格</span><br><span class="line">$9是当前系统shell进程第九个参数持有者，始终为空字符串，$后可以接任意数字</span><br><span class="line">这里$IFS$9或$IFS垂直，后面加个$与&#123;&#125;类似，起截断作用</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;ef88dbb0-2c4d-4489-9fdb-02ce4c5d6fa1&#125;</code></p><h3 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h3><p><img src="image-20240829192738522.png" alt></p><p>堆叠注入查询数据库</p><p><code>1; show databases;</code></p><p><img src="image-20240829192900891.png" alt></p><p>查询表名</p><p><img src="image-20240829192936164.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1;show columns from Flag;#</span><br><span class="line">select $_GET[&#x27;query&#x27;] || flag from flag</span><br></pre></td></tr></table></figure><p>尝试访问Flag，发现不行</p><p>输入<code>*,1</code></p><p><img src="image-20240829193113322.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这里的原理是</span><br><span class="line"></span><br><span class="line">sql=select.post[‘query’].&quot;||flag from Flag&quot;;</span><br><span class="line">如果$post[‘query’]的数据为*,1，sql语句就变成了select *,1||flag from Flag，</span><br><span class="line">就是select *,1 from Flag，这样就直接查询出了Flag表中的所有内容。</span><br><span class="line"></span><br><span class="line">这里说一下我的理解</span><br><span class="line"></span><br><span class="line">这里输入*,1,这里会增加一个临时列，他的列名为1，然后那一列的值都为1。</span><br><span class="line"></span><br><span class="line">当我们只关心数据表有多少记录行而不需要知道具体的字段值时，类似“select 1 from tblName”是一个很不错的SQL语句写法，它通常用于子查询。这样可以减少系统开销，提高运行效率，因为这样子写的SQL语句，数据库引擎就不会去检索数据表里一条条具体的记录和每条记录里一个个具体的字段值并将它们放到内存里，而是根据查询到有多少行存在就输出多少个“1”，每个“1”代表有1行记录，同时选用数字1还因为它所占用的内存空间最小，当然用数字0的效果也一样。在不需要知道具体的记录值是什么的情况下这种写法无疑更加可取。</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;70066add-3cd0-49ec-84b3-8e6ee05c3dd9&#125;</code></p><h3 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h3>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF RE wp</title>
      <link href="/2024/08/13/BUUCTF-RE-wp/"/>
      <url>/2024/08/13/BUUCTF-RE-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><span id="more"></span><p>F5一下出</p><p><img src="image-20240813004958292.png" alt></p><p>直接打开的话，结束之后自动闪退，所以要用cmd</p><p><img src="image-20240813005154655.png" alt></p><p>flag:<code>flag&#123;this_Is_a_EaSyRe&#125;</code></p><h3 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h3><p>shift+F12，然后Ctrl+F搜索关键词<code>flag</code></p><p><img src="image-20240813010913141.png" alt></p><p>双击进入，ctrl+x查看交叉引用</p><p><img src="image-20240813010954836.png" alt></p><p>然后点击F5查看源码</p><p><img src="image-20240813011117186.png" alt></p><p>得到这一段内容，选中数字单击 <code>r</code> 可以转化为ascll码对应的字母</p><p>可以知道，for循环把str2的 <code>o</code> 替换为 <code>0</code></p><p><img src="image-20240813011246912.png" alt></p><p>双击 str2 进入，可以看到str2的数值</p><p><img src="image-20240813011339666.png" alt></p><p>那么flag就是替换之后的</p><p>flag:<code>flag&#123;hell0_w0rld&#125;</code></p><h3 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h3><p>IDA打开，一键F5</p><p><img src="image-20240813012032896.png" alt></p><p>发现是把i和r替换为1</p><p><img src="image-20240813012108890.png" alt></p><p>双击flag查看内容</p><p><img src="image-20240813012146130.png" alt></p><p>发现有一段是<code>hacking_for_fun&#125;</code>，替换即可得到flag</p><p>flag:<code>flag&#123;hack1ng_fo1_fun&#125;</code></p><h3 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h3><p>拖进查壳软件</p><p><img src="image-20240813114639646.png" alt></p><p>发现是32位文件，拖进IDA32</p><p>shift+F12即可看到flag</p><p><img src="image-20240813114803075.png" alt></p><p>flag:<code>flag&#123;49d3c93df25caad81232130f3d2ebfad&#125;</code></p><h3 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h3><p>发现是32位程序</p><p><img src="image-20240813115004507.png" alt></p><p>用IDA打开发现有壳</p><p><img src="image-20240813115526632.png" alt></p><p>拖进FFI工具中自动去壳</p><p><img src="image-20240813115619957.png" alt></p><p>然后拖进IDA，F5发现flag</p><p><img src="image-20240813115707835.png" alt></p><p>flag:<code>flag&#123;HappyNewYear!&#125;</code></p><h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><p>32位</p><p><img src="image-20240813130910840.png" alt></p><p>拖进IDA，F5</p><p><img src="image-20240813130945671.png" alt></p><p>可以发现flag是异或得到的</p><p>双击global，shift+E获得<code>aFKWOXZUPFVMDGH</code>的值</p><p><img src="image-20240813131706539.png" alt></p><p>保存到十进制，编写脚本即可获得flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">l = [</span><br><span class="line">  102,  10, 107,  12, 119,  38,  79,  46,  64,  17, </span><br><span class="line">  120,  13,  90,  59,  85,  17, 112,  25,  70,  31, </span><br><span class="line">  118,  34,  77,  35,  68,  14, 103,   6, 104,  15, </span><br><span class="line">   71,  50,  79,   0</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">flag += chr(l[0])</span><br><span class="line">for i in range(1,len(l)):</span><br><span class="line">    flag += chr(l[i]^l[i-1])</span><br><span class="line"></span><br><span class="line">print( flag )</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;QianQiuWanDai_YiTongJiangHu&#125;</code></p><h3 id="reverse3"><a href="#reverse3" class="headerlink" title="reverse3"></a>reverse3</h3><p>查壳发现没壳，32位，打开</p><p><img src="image-20240813133049766.png" alt></p><p>shift+F12看到flag</p><p><img src="image-20240813135833713.png" alt></p><p>双击，然后ctrl+x查看交叉引用，然后F5一下，得到以下页面</p><p><img src="image-20240813135940665.png" alt></p><p>进入<code>sub_4110BE</code>函数，发现是base64加密</p><p>后面还有一个简单的位移运算</p><p>密文变量是 <code>Str2</code>，shift+E保存</p><p><img src="image-20240813140249918.png" alt></p><p>编写脚本得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = [</span><br><span class="line">  101, 51, 110, 105, 102, 73, 72, 57, 98, 95, </span><br><span class="line">  67, 64, 110, 64, 100, 72</span><br><span class="line">]</span><br><span class="line">flag = &quot;&quot;</span><br><span class="line">for i in range(len(s)):</span><br><span class="line">    flag += chr(s[i]-i)</span><br><span class="line"></span><br><span class="line">print( flag )</span><br><span class="line">print( base64.b64decode(flag) )</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;i_l0ve_you&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厦大一日游（机器人大赛）</title>
      <link href="/2024/08/13/%E5%8E%A6%E5%A4%A7%E4%B8%80%E6%97%A5%E6%B8%B8%EF%BC%88%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E8%B5%9B%EF%BC%89/"/>
      <url>/2024/08/13/%E5%8E%A6%E5%A4%A7%E4%B8%80%E6%97%A5%E6%B8%B8%EF%BC%88%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A4%A7%E8%B5%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/coper/p/XMU_robo_2023-11-25.html">原文链接</a></p><p>原文发表日期 <code>2023-11-25</code></p><p>朝花夕拾，感悟颇深，故迁移到新博客网址</p><p><img src="摸鱼.gif" alt></p><span id="more"></span><hr><p>11.25早晨六点，早早地起床，出了校门，坐了很长时间的地铁，来到了福州南站</p><p>看样子学长们昨天晚上调了一个通宵的车···</p><p>一个多小时后到达厦门北站，然后乘坐地铁到达岛内，又然后转乘到翔安区~~<br>见证了一个繁华到清净的过程</p><p><img src="2932150-20231126051654143-1981000588.jpg" alt></p><p>早听闻翔安校区周围都是荒地，果真如此；进入校园之后，感觉校内空间也很大</p><p>道路很宽，路上人也不多（即使是吃饭时间）；这样宽阔的路上，行车行人两不误</p><p>很奇怪的是，厦大翔安的面积远大于师大旗山，但目测其电动车比例很小，与师大大相径庭。晚上骑上共享单车时我得到了答案——在厦大骑车和在师大完全是不同的感觉，可谓冯虚御风，那叫一个爽；骑起来了，几乎不需要再蹬就可以走得很远很远。共享单车的故障率也远小于师大，这下子有共享电动车也不是很需要了</p><p>因此，在自然选择下，可以长距离骑的山地车更适用于没有减速带的厦大；交通相对堵塞的师大更适合电动车来进行频繁的零始加速</p><p>据目测，厦大跟师大的饭菜大致差不多，不过价格更便宜；米饭全部免费（因为有补贴），包装费便宜很多（呜呜呜不想回师大了）</p><p>翔安校区的建筑看起来很新很好看，毕竟是新的建筑，即使是宿舍楼也很有艺术气息；很有酒吧舞的感觉，属于是名副其实了</p><p><img src="2932150-20231126051726097-621762781.jpg" alt></p><hr><p>关于比赛</p><ol><li>准备比赛需要携带的基本物品（电控组）<br>ps.下次需要再加上魔术贴<br><img src="2932150-20231126023157525-917250009.jpg" alt><br><img src="2932150-20231126023217824-456054961.jpg" alt><br><img src="2932150-20231126023227354-1015322350.jpg" alt></li></ol><ol><li>赛前硬件出问题可能是常态，需要稳住心态，才有可能抢救<br>赛前遥控器突然故障，硬件组的学长紧急抢修得以挽救；测试结束后，pitch轴控制出现离线问题，学长进行分析，得到结论：是新的线使pitch轴的线出现接触不良<br>赛前不要改走线，否则容易出大问题</li><li>需要多和其他成员沟通，谋得更好的配合<br>电控视觉硬件等组合作完成工作，每个人熟悉自己领域的工作并了解其他领域的工作，可以使调试效率大大提升</li><li>比赛周途劳顿是常态，需要习惯<br>比赛嘛，虽然不是土木，但是总是要接触硬件，不就得跑来跑去的嘛——也是比较值得的</li></ol><p><img src="2932150-20231126051748553-609376348.jpg" alt></p><hr><p>感悟</p><ol><li><p>在RM上，师大和厦大差距很大<br>一方面在资金和支持，这导致在资源上出现缺陷，师大只有一间实验室（和一间自习室），合在一起也远没有厦大的一间实验室面积大（而厦大有整整一个楼层的实验室，六间！），也因此师大没有环形高地等试验场地；<br>另一方面在于层次上，就新生而论：厦大的新生已经可以做各式各样的机器人（包括但不限于带有发射机构的机器人），与此同时师大的新生却处于在循迹小车的层次，各种通信协议也需要自行学习（这一点利弊难辨），格局差距不小；就氛围而论，师大不及周边很多学校，协会人数过少，如果条件允许（然而显而易见，也许由于物质基础的限制，条件是不允许的）可以向首都师范大学学习；<br>归其原因，还是因为穷，没有场地也没有资金<br>在层层限制下，不能想太远，才有机会翻盘</p></li><li><p>在建设上，师大和厦大差距很大<br>同样是人文学校，同样是不注重理工科，为什么厦大机器人协会这么富（哭）<br>理工科可以算得上是一种趋势，所以各个学校都在努力向理工科砸钱，这样子，师大相对厦大的距离应该会是越来越远</p></li><li><p>在学生素质上，师大和厦大差距很大<br>让我很为赞叹的是，开会期间，有几个厦大学生，一直在那里研究和学习<br>对于大学生而言，保持专注状态已经很为难得了，除非热爱，再加上有条不紊按部就班的规划能力<br>人外有人山外有山，对于个人能力，及有待提升</p></li><li><p>需要多看开源，多交流学习以开阔眼界<br>看了集美成毅的车，他们的pid十分丝滑，车也显得十分轻。经过交流和观察得知，他们的部分结构设计是借鉴的开源，使用的材料也是相对轻便的玻纤，没有使用超级电容，很稳，最终以三十多秒零碰撞的成绩赢下了比赛。这应该是一个强基固本很好的例子，善于利用并学习，进而选择正确的决策才能换来成功</p></li><li><p>看着好，不一定真的好<br>赛前，嘉庚学院的某队队长向领导展示全向轮的小车，其灵活性能令领导赞叹不已；上场后却频频“碰壁”（物理）。不禁令人沉思——再强大的设计，不经过赛场的试炼，它可以算作是强大吗？</p></li></ol><hr><p>ATTENDATION</p><p>厦门大学学习氛围和人文主义浓厚，但是和同层次院校相比，理工科水平不足</p><p>有学长说，厦门大学的理工科不如福州大学；窃以为RoboMaster比赛需要大量的经济支持来支撑起来，厦门大学作为酒吧舞固然有更多的物质支持，而硬件比拼不过，并不代表技术会有欠缺；在恶劣的环境下即使与在相对优越的环境下的他们能打平手，某种意义上也算是大获全胜了——初心高于胜负，成长胜于输赢！</p><p><img src="2932150-20231126051816974-1134422029.jpg" alt></p><p>润去学高数了，再不学就挂科了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 965 (Div. 2) 题解</title>
      <link href="/2024/08/11/Codeforces-Round-965-Div-2-%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/11/Codeforces-Round-965-Div-2-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1998">题目链接</a></p><p>逆天抽象局，ab都是构造题，</p><p><img src="image-20240811110838813.png" alt></p><span id="more"></span><p><a href="https://codeforces.com/contest/1998/problem/A">A. Find K Distinct Points with Fixed Center</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int t , x , y , k;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        if( k % 2 )&#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">            for(int i = 1;i &lt;= (k-1)/2;i ++)&#123;</span><br><span class="line">                cout &lt;&lt; x-i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; x+i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int i = 1;i &lt;= k/2;i ++)&#123;</span><br><span class="line">                cout &lt;&lt; x-i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; x+i &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codeforces.com/contest/1998/problem/B">B. Minimize Equal Sum Subarrays</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int n;</span><br><span class="line">int a[N+10];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 2;i &lt;= n;i ++)&#123;</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;cout &lt;&lt; a[1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞行器空气动力学学习笔记（低速翼型）</title>
      <link href="/2024/08/10/%E9%A3%9E%E8%A1%8C%E5%99%A8%E7%A9%BA%E6%B0%94%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BD%8E%E9%80%9F%E7%BF%BC%E5%9E%8B%EF%BC%89/"/>
      <url>/2024/08/10/%E9%A3%9E%E8%A1%8C%E5%99%A8%E7%A9%BA%E6%B0%94%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BD%8E%E9%80%9F%E7%BF%BC%E5%9E%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>2024.11.06二次编辑</p><p>理论的话学这些已经足够了，基础知识不需要太多，该着手于上手实操和控制系统的调试了</p><p>故不再更新</p><span id="more"></span><p><img src="image-20240810173617803.png" alt></p><p>机翼定义：平行于机翼的对称面截得的机翼截面称为翼剖面，通常称为翼型</p><p>飞机设计中，在确定了平面形状、机翼形状后，首先要做的工作就是翼型设计。<br>翼型的气动特性，直接影响到机翼及整个飞行器的气动特性</p><p>翼型设计：确定机翼的几何形状</p><p><img src="image-20240810174026702.png" alt></p><p>圆头尖尾<br>用于低速、亚音速和跨音速飞行的飞机机翼，以及低超音速飞行的超音过飞机机翼</p><p>尖头尖尾<br>用于较高超音速飞行的超音速飞机机翼和导弹的弹翼</p><h3 id="翼型的几何参数"><a href="#翼型的几何参数" class="headerlink" title="翼型的几何参数"></a>翼型的几何参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前缘点、后缘点、翼弦</span><br><span class="line">弯度、厚度</span><br><span class="line">前缘半径、后缘尖锐度</span><br></pre></td></tr></table></figure><p>前缘点指的是最前面，后缘点指的是最后面，连接前缘和后缘的直线,称为翼型的弦线,其长称为几何弦长,简称弦长（一般用字母b表示）。</p><p>描述翼型经常使用体轴坐标系（相对应的是“风轴坐标系”）</p><p><img src="image-20240810174402878.png" alt></p><p>无量纲坐标可以写为</p><p><img src="image-20240810174645606.png" alt></p><p>经过这样的处理之后，翼型的长度是1</p><p>中弧线：每个x值对应的两个y值的平均值，中弧线的无量纲坐标$\bar{y}_f(\bar{x})$称为弯度分布函数，最大值称为相对弯度$\bar{f}$，对应的弦向位置记为$\bar{x}_f$</p><script type="math/tex; mode=display">\bar{y}_f(\bar{x})=\frac{\bar{y}_上+\bar{y}_下}{2}\\\bar{f}=\frac{f}{b}=[\bar{y}_f(\bar{x})]_{max}\\\bar{x}_f=\frac{x_f}{b}</script><p><img src="image-20240810175554832.png" alt></p><p>$\bar{c}&lt;=12%$ 的翼型统称 薄翼型（薄翼型理论）</p><p><img src="image-20240810175757111.png" alt></p><h5 id="前缘顿度："><a href="#前缘顿度：" class="headerlink" title="前缘顿度："></a>前缘顿度：</h5><p>对圆头翼型，用前缘的内切圆半径 $r_L$ 表示前缘钝度，该内切圆的圆心在中弧线前缘点的切线上，圆的半径 $r_L$ 称为前缘半径</p><p>相对值定义 $\bar{r}_L=\frac{r_L}{b}$</p><h5 id="后缘尖锐度："><a href="#后缘尖锐度：" class="headerlink" title="后缘尖锐度："></a>后缘尖锐度：</h5><p>后缘处上下翼面切线的夹角，称为后缘角 $\tau$，表示后缘的尖锐度</p><p><img src="image-20240810180119919.png" alt></p><h5 id="低速翼型编号"><a href="#低速翼型编号" class="headerlink" title="低速翼型编号"></a>低速翼型编号</h5><p><img src="image-20240810180304068.png" alt></p><h5 id="翼型的迎角"><a href="#翼型的迎角" class="headerlink" title="翼型的迎角"></a>翼型的迎角</h5><p>在翼型平面上，来流和翼弦之间的夹角，称之为迎角(攻角)</p><p><img src="image-20240810180715088.png" alt></p><p>一定程度内，迎角越大，升力越大</p><p>对弦线而言，来流上偏升力为正，来流下偏升力为负</p><p>飞机的迎角：来流和机身轴线间的夹角</p><p>滑跑：三轮着地，速度方向平行于地面</p><p>拉起：前轮离地，速度方向平行于地面</p><p>起飞：三轮离地，速度方向偏向于轴线方向</p><p><img src="image-20240810181103558.png" alt></p><p>对于一个无限翼展展长的机翼，展向取于一个单位展长的翼段，那么这个翼段上的绕流及气动力就是翼型的绕流和气动力</p><p>翼型表面上每个点都作用有压强和摩擦应力，它们产生一个合力品，将R分解为垂直于来流和平行于来流方向的两个分量</p><p><img src="image-20240810181451940.png" alt></p><p>垂直于来流方向的力称之为升力<br>平行于来流方向的力称之为阻力</p><p>法向力垂直于翼弦方向的力<br>轴向力平行于翼弦方向的力</p><p><img src="image-20240810181549368.png" alt></p><p>（$\alpha$ 表示来流迎角）</p><p><img src="image-20240810183121573.png" alt></p><p>低速翼型指的是马赫数小于0.3的流动对于一个给定的翼型，在不同的迎角情况下他的绕流特征是不一样的</p><p>0°迎角绕流，流过相对平滑</p><p> <img src="image-20240810183226061.png" alt></p><p>10°迎角绕流，尾部少许分流</p><p><img src="image-20240810183311856.png" alt></p><p>30°迎角绕流，整个背风区都出现了分离流动</p><p><img src="image-20240810183357865.png" alt></p><p>合适迎角——稳流</p><p>临界失速迎角——气流分离</p><p>失速迎角——湍流</p><p><img src="image-20240810183626356.png" alt></p><h5 id="库塔-儒可夫斯基后缘条件"><a href="#库塔-儒可夫斯基后缘条件" class="headerlink" title="库塔-儒可夫斯基后缘条件"></a>库塔-儒可夫斯基后缘条件</h5><p>小迎角下，翼型绕流的压力分布及升力，与绕翼型的无粘位流的压力分布及升力无本质差别；因此，不计粘性作用，用绕翼型的无粘位流求解翼型压力分布及升力,是合理的近似<br>绕翼型无粘位流的升力问题，遵循儒可夫斯基升力定理，直均流流过任意截面形状翼型的升力:  </p><p>$Y=\rho V_{\infty} \Gamma$ （升力=密度*来流速度*环量）<strong>确定速度环量是关键</strong></p><p> 只有后驻点在后缘点上，才能有唯一的速度环量值与之对应</p><p><img src="image-20240810184307965.png" alt></p><p> <img src="image-20240810184509863.png" alt></p><p>圆弧形后缘翼型：$V_{S上}=V_{S下}$ ，后缘点没有载荷（库塔-儒可夫斯基后缘条件）</p><h3 id="薄翼型理论"><a href="#薄翼型理论" class="headerlink" title="薄翼型理论"></a>薄翼型理论</h3><h5 id="低速位流的控制方程"><a href="#低速位流的控制方程" class="headerlink" title="低速位流的控制方程"></a>低速位流的控制方程</h5><p>$\Phi$速度位，$\phi _{\infty}$来流速度位，$\vec{n}$翼面外法线单位矢</p><p>速度位：即“速度势”（velocity potential），标量，用于描述无旋流动（即涡度为零的流动）和处理理想流体（无粘性且不可压缩的流体）的流动问题。</p><p>设流场中的速度矢量为 ($\mathbf{v}$)，如果流体的流动是无旋的（即涡度 ($\nabla \times \mathbf{v} = 0$)），那么存在一个标量函数 ($\Phi$)（速度势），使得流场中的速度可以表示为该函数的梯度：($\mathbf{v} = \nabla \Phi$)。</p><p>由于流体是无旋的，可以保证存在这样一个标量函数，且该函数满足拉普拉斯方程 ($\nabla^2 \Phi = 0$)，这就是所谓的速度势方程。</p><h5 id="速度位与速度的关系："><a href="#速度位与速度的关系：" class="headerlink" title="速度位与速度的关系："></a>速度位与速度的关系：</h5><p>$\nabla\Phi = \left(\frac{\partial \Phi}{\partial x}, \frac{\partial \Phi}{\partial y}\right)=(v_x,v_y)$</p><p>单位外法矢分量 $\vec{n}=(n_x,n_y)$</p><p><img src="image-20240815052851019.png" alt></p><p>翼型低速无粘位流</p><p><img src="image-20240815053041554.png" alt></p><p>小扰动线性化近似的解析解法</p><h5 id="扰动速度位的线性方程"><a href="#扰动速度位的线性方程" class="headerlink" title="扰动速度位的线性方程"></a>扰动速度位的线性方程</h5><p>翼型绕流速度位 $\Phi$ 满足拉普拉斯方程，因此它可分解为直均来流速度位 $\phi _{\infty}$ 和翼型存在引起的扰动速度位 $\phi$ ，即</p><p>因有 $\Phi=\phi _{\infty}+\phi\ \Delta \Phi=0\ \Delta\phi _{\infty}=0$（满足拉普拉斯方程）</p><p>所以扰动速度位也满足拉普拉斯方程（翼型的存在引起的扰动速度位）</p><h5 id="翼面边界条件线化近似"><a href="#翼面边界条件线化近似" class="headerlink" title="翼面边界条件线化近似"></a>翼面边界条件线化近似</h5><p>翼面上 $x,y$ 方向的流速分量记为 $v_{xw},v_{yw}$</p><p>问题：绕过一个翼型，来流迎角为$\alpha$，来流速度为$V_\infty$的无粘位流的流动情况</p><p><img src="image-20240815054031414.png" alt></p><p><img src="image-20240815054403514.png" alt></p><p>$\alpha$表示来流迎角，$cos\alpha$ 趋向于0，$sin\alpha$趋向于$\alpha$</p><p>x方向速度 ≈ 来流速度 + 由于翼型的存在引起的扰动的x方向速度</p><p>带入得到</p><p><img src="image-20240815054749889.png" alt></p><p><img src="image-20240815054859061.png" alt></p><p>最终可以得到翼面边界条件的线性化近似表达式：</p><p><img src="image-20240815055012155.png" alt></p><p>边界条件=来流速度（弯度±厚度-来流迎角）</p><h5 id="压强系数的线化近似"><a href="#压强系数的线化近似" class="headerlink" title="压强系数的线化近似"></a>压强系数的线化近似</h5><p>根据伯努利方程，流场中任一点的压强系数为</p><p><img src="image-20240815055412804.png" alt></p><p>$v$表示当地速度，$V_\infty$表示来流速度</p><p>略去二阶小量，只保留一阶小量，则有</p><p><img src="image-20240815055739662.png" alt></p><p>其中 $C_P$是物面的压强系数</p><p>进一步近似，得到</p><p><img src="image-20240815055949854.png" alt></p><p>分别为：来流迎角引起的部分+翼型弯度引起的部分+翼型厚度引起的部分</p><h5 id="小结：扰动速度位的线性叠加"><a href="#小结：扰动速度位的线性叠加" class="headerlink" title="小结：扰动速度位的线性叠加"></a>小结：扰动速度位的线性叠加</h5><p><img src="image-20240815060222795.png" alt></p><p>再将问题分解，即可分为迎角问题，弯板问题和厚度问题</p><p><img src="image-20240815060405921.png" alt></p><p>分为三个分方程，每个方程都对应一种流动</p><p><img src="image-20240815060630754.png" alt></p><p>弯度问题 对应 0攻角情况下中弧线弯板扰流，$y_{f(x)}$就是这个翼型的中弧线</p><p>厚度问题 对应 没有迎角的厚度对称问题</p><p>迎角问题 对应 有迎角的平板扰流</p>]]></content>
      
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 964 (Div.4)题解</title>
      <link href="/2024/08/07/Codeforces-Round-964-Div-4-%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/07/Codeforces-Round-964-Div-4-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1999">题目链接</a></p><p><img src="1.png" alt></p><p>差一道题就ak了，打代码的速度还是慢了点</p><span id="more"></span><p>F时间不够了，于是随便糊了个时间复杂度不对的算法，结果算法对了，少了个预处理然后就TLE了，赛时没有发现</p><p><a href="https://codeforces.com/contest/1999/problem/A">A.A+B Again?</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t , n;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; (n/10)+(n%10) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1999/problem/B">B.Card Game</a></p><p>直接穷举所有可能性即可</p><p>思路不是很难，就看如何实现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int t , a[5];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        for(int i = 1;i &lt;= 4;i ++) cin &gt;&gt; a[i];</span><br><span class="line">        int l , r , ans = 0;</span><br><span class="line">        for(int i = 1;i &lt;= 2;i ++)&#123;</span><br><span class="line">            int ii = (i==1)?2:1;</span><br><span class="line">            for(int j = 3;j &lt;= 4;j ++)&#123;</span><br><span class="line">                int jj = (j==3)?4:3;</span><br><span class="line">                l = 0 , r = 0;</span><br><span class="line">                if( a[i] &gt; a[j] ) l ++;</span><br><span class="line">                if( a[i] &lt; a[j] ) r ++;</span><br><span class="line"></span><br><span class="line">                if( a[ii] &gt; a[jj] ) l ++;</span><br><span class="line">                if( a[ii] &lt; a[jj] ) r ++;</span><br><span class="line"></span><br><span class="line">                if( l &gt; r ) ans ++;</span><br><span class="line">                //cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; a[ii] &lt;&lt; &quot; &quot; &lt;&lt; a[j] &lt;&lt; &quot; &quot; &lt;&lt; a[jj] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1999/problem/C">C.Showering</a></p><p>典型贪心（弱化版）</p><p>数据范围可以 $O(nlogn)$，无脑sort就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5;</span><br><span class="line">int t , n , s , m;</span><br><span class="line">struct TIME&#123;</span><br><span class="line">    int l , r;</span><br><span class="line">&#125;a[N+10];</span><br><span class="line"></span><br><span class="line">bool cmp( TIME x , TIME y )&#123;</span><br><span class="line">    return x.l &lt; y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; s &gt;&gt; m;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        sort( a + 1 , a + n + 1 , cmp );</span><br><span class="line">        bool flag = 0;</span><br><span class="line">        a[0].r = 0 , a[n+1].l = m;</span><br><span class="line">        for(int i = 1;i &lt;= n+1;i ++)&#123;</span><br><span class="line">            if( a[i].l - a[i-1].r &gt;= s )&#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if( flag ) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1999/problem/D">D.Slavic’s Exam</a></p><p>这里的匹配不需要连续，所以只要有<code>?</code>就直接替换就可以了，多余的<code>?</code>需要替换成任意小写字母</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int T;</span><br><span class="line">string s , t;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while( T -- )&#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        int t_top = 0;</span><br><span class="line">        //cout &lt;&lt; s.length() &lt;&lt; &quot; &quot; &lt;&lt; t.length() &lt;&lt; endl;</span><br><span class="line">        for(int i = 0;i &lt; s.length();i ++)&#123;</span><br><span class="line">            if( t_top == t.length() )&#123;</span><br><span class="line">                if( s[i] == &#x27;?&#x27; ) s[i] = &#x27;a&#x27;;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if( s[i] == &#x27;?&#x27; || s[i] == t[t_top] )&#123;</span><br><span class="line">                s[i] = t[t_top];</span><br><span class="line">                t_top ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if( t_top != t.length() ) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1999/problem/E">E.Triple Operations</a></p><p>这道题开始上难度了</p><p>先说结论，$ans=log_3(min(a_i))+\sum log_3(a_i)$</p><p>容易观察到，我们只需要将其中一个数变为0，后续将数字除以3（减小）的时候不会造成其他数字乘以3（增大），我们只需要将最小的数变为0就可以，但是同时也会有另外一个数字增大，这时造成的代价即为$log_3(min(a_i))$</p><p>现在只需要计算 $log_3(min(a_i))+\sum log_3(a_i)$ ，即$log_3l+\sum_l^r log_3(a_i)$ </p><p>我们观察到从 $l$ 到 $r$ 是单调的，所以利用指数即可在 $O(logn)$ 求解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int T;</span><br><span class="line">int l , r;</span><br><span class="line"></span><br><span class="line">int log3( int x )&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    while( x )&#123;</span><br><span class="line">        x /= 3;</span><br><span class="line">        ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int poww( int x )&#123;</span><br><span class="line">    int ans = 1;</span><br><span class="line">    while( x -- )&#123;</span><br><span class="line">        ans *= 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;/*</span><br><span class="line">    for(int i = 1;i &lt;= 100;i ++)&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; | &quot; &lt;&lt; log3(i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;*/</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while( T -- )&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        /*</span><br><span class="line">        int ans = log3(l);</span><br><span class="line">        for(int i = l;i &lt;= r;i ++)&#123;</span><br><span class="line">            ans += log3(i);</span><br><span class="line">        &#125;*/</span><br><span class="line">        int ans = log3(l)+log3(r) , log_i , jumper;</span><br><span class="line">        for(int i = l;i &lt;= r;i ++)&#123;</span><br><span class="line">            log_i = log3(i);</span><br><span class="line">            jumper = poww( log_i );</span><br><span class="line">            //cout &lt;&lt; &quot;jumper: &quot; &lt;&lt; jumper  &lt;&lt; &quot; |ans: &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            if( jumper &lt; r ) ans += (jumper-i)*log_i , i = jumper-1;</span><br><span class="line">            else ans += (r-i)*log_i , i = r;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1999/problem/F">F.Expected Median</a></p><p>假设 $1$ 有 $x$ 个，$0$ 有 $y$ 个，那么 $ans=\sum (C_x^i+C_y^{k-i}) $，即从 $x$ 中选 $i$ 个，从 $y$ 中选 $k-i$ 个的所有可能，其中 $i$ 需要满足 从 $x$ 中取出的元素多余从 $y$ 中取出（即 $1$ 比 $0$ 多，这样的中位数才能是 $1$ ）</p><p>计算组合数需要用阶乘，记得预处理（悲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5 , p = 1e9+7;</span><br><span class="line">int T , n , k;</span><br><span class="line">int a[N+10];</span><br><span class="line">int num_0 , num_1;</span><br><span class="line">int jc[N+10];</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    jc[0] = 1;</span><br><span class="line">    for(int i = 1;i &lt;= N;i ++)&#123;</span><br><span class="line">        jc[i] = jc[i-1]*i;</span><br><span class="line">        jc[i] %= p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int qpow(long long a, int b) &#123;</span><br><span class="line">  int ans = 1;</span><br><span class="line">  a = (a % p + p) % p;</span><br><span class="line">  for (; b; b &gt;&gt;= 1) &#123;</span><br><span class="line">    if (b &amp; 1) ans = (a * ans) % p;</span><br><span class="line">    a = (a * a) % p;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int inv( int x )&#123;</span><br><span class="line">    return qpow( x , p-2 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int C( int nn , int mm )&#123;</span><br><span class="line">    int ans = 1;</span><br><span class="line">    ans *= jc[nn];</span><br><span class="line">    ans %= p;</span><br><span class="line">    ans *= inv(jc[mm]);</span><br><span class="line">    ans %= p;</span><br><span class="line">    ans *= inv(jc[nn-mm]);</span><br><span class="line">    ans %= p;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while( T -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        num_0 = num_1 = 0;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            if( a[i] ) num_1 ++ ; else num_0 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = min(num_1,k);i&gt;k/2 and (k-i)&lt;=num_0;i --)&#123;</span><br><span class="line">            //cout &lt;&lt; num_0 &lt;&lt; &quot; &quot; &lt;&lt;  k-i &lt;&lt; &quot; &quot; &lt;&lt; num_1 &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            ans += C( num_0 , k-i ) * C( num_1 , i );</span><br><span class="line">            ans %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1999/problem/G1">G1.Ruler (easy version)</a></p><p>简单的二分法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5 , p = 1e9+7;</span><br><span class="line">int T , t;</span><br><span class="line"></span><br><span class="line">int ef( int l , int r )&#123;</span><br><span class="line">    if( l == r ) return l;</span><br><span class="line">    int mid = (l+r)&gt;&gt;1;</span><br><span class="line">    cout &lt;&lt; &quot;? &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    //int redder = mid + ( mid&gt;=100?1:0);</span><br><span class="line">    //t = redder*redder;</span><br><span class="line">    if( t == (mid+1)*(mid+1) ) return ef( l , mid );</span><br><span class="line">    else return ef( mid+1 , r );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while( T -- )&#123;</span><br><span class="line">        int ans = ef( 2 , 999 );</span><br><span class="line">        cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; flush;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1999/problem/G2">G2.Ruler (hard version)</a></p><p>三分法，写法有很多，七次询问可以确定一个数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5 , p = 1e9+7;</span><br><span class="line">int T , t;</span><br><span class="line"></span><br><span class="line">int ef( int l , int r )&#123;</span><br><span class="line">    if( l == r ) return l;</span><br><span class="line">    int mid_l = l+(r-l)/3 , mid_r = l+(r-l)/3*2;</span><br><span class="line">    cout &lt;&lt; &quot;? &quot; &lt;&lt; mid_l &lt;&lt; &quot; &quot; &lt;&lt; mid_r &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;/*</span><br><span class="line">    int lll = mid_l + ( mid_l&gt;=700?1:0);</span><br><span class="line">    int rrr = mid_r + ( mid_r&gt;=700?1:0);</span><br><span class="line">    t = lll*rrr;*/</span><br><span class="line">    if( t == (mid_l+1)*(mid_r+1) ) return ef( l , mid_l );</span><br><span class="line">    else if( t == (mid_l)*(mid_r+1) ) return ef( mid_l+1 , mid_r );</span><br><span class="line">    else return ef( mid_r+1 , r );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while( T -- )&#123;</span><br><span class="line">        int ans = ef( 2 , 999 );</span><br><span class="line">        cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; flush;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位板+onenote铅笔橡皮快速切换的实现方式</title>
      <link href="/2024/08/06/%E6%95%B0%E4%BD%8D%E6%9D%BF-onenote%E9%93%85%E7%AC%94%E6%A9%A1%E7%9A%AE%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/08/06/%E6%95%B0%E4%BD%8D%E6%9D%BF-onenote%E9%93%85%E7%AC%94%E6%A9%A1%E7%9A%AE%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>配置：高漫1060pro + windows11 + onenote(office最新版)</p><p>众所周知onenote最新版取消了<code>笔收藏夹</code>这一选项，导致选择画笔很不方便，一般情况下无法使画笔和橡皮快速切换，在一番探索下得到了以下方案</p><span id="more"></span><p><img src="聊天记录.jpg" alt></p><p>笔者之前使用c++做过控制键鼠点击等程序，但是黑窗口弹出需要一定时间很不方便，在和朋友交流下得到了知道了有一个叫<code>AutoHotkey</code>的编程语言，专门用来进行这样的操作</p><p><img src="插入图片1.png" alt></p><p><img src="插入图片2.png" alt></p><p>由上图可以知道切换画笔的操作是<code>Alt+D+G+键盘右键*多次+键盘左键（切回黑色画笔）+Enter</code></p><p>这样就可以编写<code>ahk</code>脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Send &#123;Alt Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;Alt Up&#125;</span><br><span class="line">Send &#123;D Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;D Up&#125;</span><br><span class="line">Send &#123;G Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;G Up&#125;</span><br><span class="line">Send &#123;Right Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;Right Up&#125;</span><br><span class="line">Send &#123;Right Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;Right Up&#125;</span><br><span class="line">Send &#123;Right Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;Right Up&#125;</span><br><span class="line">Send &#123;Left Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;Left Up&#125;</span><br><span class="line">Send &#123;Enter Down&#125;</span><br><span class="line">Sleep 50</span><br><span class="line">Send &#123;Enter Up&#125;</span><br><span class="line"></span><br><span class="line">;Click, 440, 180 ;也可以直接让鼠标点击固定坐标</span><br><span class="line"></span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>具体延迟和操作可以自行更改</p><p>然后放入路径（前提是数位板支持）就可以了</p><p><img src="插入图片3.png" alt></p><p>UPD.后来我发现切换功能里的这个可以一键切换···</p><p><img src="插入图片4.png" alt></p><p>不过无论如何是可以用了</p><p>不支持运行程序和切换功能的数位板，估计不能一键切换了</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRYTPO 24.8第一周刷题记录</title>
      <link href="/2024/08/05/CRYTPO-24-8%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/08/05/CRYTPO-24-8%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="SWPUCTF-2021-新生赛-crypto3"><a href="#SWPUCTF-2021-新生赛-crypto3" class="headerlink" title="[SWPUCTF 2021 新生赛]crypto3"></a>[SWPUCTF 2021 新生赛]crypto3</h3><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag  = &#x27;******************&#x27;</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">m1 = bytes_to_long(bytes(flag.encode()))</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">flag1 = pow(m1,p,n)</span><br><span class="line">flag2 = pow(m1,q,n)</span><br><span class="line">print(&#x27;flag1= &#x27;+str(flag1))</span><br><span class="line">print(&#x27;flag2= &#x27;+str(flag2))</span><br><span class="line">print(&#x27;n= &#x27;+str(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#flag1= 17893542812755845772427795161304049467610774531005620109503081344099161906017295486868699578946474114607624347167976713200068059018517606363517478396368430072890681401898145302336139240273132723451063402106360810413024642916851746118524166947301681245568333254648265529408446609050354235727237078987509705857</span><br><span class="line">#flag2= 95580409405085606847879727622943874726633827220524165744517624606566789614499137069562997931972825651309707390763700301965277040876322904891716953565845966918293178547100704981251056401939781365264616997055296773593435626490578886752446381493929807909671245959154990639046333135728431707979143972145708806954</span><br><span class="line">#n= 140457323583824160338989317689698102738341061967768153879646505422358544720607476140977064053629005764551339082120337223672330979298373653766782620973454095507484118565884885623328751648660379894592063436924903894986994746394508539721459355200184089470977772075720319482839923856979166319700474349042326898971</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.osgeo.cn/sagemath/tutorial/index.html">https://www.osgeo.cn/sagemath/tutorial/index.html</a></p><p>得到</p><script type="math/tex; mode=display">\left\{\begin{aligned}m^p \equiv h_1\ mod\ n\\m^q \equiv h_2\ mod\ n\\\end{aligned}\right.</script><p>由费马小定理，因为 $p$ $q$ 为质数，故</p><script type="math/tex; mode=display">\left\{\begin{aligned}m^p \equiv m\ mod\ p\\m^q \equiv m\ mod\ q\\\end{aligned}\right.</script><p>则有</p><script type="math/tex; mode=display">\left\{\begin{aligned}h_1 \equiv m+k_1*p\ mod\ n\\h_2 \equiv m+k_2*q\ mod\ n\\\end{aligned}\right.</script><p>即</p><script type="math/tex; mode=display">\left\{\begin{aligned}h_1 \equiv m+k_1*p\ + k_3*p*q\\h_2 \equiv m+k_2*q\ + k_4*p*q\\\end{aligned}\right.</script><p>可以得到，在 $Zmod(n)$ 下，有</p><script type="math/tex; mode=display">\left\{\begin{aligned}h_1+h_2 & = 2*m+k_1*p+k_2*q\ \\h_1*h_2 & = m^2+(k_1*p+k_2*q)*m\\\end{aligned}\right.</script><p>可以消去 $k_1$ $k_2$ 得到式子</p><p>$m^2 - (h1+h2)<em>m + h1</em>h2=0$</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#sage</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">h1= </span><br><span class="line">h2= </span><br><span class="line">n= </span><br><span class="line"></span><br><span class="line">PR.&lt;m&gt; = PolynomialRing( Zmod(n) )</span><br><span class="line">f = m^2 - (h1+h2)*m + h1*h2</span><br><span class="line">a = int(str(f.small_roots( X=2^400 )[0]))</span><br><span class="line"></span><br><span class="line">print( flag )</span><br><span class="line">print( long_to_bytes(flag) )</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1920535408007397834236393374892057067669865609963495845501</span><br><span class="line">b&#x27;NSSCTF&#123;why_gongmo_again&#125;&#x27;</span><br></pre></td></tr></table></figure><p>flag:<code>NSSCTF&#123;why_gongmo_again&#125;</code></p><h3 id="BUUCTF·V-amp-N2020-公开赛-easy-RSA"><a href="#BUUCTF·V-amp-N2020-公开赛-easy-RSA" class="headerlink" title="[BUUCTF·V&amp;N2020 公开赛]easy_RSA"></a>[BUUCTF·V&amp;N2020 公开赛]easy_RSA</h3><p>tag.暴力分解 小技巧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from random import randint</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">def getprime(bits):</span><br><span class="line">    while 1:</span><br><span class="line">        n = 1</span><br><span class="line">        while n.bit_length() &lt; bits:</span><br><span class="line">            n *= next_prime(randint(1,1000))</span><br><span class="line">        if isPrime(n - 1):</span><br><span class="line">            return n - 1</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(b&#x27;flag&#123;************************************&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">p = getprime(505)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">r = getPrime(512)</span><br><span class="line">assert m &lt; q</span><br><span class="line"></span><br><span class="line">n = p * q * r</span><br><span class="line">e = 0x10001</span><br><span class="line">d = invert(q ** 2, p ** 2)</span><br><span class="line">c = pow(m, 2, r)</span><br><span class="line">cipher = pow(c, e, n)</span><br><span class="line"></span><br><span class="line">print(n)</span><br><span class="line">print(d)</span><br><span class="line">print(cipher)</span><br></pre></td></tr></table></figure><hr><p>使用factordb分解得到$p\ q\ r$的数值</p><p><code>c = pow(m, 2, r)</code>已知 $m\ r$ 求 $c$</p><p>求 $x^n\equiv a\ mod\ p$ 的解的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sympy.ntheory.residue_ntheory import nthroot_mod</span><br><span class="line">x=nthroot_mod(a,n,p)</span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">import gmpy2</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">d = </span><br><span class="line">m = </span><br><span class="line">e = 0x10001</span><br><span class="line">p = 102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393</span><br><span class="line">q = 7534810196420932552168708937019691994681052660068275906973480617604535381306041583841106383688654426129050931519275383386503174076258645141589911492908993</span><br><span class="line">r = 10269028767754306217563721664976261924407940883784193817786660413744866184645984238866463711873380072803747092361041245422348883639933712733051005791543841</span><br><span class="line"></span><br><span class="line">d1 = gmpy2.invert( e , (p-1)*(q-1)*(r-1) )</span><br><span class="line">c1 = pow( m , d1 , n )</span><br><span class="line"></span><br><span class="line">from sympy.ntheory.residue_ntheory import nthroot_mod</span><br><span class="line">c = nthroot_mod( c1 , 2 , r )</span><br><span class="line">print( c )</span><br><span class="line">print( long_to_bytes( c ) )</span><br></pre></td></tr></table></figure><p>add.在其他师傅的wp上摘到的Tonelli–Shanks算法 求解二次平方根</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">def legendre(a, p):</span><br><span class="line">    return pow(a, (p - 1) // 2, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def tonelli(n, p):</span><br><span class="line">    assert legendre(n, p) == 1</span><br><span class="line">    q = p - 1</span><br><span class="line">    s = 0</span><br><span class="line">    while q % 2 == 0:</span><br><span class="line">        q //= 2</span><br><span class="line">        s += 1</span><br><span class="line">    if s == 1:</span><br><span class="line">        return pow(n, (p + 1) // 4, p)</span><br><span class="line">    for z in range(2, 10000):</span><br><span class="line">#    for z in range(2, p):</span><br><span class="line">        if p - 1 == legendre(z, p):</span><br><span class="line">            break</span><br><span class="line">    c = pow(z, q, p)</span><br><span class="line">    r = pow(n, (q + 1) // 2, p)</span><br><span class="line">    t = pow(n, q, p)</span><br><span class="line">    m = s</span><br><span class="line">    t2 = 0</span><br><span class="line">    while (t - 1) % p != 0:</span><br><span class="line">        t2 = (t * t) % p</span><br><span class="line">        for i in range(1, m):</span><br><span class="line">            if (t2 - 1) % p == 0:</span><br><span class="line">                break</span><br><span class="line">            t2 = (t2 * t2) % p</span><br><span class="line">        b = pow(c, 1 &lt;&lt; (m - i - 1), p)</span><br><span class="line">        r = (r * b) % p</span><br><span class="line">        c = (b * b) % p</span><br><span class="line">        t = (t * c) % p</span><br><span class="line">        m = i</span><br><span class="line">    return r</span><br><span class="line">n=7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409</span><br><span class="line">d=gmpy2.mpz(7515987842794170949444517202158067021118454558360145030399453487603693522695746732547224100845570119375977629070702308991221388721952258969752305904378724402002545947182529859604584400048983091861594720299791743887521228492714135449584003054386457751933095902983841246048952155097668245322664318518861440)</span><br><span class="line">cipher=1618155233923718966393124032999431934705026408748451436388483012584983753140040289666712916510617403356206112730613485227084128314043665913357106301736817062412927135716281544348612150328867226515184078966397180771624148797528036548243343316501503364783092550480439749404301122277056732857399413805293899249313045684662146333448668209567898831091274930053147799756622844119463942087160062353526056879436998061803187343431081504474584816590199768034450005448200</span><br><span class="line"></span><br><span class="line">#python2 -m primefac -vs -m=p+1  7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409</span><br><span class="line">p=gmpy2.mpz(102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393)</span><br><span class="line"></span><br><span class="line">q2=gmpy2.invert(d,p**2)</span><br><span class="line">for i in range(1000000):</span><br><span class="line">q=gmpy2.iroot(q2+i*p**2,2)</span><br><span class="line">if(q[1]==1):</span><br><span class="line">print q[0],i</span><br><span class="line">break</span><br><span class="line">q=q[0]</span><br><span class="line">r=n//p//q</span><br><span class="line"></span><br><span class="line">e=0x10001</span><br><span class="line">phi=(p-1)*(q-1)*(r-1)</span><br><span class="line">D=gmpy2.invert(e,phi)</span><br><span class="line">c=pow(cipher,D,n)</span><br><span class="line">print c</span><br><span class="line"></span><br><span class="line">m=tonelli(c,r)</span><br><span class="line">print m</span><br><span class="line">print long_to_bytes(m)</span><br><span class="line">#flag&#123;fd462593-25e4-4631-a96a-0cd5c72b2d1b&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="De1CTF2019-babyrsa"><a href="#De1CTF2019-babyrsa" class="headerlink" title="[De1CTF2019]babyrsa"></a>[De1CTF2019]babyrsa</h3><p>tag: 共膜攻击 | 低密度指数攻击 | 暴力分解 | e,phi不互质pro</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">from data import e1,e2,p,q1p,q1q,hint,flag</span><br><span class="line"></span><br><span class="line">n =  [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L]</span><br><span class="line">c =  [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L]</span><br><span class="line">f=lambda m,e,n,c:pow(m,e,n)==c</span><br><span class="line">assert(sum(map(f,[p]*4,[4]*4,n,c))==4)</span><br><span class="line"></span><br><span class="line">ee1 = 42</span><br><span class="line">ee2 = 3</span><br><span class="line">ce1 =  45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384</span><br><span class="line">ce2 =  13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158</span><br><span class="line">tmp =  864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387</span><br><span class="line">n  =  15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039</span><br><span class="line">assert(pow(e1,ee1,n)==ce1)</span><br><span class="line">assert(pow(e2+tmp,ee2,n)==ce2)</span><br><span class="line"></span><br><span class="line">e = 46531</span><br><span class="line">n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603</span><br><span class="line">c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469</span><br><span class="line">hint=int(binascii.hexlify(hint),16)</span><br><span class="line">assert(q1p*q1q==n)</span><br><span class="line">assert(q1p&lt;q1q)</span><br><span class="line">assert(c==pow(hint,e,n))</span><br><span class="line"></span><br><span class="line">flag=int(binascii.hexlify(flag),16)</span><br><span class="line">q1=q1p</span><br><span class="line">q2 =  114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513</span><br><span class="line">c1 =  262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124</span><br><span class="line">c2 =  7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596</span><br><span class="line">assert(c1==pow(flag,e1,p*q1))</span><br><span class="line">assert(c2==pow(flag,e2,p*q2))</span><br></pre></td></tr></table></figure><hr><p>对于第一部分：使用共膜攻击即可</p><p>前置知识：</p><ol><li>lambda:相当于一个函数，表达式为 <code>函数名=lambda 输入值:函数式</code>，常搭配<code>map</code>使用</li><li>map:表达式为<code>map(函数名,输入值)</code>，返回函数名对应的函数式的结果</li></ol><p>翻译一下，原式相当于 $p^4\equiv\ c_i\ mod\ n_i$</p><p>通过四组 $c_i\ n_i$ 利用中国剩余定理即可求出 $p^4$ ，然后开根即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def CRT( r , p ):</span><br><span class="line">    M = 1</span><br><span class="line">    for i in p:</span><br><span class="line">        M *= i</span><br><span class="line">    m = []</span><br><span class="line">    for i in p:</span><br><span class="line">        m.append( M // i )</span><br><span class="line">    ans = 0</span><br><span class="line">    for i in range( len(p) ):</span><br><span class="line">        ans += r[i] * m[i] * invert( m[i] , p[i] )</span><br><span class="line">        ans %= M</span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line">#part1 共膜攻击</span><br><span class="line">def part1():</span><br><span class="line">    n =  </span><br><span class="line">    c =  </span><br><span class="line">    p4 = CRT( c , n )</span><br><span class="line">    p = iroot( p4 , 4 )[0]</span><br><span class="line">    #print( p )</span><br><span class="line">    return p</span><br></pre></td></tr></table></figure><p>对于第二部分：使用低密度指数攻击</p><p>$e1\ e2$很小，所以可以直接爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">k = 0</span><br><span class="line">while True:</span><br><span class="line">    if gmpy2.iroot( ce1 + n*k , ee1 )[1] == True:</span><br><span class="line">        e1 = gmpy2.iroot( ce1 + n*k , ee1 )[0]</span><br><span class="line">        break</span><br><span class="line">    k += 1</span><br><span class="line">print( e1 )</span><br><span class="line">k = 0</span><br><span class="line">while True:</span><br><span class="line">    if gmpy2.iroot( ce2 + n*k , ee2 )[1] == True:</span><br><span class="line">        e2 = gmpy2.iroot( ce2 + n*k , ee2 )[0] - tmp</span><br><span class="line">        break</span><br><span class="line">    k += 1</span><br><span class="line">print( e2 )</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e1 = 15218928658178</span><br><span class="line">e2 = 381791429275130</span><br></pre></td></tr></table></figure><p>也可以使用先估计 $k$ 范围的做法</p><p>已知$(e2+tmp)^{ee2}=ce2+k*n$</p><p>发现ee2=3，考虑低密度指数攻击</p><p>计算<code>print( tmp**3 / n )</code></p><p>得到<code>40545.874109734694</code></p><p>因而可以穷举k，可以得到$e2+tmp$</p><p>对于前一半，运行<code>print( len(str(ce1)) , len(str(n)) )</code>；发现相差五十多位，是个小概率事件；所以认为与n无关，可以直接开根</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#part2 低密度指数攻击</span><br><span class="line">def part2():</span><br><span class="line">    ee1 = 42</span><br><span class="line">    ee2 = 3</span><br><span class="line">    ce1 = </span><br><span class="line">    ce2 =  </span><br><span class="line">    tmp =  </span><br><span class="line">    n  =  </span><br><span class="line">    print( tmp**3 / n ) </span><br><span class="line">    for k in range( 40000 , 41000 ):</span><br><span class="line">        if iroot( ce2 + k*n , ee2 )[1]:</span><br><span class="line">            e2 = iroot( ce2 + k*n , ee2 )[0] - tmp </span><br><span class="line">            break</span><br><span class="line">    #print( e2 )</span><br><span class="line">    </span><br><span class="line">    #print( len(str(ce1)) , len(str(n)) )</span><br><span class="line">    e1 = iroot( ce1 , ee1 )[0]</span><br><span class="line">    #print( e1 )</span><br><span class="line">    return e1 , e2</span><br></pre></td></tr></table></figure><p>对于第三部分：直接分解即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def part3():</span><br><span class="line">    e = </span><br><span class="line">    n = </span><br><span class="line">    c = </span><br><span class="line">    p = </span><br><span class="line">    q = </span><br><span class="line">    phi = (p-1)*(q-1)</span><br><span class="line">    d = invert( e , phi )</span><br><span class="line">    hint = pow( c , d , n )</span><br><span class="line">    print( long_to_bytes( hint ) )</span><br><span class="line">    return min( p , q )</span><br></pre></td></tr></table></figure><p>得到hint:<code>b&#39;orz...you.found.me.but.sorry.no.hint...keep.on.and.enjoy.it!&#39;</code>（和flag并无关系）</p><p>对于第四部分：</p><p>已知<code>p , q1 , q2 , e1 , e2</code>，但是 e1 , e2 和 phi1 , phi2 不互质，无法正常求私钥 d</p><p>一般来说遇到这种情况都是让 $e$ 除去其与欧拉函数的最大公约数，让这两个数重新互质，然后求 $m^{gcd(e,\phi)}$的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = gcd( e1 , (p-1) * (q1-1) )</span><br><span class="line">b = gcd( e2 , (p-1) * (q2-1) )</span><br><span class="line">print( a , b ) </span><br></pre></td></tr></table></figure><p>得到 $a=14,b=14$，发现 $m^{14}$ 的幂次比较高，不好处理</p><p> $(m^{2})^{7}=m_1\ mod\ q_1\ (m^{2})^{7}=m_2\ mod\ q_2$</p><p>$(m^2)^7\%(q1<em>q2)$组成一个新的rsa解密，$e=7\ ,\ n=q1</em>q2\ ,\ m=m^2\ ,\ c=m^{14}$</p><p>reference:</p><p><a href="https://blog.csdn.net/a5555678744/article/details/117308377">https://blog.csdn.net/a5555678744/article/details/117308377</a></p><p><a href="https://blog.csdn.net/qq_57235775/article/details/131167215">https://blog.csdn.net/qq_57235775/article/details/131167215</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n =  [ q1, q2 ]</span><br><span class="line">a = gmpy2.gcd(e1,(p-1)*(q1-1))</span><br><span class="line">b = gmpy2.gcd(e2,(p-1)*(q2-1))</span><br><span class="line">c = [ gmpy2.powmod(c1,gmpy2.invert(e1//a,(p-1)*(q1-1)),q1)</span><br><span class="line">    , gmpy2.powmod(c2,gmpy2.invert(e2//b,(p-1)*(q2-1)),q2)]</span><br><span class="line">M = n[0] * n[1]</span><br><span class="line">m = [0]*2</span><br><span class="line">inv = [0]*2</span><br><span class="line">x = 0</span><br><span class="line">for i in range(2):</span><br><span class="line">    m[i]=M//n[i]</span><br><span class="line">    inv[i]=gmpy2.invert(m[i],n[i])</span><br><span class="line">    x+=(c[i]*inv[i]*m[i])</span><br><span class="line">x = x % M</span><br><span class="line">e=7</span><br><span class="line">d=gmpy2.invert(e,(q1-1)*(q2-1))</span><br><span class="line">flag=gmpy2.iroot(gmpy2.powmod(x,d,q1*q2),2)[0]</span><br><span class="line">print(long_to_bytes(flag))</span><br></pre></td></tr></table></figure><p>flag:<code>de1ctf&#123;9b10a98b-71bb-4bdf-a6ff-f319943de21f&#125;</code></p><hr><h3 id="DASCTF-Sept-X-浙江工业大学秋季挑战赛-签到"><a href="#DASCTF-Sept-X-浙江工业大学秋季挑战赛-签到" class="headerlink" title="[DASCTF Sept X 浙江工业大学秋季挑战赛]签到"></a>[DASCTF Sept X 浙江工业大学秋季挑战赛]签到</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line">flag=b&#x27;flag&#123;******************&#125;&#x27;</span><br><span class="line">n = 2 ** 256</span><br><span class="line">flaglong=bytes_to_long(flag)</span><br><span class="line">m = random.randint(2, n-1) | 1</span><br><span class="line">c = pow(m, flaglong, n)</span><br><span class="line">print(&#x27;m = &#x27; + str(m))</span><br><span class="line">print(&#x27;c = &#x27; + str(c))</span><br><span class="line"></span><br><span class="line"># m = 73964803637492582853353338913523546944627084372081477892312545091623069227301</span><br><span class="line"># c = 21572244511100216966799370397791432119463715616349800194229377843045443048821</span><br></pre></td></tr></table></figure><hr><p>discrete_log()使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sympy.ntheory import discrete_log</span><br><span class="line">&gt;&gt;&gt; discrete_log(41, 15, 7)</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>即 $7^3\equiv 15(mod\ 41)$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sympy</span><br><span class="line">import binascii</span><br><span class="line">m = 73964803637492582853353338913523546944627084372081477892312545091623069227301</span><br><span class="line">c = 21572244511100216966799370397791432119463715616349800194229377843045443048821</span><br><span class="line">n = 2 ** 256</span><br><span class="line">flag=sympy.discrete_log(n,c,m)</span><br><span class="line">print(binascii.unhexlify(hex(flag)[2:]))</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;DASCTF_zjut&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 963 (Div. 2)题解</title>
      <link href="/2024/08/05/Codeforces-Round-963-Div-2-%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/05/Codeforces-Round-963-Div-2-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1993">题目链接</a></p><p>本场比赛应该算是今年我打的第一场算法竞赛，也是NOIP2021结束之后难得发挥出来的比赛。ABC都是比较简单的题，D是<code>二分+dp</code>，比较难想</p><p>E最终还是不会，疑似是一个高级dp</p><span id="more"></span><p><a href="https://codeforces.com/contest/1993/problem/A">A.Question Marks</a></p><p>观察样例就能打出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    int t;cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        string s;int n;cin &gt;&gt; n;cin &gt;&gt; s;</span><br><span class="line">        int a , b , c , d , e;a = b = c = d = e = 0;</span><br><span class="line">        for(int i = 0;i &lt; s.length();i ++)&#123;</span><br><span class="line">            if( s[i] == &#x27;A&#x27; ) a ++;</span><br><span class="line">            if( s[i] == &#x27;B&#x27; ) b ++;</span><br><span class="line">            if( s[i] == &#x27;C&#x27; ) c ++;</span><br><span class="line">            if( s[i] == &#x27;D&#x27; ) d ++;</span><br><span class="line">            if( s[i] == &#x27;?&#x27; ) e ++;</span><br><span class="line">        &#125;</span><br><span class="line">        a = max( a-n , 0 );</span><br><span class="line">        b = max( b-n , 0 );</span><br><span class="line">        c = max( c-n , 0 );</span><br><span class="line">        d = max( d-n , 0 );</span><br><span class="line">        //cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; n*4-a-b-c-d-e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1993/problem/B">B.Parity and Sum</a></p><p>策略是取出最大的奇数，和所有的偶数从小到大进行比较，如果比当前偶数大，那么将最大的奇数+=当前偶数，否则ans需要+1（仅加一次，此时表示当前最大的奇数不如这个偶数大，只需要进行一次最大奇数加上最大偶数的操作（即ans+=1）即可获得可以使任意偶数变为奇数的大数，如果最大的奇数从小到大累加偶数都能比下一个偶数更大则不需要进行这一步操作）</p><p>全奇全偶需要特判</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int t , n , a[200010];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int lag_d = 0;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            if( a[i] % 2 == 0 ) ans ++;</span><br><span class="line">            else lag_d = max( a[i] , lag_d );</span><br><span class="line">        &#125;</span><br><span class="line">        sort( a + 1 , a + n + 1 );</span><br><span class="line">        if( ans == n ) ans = 0;</span><br><span class="line">        if( ans )&#123;</span><br><span class="line">            for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">                if( a[i] % 2 == 0 )&#123;</span><br><span class="line">                    if( a[i] &gt; lag_d )&#123;</span><br><span class="line">                        ans ++;</span><br><span class="line">                        //cout &lt;&lt; &quot;error: &quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; lag_d &lt;&lt; endl;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        lag_d += a[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://codeforces.com/contest/1993/problem/C">C.Light Switches</a></p><p>首先可以确定，最终答案在[最大值,最大值+k]区间，如果这个区间没有答案，那么输出-1</p><p>k过大，直接扫肯定会超时；所以根据每个$a_i$计算它相应的区间（宽度为k，但是左右区间不同），然后将$l$取$max$，将$r$取$min$，如果$l&lt;r$那么答案就是$l$，否则没有答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int t , n , k , a[200010];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        int maxn = 0;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            maxn = max( maxn , a[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        int l , r;l = maxn , r = maxn + k;</span><br><span class="line">        for(int i = 1;i &lt;= n;i ++)&#123;</span><br><span class="line">            int rat = (maxn - a[i]) / k;</span><br><span class="line">            if( rat % 2 ) rat ++;</span><br><span class="line">            l = max( a[i] + rat * k , l );</span><br><span class="line">            r = min( a[i] + rat * k + k , r );</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; &quot;demo: &quot;&lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        if( l &gt;= r ) cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以下题目结为赛后补题：</p><p><a href="https://codeforces.com/contest/1993/problem/D">D.Med-imize</a></p><p>利用二分中位数，我们可以用 $log(max(a_i))$ 的代价使中位数由未知变为已知</p><p>观察得到一个结论——最终序列的 $id$ 总是在 $mod\ k$ 下能填满 $[0,n\%k]$，以此可以选择出最优化的一组解（正好填满 $[0,n\%k]$ ），即尽量多选大于中位数的选项，如果总共选到大于中位数的数字多余小于的，那么可以判断这组中位数是可以用的</p><p>最终输出最大的中位数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 5e5;</span><br><span class="line"></span><br><span class="line">int t , n , k , a[N+10];</span><br><span class="line">int dp[N+10] , b[N+10];</span><br><span class="line"></span><br><span class="line">bool checker( int mid )&#123;</span><br><span class="line">    for(int i = 0;i &lt; n;i ++)&#123;</span><br><span class="line">        if( a[i] &gt;= mid )&#123;</span><br><span class="line">            b[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            b[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0] = b[0];</span><br><span class="line">    for(int i = 1;i &lt; n;i ++)&#123;</span><br><span class="line">        if( i % k == 0 )&#123;#这一组的开头，如果前面的或者当前位置下有1就可以是1</span><br><span class="line">            dp[i] = max( dp[i-k] , b[i] );</span><br><span class="line">        &#125;else&#123;#直接选当前的，i不是第一个循环的话，则可以继承上一个循环的（反正是选最大值）</span><br><span class="line">            dp[i] = dp[i-1] + b[i];</span><br><span class="line">            if( i &gt; k )&#123;</span><br><span class="line">                dp[i] = max( dp[i] , dp[i-k] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1] &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while( t -- )&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        for(int i = 0;i &lt; n;i ++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int l = 1 , r = 1e9;</span><br><span class="line">        while( l &lt;= r )&#123;</span><br><span class="line">            int mid = (l+r)&gt;&gt;1;</span><br><span class="line">            if( checker(mid) )&#123;</span><br><span class="line">                l = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                r = mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    &#125;   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF crypto wp</title>
      <link href="/2024/06/06/BUUCTF-crypto-wp/"/>
      <url>/2024/06/06/BUUCTF-crypto-wp/</url>
      
        <content type="html"><![CDATA[<h3 id="NewStarCTF-2023-公开赛道-Rabin’s-RSA"><a href="#NewStarCTF-2023-公开赛道-Rabin’s-RSA" class="headerlink" title="[NewStarCTF 2023 公开赛道]Rabin’s RSA"></a>[NewStarCTF 2023 公开赛道]Rabin’s RSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line">p = getPrime(64)</span><br><span class="line">q = getPrime(64)</span><br><span class="line">assert p % 4 == 3</span><br><span class="line">assert q % 4 == 3</span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line"></span><br><span class="line">e = 2</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">c = pow(m,e,n)</span><br><span class="line"></span><br><span class="line">print(&#x27;n =&#x27;, n)</span><br><span class="line">print(&#x27;c =&#x27;, c)</span><br><span class="line"></span><br><span class="line"># n = 201354090531918389422241515534761536573</span><br><span class="line"># c = 20442989381348880630046435751193745753</span><br></pre></td></tr></table></figure><hr><p>Rabin加密算法——一种基于摸平方和模平方根的非对称加密</p><p>特点：</p><ul><li>同一密文，可能有两个以上对应的明文</li><li>破解该体制等价于对大整数的分解</li><li>满足 $p\equiv 3\mod4$ 且 $q\equiv 3\mod4$</li></ul><p>Rabin密码体制选取 <code>e=2</code></p><p>加密过程：</p><ul><li>$c\equiv m^2\mod n$</li></ul><p>解密过程：</p><ul><li><p>根据费马小定理计算 $m$ 在模 $p$ 和 $q$ 时的平方根 $m_p$ 和 $m_q$：</p><p>$\circ$ $m_p\equiv c^{\frac{1}{4}(p+1)}\mod p$</p><p>$\circ$ $m_q\equiv c^{\frac{1}{4}(q+1)}\mod q$</p></li><li><p>使用拓展欧几里得算法来查找 $inv_p$ 和 $inv_q$ ：</p><p>$\circ$ $inv_p<em>p+inv_q</em>q=1$</p></li><li><p>根据中国剩余定理定理求四个模 $n$ 时的平方根：</p><p>$\circ$ $r_1\equiv (inv_p\cdot p\cdot m_q+inv_q\cdot q\cdot m_p)\mod n$</p><p>$\circ$ $r_2\equiv (n-r_1)\mod n$</p><p>$\circ$ $r_3\equiv (inv_p\cdot p\cdot m_q-inv_q\cdot q\cdot m_p)\mod n$</p><p>$\circ$ $r_4\equiv (n-r_3)\mod n$</p></li></ul><hr><ul><li>为什么 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$ 是 $m^2\equiv c\mod p$ 的解？</li></ul><p>即：已知 $m^2\equiv c\mod p$，求证 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$</p><p>因为 $p$ 是素数，且 $c$ 是一个模 $p$ 的二次剩余，那么有：</p><p>$c^{\frac{p-1}{2}}\equiv 1\mod p$ $\ (Euler’s Criterion)$</p><p>恒等号两侧同时乘以 $c$</p><p>$c^{\frac{p+1}{2}}\equiv c\mod p$</p><p>恒等号两侧同时开根</p><p>$c^{\frac{p+1}{4}}\equiv c^{\frac{1}{2}}\mod p$</p><p>模 $p$ 意义下的 $c^{\frac{1}{2}}$ 即为 $m$</p><p>故 $m\equiv c^{\frac{1}{4}(p+1)}\mod p$</p><p>证毕。</p><ul><li>为什么 $inv_p<em>p+inv_q</em>q=1$</li></ul><p>根据贝祖定理，有 $x<em>p+y</em>q=gcd(p,q)=1$</p><p>该式对 $q$ 取模，得到 $x*p\equiv 1\mod q$ ，故 $x\equiv p^{-1}\mod q$</p><p>同理对 $p$ 取模，$y\equiv q^{-1}\mod p$</p><p>故有 $inv_p<em>p+inv_q</em>q=1$</p><p>证毕</p><hr><p>能够抵御低密度指数攻击的原因：</p><p>低密度指数攻击基于爆破 $k$ 满足 $m<em>m=c+i</em>n$</p><p>本题的 $n,m,c$ 数位相近，$i$ 需要枚举到 $n,m,c$ 数位量级才有可能爆破出答案</p><hr><p>由于模数 N 通常是两个大质数相乘，其<a href="https://zhida.zhihu.com/search?q=欧拉函数&amp;zhida_source=entity&amp;is_preview=1">欧拉函数</a>很大概率是偶数，故欧拉函数和加密指数不互素，那么逆元性质将不再成立，导致解密操作无法正确还原出原始明文。</p><p>原RSA里面要求 e 和 d 模 N 互为逆元 ，否则明文不唯一，明文不唯一的后果就是容易被攻击</p><p>传统RSA算法不能解决不互素的情况，无法得到所有的明文解，而二次剩余的情况可以专门被处理，所以就可以被其他算法专门研究</p><p>Tonelli-Shanks算法：$p,q\equiv 1\mod 4$</p><p>推导：设 $p=4k-3,x^2\equiv c\mod p$</p><p>由费马定理，$x^{4k-4}\equiv 1\mod p$</p><p>也即 $(c^{\frac{p-1}{4}}+1)^2\equiv 1\mod p$（存疑，这一步是怎么得到的<a href="https://zhuanlan.zhihu.com/p/631005614">https://zhuanlan.zhihu.com/p/631005614</a></p><h1 id="UNFIXED"><a href="#UNFIXED" class="headerlink" title="UNFIXED"></a>UNFIXED</h1><p>本题代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">n = 201354090531918389422241515534761536573</span><br><span class="line">c = 20442989381348880630046435751193745753</span><br><span class="line">p = 14450452739004884887</span><br><span class="line">q = 13934102561950901579</span><br><span class="line">e = 2</span><br><span class="line"></span><br><span class="line">inv_p = gmpy2.invert( p , q )</span><br><span class="line">inv_q = gmpy2.invert( q , p )</span><br><span class="line">mp = pow( c , (p+1)//4 , p )</span><br><span class="line">mq = pow( c , (q+1)//4 , q )</span><br><span class="line"></span><br><span class="line">a = (inv_p * p * mq + inv_q * q * mp) % n</span><br><span class="line">b = n - int(a)</span><br><span class="line">c = (inv_p * p * mq - inv_q * q * mp) % n</span><br><span class="line">d = n - int(c)</span><br><span class="line"># 因为rabin 加密有四种结果，全部列出。</span><br><span class="line">aa = [a, b, c, d]</span><br><span class="line"> </span><br><span class="line">for i in aa:</span><br><span class="line">    print(i)</span><br><span class="line">    print( long_to_bytes(i) )</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;r4b1n#4c58&#125;</code></p><h3 id="b01lers2020-safety-in-numbers"><a href="#b01lers2020-safety-in-numbers" class="headerlink" title="[b01lers2020]safety_in_numbers"></a>[b01lers2020]safety_in_numbers</h3><p>题目给了三个文件：enc.py<a href="https://so.csdn.net/so/search?q=加密&amp;spm=1001.2101.3001.7020">加密</a>程序，flag加密结果，pubkey公钥文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import Crypto.PublicKey.RSA as RSA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def enc(msg, pubkey):</span><br><span class="line">   (n,e) = pubkey</span><br><span class="line">   m = int.from_bytes(msg, byteorder = &#x27;little&#x27;)</span><br><span class="line">   c = pow(m, e, n)</span><br><span class="line">   ctxt = (c).to_bytes(c.bit_length() // 8 + 1, byteorder = &#x27;little&#x27;)</span><br><span class="line">   return ctxt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&quot;pubkey.pem&quot;, &quot;r&quot;) as f:</span><br><span class="line">   ciph = RSA.importKey(f.read())     # chill out, Crypto.RSA takes its sweet time... (minutes)</span><br><span class="line"></span><br><span class="line">pubkey = (ciph.n, ciph.e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&quot;flag.txt&quot;, &quot;rb&quot;) as f:</span><br><span class="line">   flag = f.read()</span><br><span class="line"></span><br><span class="line">sys.stdout.buffer.write(enc(flag, pubkey))</span><br></pre></td></tr></table></figure><hr><p>通过pem文件提取公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Crypto.PublicKey.RSA as RSA</span><br><span class="line"></span><br><span class="line">with open(&quot;pubkey.pem&quot;, &quot;r&quot;) as f:</span><br><span class="line">   ciph = RSA.importKey(f.read())     # chill out, Crypto.RSA takes its sweet time... (minutes)</span><br><span class="line">n = ciph.n</span><br><span class="line">e = ciph.e</span><br><span class="line">print (n)</span><br><span class="line">print (e)</span><br></pre></td></tr></table></figure><p>n太大太大了，跑了半天都无法输出（可能超过4300位），所以直接对c开e次方即可得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import*</span><br><span class="line">from libnum import*</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">f = open(&#x27;flag.enc&#x27;,&#x27;rb&#x27;).read()</span><br><span class="line"></span><br><span class="line">e = 65537</span><br><span class="line">tmp = int.from_bytes(f, byteorder = &#x27;little&#x27;)</span><br><span class="line"></span><br><span class="line">m = iroot(tmp,e)[0]</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line">print(long_to_bytes(m)[::-1])</span><br></pre></td></tr></table></figure><p>其中，pem文件的最后一段是存储e的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import*</span><br><span class="line">from libnum import*</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = &#x27;AQAB&#x27;</span><br><span class="line">m = base64.b64decode(s)</span><br><span class="line">m = bytes_to_long(m)</span><br><span class="line">print(hex(m))</span><br></pre></td></tr></table></figure><h3 id="AFCTF2018-你听过一次一密么？"><a href="#AFCTF2018-你听过一次一密么？" class="headerlink" title="[AFCTF2018]你听过一次一密么？"></a>[AFCTF2018]你听过一次一密么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">25030206463d3d393131555f7f1d061d4052111a19544e2e5d54</span><br><span class="line">0f020606150f203f307f5c0a7f24070747130e16545000035d54</span><br><span class="line">1203075429152a7020365c167f390f1013170b1006481e13144e</span><br><span class="line">0f4610170e1e2235787f7853372c0f065752111b15454e0e0901</span><br><span class="line">081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a1855</span><br><span class="line">0909075412132e247436425332281a1c561f04071d520f0b1158</span><br><span class="line">4116111b101e2170203011113a69001b47520601155205021901</span><br><span class="line">041006064612297020375453342c17545a01451811411a470e44</span><br><span class="line">021311114a5b0335207f7c167f22001b44520c15544801125d40</span><br><span class="line">06140611460c26243c7f5c167f3d015446010053005907145d44</span><br><span class="line">0f05110d160f263f3a7f4210372c03111313090415481d49530f</span><br></pre></td></tr></table></figure><hr><p>多次一密</p><p>已知异或的性质，有 $C_1\oplus C_2=(M_1\oplus key)\oplus(M_2\oplus key)=M_1\oplus M_2$</p><p>先试用第一行和其他行异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c = [eval(&#x27;0x&#x27;+x.strip()) for x in open(&#x27;Problem.txt&#x27;,&#x27;r&#x27;).readlines()]</span><br><span class="line">m1 = c[0]</span><br><span class="line"></span><br><span class="line">for i in range( 1 , len(c) ):</span><br><span class="line">    tmp = hex( m1^c[i] )[2:]</span><br><span class="line">    for i in range( 0 , len(tmp), 2 ):#两位一转ascll</span><br><span class="line">        p = chr(eval(&#x27;0x&#x27;+tmp[i:i+2]))</span><br><span class="line">        if p.isalpha():</span><br><span class="line">            print( p , end=&#x27;&#x27; )</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;.&#x27;, end=&#x27;&#x27; )</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....S....N.U.....A..M.N...</span><br><span class="line">...Ro..I...I....SE....P.I.</span><br><span class="line">.E..H...IN..H...........TU</span><br><span class="line">..A.H.R.....E....P......E.</span><br><span class="line">...RT...E...M....M....A.L.</span><br><span class="line">d...V..I..DNEt........K.DU</span><br><span class="line">.......I....K..I.ST...TiS.</span><br><span class="line">.....f...N.I........M.O...</span><br><span class="line">.........N.I...I.S.I..I...</span><br><span class="line">....P....N.OH...SA....Sg..</span><br></pre></td></tr></table></figure><p>规律：小写字母$\oplus$空格=相应的大写字母，大写字母$\oplus$空格=相应的小写字母</p><p>故某一 <strong>列</strong> 英文字母越多，$M_1$ 相应位置是空格的可能性越大</p><p>因为异或运算下，$x$ 的逆元是自身</p><p>故有 $M_i[j]=M_1[j]\oplus M_i[j]\oplus M_1[j]=M_1[j]\oplus M_i[j]\oplus 0x20$（$j$ 表示列）</p><p>只需知道某一字符串的某一位是空格，即可回复所有的密文在这一列的值</p><p>解密代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import Crypto.Util.strxor as xo</span><br><span class="line">import libnum, codecs, numpy as np</span><br><span class="line"></span><br><span class="line">def isChr(x):</span><br><span class="line">    if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True</span><br><span class="line">    if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">def infer(index, pos):</span><br><span class="line">    if msg[index, pos] != 0:</span><br><span class="line">        return</span><br><span class="line">    msg[index, pos] = ord(&#x27; &#x27;)</span><br><span class="line">    for x in range(len(c)):</span><br><span class="line">        if x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">dat = []</span><br><span class="line"></span><br><span class="line">def getSpace():</span><br><span class="line">    for index, x in enumerate(c):</span><br><span class="line">        res = [xo.strxor(x, y) for y in c if x!=y]</span><br><span class="line">        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))</span><br><span class="line">        cnt = [f(pos) for pos in range(len(x))]</span><br><span class="line">        for pos in range(len(x)):</span><br><span class="line">            dat.append((f(pos), index, pos))</span><br><span class="line"></span><br><span class="line">c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]</span><br><span class="line"></span><br><span class="line">msg = np.zeros([len(c), len(c[0])], dtype=int)</span><br><span class="line"></span><br><span class="line">getSpace()</span><br><span class="line"></span><br><span class="line">dat = sorted(dat)[::-1]</span><br><span class="line">for w, index, pos in dat:</span><br><span class="line">    infer(index, pos)</span><br><span class="line"></span><br><span class="line">print(&#x27;\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dear Friend, T%is tim&lt; I u</span><br><span class="line">nderstood my m$stake 8nd u</span><br><span class="line">sed One time p,d encr ptio</span><br><span class="line">n scheme, I he,rd tha- it </span><br><span class="line">is the only en.ryptio7 met</span><br><span class="line">hod that is ma9hemati:ally</span><br><span class="line"> proven to be #ot cra:ked </span><br><span class="line">ever if the ke4 is ke)t se</span><br><span class="line">cure, Let Me k#ow if  ou a</span><br><span class="line">gree with me t&quot; use t1is e</span><br><span class="line">ncryption sche e alwa s...</span><br></pre></td></tr></table></figure><p>但是有点问题，可以选择手动修复，或者使用代码修复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def know(s,x,y):</span><br><span class="line">    msg[x,y] = ord(s)</span><br><span class="line">    for index in range(len(c)):</span><br><span class="line">        if index != x:</span><br><span class="line">            msg[index,y] = xo.strxor(c[x], c[index])[y] ^ ord(s)</span><br><span class="line">            </span><br><span class="line">know(&#x27;h&#x27;,0,14)</span><br><span class="line">know(&#x27;e&#x27;,0,21)</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dear Friend, This time I u</span><br><span class="line">nderstood my mistake and u</span><br><span class="line">sed One time pad encryptio</span><br><span class="line">n scheme, I heard that it </span><br><span class="line">is the only encryption met</span><br><span class="line">hod that is mathematically</span><br><span class="line"> proven to be not cracked </span><br><span class="line">ever if the key is kept se</span><br><span class="line">cure, Let Me know if you a</span><br><span class="line">gree with me to use this e</span><br><span class="line">ncryption scheme always...</span><br></pre></td></tr></table></figure><p>有了明文了，计算 $C_1\oplus M_1$ 即可得到 <code>key</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())</span><br><span class="line">print(key)</span><br></pre></td></tr></table></figure><p>key就是flag</p><p>flag:<code>flag&#123;OPT_1s_Int3rest1ng&#125;</code></p><hr><p>后记：</p><p>按行读取TXT中的数据：<code>c = [x for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]</code></p><p>去除尾部的<code>&#39;\n&#39;</code>：<code>c = [x.strip() for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]</code></p><p>eval的用法十分灵活，默认十进制：<code>c = [eval(&#39;0x&#39;+x.strip()) for x in open(&#39;Problem.txt&#39;,&#39;r&#39;).readlines()]</code></p><h3 id="NewStarCTF-2023-公开赛道-babyaes"><a href="#NewStarCTF-2023-公开赛道-babyaes" class="headerlink" title="[NewStarCTF 2023 公开赛道]babyaes"></a>[NewStarCTF 2023 公开赛道]babyaes</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import os</span><br><span class="line">from flag import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">def pad(data):</span><br><span class="line">    return data + b&quot;&quot;.join([b&#x27;\x00&#x27; for _ in range(0, 16 - len(data))])</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    flag_ = pad(flag)</span><br><span class="line">    key = os.urandom(16) * 2</span><br><span class="line">    iv = os.urandom(16)</span><br><span class="line">    print(bytes_to_long(key) ^ bytes_to_long(iv) ^ 1)</span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    enc_flag = aes.encrypt(flag_)</span><br><span class="line">    print(enc_flag)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"># 3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="line"># b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br></pre></td></tr></table></figure><hr><p>key是高位16bytes，iv是低位16bytes，所以可以很轻易的区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import os</span><br><span class="line">from gmpy2 import*</span><br><span class="line">from Crypto.Util.number import*</span><br><span class="line"></span><br><span class="line">xor = 3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="line">enc_flag = b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br><span class="line">out = long_to_bytes(xor)#先转化成16进制形式，aes和rsa不一样，操作一般都是在hex下</span><br><span class="line">key = out[:16]*2#这一部分是key的，另外一部分是iv的（别忘了最低位有个1）</span><br><span class="line">iv = long_to_bytes(bytes_to_long(key[16:])^bytes_to_long(out[16:])^1)</span><br><span class="line">aes = AES.new(key,AES.MODE_CBC,iv)#调用函数库解密</span><br><span class="line">flag = aes.decrypt(enc_flag)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;firsT_cry_Aes&#125;</code></p><h3 id="QCTF2018-Xman-RSA"><a href="#QCTF2018-Xman-RSA" class="headerlink" title="[QCTF2018]Xman-RSA"></a>[QCTF2018]Xman-RSA</h3><p>ciphertext:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1240198b148089290e375b999569f0d53c32d356b2e95f5acee070f016b3bef243d0b5e46d9ad7aa7dfe2f21bda920d0ac7ce7b1e48f22b2de410c6f391ce7c4347c65ffc9704ecb3068005e9f35cbbb7b27e0f7a18f4f42ae572d77aaa3ee189418d6a07bab7d93beaa365c98349d8599eb68d21313795f380f05f5b3dfdc6272635ede1f83d308c0fdb2baf444b9ee138132d0d532c3c7e60efb25b9bf9cb62dba9833aa3706344229bd6045f0877661a073b6deef2763452d0ad7ab3404ba494b93fd6dfdf4c28e4fe83a72884a99ddf15ca030ace978f2da87b79b4f504f1d15b5b96c654f6cd5179b72ed5f84d3a16a8f0d5bf6774e7fd98d27bf3c9839</span><br><span class="line">129d5d4ab3f9e8017d4e6761702467bbeb1b884b6c4f8ff397d078a8c41186a3d52977fa2307d5b6a0ad01fedfc3ba7b70f776ba3790a43444fb954e5afd64b1a3abeb6507cf70a5eb44678a886adf81cb4848a35afb4db7cd7818f566c7e6e2911f5ababdbdd2d4ff9825827e58d48d5466e021a64599b3e867840c07e29582961f81643df07f678a61a9f9027ebd34094e272dfbdc4619fa0ac60f0189af785df77e7ec784e086cf692a7bf7113a7fb8446a65efa8b431c6f72c14bcfa49c9b491fb1d87f2570059e0f13166a85bb555b40549f45f04bc5dbd09d8b858a5382be6497d88197ffb86381085756365bd757ec3cdfa8a77ba1728ec2de596c5ab</span><br></pre></td></tr></table></figure><p>n2&amp;n3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw==</span><br><span class="line">TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ==</span><br></pre></td></tr></table></figure><p>n1.encrypted:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2639c28e3609a4a8c953cca9c326e8e062756305ae8aee6efcd346458aade3ee8c2106ab9dfe5f470804f366af738aa493fd2dc26cb249a922e121287f3eddec0ed8dea89747dc57aed7cd2089d75c23a69bf601f490a64f73f6a583081ae3a7ed52238c13a95d3322065adba9053ee5b12f1de1873dbad9fbf4a50a2f58088df0fddfe2ed8ca1118c81268c8c0fd5572494276f4e48b5eb424f116e6f5e9d66da1b6b3a8f102539b690c1636e82906a46f3c5434d5b04ed7938861f8d453908970eccef07bf13f723d6fdd26a61be8b9462d0ddfbedc91886df194ea022e56c1780aa6c76b9f1c7d5ea743dc75cec3c805324e90ea577fa396a1effdafa3090</span><br><span class="line">42ff1157363d9cd10da64eb4382b6457ebb740dbef40ade9b24a174d0145adaa0115d86aa2fc2a41257f2b62486eaebb655925dac78dd8d13ab405aef5b8b8f9830094c712193500db49fb801e1368c73f88f6d8533c99c8e7259f8b9d1c926c47215ed327114f235ba8c873af7a0052aa2d32c52880db55c5615e5a1793b690c37efdd5e503f717bb8de716303e4d6c4116f62d81be852c5d36ef282a958d8c82cf3b458dcc8191dcc7b490f227d1562b1d57fbcf7bf4b78a5d90cd385fd79c8ca4688e7d62b3204aeaf9692ba4d4e44875eaa63642775846434f9ce51d138ca702d907849823b1e86896e4ea6223f93fae68b026cfe5fa5a665569a9e3948a</span><br></pre></td></tr></table></figure><p>encryption.encrypted:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">gqhb jbkl2 pbkhqw pt_kqpbd</span><br><span class="line">gqhb ht pbkhqw zqreahb</span><br><span class="line">pbkhqw urtd64</span><br><span class="line"></span><br><span class="line">adg ulwdt_wh_ezb(u):</span><br><span class="line">qdwzqe pew(u.dexhad(&#x27;mdi&#x27;), 16)</span><br><span class="line"></span><br><span class="line">adg ezb_wh_ulwdt(e):</span><br><span class="line">u = mdi(e)[2:-1]</span><br><span class="line">u = &#x27;0&#x27; + u pg yde(u)%2 == 1 dytd u</span><br><span class="line">qdwzqe u.adxhad(&#x27;mdi&#x27;)</span><br><span class="line"></span><br><span class="line">adg jdw_r_kqpbd(y):</span><br><span class="line">qreahb_tdda = zqreahb(y)</span><br><span class="line"></span><br><span class="line">ezb = ulwdt_wh_ezb(qreahb_tdda)</span><br><span class="line"></span><br><span class="line">fmpyd Tqzd:</span><br><span class="line">pg pt_kqpbd(ezb):</span><br><span class="line">uqdrv</span><br><span class="line">ezb+=1</span><br><span class="line">qdwzqe ezb</span><br><span class="line"></span><br><span class="line">adg dexqlkw(t, d, e):</span><br><span class="line">k = ulwdt_wh_ezb(t)</span><br><span class="line">k = khf(k, d, e)</span><br><span class="line">qdwzqe ezb_wh_ulwdt(k).dexhad(&#x27;mdi&#x27;)</span><br><span class="line"></span><br><span class="line">adg tdkrqrwd(e):</span><br><span class="line">k = e % 4</span><br><span class="line">w = (k*k) % 4</span><br><span class="line">qdwzqe w == 1</span><br><span class="line"></span><br><span class="line">g = hkde(&#x27;gyrj.wiw&#x27;, &#x27;q&#x27;)</span><br><span class="line">gyrj = g.qdra()</span><br><span class="line"></span><br><span class="line">btj1 = &quot;&quot;</span><br><span class="line">btj2 = &quot;&quot;</span><br><span class="line">ghq p pe qrejd(yde(gyrj)):</span><br><span class="line">pg tdkrqrwd(p):</span><br><span class="line">btj2 += gyrj[p]</span><br><span class="line">dytd:</span><br><span class="line">btj1 += gyrj[p]</span><br><span class="line"></span><br><span class="line">k1 = jdw_r_kqpbd(128)</span><br><span class="line">k2 = jdw_r_kqpbd(128)</span><br><span class="line">k3 = jdw_r_kqpbd(128)</span><br><span class="line">e1 = k1*k2</span><br><span class="line">e2 = k1*k3</span><br><span class="line">d = 0i1001</span><br><span class="line">x1 = dexqlkw(btj1, d, e1)</span><br><span class="line">x2 = dexqlkw(btj2, d, e2)</span><br><span class="line">kqpew(x1)</span><br><span class="line">kqpew(x2)</span><br><span class="line"></span><br><span class="line">d1 = 0i1001</span><br><span class="line">d2 = 0i101</span><br><span class="line">k4 = jdw_r_kqpbd(128)</span><br><span class="line">k5 = jdw_r_kqpbd(128)</span><br><span class="line">e3 = k4*k5</span><br><span class="line">x1 = ezb_wh_ulwdt(khf(e1, d1, e3)).dexhad(&#x27;mdi&#x27;)</span><br><span class="line">x2 = ezb_wh_ulwdt(khf(e1, d2, e3)).dexhad(&#x27;mdi&#x27;)</span><br><span class="line">kqpew(x1)</span><br><span class="line">kqpew(x2)</span><br><span class="line"></span><br><span class="line">kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e2)))</span><br><span class="line">kqpew(urtd64.u64dexhad(ezb_wh_ulwdt(e3)))</span><br></pre></td></tr></table></figure><hr><p>加密代码非要替换一下，直接 <a href="https://quipqiup.com/">词频分析</a> 得到代码原文：（需要自行加入空格）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import is_prime </span><br><span class="line">from os import urandom </span><br><span class="line">import base64 </span><br><span class="line">def bytes_to_num(b): </span><br><span class="line">    return int(b.encode(&#x27;hex&#x27;), 16) </span><br><span class="line">def num_to_bytes(n): </span><br><span class="line">    b = hex(n)[2:-1] </span><br><span class="line">    b = &#x27;0&#x27; + b if len(b)%2 == 1 else b </span><br><span class="line">    return b.decode(&#x27;hex&#x27;) </span><br><span class="line">def get_a_prime(l): </span><br><span class="line">    random_seed = urandom(l) </span><br><span class="line">    </span><br><span class="line">    num = bytes_to_num(random_seed) </span><br><span class="line">    while True: </span><br><span class="line">        if is_prime(num): </span><br><span class="line">            break </span><br><span class="line">        num+=1 </span><br><span class="line">        return num </span><br><span class="line">def encrypt(s, e, n): </span><br><span class="line">    p = bytes_to_num(s) </span><br><span class="line">    p = pow(p, e, n) </span><br><span class="line">    return num_to_bytes(p).encode(&#x27;hex&#x27;) </span><br><span class="line"> </span><br><span class="line">def separate(n): </span><br><span class="line">    p = n % 4 </span><br><span class="line">    t = (p*p) % 4 </span><br><span class="line">    return t == 1 </span><br><span class="line">    </span><br><span class="line">f = open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) </span><br><span class="line">flag = f.read() </span><br><span class="line">msg1 = &quot;&quot; </span><br><span class="line">msg2 = &quot;&quot; </span><br><span class="line">for i in range(len(flag)): </span><br><span class="line">    if separate(i): </span><br><span class="line">        msg2 += flag[i] </span><br><span class="line">    else: </span><br><span class="line">        msg1 += flag[i] </span><br><span class="line"> </span><br><span class="line">p1 = get_a_prime(128) </span><br><span class="line">p2 = get_a_prime(128) </span><br><span class="line">p3 = get_a_prime(128) </span><br><span class="line"> </span><br><span class="line">n1 = p1*p2 </span><br><span class="line">n2 = p1*p3 </span><br><span class="line">e = 0x1001 </span><br><span class="line">c1 = encrypt(msg1, e, n1) </span><br><span class="line">c2 = encrypt(msg2, e, n2) </span><br><span class="line">print(c1) </span><br><span class="line">print(c2) </span><br><span class="line">e1 = 0x1001 </span><br><span class="line">e2 = 0x101 </span><br><span class="line">p4 = get_a_prime(128) </span><br><span class="line">p5 = get_a_prime(128) </span><br><span class="line">n3 = p4*p5 </span><br><span class="line">c1 = num_to_bytes(pow(n1, e1, n3)).encode(&#x27;hex&#x27;) </span><br><span class="line">c2 = num_to_bytes(pow(n1, e2, n3)).encode(&#x27;hex&#x27;) </span><br><span class="line">print(c1) </span><br><span class="line">print(c2) </span><br><span class="line">print(base64.b64encode(num_to_bytes(n2))) </span><br><span class="line">print(base64.b64encode(num_to_bytes(n3)))</span><br></pre></td></tr></table></figure><p>从后往前解，n2和n3是从先 <code>long_to_bytes</code>，然后 <code>base64</code> 加密，容易得到代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">from Crypto.Util.number import bytes_to_long</span><br><span class="line"></span><br><span class="line">def dec( x ):</span><br><span class="line">    return bytes_to_long(base64.b64decode(x)) </span><br><span class="line"></span><br><span class="line">n2 = dec(&#x27;PVNHb2BfGAnmxLrbKhgsYXRwWIL9eOj6K0s3I0slKHCTXTAUtZh3T0r+RoSlhpO3+77AY8P7WETYz2Jzuv5FV/mMODoFrM5fMyQsNt90VynR6J3Jv+fnPJPsm2hJ1Fqt7EKaVRwCbt6a4BdcRoHJsYN/+eh7k/X+FL5XM7viyvQxyFawQrhSV79FIoX6xfjtGW+uAeVF7DScRcl49dlwODhFD7SeLqzoYDJPIQS+VSb3YtvrDgdV+EhuS1bfWvkkXRijlJEpLrgWYmMdfsYX8u/+Ylf5xcBGn3hv1YhQrBCg77AHuUF2w/gJ/ADHFiMcH3ux3nqOsuwnbGSr7jA6Cw==&#x27;)</span><br><span class="line">n3 = dec(&#x27;TmNVbWUhCXR1od3gBpM+HGMKK/4ErfIKITxomQ/QmNCZlzmmsNyPXQBiMEeUB8udO7lWjQTYGjD6k21xjThHTNDG4z6C2cNNPz73VIaNTGz0hrh6CmqDowFbyrk+rv53QSkVKPa8EZnFKwGz9B3zXimm1D+01cov7V/ZDfrHrEjsDkgK4ZlrQxPpZAPl+yqGlRK8soBKhY/PF3/GjbquRYeYKbagpUmWOhLnF4/+DP33ve/EpaSAPirZXzf8hyatL4/5tAZ0uNq9W6T4GoMG+N7aS2GeyUA2sLJMHymW4cFK5l5kUvjslRdXOHTmz5eHxqIV6TmSBQRgovUijlNamQ==&#x27;)</span><br><span class="line"></span><br><span class="line">print( n2 )</span><br><span class="line">print( n3 )</span><br></pre></td></tr></table></figure><p>然后通过共膜攻击，求得 <code>n1</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e1 = 0x1001</span><br><span class="line">e2 = 0x101</span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line"> </span><br><span class="line">s, s1, s2 = gmpy2.gcdext(e1, e2)</span><br><span class="line">n1 = (pow(c1, s1, n3) * pow(c2, s2, n3) % n3)</span><br><span class="line"> </span><br><span class="line">print( n1 )</span><br></pre></td></tr></table></figure><p>因为 <code>n1</code> 和 <code>n2</code> 有公因数，易求得 <code>p1,p2,p3</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line"> </span><br><span class="line">n1 = </span><br><span class="line">n2 = </span><br><span class="line"></span><br><span class="line">p1 = gmpy2.gcd(n1, n2)</span><br><span class="line">p2 = n1 // p1</span><br><span class="line">p3 = n2 // p2</span><br><span class="line">print( p1 , p2 , p3 )</span><br></pre></td></tr></table></figure><p>剩下的是常规rsa，注意flag拼接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e = 0x1001</span><br><span class="line"> </span><br><span class="line">phi1 = (p1-1)*(p2-1)</span><br><span class="line">phi2 = (p1-1)*(p3-1)</span><br><span class="line">d1 = gmpy2.invert(e, phi1)</span><br><span class="line">d2 = gmpy2.invert(e, phi2)</span><br><span class="line">m1 = pow(c1, d1, n1)</span><br><span class="line">m2 = pow(c2, d2, n2)</span><br><span class="line">flag1 = long_to_bytes(int(m1))</span><br><span class="line">flag2 = long_to_bytes(int(m2))</span><br><span class="line"> </span><br><span class="line">print(flag1)</span><br><span class="line">print(flag2)</span><br><span class="line"></span><br><span class="line">for i in range(len(flag1)):</span><br><span class="line">    print(chr(flag1[i]), end = &#x27;&#x27;)</span><br><span class="line">    try:</span><br><span class="line">        print(chr(flag2[i]), end = &#x27;&#x27;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;CRYPT0_I5_50_Interestingvim rsa.py&#125;</code></p><hr><h3 id="羊城杯-2020-RRRRRRRSA"><a href="#羊城杯-2020-RRRRRRRSA" class="headerlink" title="[羊城杯 2020]RRRRRRRSA"></a>[羊城杯 2020]RRRRRRRSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import sympy</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = &#x27;GWHT&#123;************&#125;&#x27;</span><br><span class="line">flag1 = flag[:19].encode()</span><br><span class="line">flag2 = flag[19:].encode()</span><br><span class="line">assert(len(flag) == 38)</span><br><span class="line">P1 = getPrime(1038)</span><br><span class="line">P2 = sympy.nextprime(P1)</span><br><span class="line">assert(P2 - P1 &lt; 1000)</span><br><span class="line">Q1 = getPrime(512)</span><br><span class="line">Q2 = sympy.nextprime(Q1)</span><br><span class="line">N1 = P1 * P1 * Q1</span><br><span class="line">N2 = P2 * P2 * Q2</span><br><span class="line">E1 = getPrime(1024)</span><br><span class="line">E2 = sympy.nextprime(E1)</span><br><span class="line">m1 = bytes_to_long(flag1)</span><br><span class="line">m2 = bytes_to_long(flag2)</span><br><span class="line">c1 = pow(m1, E1, N1)</span><br><span class="line">c2 = pow(m2, E2, N2)</span><br><span class="line"></span><br><span class="line">output = open(&#x27;secret&#x27;, &#x27;w&#x27;)</span><br><span class="line">output.write(&#x27;N1=&#x27; + str(N1) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;c1=&#x27; + str(c1) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;E1=&#x27; + str(E1) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;N2=&#x27; + str(N2) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;c2=&#x27; + str(c2) + &#x27;\n&#x27;)</span><br><span class="line">output.write(&#x27;E2=&#x27; + str(E2) + &#x27;\n&#x27;)</span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N1=</span><br><span class="line">c1=</span><br><span class="line">E1=</span><br><span class="line">N2=</span><br><span class="line">c2=</span><br><span class="line">E2=</span><br></pre></td></tr></table></figure><hr><p><code>wiener attack</code> 是依靠连分数进行的攻击方式，适用于非常接近某一值（比如1）时，求一个比例关系，通过该比例关系再来反推关键信息就简单很多。这种攻击对于解密指数d很小时有很好的效果，一般的用法是通过 </p><p>$ed \mod \phi(N)\equiv1$ </p><p>得到 $ed=k*\phi(N)+1$</p><p>即  $\frac{e}{\phi(N)}=\frac{k}{d}+\frac{1}{\phi(N)}$</p><p>这种情况下 $\phi(N)≈N$，且 $\phi(N)$ 非常大</p><p>所以有 $\frac{e}{N}-\frac{k}{d}=\frac{1}{\phi(N)}$</p><p>也就是说 $\frac{k}{d}$ 与 $\frac{e}{N}$ 非常接近，而 $\frac{e}{N}$ 又是已知的</p><p>对 $\frac{e}{N}$ 进行连分数展开，得到的一串分数的分母很有可能就是 $d$</p><p>只要检验一下 $ed \mod \phi(N)$ ，看它是不是 $1$ 就知道对不对了。</p><p>但是这道题和普通的wiener attack 不同的是，e与N并没有近到相除约为1的地步，相差还是很大的，也就是说解密指数d也许还是很大的，这样就解不出来。</p><p>值得注意的是，e和N的关系不符合利用条件，但是N1和N2的关系却适合</p><p>对于这一道题: $\frac{N_1}{N_2}=(\frac{P_1}{P_2})^2*\frac{Q_1}{Q_2}$</p><p>显然我们可以知道的是 $\frac{N_1}{N_2}&lt;\frac{Q_1}{Q_2}$ </p><p>所以在 $\frac{Q_1}{Q_2}\in [\frac{N_1}{N_2},1]$ </p><p>尝试对 $\frac{N_1}{N_2}$ 进行连分数展开并求其各项渐进分数，其中某个连分数的分母可能就是 $Q_1$（依靠 $N\%Q$ 来验证）</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">N1=</span><br><span class="line">c1=</span><br><span class="line">E1=</span><br><span class="line">N2=</span><br><span class="line">c2=</span><br><span class="line">E2=</span><br><span class="line"></span><br><span class="line">def continuedFra(x, y): #不断生成连分数的项</span><br><span class="line">    cF = []</span><br><span class="line">    while y:</span><br><span class="line">        cF += [x // y]</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    return cF</span><br><span class="line">def Simplify(ctnf): #化简</span><br><span class="line">    numerator = 0</span><br><span class="line">    denominator = 1</span><br><span class="line">    for x in ctnf[::-1]: #注意这里是倒叙遍历</span><br><span class="line">        numerator, denominator = denominator, x * denominator + numerator</span><br><span class="line">    return (numerator, denominator) #把连分数分成分子和算出来的分母</span><br><span class="line">def getit(c):</span><br><span class="line">    cf=[]</span><br><span class="line">    for i in range(1,len(c)):</span><br><span class="line">        cf.append(Simplify(c[:i])) #各个阶段的连分数的分子和分母</span><br><span class="line">    return cf #得到一串连分数</span><br><span class="line"></span><br><span class="line">def wienerAttack(e, n):</span><br><span class="line">    cf=continuedFra(e,n)</span><br><span class="line">    for (Q2,Q1) in getit(cf):#遍历得到的连分数，令分子分母分别是Q2，Q1</span><br><span class="line">        if Q1 == 0:</span><br><span class="line">            continue</span><br><span class="line">        if N1%Q1==0 and Q1!=1:#满足这个条件就找到了</span><br><span class="line">            return Q1</span><br><span class="line">    print(&#x27;not find!&#x27;)</span><br><span class="line">Q1=wienerAttack(N1,N2)</span><br><span class="line"></span><br><span class="line">P1=gmpy2.iroot(N1//Q1,2)[0]</span><br><span class="line">P2=gmpy2.next_prime(P1)</span><br><span class="line">Q2=gmpy2.next_prime(Q1)</span><br><span class="line">phi1=P1*(P1-1)*(Q1-1)</span><br><span class="line">phi2=P2*(P2-1)*(Q2-1)</span><br><span class="line">d1=gmpy2.invert(E1,phi1)</span><br><span class="line">d2=gmpy2.invert(E2,phi2)</span><br><span class="line">m1=long_to_bytes(gmpy2.powmod(c1,d1,N1))</span><br><span class="line">m2=long_to_bytes(gmpy2.powmod(c2,d2,N2))</span><br><span class="line">print((m1+m2))</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;3aadab41754799f978669d53e64a3aca&#125;</code></p><h3 id="UTCTF2020-OTP"><a href="#UTCTF2020-OTP" class="headerlink" title="[UTCTF2020]OTP"></a>[UTCTF2020]OTP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Encoded A: 213c234c2322282057730b32492e720b35732b2124553d354c22352224237f1826283d7b0651</span><br><span class="line">Encoded B: 3b3b463829225b3632630b542623767f39674431343b353435412223243b7f162028397a103e</span><br><span class="line"></span><br><span class="line">Original A: 5448452042455354204354462043415445474f52592049532043525950544f47524150485921</span><br><span class="line">Original B: 4e4f205448452042455354204f4e452049532042494e415259204558504c4f49544154494f4e</span><br><span class="line"></span><br><span class="line">A XOR A: 7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70</span><br><span class="line">B XOR B: 7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70</span><br></pre></td></tr></table></figure><hr><p>一次一密是牢不可破的！</p><p>不过原文和密文都给了，就可以轻易得到flag了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = &#x27;7574666c61677b7477305f74696d335f703464737d7574666c61677b7477305f74696d335f70&#x27;</span><br><span class="line"> </span><br><span class="line">for i in range(0, len(c), 2):</span><br><span class="line">    print(chr(int(c[i:i+2], 16)), end = &#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;tw0_tim3_p4ds&#125;</code></p><h3 id="Dest0g3-520迎新赛-babyAES"><a href="#Dest0g3-520迎新赛-babyAES" class="headerlink" title="[Dest0g3 520迎新赛]babyAES"></a>[Dest0g3 520迎新赛]babyAES</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import os</span><br><span class="line">iv = os.urandom(16)</span><br><span class="line">key = os.urandom(16)</span><br><span class="line">my_aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()</span><br><span class="line">flag += (16 - len(flag) % 16) * b&#x27;\x00&#x27;</span><br><span class="line">c = my_aes.encrypt(flag)</span><br><span class="line">print(c)</span><br><span class="line">print(iv)</span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;</span><br><span class="line">b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;</span><br><span class="line">b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><hr><p>最喜欢的大水题，该给的都给了，直接解就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line"> </span><br><span class="line">c = b&#x27;C4:\x86Q$\xb0\xd1\x1b\xa9L\x00\xad\xa3\xff\x96 hJ\x1b~\x1c\xd1y\x87A\xfe0\xe2\xfb\xc7\xb7\x7f^\xc8\x9aP\xdaX\xc6\xdf\x17l=K\x95\xd07&#x27;</span><br><span class="line">iv = b&#x27;\xd1\xdf\x8f)\x08w\xde\xf9yX%\xca[\xcb\x18\x80&#x27;</span><br><span class="line">key = b&#x27;\xa4\xa6M\xab&#123;\xf6\x97\x94&gt;hK\x9bBe]F&#x27;</span><br><span class="line"></span><br><span class="line">my_aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">m = my_aes.decrypt(c)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4&#125;</code></p><h3 id="ACTF新生赛2020-crypto-des"><a href="#ACTF新生赛2020-crypto-des" class="headerlink" title="[ACTF新生赛2020]crypto-des"></a>[ACTF新生赛2020]crypto-des</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">72143238992041641000000.000000,</span><br><span class="line">77135357178006504000000000000000.000000,</span><br><span class="line">1125868345616435400000000.000000,</span><br><span class="line">67378029765916820000000.000000,</span><br><span class="line">75553486092184703000000000000.000000,</span><br><span class="line">4397611913739958700000.000000,</span><br><span class="line">76209378028621039000000000000000.000000</span><br><span class="line">To solve the key, Maybe you know some interesting data format about C language?</span><br></pre></td></tr></table></figure><hr><p>网上抄来的脚本，我也不知道为什么要这么干（感觉和密码学没关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from libnum import*</span><br><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">s = [72143238992041641000000.000000,77135357178006504000000000000000.000000,1125868345616435400000000.000000,67378029765916820000000.000000,75553486092184703000000000000.000000,4397611913739958700000.000000,76209378028621039000000000000000.000000]</span><br><span class="line">a = &#x27;&#x27;</span><br><span class="line">b = &#x27;&#x27;</span><br><span class="line">for i in s:</span><br><span class="line">    i = float(i)</span><br><span class="line">    a += struct.pack(&#x27;&lt;f&#x27;,i).hex()        #小端</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">for j in s:</span><br><span class="line">    i = float(i)</span><br><span class="line">    b += struct.pack(&#x27;&gt;f&#x27;,i).hex()        #小端</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(n2s(a))</span><br><span class="line">print(n2s(b))</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;Interestring Idea to encrypt&#x27;</span><br><span class="line">b&#x27;tpyrtpyrtpyrtpyrtpyrtpyrtpyr&#x27;</span><br></pre></td></tr></table></figure><p>但是我自己习惯的写法，得到的a是相同的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">import binascii</span><br><span class="line">from Crypto.Util.number import long_to_bytes , bytes_to_long</span><br><span class="line"></span><br><span class="line">s = [</span><br><span class="line">    72143238992041641000000.000000,</span><br><span class="line">    77135357178006504000000000000000.000000,</span><br><span class="line">    1125868345616435400000000.000000,</span><br><span class="line">    67378029765916820000000.000000,</span><br><span class="line">    75553486092184703000000000000.000000,</span><br><span class="line">    4397611913739958700000.000000,</span><br><span class="line">    76209378028621039000000000000000.000000</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def solve( f ):</span><br><span class="line">    output = &#x27;&#x27;</span><br><span class="line">    for i in s:</span><br><span class="line">        output += str(struct.pack(f,float(i)))[2:].strip(&#x27;\&#x27;&#x27;)</span><br><span class="line">    return output</span><br><span class="line"></span><br><span class="line">a = solve(&#x27;&lt;f&#x27;)</span><br><span class="line">b = solve(&#x27;&gt;f&#x27;)</span><br><span class="line">print( a )</span><br><span class="line">print( b )</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Interestring Idea to encrypt</span><br><span class="line">etnItsergniredI ot acne tpyr</span><br></pre></td></tr></table></figure><p><a href="https://www.codeleading.com/article/82534229429/">这篇文章</a>的解法看着相对靠谱很多，但是没有详细代码，不知道是如何操作的，尝试只好一番之后未成功只好作罢</p><p>输出结果中，b的不一样而a一样，但是解压密码就是a的输出</p><p>解压密码是:<code>Interestring Idea to encrypt</code></p><p>得到zip文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import pyDes</span><br><span class="line">import base64</span><br><span class="line">from FLAG import flag</span><br><span class="line">deskey = &quot;********&quot;</span><br><span class="line">DES = pyDes.des(deskey)</span><br><span class="line">DES.setMode(&#x27;ECB&#x27;)</span><br><span class="line">DES.Kn = 一个矩阵</span><br><span class="line">cipher_list = base64.b64encode(DES.encrypt(flag))</span><br><span class="line">#b&#x27;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#x27;</span><br></pre></td></tr></table></figure><p>新生赛的题是这样的，直接解就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import pyDes</span><br><span class="line">import base64</span><br><span class="line">from Crypto.Util.number  import*</span><br><span class="line">deskey  = &quot;********&quot;</span><br><span class="line">DES = pyDes.des(deskey)</span><br><span class="line">DES.setMode(&#x27;ECB&#x27;)</span><br><span class="line">DES.Kn =</span><br><span class="line"></span><br><span class="line">k = b&#x27;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#x27;</span><br><span class="line">data = base64.b64decode(k)</span><br><span class="line">flag = DES.decrypt(data)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;breaking_DES_is_just_a_small_piece_of_cake&#125;</code></p><h3 id="AFCTF2018-One-Secret-Two-encryption"><a href="#AFCTF2018-One-Secret-Two-encryption" class="headerlink" title="[AFCTF2018]One Secret, Two encryption"></a>[AFCTF2018]One Secret, Two encryption</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一份秘密发送给两个人不太好吧，那我各自加密一次好啦~~~</span><br><span class="line">素数生成好慢呀</span><br><span class="line">偷个懒也……不会有问题的吧？</span><br></pre></td></tr></table></figure><p><code>flag_encry1</code></p><p><code>flag_encry2</code></p><p><code>public1.pub</code></p><p><code>public2.pub</code></p><hr><p>先用 <a href="http://www.hiencode.com/pub_asys.html">公钥解析</a> 提取一下公钥</p><p>得到两组n和e</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( math.gcd(n1,n2) )</span><br></pre></td></tr></table></figure><p>得到两组p和q</p><p>也可以直接用库函数来解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import rsa</span><br><span class="line">d=int(gmpy2.invert(e,(p-1)*(q-1)))</span><br><span class="line">Rsa=rsa.PrivateKey(n,e,d,p,q)</span><br><span class="line">with open(&#x27;flag_encry1&#x27;,&#x27;rb&#x27;) as f:</span><br><span class="line">     cipher1=f.read()</span><br><span class="line">     print(rsa.decrypt(cipher1,Rsa))</span><br></pre></td></tr></table></figure><p>flag:<code>flag&#123;You_Know_0p3u55I&#125;</code></p><h3 id="watevrCTF-2019-Swedish-RSA"><a href="#watevrCTF-2019-Swedish-RSA" class="headerlink" title="[watevrCTF 2019]Swedish RSA"></a>[watevrCTF 2019]Swedish RSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">flag = bytearray(raw_input())</span><br><span class="line">flag = list(flag)</span><br><span class="line">length = len(flag)</span><br><span class="line">bits = 16</span><br><span class="line"></span><br><span class="line">## Prime for Finite Field.</span><br><span class="line">p = random_prime(2^bits-1, False, 2^(bits-1))</span><br><span class="line"></span><br><span class="line">file_out = open(&quot;downloads/polynomial_rsa.txt&quot;, &quot;w&quot;)</span><br><span class="line">file_out.write(&quot;Prime: &quot; + str(p) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">## Univariate Polynomial Ring in y over Finite Field of size p</span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line"></span><br><span class="line">## Analogous to the primes in Z</span><br><span class="line">def gen_irreducable_poly(deg):</span><br><span class="line">    while True:</span><br><span class="line">        out = R.random_element(degree=deg)</span><br><span class="line">        if out.is_irreducible():</span><br><span class="line">            return out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Polynomial &quot;primes&quot;</span><br><span class="line">P = gen_irreducable_poly(ZZ.random_element(length, 2*length))</span><br><span class="line">Q = gen_irreducable_poly(ZZ.random_element(length, 2*length))</span><br><span class="line"></span><br><span class="line">## Public exponent key</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">## Modulus</span><br><span class="line">N = P*Q</span><br><span class="line">file_out.write(&quot;Modulus: &quot; + str(N) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line"></span><br><span class="line">## Encrypt</span><br><span class="line">m = S(flag)</span><br><span class="line">c = m^e</span><br><span class="line"></span><br><span class="line">file_out.write(&quot;Ciphertext: &quot; + str(c))</span><br><span class="line">file_out.close()</span><br></pre></td></tr></table></figure><hr><p>将传统 RSA 中的 p和q 用多项式来替代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">传统欧拉函数：对于正整数n，欧拉函数是小于等于n的数中与n互质的数的个数。</span><br><span class="line">多项式欧拉函数：对于多项式P(y)来讲，欧拉函数phi(P(y))表示所有不高于P(y)幂级的环内所有多项式中，与P(y)无（除1以外）公因式的其他多项式的个数。</span><br></pre></td></tr></table></figure><p>经过 <code>is_irreducible</code> 函数的判断，可以得知 $P(y)$ 是不可约多项式，所以 $\phi(P(y))=43753^{degree()}-1$</p><p>$degree()$ 就是多项式的最高项指数</p><p>信息是多项式形式的，明文的每个字符都转化成数值，作为多项式上的系数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">P=43753</span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(P))</span><br><span class="line">N=</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line">C=</span><br><span class="line">p,q = N.factor()</span><br><span class="line">p,q = p[0],q[0]</span><br><span class="line">phi=(pow(P,65)-1)*(pow(P,112)-1)</span><br><span class="line">e = 65537</span><br><span class="line">d = inverse_mod(e,phi)</span><br><span class="line">m = C^d</span><br><span class="line">print(&quot;&quot;.join([chr(c) for c in m.list()]))</span><br></pre></td></tr></table></figure><p>flag<code>flag&#123;RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro&#125;</code></p><h3 id="watevrCTF-2019-ECC-RSA"><a href="#watevrCTF-2019-ECC-RSA" class="headerlink" title="[watevrCTF 2019]ECC-RSA"></a>[watevrCTF 2019]ECC-RSA</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from fastecdsa.curve import P521 as Curve</span><br><span class="line">from fastecdsa.point import Point</span><br><span class="line">from Crypto.Util.number import bytes_to_long, isPrime</span><br><span class="line">from os import urandom</span><br><span class="line">from random import getrandbits</span><br><span class="line"></span><br><span class="line">def gen_rsa_primes(G):</span><br><span class="line">urand = bytes_to_long(urandom(521//8))</span><br><span class="line">while True:</span><br><span class="line">s = getrandbits(521) ^ urand</span><br><span class="line"></span><br><span class="line">Q = s*G</span><br><span class="line">if isPrime(Q.x) and isPrime(Q.y):</span><br><span class="line">print(&quot;ECC Private key:&quot;, hex(s))</span><br><span class="line">print(&quot;RSA primes:&quot;, hex(Q.x), hex(Q.y))</span><br><span class="line">print(&quot;Modulo:&quot;, hex(Q.x * Q.y))</span><br><span class="line">return (Q.x, Q.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = int.from_bytes(input(), byteorder=&quot;big&quot;)</span><br><span class="line"></span><br><span class="line">ecc_p = Curve.p</span><br><span class="line">a = Curve.a</span><br><span class="line">b = Curve.b</span><br><span class="line"></span><br><span class="line">Gx = Curve.gx</span><br><span class="line">Gy = Curve.gy</span><br><span class="line">G = Point(Gx, Gy, curve=Curve)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = 0x10001</span><br><span class="line">p, q = gen_rsa_primes(G)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_out = open(&quot;downloads/ecc-rsa.txt&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line">file_out.write(&quot;ECC Curve Prime: &quot; + hex(ecc_p) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Curve a: &quot; + hex(a) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Curve b: &quot; + hex(b) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Gx: &quot; + hex(Gx) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;Gy: &quot; + hex(Gy) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">file_out.write(&quot;e: &quot; + hex(e) + &quot;\n&quot;)</span><br><span class="line">file_out.write(&quot;p * q: &quot; + hex(n) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">c = pow(flag, e, n)</span><br><span class="line">file_out.write(&quot;ciphertext: &quot; + hex(c) + &quot;\n&quot;)</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
            <tag> 常驻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论小芝士</title>
      <link href="/2024/06/03/%E6%95%B0%E8%AE%BA%E5%B0%8F%E8%8A%9D%E5%A3%AB/"/>
      <url>/2024/06/03/%E6%95%B0%E8%AE%BA%E5%B0%8F%E8%8A%9D%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>欧拉定理</strong>：<a href="https://oi-wiki.org/math/number-theory/fermat/">https://oi-wiki.org/math/number-theory/fermat/</a></p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#[LitCTF 2023]Euler</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p*q</span><br><span class="line">c = pow(m,n-p-q+3,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">n = </span><br><span class="line">c = </span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>$phi = n-p-q+1$，故 $c=m^{phi+2} mod \ n$ ，由欧拉定理可得 $c^{phi}\equiv 1 \ mod n $</p><p>则  $c\equiv m^{2} mod \ n $</p><p>直接开根即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">c = </span><br><span class="line">print( long_to_bytes(gmpy2.iroot(c,2)[0]) )</span><br></pre></td></tr></table></figure><hr><p>威尔逊定理：$(p-1)!\equiv -1\ mod\ p$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#[长安杯 2021]checkin</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(16)</span><br><span class="line">n = p*q</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">for i in range(1,p-q):</span><br><span class="line">    m = m*i%n</span><br><span class="line">e = 1049</span><br><span class="line">print(pow(2,e,n))</span><br><span class="line">print(pow(m,e,n))</span><br><span class="line">#4513855932190587780512692251070948513905472536079140708186519998265613363916408288602023081671609336332823271976169443708346965729874135535872958782973382975364993581165018591335971709648749814573285241290480406050308656233944927823668976933579733318618949138978777831374262042028072274386196484449175052332019377</span><br><span class="line">#3303523331971096467930886326777599963627226774247658707743111351666869650815726173155008595010291772118253071226982001526457616278548388482820628617705073304972902604395335278436888382882457685710065067829657299760804647364231959804889954665450340608878490911738748836150745677968305248021749608323124958372559270</span><br></pre></td></tr></table></figure><p>第一步爆破n：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hint1 = </span><br><span class="line">hint2 = </span><br><span class="line">e = 1049</span><br><span class="line">for k in range( 1 , 1000000 ):</span><br><span class="line">    if ( 2**e - hint1 ) % k == 0:</span><br><span class="line">        n = ( 2**e - hint1 ) // k</span><br><span class="line">        print( k , n.bit_length() , n  )</span><br></pre></td></tr></table></figure><p>得到 $n$，直接分解得到 $p$ 和 $q$</p><p>第二步：</p><p>已知 $M\equiv m*(p-q-1)\ mod\ n$</p><p>因为 $p\mid n$，所以 $M\equiv m*(p-q-1)\ mod\ p$（放缩）</p><p>得到方程</p><script type="math/tex; mode=display">\begin{cases}    (p-1)! \equiv -1\ mod\ p\\    M\equiv m*(p-q-1)\ mod\ p\end{cases}</script><p>$\therefore m\equiv \dfrac{M<em>(p-1)!}{(-1)</em>(p-q-1)!}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">hint2 = 33035...</span><br><span class="line">e = 1049</span><br><span class="line">n = 58237...</span><br><span class="line"></span><br><span class="line">p = 17022...</span><br><span class="line">q = 34211</span><br><span class="line"></span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">assert p*q == n</span><br><span class="line">d = gmpy2.invert( e , phi )</span><br><span class="line">m = pow( hint2 , d , n )</span><br><span class="line">print( m )</span><br><span class="line">m = -1*m</span><br><span class="line">for i in range( p-q , p ):</span><br><span class="line">    m = m * i % p</span><br><span class="line">print( long_to_bytes(m) )</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制导镖</title>
      <link href="/2024/06/02/%E5%88%B6%E5%AF%BC%E9%95%96/"/>
      <url>/2024/06/02/%E5%88%B6%E5%AF%BC%E9%95%96/</url>
      
        <content type="html"><![CDATA[<p>发射点到对方前哨站的距离：16m；发射点到对方基地的距离：25m</p><span id="more"></span><hr><p>三个阶段：</p><p>第一阶段，可以辅助制导，通过少量气瓶等方案实现，在镖架的机械误差较大，散布直径在500mm-1000mm的镖可以制导击中前哨站概率超过20%，散布直径在200mm-500mm的镖可以制导击中前哨站概率超过40%，散布直径200mm以下的听天由命不过也基本上大概率能中</p><p>第二阶段，可以辅助制导，通过舵机等方案实现（和南航较像），对镖架要求进一步降低，可以击中前哨站概率超过60%</p><p>第三阶段，可以制导，通过较大推力实现稳定弹道方案，只要不摔坏就一定能打中</p><hr><p>第一阶段：</p><p>构想：主体沿用旧版传统飞镖，尾部新增安装一个<code>气球</code>，使用3d打印件控制气球大小的上限，主体部分嵌入飞镖内部，通过一个360°舵机控制其出风方向，通过陀螺仪传感器数值进行定点放气</p><p>或者考虑使用舵机等电机进行动量和姿态的改变</p><p>upd：为了保持镖身左右稳定，可以考虑使用两个舵机进行对称控制</p><p>大致成本：</p><p>镖身：耗材的价格</p><p>陀螺仪MPU6050：7r</p><p>舵机最普通的*2：5*2=10r</p><p>摄像头ov7670：7r</p><p>开发板c6t6：5r</p><p>总成本：50-</p><hr><p>第二阶段（南航制导镖）</p><p>大致成本：</p><p>STM32F401CCU6 14.5r</p><p>MPU6050 6.58r</p><p>蓝剑高刷新率微型舵机 39r</p><p>stm32H750视觉处理 40r</p><p>ov7725摄像头 25r</p><p>第三阶段：</p><p>在保证推重比小于1的前提下，飞行至最高点时开启制导模式，使用FPGA和大于0.5g的推力和pid等控制方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install crypto in sage of wsl</title>
      <link href="/2024/05/23/install-crypto-in-sage-of-wsl/"/>
      <url>/2024/05/23/install-crypto-in-sage-of-wsl/</url>
      
        <content type="html"><![CDATA[<p>When I input <code>sudo -pip install pycryptodome</code></p><span id="more"></span><p>It output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper# python3 -m pip install --user pipx</span><br><span class="line">error: externally-managed-environment</span><br><span class="line"></span><br><span class="line">× This environment is externally managed</span><br><span class="line">╰─&gt; To install Python packages system-wide, try apt install</span><br><span class="line">    python3-xyz, where xyz is the package you are trying to</span><br><span class="line">    install.</span><br><span class="line">    </span><br><span class="line">    If you wish to install a non-Debian-packaged Python package,</span><br><span class="line">    create a virtual environment using python3 -m venv path/to/venv.</span><br><span class="line">    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make</span><br><span class="line">    sure you have python3-full installed.</span><br><span class="line">    </span><br><span class="line">    If you wish to install a non-Debian packaged Python application,</span><br><span class="line">    it may be easiest to use pipx install xyz, which will manage a</span><br><span class="line">    virtual environment for you. Make sure you have pipx installed.</span><br><span class="line"></span><br><span class="line">    See /usr/share/doc/python3.11/README.venv for more information.</span><br><span class="line"></span><br><span class="line">note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.</span><br><span class="line">hint: See PEP 668 for the detailed specification.</span><br><span class="line">root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper#</span><br></pre></td></tr></table></figure><p>Just translate it</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper/Desktop# sage --pip install pycrypto</span><br><span class="line">error: externally-managed-environment</span><br><span class="line"></span><br><span class="line">× 该环境由外部管理</span><br><span class="line">╰─&gt; 要在全系统安装 Python 软件包，请尝试使用 apt install</span><br><span class="line">    python3-xyz，其中 xyz 是要安装的软件包。</span><br><span class="line">    安装。</span><br><span class="line"></span><br><span class="line">    如果您想安装非 Debian 打包的 Python 软件包、</span><br><span class="line">    使用 python3 -m venv path/to/venv 创建一个虚拟环境。</span><br><span class="line">    然后使用 path/to/venv/bin/python 和 path/to/venv/bin/pip。确保</span><br><span class="line">    确保安装了 python3-full。</span><br><span class="line"></span><br><span class="line">    如果您想安装非 Debian 打包的 Python 应用程序、</span><br><span class="line">    最简单的方法是使用 pipx install xyz，它会为您管理一个</span><br><span class="line">    虚拟环境。请确保已安装 pipx。</span><br><span class="line"></span><br><span class="line">    更多信息请参见 /usr/share/doc/python3.11/README.venv。</span><br><span class="line"></span><br><span class="line">注意：如果您认为这是一个错误，请联系您的 Python 安装或操作系统发行提供商。您可以通过 --break-system-packages 来覆盖此选项，但可能会破坏您的 Python 安装或操作系统。</span><br><span class="line">提示：详细规范请参见 PEP 668。</span><br></pre></td></tr></table></figure><p>I choose ignore it and input <code>sage --pip install pycryptodome --break-system-packages</code></p><p>In this way, we succeed.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper/Desktop# sage --pip install pycryptodome --break-system-packages</span><br><span class="line">Collecting pycryptodome</span><br><span class="line">  Downloading pycryptodome-3.20.0-cp35-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (2.1 MB)</span><br><span class="line">     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.1/2.1 MB 93.7 kB/s eta 0:00:00</span><br><span class="line">Installing collected packages: pycryptodome</span><br><span class="line">Successfully installed pycryptodome-3.20.0</span><br><span class="line">WARNING: Running pip as the &#x27;root&#x27; user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv</span><br><span class="line">root@LAPTOP-LDQVJGQS:/mnt/c/Users/coper/Desktop# </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cryptoCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo usage</title>
      <link href="/2024/05/23/hexo-usage/"/>
      <url>/2024/05/23/hexo-usage/</url>
      
        <content type="html"><![CDATA[<p><code>hexo s</code>  #启动并预览</p><p><code>hexo c</code>  #清除缓存文件 db.json 和已生成的静态文件 public </p><p><code>hexo g</code>  #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写) </p><p><code>hexo d</code>  #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</p>]]></content>
      
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
